<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaDataServiceDB.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.metadataservice</a> &gt; <span class="el_source">MetaDataServiceDB.java</span></div><h1>MetaDataServiceDB.java</h1><pre class="source lang-java linenums">
package es.bsc.dataclay.metadataservice;

import java.sql.Array;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import es.bsc.dataclay.dbhandler.sql.DataServiceDBSQLStatements;
import es.bsc.dataclay.logic.server.LogicModuleSrv;
import es.bsc.dataclay.util.management.metadataservice.ExternalExecutionEnvironment;
import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.exceptions.dbhandler.DbHandlerException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectAlreadyExistException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.metadataservice.MetaDataServiceSQLStatements.SqlStatements;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.StorageLocationID;
import es.bsc.dataclay.util.management.metadataservice.DataClayInstance;
import es.bsc.dataclay.util.management.metadataservice.ExecutionEnvironment;
import es.bsc.dataclay.util.management.metadataservice.StorageLocation;
import es.bsc.dataclay.dbhandler.sql.sqlite.SQLiteDataSource;
import org.sqlite.SQLiteErrorCode;

/**
 * MetaData data base.
 */
public final class MetaDataServiceDB {
<span class="nc" id="L45">	private static final Logger logger = LogManager.getLogger(&quot;MetaDataService.db&quot;);</span>

	/** Data source. */
	private final SQLiteDataSource dataSource;

	/**
	 * MetaDataServiceDB constructor.
	 * 
	 * @param dataSource data source
	 */
<span class="nc" id="L55">	public MetaDataServiceDB(final SQLiteDataSource dataSource) {</span>
<span class="nc" id="L56">		this.dataSource = dataSource;</span>
<span class="nc" id="L57">	}</span>

	/**
	 * Create tables of MDS.
	 */
	public void createTables() {
<span class="nc" id="L63">		synchronized (dataSource) {</span>

<span class="nc" id="L65">			Connection conn = null;</span>
			try {
<span class="nc" id="L67">				conn = getConnection();</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">				for (final SqlStatements stmt : SqlStatements.values()) {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">					if (stmt.name().startsWith(&quot;CREATE_TABLE&quot;)) {</span>
<span class="nc" id="L70">						try (PreparedStatement ps = conn.prepareStatement(stmt.getSqlStatement())) {</span>
<span class="nc" id="L71">							ps.execute();</span>
						}
					}
				}
<span class="nc" id="L75">			} catch (final SQLException e) {</span>
<span class="nc" id="L76">				LogicModuleSrv.doExit(e.getErrorCode());</span>
			} finally {
<span class="nc" id="L78">				closeConnection(conn);</span>
			}
<span class="nc" id="L80">		}</span>
<span class="nc" id="L81">	}</span>

	/**
	 * Delete the tables of MDS. Just the other way around of createTables --much simpler.
	 */
	public void dropTables() {
<span class="nc" id="L87">		synchronized (dataSource) {</span>

<span class="nc" id="L89">			final Connection conn = getConnection();</span>
			try {
<span class="nc bnc" id="L91" title="All 2 branches missed.">				for (final SqlStatements stmt : SqlStatements.values()) {</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">					if (stmt.name().startsWith(&quot;DROP_TABLE&quot;)) {</span>
<span class="nc" id="L93">						try (PreparedStatement ps = conn.prepareStatement(stmt.getSqlStatement())) {</span>
<span class="nc" id="L94">							ps.execute();</span>
						}
					}
				}

<span class="nc" id="L99">			} catch (final SQLException e) {</span>
<span class="nc" id="L100">				LogicModuleSrv.doExit(e.getErrorCode());</span>
			} finally {
<span class="nc" id="L102">				closeConnection(conn);</span>
			}
<span class="nc" id="L104">		}</span>
<span class="nc" id="L105">	}</span>

	/**
	 * Store ObjectMetaData into database
	 * 
	 * @param objectMD
	 *            ObjectMetaData
	 */
	public void store(final ObjectMetaData objectMD) {
<span class="nc" id="L114">		synchronized (dataSource) {</span>

<span class="nc" id="L116">			final Connection conn = getConnection();</span>
<span class="nc" id="L117">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.INSERT_METADATA.getSqlStatement())) {</span>
<span class="nc" id="L118">				ps.setObject(1, objectMD.getDataClayID().getId());</span>
<span class="nc" id="L119">				ps.setObject(2, objectMD.getMetaClassID().getId());</span>
<span class="nc" id="L120">				ps.setObject(3, objectMD.getDataSetID().getId());</span>
<span class="nc" id="L121">				final UUID[] theArray = new UUID[objectMD.getExecutionEnvironmentIDs().size()];</span>
<span class="nc" id="L122">				int i = 0;</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">				for (final ExecutionEnvironmentID locID : objectMD.getExecutionEnvironmentIDs()) {</span>
<span class="nc" id="L124">					theArray[i] = locID.getId();</span>
<span class="nc" id="L125">					i++;</span>
<span class="nc" id="L126">				}</span>
<span class="nc" id="L127">				Array sqlArray = ps.getConnection().createArrayOf(&quot;uuid&quot;, theArray);</span>
<span class="nc" id="L128">				ps.setArray(4, sqlArray);</span>
<span class="nc" id="L129">				ps.setBoolean(5, objectMD.isReadOnly());</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">				if (objectMD.getAlias() != null) {</span>
<span class="nc" id="L131">					ps.setString(6, objectMD.getAlias());</span>
				}
<span class="nc" id="L133">				ps.setInt(7, objectMD.getLang().getNumber());</span>
<span class="nc" id="L134">				ps.setObject(8, objectMD.getOwnerID().getId());</span>

				try {
<span class="nc" id="L137">					ps.executeUpdate();</span>
<span class="nc" id="L138">				} catch (final SQLException e) {</span>
					/* A primary key constraint is violated */
<span class="nc bnc" id="L140" title="All 2 branches missed.">					if (e.getErrorCode() == SQLiteErrorCode.SQLITE_CONSTRAINT.code) {</span>
<span class="nc" id="L141">						throw new DbObjectAlreadyExistException(objectMD.getDataClayID());</span>
					} else {
<span class="nc" id="L143">						LogicModuleSrv.doExit(e.getErrorCode());</span>
					}
<span class="nc" id="L145">				}</span>
<span class="nc" id="L146">			} catch (final DbObjectAlreadyExistException dbe) {</span>
<span class="nc" id="L147">				throw dbe;</span>
<span class="nc" id="L148">			} catch (final SQLException e) {</span>
<span class="nc" id="L149">				LogicModuleSrv.doExit(e.getErrorCode());</span>
			} finally {
<span class="nc" id="L151">				closeConnection(conn);</span>
			}
<span class="nc" id="L153">		}</span>
<span class="nc" id="L154">	}</span>

	/**
	 * Get object metadata by ID
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return The ObjectMetaData or null if it does not exist
	 */
	public ObjectMetaData getByID(final ObjectID objectID) {
<span class="nc" id="L164">		synchronized (dataSource) {</span>

<span class="nc" id="L166">			final Connection conn = getConnection();</span>
<span class="nc" id="L167">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.SELECT_METADATA.getSqlStatement())) {</span>
<span class="nc" id="L168">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L169">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">					if (rs.next()) {</span>
<span class="nc" id="L171">						return deserializeObjectMetaData(rs);</span>
					} else {
<span class="nc" id="L173">						return null;</span>
					}
<span class="nc bnc" id="L175" title="All 2 branches missed.">				}</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">			} catch (final SQLException e) {</span>
<span class="nc" id="L177">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L178">				return null;</span>
<span class="nc" id="L179">			} catch (final Exception e) {</span>
<span class="nc" id="L180">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L182">				closeConnection(conn);</span>
			}
		}
	}
	
	/**
	 * Get all objects registered in system
	 * 
	 * @return The id of all objects registered
	 */
	public Set&lt;ObjectID&gt; getAllObjectIDs() {
<span class="nc" id="L193">		synchronized (dataSource) {</span>

<span class="nc" id="L195">			final Set&lt;ObjectID&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc" id="L196">			final Connection conn = getConnection();</span>
<span class="nc" id="L197">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.SELECT_ALL_OIDS.getSqlStatement())) {</span>
<span class="nc" id="L198">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">					while (rs.next()) {</span>
<span class="nc" id="L200">						final ObjectID objectID = new ObjectID((UUID) rs.getObject(&quot;oid&quot;));</span>
<span class="nc" id="L201">						result.add(objectID);</span>
<span class="nc" id="L202">					}</span>
				}
<span class="nc" id="L204">				return result;</span>
<span class="nc" id="L205">			} catch (final SQLException e) {</span>
<span class="nc" id="L206">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L207">				return null;</span>
<span class="nc" id="L208">			} catch (final Exception e) {</span>
<span class="nc" id="L209">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L211">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Check if there is an object object metadata identified by ID provided
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return TRUE if exists. FALSE otherwise
	 */
	public boolean existsByID(final ObjectID objectID) {
<span class="nc" id="L224">		synchronized (dataSource) {</span>

<span class="nc" id="L226">			final Connection conn = getConnection();</span>
<span class="nc" id="L227">			try (PreparedStatement existsStatement = conn</span>
<span class="nc" id="L228">					.prepareStatement(SqlStatements.EXISTS_METADATA_BY_ID.getSqlStatement())) {</span>

<span class="nc" id="L230">				existsStatement.setObject(1, objectID.getId());</span>
<span class="nc" id="L231">				try (ResultSet rs = existsStatement.executeQuery()) {</span>
<span class="nc" id="L232">					rs.next();</span>
<span class="nc" id="L233">					return rs.getBoolean(1);</span>
				}
<span class="nc" id="L235">			} catch (final SQLException e) {</span>
<span class="nc" id="L236">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L237">				return false;</span>
<span class="nc" id="L238">			} catch (final Exception e) {</span>
<span class="nc" id="L239">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L241">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Check if there is any ObjectMetaData with DataSetID provided
	 * 
	 * @param datasetID
	 *            DataSetID
	 * @return TRUE if there is any ObjectMetaData with DataSetID provided. FALSE otherwise.
	 */
	public boolean existsByDataSetID(final DataSetID datasetID) {
<span class="nc" id="L254">		synchronized (dataSource) {</span>

<span class="nc" id="L256">			final Connection conn = getConnection();</span>
<span class="nc" id="L257">			try (PreparedStatement existsStatement = conn</span>
<span class="nc" id="L258">					.prepareStatement(SqlStatements.EXISTS_METADATA_BY_DATASETID.getSqlStatement())) {</span>

<span class="nc" id="L260">				existsStatement.setObject(1, datasetID.getId());</span>
<span class="nc" id="L261">				try (ResultSet rs = existsStatement.executeQuery()) {</span>
<span class="nc" id="L262">					rs.next();</span>
<span class="nc" id="L263">					return rs.getBoolean(1);</span>
				}
<span class="nc" id="L265">			} catch (final SQLException e) {</span>
<span class="nc" id="L266">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L267">				return false;</span>
<span class="nc" id="L268">			} catch (final Exception e) {</span>
<span class="nc" id="L269">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L271">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Delete object metadata identified by ID provided (ignored if object does not exist)
	 * 
	 * @param objectID
	 *            ID of the object
	 */
	public void deleteByID(final ObjectID objectID) throws DbHandlerException {
<span class="nc" id="L283">		synchronized (dataSource) {</span>

<span class="nc" id="L285">			final Connection conn = getConnection();</span>
<span class="nc" id="L286">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.DELETE_METADATA.getSqlStatement())) {</span>

<span class="nc" id="L288">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L289">				ps.executeUpdate();</span>
<span class="nc" id="L290">			} catch (final SQLException e) {</span>
<span class="nc" id="L291">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L292">			} catch (final Exception e) {</span>
<span class="nc" id="L293">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L295">				closeConnection(conn);</span>
			}
<span class="nc" id="L297">		}</span>
<span class="nc" id="L298">	}</span>

	/**
	 * Update object metadata by ID
	 * 
	 * @param objectID
	 *            ID of the object to update
	 * @param newAlias
	 *            new alias of the object
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void updateAliasByID(final ObjectID objectID, final String newAlias)
			throws DbObjectNotExistException {
<span class="nc" id="L312">		synchronized (dataSource) {</span>

<span class="nc" id="L314">			final Connection conn = getConnection();</span>
<span class="nc" id="L315">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.UPDATE_ALIAS_METADATA.getSqlStatement())) {</span>
<span class="nc" id="L316">				ps.setString(1, newAlias);</span>
<span class="nc" id="L317">				ps.setObject(2, objectID.getId());</span>
<span class="nc" id="L318">				final int count = ps.executeUpdate();</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">				if (count == 0) {</span>
<span class="nc" id="L320">					throw new DbObjectNotExistException(objectID);</span>
				}
<span class="nc" id="L322">			} catch (final SQLException e) {</span>
<span class="nc" id="L323">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L324">			} catch (final DbObjectNotExistException dbe) {</span>
<span class="nc" id="L325">				throw dbe;</span>
<span class="nc" id="L326">			} catch (final Exception e) {</span>
<span class="nc" id="L327">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L329">				closeConnection(conn);</span>
			}
<span class="nc" id="L331">		}</span>
<span class="nc" id="L332">	}</span>

	/**
	 * Update object metadata by ID
	 * 
	 * @param objectID
	 *            ID of object to update
	 * @param newdatasetid
	 *            New dataset id
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void updateDataSetIDByID(final ObjectID objectID, final DataSetID newdatasetid)
			throws DbObjectNotExistException {
<span class="nc" id="L346">		synchronized (dataSource) {</span>
<span class="nc" id="L347">			final Connection conn = getConnection();</span>
<span class="nc" id="L348">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.UPDATE_DATASETID_METADATA.getSqlStatement())) {</span>

<span class="nc" id="L350">				ps.setObject(1, newdatasetid.getId());</span>
<span class="nc" id="L351">				ps.setObject(2, objectID.getId());</span>
<span class="nc" id="L352">				final int count = ps.executeUpdate();</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">				if (count == 0) {</span>
<span class="nc" id="L354">					throw new DbObjectNotExistException(objectID);</span>
				}
<span class="nc" id="L356">			} catch (final SQLException e) {</span>
<span class="nc" id="L357">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L358">			} catch (final DbObjectNotExistException dbe) {</span>
<span class="nc" id="L359">				throw dbe;</span>
<span class="nc" id="L360">			} catch (final Exception e) {</span>
<span class="nc" id="L361">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L363">				closeConnection(conn);</span>
			}
<span class="nc" id="L365">		}</span>
<span class="nc" id="L366">	}</span>

	/**
	 * Update object metadata by ID
	 * 
	 * @param objectID
	 *            ID of object to update
	 * @param newLocs
	 *            New location ids
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void updateLocationIDsByID(final ObjectID objectID, final Set&lt;ExecutionEnvironmentID&gt; newLocs)
			throws DbObjectNotExistException {
<span class="nc" id="L380">		synchronized (dataSource) {</span>
<span class="nc" id="L381">			final Connection conn = getConnection();</span>
<span class="nc" id="L382">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.UPDATE_LOCS_METADATA.getSqlStatement())) {</span>

<span class="nc" id="L384">				final Object[] theArray = new Object[newLocs.size()];</span>
<span class="nc" id="L385">				int i = 0;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">				for (final ExecutionEnvironmentID stLocID : newLocs) {</span>
<span class="nc" id="L387">					theArray[i] = stLocID.getId();</span>
<span class="nc" id="L388">					i++;</span>
<span class="nc" id="L389">				}</span>
<span class="nc" id="L390">				final Array sqlArray = ps.getConnection().createArrayOf(&quot;uuid&quot;, theArray);</span>
<span class="nc" id="L391">				ps.setArray(1, sqlArray);</span>
<span class="nc" id="L392">				ps.setObject(2, objectID.getId());</span>
<span class="nc" id="L393">				final int count = ps.executeUpdate();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">				if (count == 0) {</span>
<span class="nc" id="L395">					throw new DbObjectNotExistException(objectID);</span>
				}
<span class="nc" id="L397">			} catch (final SQLException e) {</span>
<span class="nc" id="L398">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L399">			} catch (final DbObjectNotExistException dbe) {</span>
<span class="nc" id="L400">				throw dbe;</span>
<span class="nc" id="L401">			} catch (final Exception e) {</span>
<span class="nc" id="L402">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L404">				closeConnection(conn);</span>
			}
<span class="nc" id="L406">		}</span>
<span class="nc" id="L407">	}</span>

	/**
	 * Update object metadata by ID
	 * 
	 * @param objectID
	 *            ID of object to update
	 * @param newisreadonly
	 *            new is read only value
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void updateReadOnlyByID(final ObjectID objectID, final boolean newisreadonly)
			throws DbObjectNotExistException {
<span class="nc" id="L421">		synchronized (dataSource) {</span>
<span class="nc" id="L422">			final Connection conn = getConnection();</span>
<span class="nc" id="L423">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.UPDATE_READONLY_METADATA.getSqlStatement())) {</span>

<span class="nc" id="L425">				ps.setBoolean(1, newisreadonly);</span>
<span class="nc" id="L426">				ps.setObject(2, objectID.getId());</span>
<span class="nc" id="L427">				final int count = ps.executeUpdate();</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">				if (count == 0) {</span>
<span class="nc" id="L429">					throw new DbObjectNotExistException(objectID);</span>
				}
<span class="nc" id="L431">			} catch (final SQLException e) {</span>
<span class="nc" id="L432">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L433">			} catch (final DbObjectNotExistException dbe) {</span>
<span class="nc" id="L434">				throw dbe;</span>
<span class="nc" id="L435">			} catch (final Exception e) {</span>
<span class="nc" id="L436">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L438">				closeConnection(conn);</span>
			}
<span class="nc" id="L440">		}</span>
<span class="nc" id="L441">	}</span>

	/**
	 * Update object metadata by ID
	 * 
	 * @param objectID
	 *            ID of object to update
	 * @param newLocs
	 *            New storage location ids
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void updateForReplicaByID(final ObjectID objectID, final Set&lt;ExecutionEnvironmentID&gt; newLocs,
			final boolean newReadOnly) throws DbObjectNotExistException {
<span class="nc" id="L455">		synchronized (dataSource) {</span>
<span class="nc" id="L456">			final Connection conn = getConnection();</span>
<span class="nc" id="L457">			try (PreparedStatement ps = conn</span>
<span class="nc" id="L458">					.prepareStatement(SqlStatements.UPDATE_FOR_REPLICA_METADATA.getSqlStatement())) {</span>

<span class="nc" id="L460">				final Object[] theArray = new Object[newLocs.size()];</span>
<span class="nc" id="L461">				int i = 0;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">				for (final ExecutionEnvironmentID locID : newLocs) {</span>
<span class="nc" id="L463">					theArray[i] = locID.getId();</span>
<span class="nc" id="L464">					i++;</span>
<span class="nc" id="L465">				}</span>
<span class="nc" id="L466">				final Array sqlArray = ps.getConnection().createArrayOf(&quot;uuid&quot;, theArray);</span>
<span class="nc" id="L467">				ps.setArray(1, sqlArray);</span>
<span class="nc" id="L468">				ps.setBoolean(2, newReadOnly);</span>
<span class="nc" id="L469">				ps.setObject(3, objectID.getId());</span>
<span class="nc" id="L470">				final int count = ps.executeUpdate();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">				if (count == 0) {</span>
<span class="nc" id="L472">					throw new DbObjectNotExistException(objectID);</span>
				}
<span class="nc" id="L474">			} catch (final SQLException e) {</span>
<span class="nc" id="L475">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L476">			} catch (final DbObjectNotExistException dbe) {</span>
<span class="nc" id="L477">				throw dbe;</span>
<span class="nc" id="L478">			} catch (final Exception e) {</span>
<span class="nc" id="L479">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L481">				closeConnection(conn);</span>
			}
<span class="nc" id="L483">		}</span>
<span class="nc" id="L484">	}</span>

	/**
	 * Get a set of objects metadata by its Class ID
	 * 
	 * @param classID
	 *            Class ID of the objects
	 * @return The ObjectMetaDatas with class id provided
	 */
	public ArrayList&lt;ObjectMetaData&gt; getByClass(final MetaClassID classID) {
<span class="nc" id="L494">		synchronized (dataSource) {</span>
<span class="nc" id="L495">			final ArrayList&lt;ObjectMetaData&gt; resultList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L496">			final Connection conn = getConnection();</span>
<span class="nc" id="L497">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.SELECT_METADATA_FOR_CLASS.getSqlStatement())) {</span>

<span class="nc" id="L499">				ps.setObject(1, classID.getId());</span>
<span class="nc" id="L500">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">					while (rs.next()) {</span>
<span class="nc" id="L502">						final ObjectMetaData objectMD = deserializeObjectMetaData(rs);</span>
<span class="nc" id="L503">						resultList.add(objectMD);</span>
<span class="nc" id="L504">					}</span>
				}
<span class="nc" id="L506">				return resultList;</span>
<span class="nc" id="L507">			} catch (final SQLException e) {</span>
<span class="nc" id="L508">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L509">				return null;</span>
<span class="nc" id="L510">			} catch (final Exception e) {</span>
<span class="nc" id="L511">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L513">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Get anb object by class - alias (null if it does not exist)
	 * 
	 * @param alias
	 *            alias of the object
	 * @return object instancing specified class and aliased with given alias. null if there is none.
	 */
	public ObjectMetaData getByAlias(final String alias) {
<span class="nc" id="L526">		synchronized (dataSource) {</span>
<span class="nc" id="L527">			final Connection conn = getConnection();</span>
<span class="nc" id="L528">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.SELECT_METADATA_BY_ALIAS.getSqlStatement())) {</span>
<span class="nc" id="L529">				ps.setString(1, alias);</span>
<span class="nc" id="L530">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">					if (rs.next()) {</span>
<span class="nc" id="L532">						return deserializeObjectMetaData(rs);</span>
					} else {
<span class="nc" id="L534">						return null;</span>
					}
<span class="nc bnc" id="L536" title="All 2 branches missed.">				}</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">			} catch (final SQLException e) {</span>
<span class="nc" id="L538">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L539">				return null;</span>
<span class="nc" id="L540">			} catch (final Exception e) {</span>
<span class="nc" id="L541">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L543">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Registers an object to be federated with an external dataClay instance
	 * 
	 * @param objectID
	 *            id of the object to be federated
	 * @param dataClayID
	 *            id of the external dataClay instance
	 * @return true if the object has been successfully registered, false if it was already registered previously
	 */
	public boolean insertFederatedObject(final ObjectID objectID, final DataClayInstanceID dataClayID) {
<span class="nc" id="L558">		synchronized (dataSource) {</span>
<span class="nc" id="L559">			final Connection conn = getConnection();</span>
<span class="nc" id="L560">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.INSERT_FEDERATED_OBJECT.getSqlStatement())) {</span>

<span class="nc" id="L562">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L563">				ps.setObject(2, dataClayID.getId());</span>
				try {
<span class="nc" id="L565">					ps.executeUpdate();</span>
<span class="nc" id="L566">				} catch (final SQLException e) {</span>
					/* A primary key constraint is violated */
<span class="nc bnc" id="L568" title="All 2 branches missed.">					if (e.getErrorCode() == SQLiteErrorCode.SQLITE_CONSTRAINT.code) {</span>
<span class="nc" id="L569">						throw new DbObjectAlreadyExistException(dataClayID);</span>
					} else {
<span class="nc" id="L571">						LogicModuleSrv.doExit(e.getErrorCode());</span>
					}
<span class="nc" id="L573">				}</span>
<span class="nc" id="L574">				return true;</span>
<span class="nc" id="L575">			} catch (final SQLException e) {</span>
<span class="nc" id="L576">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L577">				return false;</span>
<span class="nc" id="L578">			} catch (final Exception e) {</span>
<span class="nc" id="L579">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L581">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Delete federated object
	 * 
	 * @param objectID
	 *            id of the object to be deleted
	 * @param dataClayID
	 *            id of the external dataClay instance
	 * @return true if the object has been successfully deleted, false otherwise
	 */
	public boolean deleteFederatedObject(final ObjectID objectID, final DataClayInstanceID dataClayID) {
<span class="nc" id="L596">		synchronized (dataSource) {</span>
<span class="nc" id="L597">			final Connection conn = getConnection();</span>
<span class="nc" id="L598">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.DELETE_FEDERATED_OBJECT.getSqlStatement())) {</span>

<span class="nc" id="L600">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L601">				ps.setObject(2, dataClayID.getId());</span>
				try {
<span class="nc" id="L603">					ps.executeUpdate();</span>
<span class="nc" id="L604">				} catch (final SQLException e) {</span>
<span class="nc" id="L605">					return false;</span>
<span class="nc" id="L606">				}</span>
<span class="nc" id="L607">				return true;</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">			} catch (final SQLException e) {</span>
<span class="nc" id="L609">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L610">				return false;</span>
<span class="nc" id="L611">			} catch (final Exception e) {</span>
<span class="nc" id="L612">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L614">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Checks if the object is already federated with given external dataClay instance.
	 * 
	 * @param objectID
	 *            id of the object to be checked
	 * @param dataClayID
	 *            id of the external dataClay id
	 * @return true if the object is already registered as federated object with given external dataClay instance. false
	 *         otherwise.
	 */
	public boolean existsFederatedObjectWithDC(final ObjectID objectID, final DataClayInstanceID dataClayID) {
<span class="nc" id="L630">		synchronized (dataSource) {</span>
<span class="nc" id="L631">			final Connection conn = getConnection();</span>
<span class="nc" id="L632">			try (PreparedStatement ps = conn</span>
<span class="nc" id="L633">					.prepareStatement(SqlStatements.EXISTS_FEDERATED_OBJECT_WITH_DC.getSqlStatement())) {</span>

<span class="nc" id="L635">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L636">				ps.setObject(2, dataClayID.getId());</span>
<span class="nc" id="L637">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc" id="L638">					rs.next();</span>
<span class="nc" id="L639">					return rs.getBoolean(1);</span>
				}
<span class="nc" id="L641">			} catch (final SQLException e) {</span>
<span class="nc" id="L642">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L643">				return false;</span>
<span class="nc" id="L644">			} catch (final Exception e) {</span>
<span class="nc" id="L645">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L647">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Checks if the object is already federated.
	 * 
	 * @param objectID
	 *            id of the object to be checked
	 * @return true if the object is already registered as federated object with given external dataClay instance. false
	 *         otherwise.
	 */
	public boolean existsFederatedObject(final ObjectID objectID) {
<span class="nc" id="L661">		synchronized (dataSource) {</span>
<span class="nc" id="L662">			final Connection conn = getConnection();</span>
<span class="nc" id="L663">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.EXISTS_FEDERATED_OBJECT.getSqlStatement())) {</span>

<span class="nc" id="L665">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L666">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc" id="L667">					rs.next();</span>
<span class="nc" id="L668">					return rs.getBoolean(1);</span>
				}
<span class="nc" id="L670">			} catch (final SQLException e) {</span>
<span class="nc" id="L671">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L672">				return false;</span>
<span class="nc" id="L673">			} catch (final Exception e) {</span>
<span class="nc" id="L674">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L676">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Retrieves external target dataClays ids which the given object is federated with
	 * 
	 * @param objectID
	 *            id of the object to be checked
	 * @return ids of external dataClays which the object is federated with
	 */
	public Set&lt;DataClayInstanceID&gt; getDataClaysOurObjectIsFederatedWith(final ObjectID objectID) {
<span class="nc" id="L689">		synchronized (dataSource) {</span>
<span class="nc" id="L690">			final Connection conn = getConnection();</span>
<span class="nc" id="L691">			final Set&lt;DataClayInstanceID&gt; result = new HashSet&lt;&gt;();</span>

<span class="nc" id="L693">			try (PreparedStatement ps = conn</span>
<span class="nc" id="L694">					.prepareStatement(SqlStatements.SELECT_TARGET_DATACLAYS_FEDERATED_OBJECT.getSqlStatement())) {</span>

<span class="nc" id="L696">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L697">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">					while (rs.next()) {</span>
<span class="nc" id="L699">						final DataClayInstanceID extDataClayID = new DataClayInstanceID(</span>
<span class="nc" id="L700">								(UUID) rs.getObject(&quot;targetDataClayID&quot;));</span>
<span class="nc" id="L701">						result.add(extDataClayID);</span>
<span class="nc" id="L702">					}</span>
				}
<span class="nc" id="L704">			} catch (final SQLException e) {</span>
<span class="nc" id="L705">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L706">			} catch (final Exception e) {</span>
<span class="nc" id="L707">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L709">				closeConnection(conn);</span>
			}

<span class="nc" id="L712">			return result;</span>
		}
	}

	/**
	 * Method that retrieves all the objects federated/belonging to dataClay with ID provided.
	 * 
	 * @param extDataClayInstanceID
	 *            id of dataclay
	 * @return all the objects federated/belonging to dataClay with ID provided.
	 */
	public Set&lt;ObjectID&gt; getObjectsFederatedWithDataClay(final DataClayInstanceID extDataClayInstanceID) {
<span class="nc" id="L724">		synchronized (dataSource) {</span>
<span class="nc" id="L725">			final Connection conn = getConnection();</span>
<span class="nc" id="L726">			final Set&lt;ObjectID&gt; result = new HashSet&lt;&gt;();</span>

<span class="nc" id="L728">			try (PreparedStatement ps = conn</span>
<span class="nc" id="L729">					.prepareStatement(SqlStatements.SELECT_OBJECTS_FEDERATED_WITH_DATACLAY.getSqlStatement())) {</span>

<span class="nc" id="L731">				ps.setObject(1, extDataClayInstanceID.getId());</span>
<span class="nc" id="L732">				ps.setObject(2, extDataClayInstanceID.getId());</span>
<span class="nc" id="L733">				ps.setBoolean(3, false);</span>
<span class="nc" id="L734">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">					while (rs.next()) {</span>
<span class="nc" id="L736">						final ObjectID objectID = new ObjectID(</span>
<span class="nc" id="L737">								(UUID) rs.getObject(&quot;oid&quot;));</span>
<span class="nc" id="L738">						result.add(objectID);</span>
<span class="nc" id="L739">					}</span>
				}
<span class="nc" id="L741">			} catch (final SQLException e) {</span>
<span class="nc" id="L742">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L743">			} catch (final Exception e) {</span>
<span class="nc" id="L744">				e.printStackTrace();</span>
<span class="nc" id="L745">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L747">				closeConnection(conn);</span>
			}

<span class="nc" id="L750">			return result;</span>
		}
	}

	/**
	 * Registers an object that has been federated from an external dataClay instance.
	 * 
	 * @param objectID
	 *            ID of the external object
	 * @param srcDataClayID
	 *            id of the source dataClay instance federating this object
	 * @param unregisteredFlag Indicates object is unregistered
	 */
	public void insertExternalObject(final ObjectID objectID, final DataClayInstanceID srcDataClayID, 
			final boolean unregisteredFlag) {
<span class="nc" id="L765">		synchronized (dataSource) {</span>
<span class="nc" id="L766">			final Connection conn = getConnection();</span>
<span class="nc" id="L767">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.INSERT_EXTERNAL_OBJECT.getSqlStatement())) {</span>

<span class="nc" id="L769">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L770">				ps.setObject(2, srcDataClayID.getId());</span>
<span class="nc" id="L771">				ps.setBoolean(3, unregisteredFlag);</span>
<span class="nc" id="L772">				ps.executeUpdate();</span>
<span class="nc" id="L773">			} catch (final SQLException e) {</span>
<span class="nc" id="L774">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L775">			} catch (final Exception e) {</span>
<span class="nc" id="L776">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L778">				closeConnection(conn);</span>
			}
<span class="nc" id="L780">		}</span>
<span class="nc" id="L781">	}</span>

	/**
	 * Delete a federated object from an external dataClay instance.
	 * 
	 * @param objectID
	 *            ID of the external object
	 */
	public void deleteExternalObject(final ObjectID objectID) {
<span class="nc" id="L790">		synchronized (dataSource) {</span>
<span class="nc" id="L791">			final Connection conn = getConnection();</span>
<span class="nc" id="L792">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.DELETE_EXTERNAL_OBJECT.getSqlStatement())) {</span>
<span class="nc" id="L793">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L794">				ps.executeUpdate();</span>
<span class="nc" id="L795">			} catch (final SQLException e) {</span>
<span class="nc" id="L796">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L797">			} catch (final Exception e) {</span>
<span class="nc" id="L798">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L800">				closeConnection(conn);</span>
			}
<span class="nc" id="L802">		}</span>
<span class="nc" id="L803">	}</span>

	/**
	 * Checks whether the given object is externally federated
	 * 
	 * @param objectID
	 *            id of the object to be checked
	 * @param unregisteredFlag Indicates if object is unregistered or not
	 * @return true if it is an external object federated. false otherwise.
	 */
	public boolean existsExternalObject(final ObjectID objectID, final boolean unregisteredFlag) {
<span class="nc" id="L814">		synchronized (dataSource) {</span>
<span class="nc" id="L815">			final Connection conn = getConnection();</span>
<span class="nc" id="L816">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.EXISTS_EXTERNAL_OBJECT.getSqlStatement())) {</span>

<span class="nc" id="L818">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L819">				ps.setBoolean(2, unregisteredFlag);</span>
<span class="nc" id="L820">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc" id="L821">					rs.next();</span>
<span class="nc" id="L822">					return rs.getBoolean(1);</span>
				}
<span class="nc" id="L824">			} catch (final SQLException e) {</span>
<span class="nc" id="L825">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L826">				return false;</span>
<span class="nc" id="L827">			} catch (final Exception e) {</span>
<span class="nc" id="L828">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L830">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Get unregistered external objects.
	 * @return id of external objects unregistered
	 */
	public Set&lt;ObjectID&gt; getUnregisteredExternalObjects() {
<span class="nc" id="L840">		synchronized (dataSource) {</span>
<span class="nc" id="L841">			final Set&lt;ObjectID&gt; resultList = new HashSet&lt;&gt;();</span>
<span class="nc" id="L842">			final Connection conn = getConnection();</span>
<span class="nc" id="L843">			try (PreparedStatement ps = conn</span>
<span class="nc" id="L844">					.prepareStatement(SqlStatements.SELECT_UNREGISTERED_EXTERNAL_OBJECTS.getSqlStatement())) {</span>
<span class="nc" id="L845">				ps.setBoolean(1, true);</span>
<span class="nc" id="L846">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">					while (rs.next()) {</span>
<span class="nc" id="L848">						final ObjectID oid = new ObjectID(</span>
<span class="nc" id="L849">								(UUID) rs.getObject(&quot;oid&quot;));</span>
<span class="nc" id="L850">						resultList.add(oid);</span>
<span class="nc" id="L851">					}</span>
				}
<span class="nc" id="L853">				return resultList;</span>
<span class="nc" id="L854">			} catch (final SQLException e) {</span>
<span class="nc" id="L855">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L856">				return null;</span>
<span class="nc" id="L857">			} catch (final Exception e) {</span>
<span class="nc" id="L858">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L860">				closeConnection(conn);</span>
			}
		}
	}

	
	/**
	 * Update external object flag unregistered
	 * 
	 * @param objectID
	 *            ID of the object to update
	 * @param unregisteredFlag
	 *            Value of flag unregistered
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void updateUnregisteredFlagExternalObject(final ObjectID objectID, final boolean unregisteredFlag)
			throws DbObjectNotExistException {
<span class="nc" id="L878">		synchronized (dataSource) {</span>
<span class="nc" id="L879">			final Connection conn = getConnection();</span>
<span class="nc" id="L880">			try (PreparedStatement ps = conn.prepareStatement(SqlStatements.UPDATE_UNREGISTER_EXTERNAL_OBJECT.getSqlStatement())) {</span>

<span class="nc" id="L882">				ps.setBoolean(1, unregisteredFlag);</span>
<span class="nc" id="L883">				ps.setObject(2, objectID.getId());</span>
<span class="nc" id="L884">				final int count = ps.executeUpdate();</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">				if (count == 0) {</span>
<span class="nc" id="L886">					throw new DbObjectNotExistException(objectID);</span>
				}
<span class="nc" id="L888">			} catch (final SQLException e) {</span>
<span class="nc" id="L889">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L890">			} catch (final DbObjectNotExistException dbe) {</span>
<span class="nc" id="L891">				throw dbe;</span>
<span class="nc" id="L892">			} catch (final Exception e) {</span>
<span class="nc" id="L893">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L895">				closeConnection(conn);</span>
			}
<span class="nc" id="L897">		}</span>
<span class="nc" id="L898">	}</span>
	
	/**
	 * Retrieves external source dataClay id owning the given object.
	 * 
	 * @param objectID
	 *            id of the object to be checked
	 * @return id of the external source dataClay
	 */
	public DataClayInstanceID getExternalDataClayOfObject(final ObjectID objectID) {
<span class="nc" id="L908">		synchronized (dataSource) {</span>
<span class="nc" id="L909">			final Connection conn = getConnection();</span>
<span class="nc" id="L910">			try (PreparedStatement ps = conn</span>
<span class="nc" id="L911">					.prepareStatement(SqlStatements.SELECT_SOURCE_DATACLAY_EXTERNAL_OBJECT.getSqlStatement())) {</span>

<span class="nc" id="L913">				ps.setObject(1, objectID.getId());</span>
<span class="nc" id="L914">				try (ResultSet rs = ps.executeQuery()) {</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">					if (rs.next()) {</span>
<span class="nc" id="L916">						return new DataClayInstanceID((UUID) rs.getObject(&quot;srcDataClayID&quot;));</span>
					} else {
<span class="nc" id="L918">						return null;</span>
					}
<span class="nc bnc" id="L920" title="All 2 branches missed.">				}</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">			} catch (final SQLException e) {</span>
<span class="nc" id="L922">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L923">				return null;</span>
<span class="nc" id="L924">			} catch (final Exception e) {</span>
<span class="nc" id="L925">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L927">				closeConnection(conn);</span>
			}
		}
	}

	/**
	 * Vacuum database.
	 */
	public void vacuum() {
<span class="nc" id="L936">		synchronized (dataSource) {</span>
<span class="nc" id="L937">			final Connection conn = getConnection();</span>
<span class="nc" id="L938">			try (PreparedStatement ps = conn</span>
<span class="nc" id="L939">					.prepareStatement(SqlStatements.VACUUM.getSqlStatement())) {</span>
<span class="nc" id="L940">				ps.executeUpdate();</span>
<span class="nc" id="L941">			} catch (final SQLException e) {</span>
<span class="nc" id="L942">				LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L943">			} catch (final Exception e) {</span>
<span class="nc" id="L944">				throw new DbHandlerException(e);</span>
			} finally {
<span class="nc" id="L946">				closeConnection(conn);</span>
			}
<span class="nc" id="L948">		}</span>

<span class="nc" id="L950">	}</span>

	/**
	 * Close DB.
	 */
	public void close() {
		try {
<span class="nc" id="L957">			dataSource.close();</span>
<span class="nc" id="L958">		} catch (final Exception e) {</span>
			// TODO
<span class="nc" id="L960">			e.printStackTrace();</span>
<span class="nc" id="L961">		}</span>
<span class="nc" id="L962">	}</span>

	private Connection getConnection() {
		try {
<span class="nc" id="L966">			return dataSource.getConnection();</span>
<span class="nc" id="L967">		} catch (final SQLException e) {</span>
<span class="nc" id="L968">			LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L969">			return null;</span>
		}
	}

	private void closeConnection(final Connection conn) {
		try {
<span class="nc" id="L975">			conn.close();</span>
<span class="nc" id="L976">		} catch (final SQLException e) {</span>
<span class="nc" id="L977">			LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L978">		}</span>
<span class="nc" id="L979">	}</span>

	/**
	 * Deserialize object metadata
	 * 
	 * @param rs
	 *            Result set
	 * @return Object MetaData
	 */
	private ObjectMetaData deserializeObjectMetaData(final ResultSet rs) {
<span class="nc" id="L989">		ObjectMetaData objectMD = null;</span>
		try {
<span class="nc" id="L991">			final ObjectID objectID = new ObjectID((UUID) rs.getObject(&quot;oid&quot;));</span>
<span class="nc" id="L992">			final MetaClassID classID = new MetaClassID((UUID) rs.getObject(&quot;classid&quot;));</span>
<span class="nc" id="L993">			final DataSetID dataSetID = new DataSetID((UUID) rs.getObject(&quot;datasetid&quot;));</span>
<span class="nc" id="L994">			Array sqlArray = rs.getArray(&quot;stlocs&quot;);</span>
<span class="nc" id="L995">			final UUID[] uuidArray = (UUID[]) sqlArray.getArray();</span>
<span class="nc" id="L996">			final HashSet&lt;ExecutionEnvironmentID&gt; backendIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">			for (final UUID uuid : uuidArray) {</span>
<span class="nc" id="L998">				final ExecutionEnvironmentID backendID = new ExecutionEnvironmentID(uuid);</span>
<span class="nc" id="L999">				backendIDs.add(backendID);</span>
			}
<span class="nc" id="L1001">			final boolean isReadOnly = rs.getBoolean(&quot;isreadonly&quot;);</span>
<span class="nc" id="L1002">			final String alias = rs.getString(&quot;alias&quot;);</span>
<span class="nc" id="L1003">			final int langCode = rs.getInt(&quot;language&quot;);</span>
			final Langs lang;

<span class="nc bnc" id="L1006" title="All 2 branches missed.">			if (Langs.LANG_PYTHON.getNumber() == langCode) {</span>
<span class="nc" id="L1007">				lang = Langs.LANG_PYTHON;</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">			} else if (Langs.LANG_JAVA.getNumber() == langCode) {</span>
<span class="nc" id="L1009">				lang = Langs.LANG_JAVA;</span>
			} else {
<span class="nc" id="L1011">				logger.warn(&quot;Deserializing language none!&quot;);</span>
<span class="nc" id="L1012">				lang = Langs.LANG_NONE;</span>
			}

<span class="nc" id="L1015">			final AccountID ownerID = new AccountID((UUID) rs.getObject(&quot;accountid&quot;));</span>

<span class="nc" id="L1017">			objectMD = new ObjectMetaData(objectID, classID, dataSetID, backendIDs, isReadOnly, alias, lang, ownerID);</span>

<span class="nc" id="L1019">			return objectMD;</span>
<span class="nc" id="L1020">		} catch (final SQLException e) {</span>
<span class="nc" id="L1021">			LogicModuleSrv.doExit(e.getErrorCode());</span>
<span class="nc" id="L1022">			return null;</span>
<span class="nc" id="L1023">		} catch (final Exception e) {</span>
<span class="nc" id="L1024">			throw new DbHandlerException(e);</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>