<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaDataService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.metadataservice</a> &gt; <span class="el_source">MetaDataService.java</span></div><h1>MetaDataService.java</h1><pre class="source lang-java linenums">
/**
 * @file MetaDataService.java
 * @date May 21, 2013
 */
package es.bsc.dataclay.metadataservice;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import es.bsc.dataclay.util.management.metadataservice.*;
import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import es.bsc.dataclay.commonruntime.DataClayRuntime;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectAlreadyExistException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.exceptions.metadataservice.AliasAlreadyInUseException;
import es.bsc.dataclay.exceptions.metadataservice.ExecutionEnvironmentAlreadyExistsException;
import es.bsc.dataclay.exceptions.metadataservice.ExecutionEnvironmentNotExistException;
import es.bsc.dataclay.exceptions.metadataservice.ExternalDataClayNotRegisteredException;
import es.bsc.dataclay.exceptions.metadataservice.MultipleAliasesException;
import es.bsc.dataclay.exceptions.metadataservice.ObjectAlreadyRegisteredException;
import es.bsc.dataclay.exceptions.metadataservice.ObjectHasReplicas;
import es.bsc.dataclay.exceptions.metadataservice.ObjectNotRegisteredException;
import es.bsc.dataclay.exceptions.metadataservice.StorageLocationAlreadyExistsException;
import es.bsc.dataclay.exceptions.metadataservice.StorageLocationNotExistException;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.StorageLocationID;
import es.bsc.dataclay.util.management.AbstractManager;
import es.bsc.dataclay.util.structs.MemoryCache;
import es.bsc.dataclay.util.structs.Tuple;
import es.bsc.dataclay.dbhandler.sql.sqlite.SQLiteDataSource;

/**
 * This class is responsible to manage information related to an object (metaclassID of the object, backend in which is stored,
 * interface and contract used for creating the object...).
 */
public final class MetaDataService extends AbstractManager {
<span class="nc" id="L54">	private static final Logger logger = LogManager.getLogger(&quot;MetaDataService&quot;);</span>

	/** Indicates if debug is enabled. */
<span class="nc" id="L57">	protected static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

	/** Object cache. */
	private final MemoryCache&lt;ObjectID, ObjectMetaData&gt; objectMDCache;

	/** Federated objects cache. */
	private final MemoryCache&lt;ObjectID, Set&lt;DataClayInstanceID&gt;&gt; federatedObjectsCache;

	/** Object by Alias cache. */
	private final MemoryCache&lt;String, ObjectMetaData&gt; objectMDCacheByAlias;

	/** MetaDataService database. */
	private final MetaDataServiceDB metadataDB;

	/**
	 * Instantiates an MetaDataService that uses the Backend configuration provided.
	 * 
	 * @param dataSource
	 *            Data source.
	 * @post Creates MetaDataService and initializes the backend.
	 */
	public MetaDataService(final SQLiteDataSource dataSource) {
<span class="nc" id="L79">		super(dataSource);</span>
<span class="nc" id="L80">		metadataDB = new MetaDataServiceDB(dataSource);</span>
<span class="nc" id="L81">		metadataDB.createTables();</span>

		// Init caches
<span class="nc" id="L84">		this.objectMDCache = new MemoryCache&lt;&gt;();</span>
<span class="nc" id="L85">		this.objectMDCacheByAlias = new MemoryCache&lt;&gt;();</span>
<span class="nc" id="L86">		this.federatedObjectsCache = new MemoryCache&lt;&gt;();</span>
<span class="nc" id="L87">	}</span>

	/**
	 * Checks whether an objects exists or not.
	 * 
	 * @param objectID
	 *            ID of the object to be checked.
	 * @return True if the objectID is registered in the service, false otherwise.
	 * @throws Exception
	 *             if any exception occurs
	 */
	public boolean existsObject(final ObjectID objectID) {
		// Check cache
<span class="nc" id="L100">		ObjectMetaData objectMD = objectMDCache.get(objectID);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// Query by example
<span class="nc" id="L103">			objectMD = metadataDB.getByID(objectID);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">			if (objectMD != null) {</span>
				// Update cache if necessary
<span class="nc bnc" id="L106" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L107">					logger.debug(&quot;Updating cache of metadatas: {} -&gt; {}&quot;, objectID, objectMD);</span>
				}
<span class="nc" id="L109">				objectMDCache.put(objectID, objectMD);</span>
<span class="nc" id="L110">				final String alias = objectMD.getAlias();</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">				if (alias != null) {</span>
<span class="nc" id="L112">					objectMDCacheByAlias.put(alias, objectMD);</span>
				}
			}
		}
<span class="nc bnc" id="L116" title="All 2 branches missed.">		return (objectMD != null);</span>
	}

	/**
	 * This operation gets all the backend IDs that contain the object with ID provided.
	 * 
	 * @param objectID
	 *            ID of the object to query
	 * @return The set of backends corresponding to those containing a replica of the object specified. The result can be empty.
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object is not registered.
	 */
	public Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getObjectBackends(final ObjectID objectID) {
		//FIXME: modify move algorithm

		// Query object info
<span class="nc" id="L133">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. Since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L138">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// Prepare result
<span class="nc" id="L141">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; objectMDbackends = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">		for (final ExecutionEnvironmentID curEntry : objectMD.getExecutionEnvironmentIDs()) {</span>
			//FIXME: modify move algorithm
<span class="nc" id="L145">			final ExecutionEnvironment backend = null;</span>
<span class="nc" id="L146">			objectMDbackends.put(curEntry, backend);</span>
<span class="nc" id="L147">		}</span>
<span class="nc" id="L148">		return objectMDbackends;</span>
	}

	/**
	 * This operation retrieves the metadata of an object.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return the metadata of the given object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object is not registered
	 */
	public MetaDataInfo getObjectMetaData(final ObjectID objectID) {
		// Query object info
<span class="nc" id="L163">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">		if (objectMD == null) {</span>
<span class="nc" id="L165">			return null; // do not send exception to avoid serializing it, critical path.</span>
		}

<span class="nc" id="L168">		final MetaDataInfo result = buildMetaDataInfo(objectMD);</span>
<span class="nc" id="L169">		return result;</span>
	}

	/**
	 * Get all objects registered in system
	 * @return ids of all registered objects
	 */
	public Set&lt;ObjectID&gt; getAllObjectIDsRegistered() {
<span class="nc" id="L177">		return metadataDB.getAllObjectIDs();</span>
	}

	/**
	 * Get object ID from alias
	 *
	 * @param alias
	 *            Alias of the object
	 * @return the ID of the object if it is found and its metadata
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object is not registered
	 */
	public Tuple&lt;ObjectID, MetaDataInfo&gt; getObjectInfoFromAlias(final String alias) {
<span class="nc" id="L191">		ObjectMetaData objectMD = objectMDCacheByAlias.get(alias);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">		if (objectMD != null) {</span>
<span class="nc" id="L193">			final MetaDataInfo metadataInfo = buildMetaDataInfo(objectMD);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L195">				logger.debug(&quot;Get by alias: Obtained object &quot; + objectMD.getDataClayID() + &quot; from alias: &quot; + alias);</span>
			}
<span class="nc" id="L197">			return new Tuple&lt;&gt;(objectMD.getDataClayID(), metadataInfo);</span>
		} else {
<span class="nc bnc" id="L199" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L200">				logger.debug(&quot;Alias &quot; + alias + &quot; not found in cache.&quot;);</span>
			}
		}
<span class="nc" id="L203">		objectMD = metadataDB.getByAlias(alias);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">		if (objectMD == null) {</span>
<span class="nc" id="L205">			throw new ObjectNotRegisteredException(alias);</span>
		}

<span class="nc" id="L208">		final MetaDataInfo metadataInfo = buildMetaDataInfo(objectMD);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L210">			logger.debug(&quot;Get by alias: Obtained object &quot; + objectMD.getDataClayID() + &quot; from alias: &quot; + alias);</span>
		}
<span class="nc" id="L212">		return new Tuple&lt;&gt;(objectMD.getDataClayID(), metadataInfo);</span>
	}

	/**
	 * Delete alias of object
	 * 
	 * @param alias
	 *            Alias of the object
	 * @return ID of the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object is not registered
	 */
	public ObjectID deleteAlias(final String alias) {
<span class="nc" id="L226">		ObjectMetaData objectMD = objectMDCacheByAlias.remove(alias);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if (objectMD == null) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L229">				logger.debug(&quot;Alias &quot; + alias + &quot; not found in cache.&quot;);</span>
			}

<span class="nc" id="L232">			objectMD = metadataDB.getByAlias(alias);</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">			if (objectMD == null) {</span>
<span class="nc" id="L235">				throw new ObjectNotRegisteredException(alias);</span>
			}
		}

<span class="nc" id="L239">		objectMD.setAlias(null);</span>

		try {
<span class="nc" id="L242">			metadataDB.updateAliasByID(objectMD.getDataClayID(), null);</span>
<span class="nc" id="L243">		} catch (final DbObjectNotExistException e) {</span>
			// Ignore exception, maybe the object has been garbage collected
<span class="nc" id="L245">		}</span>

<span class="nc bnc" id="L247" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L248">			logger.debug(&quot;Delete Alias: removed alias &quot; + alias + &quot; in object &quot; + objectMD.getDataClayID());</span>
		}
<span class="nc" id="L250">		return objectMD.getDataClayID();</span>
	}

	/**
	 * Returns information about the objects instantiating a given class.
	 * 
	 * @param classID
	 *            the id of the class
	 * @return a map indexed by the object ids with their info
	 */
	public Map&lt;ObjectID, MetaDataInfo&gt; getObjectsOfSpecificClass(final MetaClassID classID) {
<span class="nc" id="L261">		final Map&lt;ObjectID, MetaDataInfo&gt; result = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc" id="L263">		final ArrayList&lt;ObjectMetaData&gt; objects = metadataDB.getByClass(classID);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">		for (final ObjectMetaData objectMD : objects) {</span>
<span class="nc" id="L265">			final MetaDataInfo mdInfo = buildMetaDataInfo(objectMD);</span>
<span class="nc" id="L266">			result.put(objectMD.getDataClayID(), mdInfo);</span>
<span class="nc" id="L267">		}</span>
<span class="nc" id="L268">		return result;</span>
	}

	/**
	 * This operation registers the MetaData of an object.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param metaClassID
	 *            ID of the class of the object
	 * @param datasetIDofProvider
	 *            ID of the dataset where the object is created
	 * @param backendIDs
	 *            IDs of the backeds where the object is stored (replicas)
	 * @param isReadOnly
	 *            whether the object is readonly or not
	 * @param alias
	 *            alias for the object
	 * @param lang
	 *            Object language
	 * @param ownerID
	 *            Owner account ID
	 * @return MetaDataInfo of the registered object
	 * @throws ObjectAlreadyRegisteredException
	 *             if the object was already registered
	 * @throws AliasAlreadyInUseException if some of the aliases provided already exist
	 */
	public MetaDataInfo registerObject(final ObjectID objectID, final MetaClassID metaClassID,
			final DataSetID datasetIDofProvider, final Set&lt;ExecutionEnvironmentID&gt; backendIDs, final boolean isReadOnly,
			final String alias, final Langs lang, final AccountID ownerID)
					throws ObjectAlreadyRegisteredException, AliasAlreadyInUseException {

<span class="nc" id="L300">		ObjectID newObjectID = objectID;</span>

<span class="nc bnc" id="L302" title="All 2 branches missed.">		if (alias != null) {</span>
			// Check there is no other object with same class and alias
			try {
<span class="nc" id="L305">				this.getObjectInfoFromAlias(alias);</span>
<span class="nc" id="L306">				throw new AliasAlreadyInUseException(alias);</span>
<span class="nc" id="L307">			} catch (final ObjectNotRegisteredException e) {</span>
				// it's ok, object not registered
			}

<span class="nc" id="L311">			newObjectID = DataClayRuntime.getObjectIDFromAlias(alias);</span>
		}

<span class="nc" id="L314">		ObjectMetaData objectMDInfo = this.getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">		if (objectMDInfo == null) {</span>
<span class="nc" id="L316">			final ObjectMetaData objectMD = new ObjectMetaData(newObjectID, metaClassID, datasetIDofProvider, backendIDs,</span>
					isReadOnly, alias, lang, ownerID);

<span class="nc bnc" id="L319" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L320">				logger.debug(&quot;Registering object &quot; + objectID + &quot; with alias: &quot; + alias + &quot; and language &quot; + lang + &quot;.&quot;);</span>
			}

			try {
<span class="nc" id="L324">				metadataDB.store(objectMD);</span>
<span class="nc" id="L325">			} catch (final DbObjectAlreadyExistException e) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L327">					logger.debug(&quot;Object &quot; + objectID + &quot; already registered&quot;);</span>
				}
<span class="nc" id="L329">				throw new ObjectAlreadyRegisteredException(objectID);</span>
<span class="nc" id="L330">			}</span>


<span class="nc" id="L333">			final ObjectID result = objectMD.getDataClayID(); // which now equals to objectID</span>

			// Update cache
<span class="nc bnc" id="L336" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L337">				logger.debug(&quot;[==Register object==] Updating cache of metadatas: {} -&gt; {}&quot;, objectID, objectMD);</span>
			}
<span class="nc" id="L339">			objectMDCache.put(result, objectMD);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">			if (alias != null) {</span>
<span class="nc" id="L341">				objectMDCacheByAlias.put(alias, objectMD);</span>
			}
<span class="nc" id="L343">			return buildMetaDataInfo(objectMD);</span>
		} else {
			// object is already registered, check if backend ids are different
			// new registration caused by a new replica
<span class="nc" id="L347">			Set&lt;ExecutionEnvironmentID&gt; currentLocations = objectMDInfo.getExecutionEnvironmentIDs();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">			if (currentLocations.containsAll(backendIDs)) {</span>
<span class="nc" id="L349">				throw new ObjectAlreadyRegisteredException(objectID);</span>
			} else {
<span class="nc" id="L351">				logger.debug(&quot;[==Register object==] Updating locations of object {}, probably due to a new replica&quot;, objectID);</span>
<span class="nc" id="L352">				currentLocations.addAll(backendIDs);</span>
<span class="nc" id="L353">				metadataDB.updateLocationIDsByID(objectID, currentLocations);</span>
			}
<span class="nc" id="L355">			return buildMetaDataInfo(objectMDInfo);</span>
		}
	}

	/**
	 * This operation allows to explicitly register an objectID replacement. If newObjectID is already registered, an exception
	 * is raised and the old ID is kept.
	 * 
	 * @param oldObjectID
	 *            original ID of the object
	 * @param newObjectID
	 *            final ID for the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if object does not exist ObjectAlreadyRegisteredException: if new id is already
	 *             being used
	 */
	public void changeObjectID(final ObjectID oldObjectID, final ObjectID newObjectID)
			throws ObjectNotRegisteredException, ObjectAlreadyRegisteredException {
<span class="nc" id="L374">		ObjectMetaData objectMD = null;</span>

		// Query object info
<span class="nc" id="L377">		objectMD = getObjectBasicMetaData(oldObjectID);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L382">			throw new ObjectNotRegisteredException(oldObjectID);</span>
		}

		// Store new one
<span class="nc" id="L386">		objectMD.setDataClayID(newObjectID);</span>
		try {
<span class="nc" id="L388">			metadataDB.store(objectMD);</span>
<span class="nc" id="L389">		} catch (final DbObjectAlreadyExistException e) {</span>
<span class="nc" id="L390">			objectMD.setDataClayID(oldObjectID);</span>
<span class="nc" id="L391">			throw new ObjectAlreadyRegisteredException(newObjectID);</span>
<span class="nc" id="L392">		}</span>

		// Delete old object if new one was stored correctly
<span class="nc" id="L395">		metadataDB.deleteByID(oldObjectID);</span>

		// Update in Cache
<span class="nc bnc" id="L398" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L399">			logger.debug(&quot;[==Change objectID==] Removing from cache of metadatas: {}&quot;, oldObjectID);</span>
		}
<span class="nc" id="L401">		objectMDCache.remove(oldObjectID);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L403">			logger.debug(&quot;[==Change objectID==] Adding to cache of metadatas: {} -&gt; {}&quot;, newObjectID, objectMD);</span>
		}
<span class="nc" id="L405">		objectMDCache.put(newObjectID, objectMD);</span>

		// Since objectID is not Key for Alias cache, just update it
<span class="nc" id="L408">		final String alias = objectMD.getAlias();</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">		if (alias != null) {</span>
<span class="nc" id="L410">			objectMDCacheByAlias.put(alias, objectMD);</span>
		}
<span class="nc" id="L412">	}</span>

	/**
	 * This operation allows to explicitly register an dataSetID replacement.
	 * 
	 * @param objectID
	 *            original ID of the object
	 * @param newDataSetID
	 *            final DataSetID for the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if object does not exist
	 */
	public void changeDataSetID(final ObjectID objectID, final DataSetID newDataSetID)
			throws ObjectNotRegisteredException {

		// Query object info
<span class="nc" id="L429">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L434">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// Update it
		try {
<span class="nc" id="L438">			metadataDB.updateDataSetIDByID(objectID, newDataSetID);</span>
<span class="nc" id="L439">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L440">			throw new ObjectNotRegisteredException(objectID);</span>
<span class="nc" id="L441">		}</span>

		// Update cache if necessary
<span class="nc bnc" id="L444" title="All 2 branches missed.">		if (objectMDCache.containsKey(objectID)) {</span>
<span class="nc" id="L445">			objectMDCache.get(objectID).setDataSetID(newDataSetID);</span>
<span class="nc" id="L446">			final String alias = objectMD.getAlias();</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">			if (alias != null) {</span>
<span class="nc" id="L448">				objectMDCacheByAlias.put(alias, objectMDCache.get(objectID));</span>
			}
		}
<span class="nc" id="L451">	}</span>

	/**
	 * Registers a set of versions, copying parts of the metadata from the original objects
	 * 
	 * @param versionToOriginalMapping
	 *            Mapping from version objectID to original objectID
	 * @param backendID
	 *            Backend in which the version is stored
	 * @param lang
	 *            Language doing the operation (should match the object's one)
	 * @return the metadata of the original objects (it will be required for consolidate)
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if an object does not exist
	 */
	public Map&lt;ObjectID, MetaDataInfo&gt; registerVersions(final Map&lt;ObjectID, ObjectID&gt; versionToOriginalMapping,
			final ExecutionEnvironmentID backendID, final Langs lang) throws ObjectNotRegisteredException {
<span class="nc" id="L469">		final Map&lt;ObjectID, MetaDataInfo&gt; result = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">		for (final Entry&lt;ObjectID, ObjectID&gt; versionToOriginal : versionToOriginalMapping.entrySet()) {</span>
<span class="nc" id="L471">			final ObjectID versionID = versionToOriginal.getKey();</span>
<span class="nc" id="L472">			final ObjectID originalID = versionToOriginal.getValue();</span>

			// Get metadata of the original object and put it in the result
<span class="nc" id="L475">			final MetaDataInfo originalMD = getObjectMetaData(originalID);</span>
<span class="nc" id="L476">			result.put(originalID, originalMD);</span>

			// Register version metadata
<span class="nc" id="L479">			final Set&lt;ExecutionEnvironmentID&gt; backends = new HashSet&lt;&gt;();</span>
<span class="nc" id="L480">			backends.add(backendID);</span>
<span class="nc" id="L481">			final ObjectMetaData versionMD = new ObjectMetaData(versionID, originalMD.getMetaclassID(),</span>
<span class="nc" id="L482">					originalMD.getDatasetID(), backends, false, null, lang, originalMD.getOwnerID());</span>

<span class="nc" id="L484">			metadataDB.store(versionMD);</span>

			// Store versionMD in the cache
<span class="nc bnc" id="L487" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L488">				logger.debug(&quot;[==New version==] Adding version to cache of metadatas: {} -&gt; {}&quot;, versionID, versionMD);</span>
			}
<span class="nc" id="L490">			objectMDCache.put(versionID, versionMD);</span>
<span class="nc" id="L491">			final String alias = versionMD.getAlias();</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">			if (alias != null) {</span>
<span class="nc" id="L493">				objectMDCacheByAlias.put(alias, versionMD);</span>
			}
<span class="nc" id="L495">		}</span>
<span class="nc" id="L496">		return result;</span>
	}

	/**
	 * This operation unregisters an object with ID provided. This also unregisters all replicas and returns its locations.
	 * 
	 * @param objectID
	 *            ID of the object to unregister
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if object does not exist
	 */
	public void unregisterObject(final ObjectID objectID) throws ObjectNotRegisteredException {

<span class="nc bnc" id="L510" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L511">			logger.debug(&quot;Unregistering &quot; + objectID);</span>
		}

		// Query object info
<span class="nc" id="L515">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L520">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// Unregister object
<span class="nc" id="L523">		metadataDB.deleteByID(objectID);</span>

		// Update cache if necessary
<span class="nc" id="L526">		objectMDCache.remove(objectID);</span>
<span class="nc" id="L527">		final String alias = objectMD.getAlias();</span>
<span class="nc" id="L528">		objectMDCacheByAlias.remove(alias);</span>
<span class="nc" id="L529">	}</span>

	/**
	 * This operation cleans DB after unregistering objects
	 */
	public void vacuumDB()  {
<span class="nc bnc" id="L535" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L536">			logger.debug(&quot;Vacuum db &quot;);</span>
		}
<span class="nc" id="L538">		metadataDB.vacuum();</span>
<span class="nc" id="L539">	}</span>


	/**
         * Checks that given dataset has no object.
         *
         * @param datasetID
         *            the ID of the dataset to be checked
         * @return Whether the dataset is empty or not.
         * @throws Exception
         *             if an exception occurs.
	 */
	public boolean checkDatasetIsEmpty(final DataSetID datasetID) {
<span class="nc bnc" id="L552" title="All 2 branches missed.">		return !metadataDB.existsByDataSetID(datasetID);</span>
	}

	/**
	 * This operation verifies that the object with ID provided exists in the backend with ID provided as source backend and not
	 * in the destination backend.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param srcBackend
	 *            ID of the source backend
	 * @param destBackend
	 *            ID of the destination backend
	 * @return TRUE if the object exists in the source backend and not in the destination backend. FALSE otherwise.
	 * @throws Exception
	 *             if an exception occurs ObjectNotRegisteredException: if the object does not exist
	 */
	public boolean checkObjectInSrcNotInDest(final ObjectID objectID, final ExecutionEnvironmentID srcBackend,
			final ExecutionEnvironmentID destBackend) throws ObjectNotRegisteredException {
		// Query object info
<span class="nc" id="L572">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L577">			throw new ObjectNotRegisteredException(objectID);</span>
		}
<span class="nc" id="L579">		final Set&lt;ExecutionEnvironmentID&gt; backendIDs = objectMD.getExecutionEnvironmentIDs();</span>
<span class="nc bnc" id="L580" title="All 4 branches missed.">		return backendIDs.contains(srcBackend) &amp;&amp; !backendIDs.contains(destBackend);</span>
	}

	/**
	 * This operation moves an object from source location to destination location
	 * 
	 * @param objectID
	 *            ID of the object to modify
	 * @param srcBackendID
	 *            ID of the backend of the replica to be moved
	 * @param destBackendID
	 *            ID of the backend in which the object is 'moved'
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object does not exist or it is not present in source backend
	 *             ExecutionEnvironmentNotExistException: if destination backend does not exist
	 */
	public void migrateObjectToBackend(final ObjectID objectID, final ExecutionEnvironmentID srcBackendID,
			final ExecutionEnvironmentID destBackendID)
					throws ObjectNotRegisteredException, ExecutionEnvironmentNotExistException {


		// Query object info
<span class="nc" id="L603">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L608">			throw new ObjectNotRegisteredException(objectID);</span>
		}
<span class="nc" id="L610">		final Set&lt;ExecutionEnvironmentID&gt; backendIDs = objectMD.getExecutionEnvironmentIDs();</span>

		// Check it is in srcBackend
<span class="nc bnc" id="L613" title="All 2 branches missed.">		if (!backendIDs.contains(srcBackendID)) {</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L615">				logger.debug(&quot;[==MOVE==] Migrating metadata FAILED of &quot; + objectID + &quot; from &quot; + srcBackendID + &quot; to &quot;</span>
						+ destBackendID + &quot; due not registered in source.&quot;);
			}

<span class="nc" id="L619">			throw new ObjectNotRegisteredException(objectID);</span>
		} else {
			// Check it is not present in destBackend
<span class="nc bnc" id="L622" title="All 2 branches missed.">			if (backendIDs.contains(destBackendID)) {</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L624">					logger.debug(&quot;[==MOVE==] Migrating metadata FAILED of &quot; + objectID + &quot; from &quot; + srcBackendID</span>
							+ &quot; to &quot; + destBackendID + &quot; due already registered in destination.&quot;);
				}

<span class="nc" id="L628">				throw new ObjectAlreadyRegisteredException(objectID);</span>
			} else {
<span class="nc" id="L630">				migrateObjectToBackend(objectID, objectMD, srcBackendID, destBackendID);</span>
			}
		}
<span class="nc" id="L633">	}</span>

	/**
	 * This operations removes the srcBackendID from the locations of the specified objects and adds the corresponding new
	 * location from newObjBackends to each of them. If unregisterBackend is set to true, the srcBackendID is unregistered.
	 * WARNING: This function is not checking whether the srcBackendID becomes totally empty after migrating specified
	 * objects!!! For that, we would need an structure to keep which objects has every backend
	 * 
	 * @param srcBackendID
	 *            ID of the unregistered backend from which objects are migrated
	 * @param newObjBackends
	 *            the objects for every new destination backend
	 * @param unregisterBackend
	 *            whether to unregister the srcBackendID or not
	 * @return TRUE if the backend has been successfully unregistered. FALSE otherwise.
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ExecutionEnvironmentNotExistException: if backend does not exist
	 */
	public boolean migrateObjectsToBackend(final ExecutionEnvironmentID srcBackendID,
			final Map&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; newObjBackends, final boolean unregisterBackend)
					throws ExecutionEnvironmentNotExistException {

		// Register migrations
<span class="nc bnc" id="L657" title="All 2 branches missed.">		for (final Entry&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; curEntry : newObjBackends.entrySet()) {</span>
<span class="nc" id="L658">			final ExecutionEnvironmentID destBackendID = curEntry.getKey();</span>

			// Query objects info
<span class="nc bnc" id="L661" title="All 2 branches missed.">			for (final ObjectID objectID : curEntry.getValue()) {</span>
<span class="nc" id="L662">				final ObjectMetaData curObjectMetaData = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">				if (curObjectMetaData == null) {</span>
					// TODO: Need new design for this. since getObjectBasicMetadata is in critical
					// path, it is returning
					// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L667">					throw new ObjectNotRegisteredException(objectID);</span>
				}
<span class="nc" id="L669">				migrateObjectToBackend(objectID, curObjectMetaData, srcBackendID, destBackendID);</span>
<span class="nc" id="L670">			}</span>
<span class="nc" id="L671">		}</span>

		// Unregister backend if required
		//FIXME: if (unregisterBackend) {
<span class="nc" id="L675">		return true;</span>
	}

	/**
	 * This operation modifies the permissions of the object with ID provided to read-only
	 * 
	 * @param objectID
	 *            ID of the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object does not exist
	 */
	public void setObjectReadOnly(final ObjectID objectID) throws ObjectNotRegisteredException {
		// Query object info
<span class="nc" id="L689">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L694">			throw new ObjectNotRegisteredException(objectID);</span>
		}
<span class="nc bnc" id="L696" title="All 2 branches missed.">		if (!objectMD.isReadOnly()) {</span>
			// Update it
			try {
<span class="nc" id="L699">				metadataDB.updateReadOnlyByID(objectID, true);</span>

<span class="nc" id="L701">			} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L702">				throw new ObjectNotRegisteredException(objectID);</span>
<span class="nc" id="L703">			}</span>
		}

		// Update cache if necessary
<span class="nc bnc" id="L707" title="All 2 branches missed.">		if (objectMDCache.containsKey(objectID)) {</span>
<span class="nc" id="L708">			objectMDCache.get(objectID).setReadOnly(true);</span>
<span class="nc" id="L709">			final String alias = objectMD.getAlias();</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">			if (alias != null) {</span>
<span class="nc" id="L711">				objectMDCacheByAlias.put(alias, objectMDCache.get(objectID));</span>
			}
		}

<span class="nc" id="L715">	}</span>

	/**
	 * This operation modifies the permissions of the object with ID provided to read-write
	 * 
	 * @param objectID
	 *            ID of the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object does not exist &lt;br&gt;
	 *             ObjectHasReplicas: if the object has replicas
	 */
	public void setObjectReadWrite(final ObjectID objectID) throws ObjectNotRegisteredException {
		// Query object info
<span class="nc" id="L729">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L734">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// WARNING: in 2.0 we assume that if an object has replicas it MUST be READ-ONLY
		// (jmarti 13 Jun 2013)
<span class="nc bnc" id="L738" title="All 2 branches missed.">		if (objectMD.getExecutionEnvironmentIDs().size() &gt; 1) {</span>
<span class="nc" id="L739">			throw new ObjectHasReplicas(objectID);</span>
		} else {
<span class="nc bnc" id="L741" title="All 2 branches missed.">			if (objectMD.isReadOnly()) {</span>
				// Update it
				try {
<span class="nc" id="L744">					metadataDB.updateReadOnlyByID(objectID, false);</span>

<span class="nc" id="L746">				} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L747">					throw new ObjectNotRegisteredException(objectID);</span>
<span class="nc" id="L748">				}</span>
			}
		}

		// Update cache if necessary
<span class="nc bnc" id="L753" title="All 2 branches missed.">		if (objectMDCache.containsKey(objectID)) {</span>
<span class="nc" id="L754">			objectMDCache.get(objectID).setReadOnly(false);</span>
<span class="nc" id="L755">			final String alias = objectMD.getAlias();</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">			if (alias != null) {</span>
<span class="nc" id="L757">				objectMDCacheByAlias.put(alias, objectMDCache.get(objectID));</span>
			}
		}
<span class="nc" id="L760">	}</span>

	/**
	 * Registers an object to be federated with an external dataClay identified with the given ID
	 * 
	 * @param objectID
	 *            id of the object to be federated
	 * @param dataClayID
	 *            id of the external dataClay
	 * @return false if the object cannot be federated, either because it was already federated or dataClayID is not registered
	 *         true otherwise.
	 */
	public boolean federateObjectWith(final ObjectID objectID, final DataClayInstanceID dataClayID) {
<span class="nc" id="L773">		Set&lt;DataClayInstanceID&gt; dcIDs = federatedObjectsCache.get(objectID);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">		if (dcIDs != null) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">			if (dcIDs.contains(dataClayID)) {</span>
<span class="nc" id="L776">				return false;</span>
			}
		}

		// Check object exists
<span class="nc" id="L781">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L786">			throw new ObjectNotRegisteredException(objectID);</span>
		}

<span class="nc bnc" id="L789" title="All 2 branches missed.">		if (!metadataDB.insertFederatedObject(objectID, dataClayID)) {</span>
<span class="nc" id="L790">			return false;</span>
		}
<span class="nc" id="L792">		dcIDs = federatedObjectsCache.get(objectID);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">		if (dcIDs == null) {</span>
<span class="nc" id="L794">			dcIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L795">			federatedObjectsCache.put(objectID, dcIDs);</span>
		}
<span class="nc" id="L797">		dcIDs.add(dataClayID);</span>
<span class="nc" id="L798">		return true;</span>
	}

	/**
	 * Unfederate object with an external dataClay identified with the given ID
	 * 
	 * @param objectID
	 *            id of the object to be unfederated
	 * @param dataClayID
	 *            id of the external dataClay
	 * @return false if the object cannot be unfederated, either because it was not federated or others. true otherwise.
	 */
	public boolean unfederateObjectWith(final ObjectID objectID, final DataClayInstanceID dataClayID) {

		// Check object exists
<span class="nc" id="L813">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L818">			throw new ObjectNotRegisteredException(objectID);</span>
		}

<span class="nc bnc" id="L821" title="All 2 branches missed.">		if (!metadataDB.deleteFederatedObject(objectID, dataClayID)) {</span>
			// object already unfederated
<span class="nc" id="L823">			return false;</span>
		}

<span class="nc" id="L826">		federatedObjectsCache.remove(objectID);</span>

<span class="nc" id="L828">		return true;</span>
	}

	/**
	 * Checks whether the object is actually federated with dataClay instance identified with given ID
	 * 
	 * @param objectID
	 *            id of the object
	 * @param dataClayID
	 *            id of the external dataClay instance
	 * @return true if the object is federated. false otherwise.
	 */
	public boolean checkIsFederatedWith(final ObjectID objectID, final DataClayInstanceID dataClayID) {
<span class="nc" id="L841">		Set&lt;DataClayInstanceID&gt; dcIDs = federatedObjectsCache.get(objectID);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">		if (dcIDs != null) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">			if (dcIDs.contains(dataClayID)) {</span>
<span class="nc" id="L844">				return true;</span>
			}
		}
<span class="nc" id="L847">		final boolean result = metadataDB.existsFederatedObjectWithDC(objectID, dataClayID);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">		if (result) {</span>
<span class="nc" id="L849">			dcIDs = federatedObjectsCache.get(objectID);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">			if (dcIDs == null) {</span>
<span class="nc" id="L851">				dcIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L852">				federatedObjectsCache.put(objectID, dcIDs);</span>
			}
<span class="nc" id="L854">			dcIDs.add(dataClayID);</span>
		}
<span class="nc" id="L856">		return result;</span>
	}

	/**
	 * Get all dataClays object provided is federated with
	 * @param objectID ID of the object 
	 * @return dataClay IDs the object is federated with
	 */
	public Set&lt;DataClayInstanceID&gt; getDataClaysOurObjectIsFederatedWith(final ObjectID objectID) {
<span class="nc" id="L865">		return metadataDB.getDataClaysOurObjectIsFederatedWith(objectID);</span>
	}

	/**
	 * Registers an object that is federated from an external dataClay instance.
	 * 
	 * @param objectID
	 *            ID of the federated object in the external dataClay
	 * @param dataClayID
	 *            id of the external source dataClay
	 */
	public void registerExternalObject(final ObjectID objectID, final DataClayInstanceID dataClayID) {
<span class="nc" id="L877">		metadataDB.insertExternalObject(objectID, dataClayID, false);</span>
<span class="nc" id="L878">	}</span>

	/**
	 * Unregisters an object that is federated from an external dataClay instance.
	 * 
	 * @param objectID
	 *            ID of the federated object in the external dataClay
	 */
	public void unregisterExternalObject(final ObjectID objectID) {
<span class="nc" id="L887">		metadataDB.deleteExternalObject(objectID);</span>
<span class="nc" id="L888">	}</span>

	/**
	 * Checks if the object is actually a federated object
	 * 
	 * @param objectID
	 *            id of the object
	 * @return TRUE if object is external.
	 */
	public boolean existsExternalObject(final ObjectID objectID) {
<span class="nc bnc" id="L898" title="All 2 branches missed.">		return metadataDB.existsExternalObject(objectID, true) </span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">				|| metadataDB.existsExternalObject(objectID, false);</span>
	}

	/**
	 * Checks if the object is actually a federated object with unregistered flag = false
	 * 
	 * @param objectID
	 *            id of the object
	 * @return TRUE if object is external.
	 */
	public boolean externalObjectIsRegistered(final ObjectID objectID) {
<span class="nc" id="L910">		return metadataDB.existsExternalObject(objectID, false);</span>
	}

	/**
	 * Checks if the object is actually a federated object with unregistered flag = true
	 * 
	 * @param objectID
	 *            id of the object
	 * @return TRUE if object is external.
	 */
	public boolean externalObjectIsUnregistered(final ObjectID objectID) {
<span class="nc" id="L921">		return metadataDB.existsExternalObject(objectID, true);</span>
	}

	/**
	 * Update external object to be marked as unregistered 
	 * 
	 * @param objectID
	 *            ID of the object to update
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void markExternalObjectAsUnregistered(final ObjectID objectID) { 
<span class="nc" id="L933">		this.metadataDB.updateUnregisteredFlagExternalObject(objectID, true);</span>
<span class="nc" id="L934">	}</span>

	/**
	 * Update external object to be marked as registered 
	 * 
	 * @param objectID
	 *            ID of the object to update
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void markExternalObjectAsRegistered(final ObjectID objectID) { 
<span class="nc" id="L945">		this.metadataDB.updateUnregisteredFlagExternalObject(objectID, false);</span>
<span class="nc" id="L946">	}</span>

	/**
	 * Get unregistered external objects.
	 * @return id of external objects unregistered
	 */
	public Set&lt;ObjectID&gt; getUnregisteredExternalObjects() {
<span class="nc" id="L953">		return metadataDB.getUnregisteredExternalObjects();</span>
	}

	/**
	 * Method that retrieves the info of external source dataClay of this object
	 * 
	 * @param objectID
	 *            id of the object
	 * @return info of the external source dataClay
	 */
	public DataClayInstanceID getExternalSourceDataClayOfObject(final ObjectID objectID) {
<span class="nc" id="L964">		return metadataDB.getExternalDataClayOfObject(objectID);</span>
	}

	/**
	 * Method that retrieves all the objects federated/belonging to dataClay with ID provided.
	 * 
	 * @param extDataClayInstanceID
	 *            id of dataclay
	 * @return all the objects federated/belonging to dataClay with ID provided.
	 */
	public Set&lt;ObjectID&gt; getObjectsFederatedWithDataClay(final DataClayInstanceID extDataClayInstanceID) {
<span class="nc" id="L975">		return metadataDB.getObjectsFederatedWithDataClay(extDataClayInstanceID);</span>
	}

	// ========= PRIVATE FUNCTIONS ========= //

	/**
	 * Builds a MetaDataInfo structure from ObjectMetaData
	 * 
	 * @param objectMD
	 *            the object metadata
	 * @return MetaDataInfo representation of the given object metadata
	 */
	private MetaDataInfo buildMetaDataInfo(final ObjectMetaData objectMD) {
<span class="nc" id="L988">		final Set&lt;ExecutionEnvironmentID&gt; objectMDlocations = ConcurrentHashMap.newKeySet();</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">		for (final ExecutionEnvironmentID curLocID : objectMD.getExecutionEnvironmentIDs()) {</span>
<span class="nc" id="L990">			objectMDlocations.add(curLocID);</span>
<span class="nc" id="L991">		}</span>
<span class="nc" id="L992">		final MetaDataInfo result = new MetaDataInfo(objectMD.getDataClayID(), objectMD.getDataSetID(),</span>
<span class="nc" id="L993">				objectMD.getMetaClassID(), objectMD.isReadOnly(), objectMDlocations, objectMD.getAlias(),</span>
<span class="nc" id="L994">				objectMD.getOwnerID());</span>

<span class="nc" id="L996">		return result;</span>
	}

	/**
	 * This method returns the metadata of an object.
	 * 
	 * @param objectID
	 *            the ID of the object to be retrieved
	 * @return the metadata of the specified object
	 * @throws ObjectNotRegisteredException
	 *             if the object is not registered
	 */
	private ObjectMetaData getObjectBasicMetaData(final ObjectID objectID) {
<span class="nc bnc" id="L1009" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1010">			logger.debug(&quot;Retrieval of ObjectBasicMetaData for {}&quot;, objectID);</span>
		}

<span class="nc" id="L1013">		ObjectMetaData objectMD = objectMDCache.get(objectID);</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// Query by example
<span class="nc" id="L1016">			objectMD = metadataDB.getByID(objectID);</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">			if (objectMD != null) {</span>
				// Update cache if necessary
<span class="nc bnc" id="L1019" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1020">					logger.debug(&quot;[==Get metadata==] Adding version to cache of metadatas: {} -&gt; {}&quot;, objectID, objectMD);</span>
				}
<span class="nc" id="L1022">				objectMDCache.put(objectID, objectMD);</span>
<span class="nc" id="L1023">				final String alias = objectMD.getAlias();</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">				if (alias != null) {</span>
<span class="nc" id="L1025">					objectMDCacheByAlias.put(alias, objectMD);</span>
				}
<span class="nc" id="L1027">			} else {</span>
<span class="nc" id="L1028">				return null; // do not send exception to avoid serializing it, critical path.</span>
			}

		} else { 
<span class="nc bnc" id="L1032" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1033">				logger.debug(&quot;Found metadata {} in cache for {}&quot;, objectMD, objectID);</span>
			}
		}

		/*
		 * } else { // Check cache objectMD = objectMDCache.get(objectID); if (objectMD == null) { // Query by example objectMD
		 * = metadataDB.getByID(objectID); if (objectMD != null) { // Update cache if necessary objectMDCache.put(objectID,
		 * objectMD); for (final String alias : objectMD.getAliases()) { objectMDCacheByAlias.put( new
		 * Tuple&lt;&gt;(objectMD.getMetaClassID(), alias), objectMD); } } else { throw new ObjectNotRegisteredException(objectID); }
		 * } }
		 */
<span class="nc" id="L1044">		return objectMD;</span>
	}



	/**
	 * Migrate an object with ID and MetaData provided from the source backend specified to the destination backend specified.
	 * 
	 * @param objectID
	 *            ID of the object.
	 * @param objectMD
	 *            Object meta data.
	 * @param srcBackendID
	 *            ID of the source backend.
	 * @param destBackendID
	 *            ID of the destination backend.
	 * @throws ObjectNotRegisteredException
	 *             if object does not exist
	 */
	private void migrateObjectToBackend(final ObjectID objectID, final ObjectMetaData objectMD,
			final ExecutionEnvironmentID srcBackendID, final ExecutionEnvironmentID destBackendID)
					throws ObjectNotRegisteredException {

<span class="nc bnc" id="L1067" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1068">			logger.debug(</span>
					&quot;[==MOVE==] Migrating metadata of &quot; + objectID + &quot; from &quot; + srcBackendID + &quot; to &quot; + destBackendID);
		}

		// Copy metadata
<span class="nc" id="L1073">		final Set&lt;ExecutionEnvironmentID&gt; newBackendIDs = new HashSet&lt;&gt;(objectMD.getExecutionEnvironmentIDs());</span>
<span class="nc" id="L1074">		newBackendIDs.remove(srcBackendID);</span>
<span class="nc" id="L1075">		newBackendIDs.add(destBackendID);</span>

		// Update db
		try {
<span class="nc" id="L1079">			metadataDB.updateLocationIDsByID(objectID, newBackendIDs);</span>
<span class="nc" id="L1080">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L1081">			throw new ObjectNotRegisteredException(objectID);</span>
<span class="nc" id="L1082">		}</span>

		// Update real metadata
<span class="nc" id="L1085">		objectMD.getExecutionEnvironmentIDs().add(destBackendID);</span>
<span class="nc" id="L1086">		objectMD.getExecutionEnvironmentIDs().remove(srcBackendID);</span>

		// Update cache
<span class="nc" id="L1089">		final ObjectID theobjectID = objectID;</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">		if (objectMDCache.containsKey(theobjectID)) {</span>
<span class="nc" id="L1091">			objectMDCache.get(theobjectID).getExecutionEnvironmentIDs().remove(srcBackendID);</span>
<span class="nc" id="L1092">			objectMDCache.get(theobjectID).getExecutionEnvironmentIDs().add(destBackendID);</span>
<span class="nc" id="L1093">			String alias = objectMD.getAlias();</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">			if (alias != null) {</span>
<span class="nc" id="L1095">				objectMDCacheByAlias.put(alias, objectMDCache.get(theobjectID));</span>
			}
		}
<span class="nc" id="L1098">	}</span>

	// ====== Getters for testing purposes ====== //

	/**
	 * Get the MetaDataService::objectMDCache
	 * 
	 * @return the Object MetaData Cache
	 */
	public MemoryCache&lt;ObjectID, ObjectMetaData&gt; getObjectCache() {
<span class="nc" id="L1108">		return this.objectMDCache;</span>
	}

	// ====== OTHER ======= //

	/**
	 * Method used for unit testing.
	 * 
	 * @return The db handler reference of this manager.
	 */
	public MetaDataServiceDB getDbHandler() {
<span class="nc" id="L1119">		return this.metadataDB;</span>
	}

	/**
	 * Close DbHandler
	 */
	public void closeDbHandler() {
<span class="nc" id="L1126">		this.metadataDB.close();</span>
<span class="nc" id="L1127">	}</span>

	@Override
	public void cleanCaches() {
<span class="nc" id="L1131">		objectMDCache.clear();</span>
<span class="nc" id="L1132">		objectMDCacheByAlias.clear();</span>
<span class="nc" id="L1133">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>