<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaDataService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.metadataservice</a> &gt; <span class="el_source">MetaDataService.java</span></div><h1>MetaDataService.java</h1><pre class="source lang-java linenums">
/**
 * @file MetaDataService.java
 * @date May 21, 2013
 */
package es.bsc.dataclay.metadataservice;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import es.bsc.dataclay.commonruntime.DataClayRuntime;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectAlreadyExistException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.exceptions.metadataservice.AliasAlreadyInUseException;
import es.bsc.dataclay.exceptions.metadataservice.ExecutionEnvironmentAlreadyExistsException;
import es.bsc.dataclay.exceptions.metadataservice.ExecutionEnvironmentNotExistException;
import es.bsc.dataclay.exceptions.metadataservice.ExternalDataClayNotRegisteredException;
import es.bsc.dataclay.exceptions.metadataservice.MultipleAliasesException;
import es.bsc.dataclay.exceptions.metadataservice.ObjectAlreadyRegisteredException;
import es.bsc.dataclay.exceptions.metadataservice.ObjectHasReplicas;
import es.bsc.dataclay.exceptions.metadataservice.ObjectNotRegisteredException;
import es.bsc.dataclay.exceptions.metadataservice.StorageLocationAlreadyExistsException;
import es.bsc.dataclay.exceptions.metadataservice.StorageLocationNotExistException;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.StorageLocationID;
import es.bsc.dataclay.util.management.AbstractManager;
import es.bsc.dataclay.util.management.metadataservice.DataClayInstance;
import es.bsc.dataclay.util.management.metadataservice.ExecutionEnvironment;
import es.bsc.dataclay.util.management.metadataservice.MetaDataInfo;
import es.bsc.dataclay.util.management.metadataservice.StorageLocation;
import es.bsc.dataclay.util.structs.LruCache;
import es.bsc.dataclay.util.structs.Tuple;

/**
 * This class is responsible to manage information related to an object (metaclassID of the object, backend in which is stored,
 * interface and contract used for creating the object...).
 */
public final class MetaDataService extends AbstractManager {
<span class="fc" id="L56">	private static final Logger logger = LogManager.getLogger(&quot;MetaDataService&quot;);</span>

	/** Indicates if debug is enabled. */
<span class="fc" id="L59">	protected static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

	/** Object cache. */
	private final LruCache&lt;ObjectID, ObjectMetaData&gt; objectMDCache;

	/** Federated objects cache. */
	private final LruCache&lt;ObjectID, Set&lt;DataClayInstanceID&gt;&gt; federatedObjectsCache;

	/** Object by Alias cache. */
	private final LruCache&lt;String, ObjectMetaData&gt; objectMDCacheByAlias;

	/** Cache for Storage Location mapping. */
	private final ConcurrentHashMap&lt;StorageLocationID, StorageLocation&gt; currentStorageLocations;

	/** Current Execution Environments mappings. */
	private final ConcurrentHashMap&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; currentExecutionEnvironments;
	private final ConcurrentHashMap&lt;String, ExecutionEnvironmentID&gt; currentJavaExecutionEnvironments;
	private final ConcurrentHashMap&lt;String, ExecutionEnvironmentID&gt; currentPythonExecutionEnvironments;

	/** External dataClay info cache. */
	private final LruCache&lt;DataClayInstanceID, DataClayInstance&gt; externalDataClaysCache;

	/** External dataClay IDs per host-port cache. */
	private final LruCache&lt;Tuple&lt;String, Integer&gt;, DataClayInstanceID&gt; dataClaysPerHostPortCache;

	/** MetaDataService database. */
	private final MetaDataServiceDB metadataDB;

	/**
	 * Instantiates an MetaDataService that uses the Backend configuration provided.
	 * 
	 * @param managerName
	 *            Manager/service name.
	 * @post Creates MetaDataService and initializes the backend.
	 */
	public MetaDataService(final BasicDataSource dataSource) {
<span class="fc" id="L95">		super(dataSource);</span>
<span class="fc" id="L96">		metadataDB = new MetaDataServiceDB(dataSource);</span>
<span class="fc" id="L97">		metadataDB.createTables();</span>

		// Init caches
<span class="fc" id="L100">		this.objectMDCache = new LruCache&lt;&gt;(Configuration.Flags.MAX_ENTRIES_METADATASERVICE_CACHE.getIntValue());</span>
<span class="fc" id="L101">		this.objectMDCacheByAlias = new LruCache&lt;&gt;(Configuration.Flags.MAX_ENTRIES_METADATASERVICE_CACHE.getIntValue());</span>
<span class="fc" id="L102">		this.externalDataClaysCache = new LruCache&lt;&gt;(Configuration.Flags.MAX_ENTRIES_METADATASERVICE_CACHE.getIntValue());</span>
<span class="fc" id="L103">		this.dataClaysPerHostPortCache = new LruCache&lt;&gt;(Configuration.Flags.MAX_ENTRIES_METADATASERVICE_CACHE.getIntValue());</span>


<span class="fc" id="L106">		this.currentStorageLocations = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L107">		this.currentExecutionEnvironments = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L108">		this.currentJavaExecutionEnvironments = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L109">		this.currentPythonExecutionEnvironments = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L110">		this.federatedObjectsCache = new LruCache&lt;&gt;(</span>
<span class="fc" id="L111">				Configuration.Flags.MAX_ENTRIES_METADATASERVICE_CACHE.getIntValue());</span>
<span class="fc" id="L112">	}</span>

	/**
	 * Checks whether an objects exists or not.
	 * 
	 * @param objectID
	 *            ID of the object to be checked.
	 * @return True if the objectID is registered in the service, false otherwise.
	 * @throws Exception
	 *             if any exception occurs
	 */
	public boolean existsObject(final ObjectID objectID) {
		// Check cache
<span class="nc" id="L125">		ObjectMetaData objectMD = objectMDCache.get(objectID);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// Query by example
<span class="nc" id="L128">			objectMD = metadataDB.getByID(objectID);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">			if (objectMD != null) {</span>
				// Update cache if necessary
<span class="nc bnc" id="L131" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L132">					logger.debug(&quot;Updating cache of metadatas: {} -&gt; {}&quot;, objectID, objectMD);</span>
				}
<span class="nc" id="L134">				objectMDCache.put(objectID, objectMD);</span>
<span class="nc" id="L135">				final String alias = objectMD.getAlias();</span>
<span class="nc" id="L136">				objectMDCacheByAlias.put(alias, objectMD);</span>
			}
		}
<span class="nc bnc" id="L139" title="All 2 branches missed.">		return (objectMD != null);</span>
	}

	/**
	 * This operation gets all the backend IDs that contain the object with ID provided.
	 * 
	 * @param objectID
	 *            ID of the object to query
	 * @return The set of backends corresponding to those containing a replica of the object specified. The result can be empty.
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object is not registered.
	 */
	public Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getObjectBackends(final ObjectID objectID) {
		// Query object info
<span class="fc" id="L154">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. Since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L159">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// Prepare result
<span class="fc" id="L162">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; objectMDbackends = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L164" title="All 2 branches covered.">		for (final ExecutionEnvironmentID curEntry : objectMD.getExecutionEnvironmentIDs()) {</span>
<span class="fc" id="L165">			final ExecutionEnvironment backend = getExecutionEnvironment(curEntry);</span>
<span class="fc" id="L166">			objectMDbackends.put(curEntry, backend);</span>
<span class="fc" id="L167">		}</span>
<span class="fc" id="L168">		return objectMDbackends;</span>
	}

	/**
	 * This operation retrieves the metadata of an object.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return the metadata of the given object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object is not registered
	 */
	public MetaDataInfo getObjectMetaData(final ObjectID objectID) {
		// Query object info
<span class="nc" id="L183">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">		if (objectMD == null) {</span>
<span class="nc" id="L185">			return null; // do not send exception to avoid serializing it, critical path.</span>
		}

<span class="nc" id="L188">		final MetaDataInfo result = buildMetaDataInfo(objectMD);</span>
<span class="nc" id="L189">		return result;</span>
	}

	/**
	 * Get all objects registered in system
	 * @return ids of all registered objects
	 */
	public Set&lt;ObjectID&gt; getAllObjectIDsRegistered() {
<span class="nc" id="L197">		return metadataDB.getAllObjectIDs();</span>
	}

	/**
	 * Get object ID from alias
	 * 
	 * @param metaClassID
	 *            ID of the class of the object
	 * @param alias
	 *            Alias of the object
	 * @return the ID of the object if it is found and its metadata
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object is not registered
	 */
	public Tuple&lt;ObjectID, MetaDataInfo&gt; getObjectInfoFromAlias(final String alias) {
<span class="nc" id="L213">		ObjectMetaData objectMD = objectMDCacheByAlias.get(alias);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">		if (objectMD != null) {</span>
<span class="nc" id="L215">			final MetaDataInfo metadataInfo = buildMetaDataInfo(objectMD);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L217">				logger.debug(&quot;Get by alias: Obtained object &quot; + objectMD.getDataClayID() + &quot; from alias: &quot; + alias);</span>
			}
<span class="nc" id="L219">			return new Tuple&lt;&gt;(objectMD.getDataClayID(), metadataInfo);</span>
		} else {
<span class="nc bnc" id="L221" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L222">				logger.debug(&quot;Alias &quot; + alias + &quot; not found in cache.&quot;);</span>
			}
		}
<span class="nc" id="L225">		objectMD = metadataDB.getByAlias(alias);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">		if (objectMD == null) {</span>
<span class="nc" id="L227">			throw new ObjectNotRegisteredException(alias);</span>
		}

<span class="nc" id="L230">		final MetaDataInfo metadataInfo = buildMetaDataInfo(objectMD);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L232">			logger.debug(&quot;Get by alias: Obtained object &quot; + objectMD.getDataClayID() + &quot; from alias: &quot; + alias);</span>
		}
<span class="nc" id="L234">		return new Tuple&lt;&gt;(objectMD.getDataClayID(), metadataInfo);</span>
	}

	/**
	 * Delete alias of object
	 * 
	 * @param alias
	 *            Alias of the object
	 * @return ID of the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object is not registered
	 */
	public ObjectID deleteAlias(final String alias) {
<span class="nc" id="L248">		ObjectMetaData objectMD = objectMDCacheByAlias.remove(alias);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">		if (objectMD == null) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L251">				logger.debug(&quot;Alias &quot; + alias + &quot; not found in cache.&quot;);</span>
			}

<span class="nc" id="L254">			objectMD = metadataDB.getByAlias(alias);</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (objectMD == null) {</span>
<span class="nc" id="L257">				throw new ObjectNotRegisteredException(alias);</span>
			}
		}

<span class="nc" id="L261">		objectMD.setAlias(null);</span>

		try {
<span class="nc" id="L264">			metadataDB.updateAliasByID(objectMD.getDataClayID(), null);</span>
<span class="nc" id="L265">		} catch (final DbObjectNotExistException e) {</span>
			// Ignore exception, maybe the object has been garbage collected
<span class="nc" id="L267">		}</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L270">			logger.debug(&quot;Delete Alias: removed alias &quot; + alias + &quot; in object &quot; + objectMD.getDataClayID());</span>
		}
<span class="nc" id="L272">		return objectMD.getDataClayID();</span>
	}

	/**
	 * Returns information about the objects instantiating a given class.
	 * 
	 * @param classID
	 *            the id of the class
	 * @return a map indexed by the object ids with their info
	 */
	public Map&lt;ObjectID, MetaDataInfo&gt; getObjectsOfSpecificClass(final MetaClassID classID) {
<span class="fc" id="L283">		final Map&lt;ObjectID, MetaDataInfo&gt; result = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L285">		final ArrayList&lt;ObjectMetaData&gt; objects = metadataDB.getByClass(classID);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">		for (final ObjectMetaData objectMD : objects) {</span>
<span class="fc" id="L287">			final MetaDataInfo mdInfo = buildMetaDataInfo(objectMD);</span>
<span class="fc" id="L288">			result.put(objectMD.getDataClayID(), mdInfo);</span>
<span class="fc" id="L289">		}</span>
<span class="fc" id="L290">		return result;</span>
	}

	/**
	 * This operation registers the MetaData of an object.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param metaClassID
	 *            ID of the class of the object
	 * @param datasetIDofProvider
	 *            ID of the dataset where the object is created
	 * @param backendIDs
	 *            IDs of the backeds where the object is stored (replicas)
	 * @param isReadOnly
	 *            whether the object is readonly or not
	 * @param aliases
	 *            aliases for the object
	 * @param lang
	 *            Object language
	 * @param ownerID
	 *            Owner account ID
	 * @return MetaDataInfo of the registered object
	 * @throws ObjectAlreadyRegisteredException
	 *             if the object was already registered
	 * @throws AliasAlreadyInUseException if some of the aliases provided already exist
	 */
	public MetaDataInfo registerObject(final ObjectID objectID, final MetaClassID metaClassID,
			final DataSetID datasetIDofProvider, final Set&lt;ExecutionEnvironmentID&gt; backendIDs, final boolean isReadOnly,
			final String alias, final Langs lang, final AccountID ownerID)
					throws ObjectAlreadyRegisteredException, AliasAlreadyInUseException {

<span class="fc" id="L322">		ObjectID newObjectID = objectID;</span>

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">		if (alias != null) {</span>
			// Check there is no other object with same class and alias
			try {
<span class="nc" id="L327">				this.getObjectInfoFromAlias(alias);</span>
<span class="nc" id="L328">				throw new AliasAlreadyInUseException(alias);</span>
<span class="nc" id="L329">			} catch (final ObjectNotRegisteredException e) {</span>
				// it's ok, object not registered
			}

<span class="nc" id="L333">			newObjectID = DataClayRuntime.getObjectIDFromAlias(alias);</span>
		}



<span class="fc" id="L338">		final ObjectMetaData objectMD = new ObjectMetaData(newObjectID, metaClassID, datasetIDofProvider, backendIDs,</span>
				isReadOnly, alias, lang, ownerID);

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L342">			logger.debug(&quot;Registering object &quot; + objectID + &quot; with alias: &quot; + alias + &quot; and language &quot; + lang + &quot;.&quot;);</span>
		}

		try {
<span class="fc" id="L346">			metadataDB.store(objectMD);</span>
<span class="fc" id="L347">		} catch (final DbObjectAlreadyExistException e) {</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L349">				logger.debug(&quot;Object &quot; + objectID + &quot; already registered&quot;);</span>
			}
<span class="fc" id="L351">			throw new ObjectAlreadyRegisteredException(objectID);</span>
<span class="fc" id="L352">		}</span>

<span class="fc" id="L354">		final ObjectID result = objectMD.getDataClayID(); // which now equals to objectID</span>

		// Update cache
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L358">			logger.debug(&quot;[==Register object==] Updating cache of metadatas: {} -&gt; {}&quot;, objectID, objectMD);</span>
		}
<span class="fc" id="L360">		objectMDCache.put(result, objectMD);</span>
<span class="fc" id="L361">		objectMDCacheByAlias.put(alias, objectMD);</span>
<span class="fc" id="L362">		return buildMetaDataInfo(objectMD);</span>
	}

	/**
	 * This operation allows to explicitly register an objectID replacement. If newObjectID is already registered, an exception
	 * is raised and the old ID is kept.
	 * 
	 * @param oldObjectID
	 *            original ID of the object
	 * @param newObjectID
	 *            final ID for the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if object does not exist ObjectAlreadyRegisteredException: if new id is already
	 *             being used
	 */
	public void changeObjectID(final ObjectID oldObjectID, final ObjectID newObjectID)
			throws ObjectNotRegisteredException, ObjectAlreadyRegisteredException {
<span class="fc" id="L380">		ObjectMetaData objectMD = null;</span>

		// Query object info
<span class="fc" id="L383">		objectMD = getObjectBasicMetaData(oldObjectID);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="fc" id="L388">			throw new ObjectNotRegisteredException(oldObjectID);</span>
		}

		// Store new one
<span class="fc" id="L392">		objectMD.setDataClayID(newObjectID);</span>
		try {
<span class="fc" id="L394">			metadataDB.store(objectMD);</span>
<span class="fc" id="L395">		} catch (final DbObjectAlreadyExistException e) {</span>
<span class="fc" id="L396">			objectMD.setDataClayID(oldObjectID);</span>
<span class="fc" id="L397">			throw new ObjectAlreadyRegisteredException(newObjectID);</span>
<span class="fc" id="L398">		}</span>

		// Delete old object if new one was stored correctly
<span class="fc" id="L401">		metadataDB.deleteByID(oldObjectID);</span>

		// Update in Cache
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L405">			logger.debug(&quot;[==Change objectID==] Removing from cache of metadatas: {}&quot;, oldObjectID);</span>
		}
<span class="fc" id="L407">		objectMDCache.remove(oldObjectID);</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L409">			logger.debug(&quot;[==Change objectID==] Adding to cache of metadatas: {} -&gt; {}&quot;, newObjectID, objectMD);</span>
		}
<span class="fc" id="L411">		objectMDCache.put(newObjectID, objectMD);</span>

		// Since objectID is not Key for Alias cache, just update it
<span class="fc" id="L414">		final String alias = objectMD.getAlias();</span>
<span class="fc" id="L415">		objectMDCacheByAlias.put(alias, objectMD);</span>
<span class="fc" id="L416">	}</span>

	/**
	 * This operation allows to explicitly register an dataSetID replacement.
	 * 
	 * @param objectID
	 *            original ID of the object
	 * @param newDataSetID
	 *            final DataSetID for the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if object does not exist
	 */
	public void changeDataSetID(final ObjectID objectID, final DataSetID newDataSetID)
			throws ObjectNotRegisteredException {

		// Query object info
<span class="nc" id="L433">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L438">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// Update it
		try {
<span class="nc" id="L442">			metadataDB.updateDataSetIDByID(objectID, newDataSetID);</span>
<span class="nc" id="L443">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L444">			throw new ObjectNotRegisteredException(objectID);</span>
<span class="nc" id="L445">		}</span>

		// Update cache if necessary
<span class="nc bnc" id="L448" title="All 2 branches missed.">		if (objectMDCache.containsKey(objectID)) {</span>
<span class="nc" id="L449">			objectMDCache.get(objectID).setDataSetID(newDataSetID);</span>
<span class="nc" id="L450">			final String alias = objectMD.getAlias();</span>
<span class="nc" id="L451">			objectMDCacheByAlias.put(alias, objectMDCache.get(objectID));</span>
		}
<span class="nc" id="L453">	}</span>

	/**
	 * Registers a set of versions, copying parts of the metadata from the original objects
	 * 
	 * @param versionToOriginalMapping
	 *            Mapping from version objectID to original objectID
	 * @param backendID
	 *            Backend in which the version is stored
	 * @param lang
	 *            Language doing the operation (should match the object's one)
	 * @return the metadata of the original objects (it will be required for consolidate)
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if an object does not exist
	 */
	public Map&lt;ObjectID, MetaDataInfo&gt; registerVersions(final Map&lt;ObjectID, ObjectID&gt; versionToOriginalMapping,
			final ExecutionEnvironmentID backendID, final Langs lang) throws ObjectNotRegisteredException {
<span class="nc" id="L471">		final Map&lt;ObjectID, MetaDataInfo&gt; result = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">		for (final Entry&lt;ObjectID, ObjectID&gt; versionToOriginal : versionToOriginalMapping.entrySet()) {</span>
<span class="nc" id="L473">			final ObjectID versionID = versionToOriginal.getKey();</span>
<span class="nc" id="L474">			final ObjectID originalID = versionToOriginal.getValue();</span>

			// Get metadata of the original object and put it in the result
<span class="nc" id="L477">			final MetaDataInfo originalMD = getObjectMetaData(originalID);</span>
<span class="nc" id="L478">			result.put(originalID, originalMD);</span>

			// Register version metadata
<span class="nc" id="L481">			final Set&lt;ExecutionEnvironmentID&gt; backends = new HashSet&lt;&gt;();</span>
<span class="nc" id="L482">			backends.add(backendID);</span>
<span class="nc" id="L483">			final ObjectMetaData versionMD = new ObjectMetaData(versionID, originalMD.getMetaclassID(),</span>
<span class="nc" id="L484">					originalMD.getDatasetID(), backends, false, null, lang, originalMD.getOwnerID());</span>

<span class="nc" id="L486">			metadataDB.store(versionMD);</span>

			// Store versionMD in the cache
<span class="nc bnc" id="L489" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L490">				logger.debug(&quot;[==New version==] Adding version to cache of metadatas: {} -&gt; {}&quot;, versionID, versionMD);</span>
			}
<span class="nc" id="L492">			objectMDCache.put(versionID, versionMD);</span>
<span class="nc" id="L493">			final String alias = versionMD.getAlias();</span>
<span class="nc" id="L494">			objectMDCacheByAlias.put(alias, versionMD);</span>
<span class="nc" id="L495">		}</span>
<span class="nc" id="L496">		return result;</span>
	}

	/**
	 * This operation registers a new replica of an object
	 * 
	 * @param objectID
	 *            the object ID
	 * @param newBackendID
	 *            the location of the new replica
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if object does not exist ExecutionEnvironmentNotExistException: if destination
	 *             backend does not exist
	 */
	public void registerReplica(final ObjectID objectID, final ExecutionEnvironmentID newBackendID)
			throws ObjectNotRegisteredException, ExecutionEnvironmentNotExistException {

		// Verify dest. backend exists
<span class="fc" id="L515">		final boolean backendExists = metadataDB.existsByID(newBackendID);</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">		if (!backendExists) {</span>
<span class="nc" id="L517">			throw new ExecutionEnvironmentNotExistException(newBackendID);</span>
		}

		// Query object info
<span class="fc" id="L521">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L526">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// CHECKSTYLE:OFF
		// Check it is not present in destBackend
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">		if (objectMD.getExecutionEnvironmentIDs().contains(newBackendID)) {</span>
			// We do nothing in this case, since we want to replicate all the possible
			// objects, i.e. if we find a replica
			// of a subobject in the backend, go to the next subobject instead of throwing
			// exception.
			// throw new ReplicaAlreadyRegisteredException(objectID, newBackendID);
			// CHECKSTYLE:ON
		} else {
			// Migrate
			try {
<span class="fc" id="L540">				final Set&lt;ExecutionEnvironmentID&gt; newBackendIDs = new HashSet&lt;&gt;(objectMD.getExecutionEnvironmentIDs());</span>
<span class="fc" id="L541">				newBackendIDs.add(newBackendID);</span>
<span class="fc" id="L542">				metadataDB.updateForReplicaByID(objectID, newBackendIDs, true);</span>
<span class="nc" id="L543">			} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L544">				throw new ObjectNotRegisteredException(objectID);</span>
<span class="fc" id="L545">			}</span>

			// Update cache if necessary
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">			if (objectMDCache.containsKey(objectID)) {</span>
<span class="fc" id="L549">				objectMDCache.get(objectID).getExecutionEnvironmentIDs().add(newBackendID);</span>
<span class="fc" id="L550">				objectMDCache.get(objectID).setReadOnly(true);</span>
<span class="fc" id="L551">				final String alias = objectMD.getAlias();</span>
<span class="fc" id="L552">				objectMDCacheByAlias.put(alias, objectMDCache.get(objectID));</span>
			}
		}

<span class="fc" id="L556">	}</span>

	/**
	 * This operation unregisters an object with ID provided. This also unregisters all replicas and returns its locations.
	 * 
	 * @param objectID
	 *            ID of the object to unregister
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if object does not exist
	 */
	public void unregisterObject(final ObjectID objectID) throws ObjectNotRegisteredException {

<span class="pc bpc" id="L569" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L570">			logger.debug(&quot;Unregistering &quot; + objectID);</span>
		}

		// Query object info
<span class="fc" id="L574">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="fc" id="L579">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// Unregister object
<span class="fc" id="L582">		metadataDB.deleteByID(objectID);</span>

		// Update cache if necessary
<span class="fc" id="L585">		objectMDCache.remove(objectID);</span>
<span class="fc" id="L586">		final String alias = objectMD.getAlias();</span>
<span class="fc" id="L587">		objectMDCacheByAlias.remove(alias);</span>
<span class="fc" id="L588">	}</span>

	/**
	 * Checks that given dataset has no object.
	 * 
	 * @param datasetID
	 *            the ID of the dataset to be checked
	 * @return Whether the dataset is empty or not.
	 * @throws Exception
	 *             if an exception occurs.
	 */
	public boolean checkDatasetIsEmpty(final DataSetID datasetID) {
<span class="nc bnc" id="L600" title="All 2 branches missed.">		return !metadataDB.existsByDataSetID(datasetID);</span>
	}

	/**
	 * This operation verifies that the object with ID provided exists in the backend with ID provided as source backend and not
	 * in the destination backend.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param srcBackend
	 *            ID of the source backend
	 * @param destBackend
	 *            ID of the destination backend
	 * @return TRUE if the object exists in the source backend and not in the destination backend. FALSE otherwise.
	 * @throws Exception
	 *             if an exception occurs ObjectNotRegisteredException: if the object does not exist
	 */
	public boolean checkObjectInSrcNotInDest(final ObjectID objectID, final ExecutionEnvironmentID srcBackend,
			final ExecutionEnvironmentID destBackend) throws ObjectNotRegisteredException {
		// Query object info
<span class="fc" id="L620">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L625">			throw new ObjectNotRegisteredException(objectID);</span>
		}
<span class="fc" id="L627">		final Set&lt;ExecutionEnvironmentID&gt; backendIDs = objectMD.getExecutionEnvironmentIDs();</span>
<span class="pc bpc" id="L628" title="2 of 4 branches missed.">		return backendIDs.contains(srcBackend) &amp;&amp; !backendIDs.contains(destBackend);</span>
	}

	/**
	 * This operation moves an object from source location to destination location
	 * 
	 * @param objectID
	 *            ID of the object to modify
	 * @param srcBackendID
	 *            ID of the backend of the replica to be moved
	 * @param destBackendID
	 *            ID of the backend in which the object is 'moved'
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object does not exist or it is not present in source backend
	 *             ExecutionEnvironmentNotExistException: if destination backend does not exist
	 */
	public void migrateObjectToBackend(final ObjectID objectID, final ExecutionEnvironmentID srcBackendID,
			final ExecutionEnvironmentID destBackendID)
					throws ObjectNotRegisteredException, ExecutionEnvironmentNotExistException {

		// Verify dest. backend exists
<span class="fc bfc" id="L650" title="All 2 branches covered.">		if (!currentExecutionEnvironments.containsKey(destBackendID)) {</span>
<span class="fc" id="L651">			final ExecutionEnvironment backend = metadataDB.getByID(destBackendID);</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">			if (backend == null) {</span>
<span class="fc" id="L653">				throw new ExecutionEnvironmentNotExistException(destBackendID);</span>
			}

			// Update cache
<span class="fc" id="L657">			currentExecutionEnvironments.put(destBackendID, backend);</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">			if (backend.getLang() == Langs.LANG_JAVA) {</span>
<span class="fc" id="L659">				currentJavaExecutionEnvironments.put(backend.getAddress(), backend.getDataClayID());</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">			} else if (backend.getLang() == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L661">				currentPythonExecutionEnvironments.put(backend.getAddress(), backend.getDataClayID());</span>
			}
		}

		// Query object info
<span class="fc" id="L666">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="fc" id="L671">			throw new ObjectNotRegisteredException(objectID);</span>
		}
<span class="fc" id="L673">		final Set&lt;ExecutionEnvironmentID&gt; backendIDs = objectMD.getExecutionEnvironmentIDs();</span>

		// Check it is in srcBackend
<span class="fc bfc" id="L676" title="All 2 branches covered.">		if (!backendIDs.contains(srcBackendID)) {</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L678">				logger.debug(&quot;[==MOVE==] Migrating metadata FAILED of &quot; + objectID + &quot; from &quot; + srcBackendID + &quot; to &quot;</span>
						+ destBackendID + &quot; due not registered in source.&quot;);
			}

<span class="fc" id="L682">			throw new ObjectNotRegisteredException(objectID);</span>
		} else {
			// Check it is not present in destBackend
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">			if (backendIDs.contains(destBackendID)) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L687">					logger.debug(&quot;[==MOVE==] Migrating metadata FAILED of &quot; + objectID + &quot; from &quot; + srcBackendID</span>
							+ &quot; to &quot; + destBackendID + &quot; due already registered in destination.&quot;);
				}

<span class="nc" id="L691">				throw new ObjectAlreadyRegisteredException(objectID);</span>
			} else {
<span class="fc" id="L693">				migrateObjectToBackend(objectID, objectMD, srcBackendID, destBackendID);</span>
			}
		}
<span class="fc" id="L696">	}</span>

	/**
	 * This operations removes the srcBackendID from the locations of the specified objects and adds the corresponding new
	 * location from newObjBackends to each of them. If unregisterBackend is set to true, the srcBackendID is unregistered.
	 * WARNING: This function is not checking whether the srcBackendID becomes totally empty after migrating specified
	 * objects!!! For that, we would need an structure to keep which objects has every backend
	 * 
	 * @param srcBackendID
	 *            ID of the unregistered backend from which objects are migrated
	 * @param newObjBackends
	 *            the objects for every new destination backend
	 * @param unregisterBackend
	 *            whether to unregister the srcBackendID or not
	 * @return TRUE if the backend has been successfully unregistered. FALSE otherwise.
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ExecutionEnvironmentNotExistException: if backend does not exist
	 */
	public boolean migrateObjectsToBackend(final ExecutionEnvironmentID srcBackendID,
			final Map&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; newObjBackends, final boolean unregisterBackend)
					throws ExecutionEnvironmentNotExistException {

		// Verify dest. backends exist
<span class="fc bfc" id="L720" title="All 2 branches covered.">		for (final ExecutionEnvironmentID destBackendID : newObjBackends.keySet()) {</span>
			// Verify dest. backend exists
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">			if (!currentExecutionEnvironments.containsKey(destBackendID)) {</span>
<span class="fc" id="L723">				final ExecutionEnvironment backend = metadataDB.getByID(destBackendID);</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">				if (backend == null) {</span>
<span class="fc" id="L725">					throw new ExecutionEnvironmentNotExistException(destBackendID);</span>
				}

				// Update cache
<span class="fc" id="L729">				currentExecutionEnvironments.put(destBackendID, backend);</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">				if (backend.getLang() == Langs.LANG_JAVA) {</span>
<span class="fc" id="L731">					currentJavaExecutionEnvironments.put(backend.getAddress(), backend.getDataClayID());</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">				} else if (backend.getLang() == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L733">					currentPythonExecutionEnvironments.put(backend.getAddress(), backend.getDataClayID());</span>
				}
			}
<span class="fc" id="L736">		}</span>

		// Register migrations
<span class="fc bfc" id="L739" title="All 2 branches covered.">		for (final Entry&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; curEntry : newObjBackends.entrySet()) {</span>
<span class="fc" id="L740">			final ExecutionEnvironmentID destBackendID = curEntry.getKey();</span>

			// Query objects info
<span class="fc bfc" id="L743" title="All 2 branches covered.">			for (final ObjectID objectID : curEntry.getValue()) {</span>
<span class="fc" id="L744">				final ObjectMetaData curObjectMetaData = getObjectBasicMetaData(objectID);</span>
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">				if (curObjectMetaData == null) {</span>
					// TODO: Need new design for this. since getObjectBasicMetadata is in critical
					// path, it is returning
					// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L749">					throw new ObjectNotRegisteredException(objectID);</span>
				}
<span class="fc" id="L751">				migrateObjectToBackend(objectID, curObjectMetaData, srcBackendID, destBackendID);</span>
<span class="fc" id="L752">			}</span>
<span class="fc" id="L753">		}</span>

		// Unregister backend if required
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">		if (unregisterBackend) {</span>
			try {
<span class="fc" id="L758">				metadataDB.deleteByID(srcBackendID);</span>

				// Update cache
<span class="fc" id="L761">				currentExecutionEnvironments.remove(srcBackendID);</span>

<span class="fc" id="L763">				return true;</span>
<span class="nc" id="L764">			} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L765">				throw new ExecutionEnvironmentNotExistException(srcBackendID);</span>
			}
		}
<span class="nc" id="L768">		return false;</span>
	}

	/**
	 * This operation modifies the permissions of the object with ID provided to read-only
	 * 
	 * @param objectID
	 *            ID of the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object does not exist
	 */
	public void setObjectReadOnly(final ObjectID objectID) throws ObjectNotRegisteredException {
		// Query object info
<span class="fc" id="L782">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="fc" id="L787">			throw new ObjectNotRegisteredException(objectID);</span>
		}
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">		if (!objectMD.isReadOnly()) {</span>
			// Update it
			try {
<span class="fc" id="L792">				metadataDB.updateReadOnlyByID(objectID, true);</span>

<span class="nc" id="L794">			} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L795">				throw new ObjectNotRegisteredException(objectID);</span>
<span class="fc" id="L796">			}</span>
		}

		// Update cache if necessary
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">		if (objectMDCache.containsKey(objectID)) {</span>
<span class="fc" id="L801">			objectMDCache.get(objectID).setReadOnly(true);</span>
<span class="fc" id="L802">			final String alias = objectMD.getAlias();</span>
<span class="fc" id="L803">			objectMDCacheByAlias.put(alias, objectMDCache.get(objectID));</span>
		}

<span class="fc" id="L806">	}</span>

	/**
	 * This operation modifies the permissions of the object with ID provided to read-write
	 * 
	 * @param objectID
	 *            ID of the object
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ObjectNotRegisteredException: if the object does not exist &lt;br&gt;
	 *             ObjectHasReplicas: if the object has replicas
	 */
	public void setObjectReadWrite(final ObjectID objectID) throws ObjectNotRegisteredException {
		// Query object info
<span class="fc" id="L820">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L825">			throw new ObjectNotRegisteredException(objectID);</span>
		}
		// WARNING: in 2.0 we assume that if an object has replicas it MUST be READ-ONLY
		// (jmarti 13 Jun 2013)
<span class="fc bfc" id="L829" title="All 2 branches covered.">		if (objectMD.getExecutionEnvironmentIDs().size() &gt; 1) {</span>
<span class="fc" id="L830">			throw new ObjectHasReplicas(objectID);</span>
		} else {
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">			if (objectMD.isReadOnly()) {</span>
				// Update it
				try {
<span class="nc" id="L835">					metadataDB.updateReadOnlyByID(objectID, false);</span>

<span class="nc" id="L837">				} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L838">					throw new ObjectNotRegisteredException(objectID);</span>
<span class="nc" id="L839">				}</span>
			}
		}

		// Update cache if necessary
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">		if (objectMDCache.containsKey(objectID)) {</span>
<span class="fc" id="L845">			objectMDCache.get(objectID).setReadOnly(false);</span>
<span class="fc" id="L846">			final String alias = objectMD.getAlias();</span>
<span class="fc" id="L847">			objectMDCacheByAlias.put(alias, objectMDCache.get(objectID));</span>
		}
<span class="fc" id="L849">	}</span>

	// =========== OPS FOR BACKEND MANAGEMENT ============ //

	/**
	 * This operation register the Storage Location with ID provided.
	 * 
	 * @param newStLoc
	 *            Specifications of the Storage Location to register
	 * @return The ID of the new Storage Location registered
	 * @throws StorageLocationAlreadyExistsException
	 *             if the storage location is already registered
	 */
	public StorageLocationID registerStorageLocation(final StorageLocation newStLoc)
			throws StorageLocationAlreadyExistsException {
		// Verify backend does not exist

<span class="fc" id="L866">		final StorageLocation stLocation = metadataDB.getStorageLocationByName(newStLoc.getName());</span>

<span class="pc bpc" id="L868" title="1 of 2 branches missed.">		if (stLocation != null) {</span>
<span class="nc" id="L869">			throw new StorageLocationAlreadyExistsException(newStLoc);</span>
		}
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L872">			logger.debug(&quot;Registering new backend: &quot; + newStLoc);</span>
		}

		// Store backend
<span class="fc" id="L876">		metadataDB.store(newStLoc);</span>

		// Update cache
<span class="fc" id="L879">		currentStorageLocations.put(newStLoc.getDataClayID(), newStLoc);</span>
<span class="fc" id="L880">		return newStLoc.getDataClayID();</span>
	}

	/**
	 * Unregisters a storage location
	 * 
	 * @param stLocID
	 *            id of the storage location to be unregistered
	 */
	public void unregisterStorageLocation(final StorageLocationID stLocID) {
<span class="nc" id="L890">		metadataDB.deleteByID(stLocID);</span>
<span class="nc" id="L891">	}</span>

	/**
	 * Updates host and port of a storage location
	 * 
	 * @param stLocID
	 *            id of the storage location to be updated
	 * @param newhost New host 
	 * @param newport New port
	 */
	public void updateStorageLocation(final StorageLocationID stLocID, final String newhost, final Integer newport) {
<span class="nc" id="L902">		metadataDB.updateStorageLocationByID(stLocID, newhost, newport);</span>
<span class="nc" id="L903">	}</span>

	/**
	 * Updates host and port of a execution environment
	 * 
	 * @param id
	 *            id of the execution environment to be updated
	 * @param newhost New host 
	 * @param newport New port
	 */
	public void updateExecutionEnvironment(final ExecutionEnvironmentID eeID, final String newhost, final Integer newport) {
<span class="nc" id="L914">		metadataDB.updateExecutionEnvironmentByID(eeID, newhost, newport);</span>
<span class="nc" id="L915">	}</span>

	/**
	 * This operation register the Execution Environment with ID provided.
	 * 
	 * @param newBackend
	 *            Specifications of the Execution Environment to register
	 * @return The ID of the new Execution Environment registered
	 * @throws ExecutionEnvironmentAlreadyExistsException
	 *             if the execution environment is already registered
	 */
	public ExecutionEnvironmentID registerExecutionEnvironment(final ExecutionEnvironment newBackend)
			throws ExecutionEnvironmentAlreadyExistsException {
		// Verify backend does not exist
<span class="fc" id="L929">		final ExecutionEnvironment exeEnv = metadataDB.getByID(newBackend.getDataClayID());</span>

<span class="pc bpc" id="L931" title="1 of 2 branches missed.">		if (exeEnv != null) {</span>
<span class="nc" id="L932">			throw new ExecutionEnvironmentAlreadyExistsException(newBackend);</span>
		}
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L935">			logger.debug(&quot;Registering new backend: &quot; + newBackend);</span>
		}

		// Store backend
<span class="fc" id="L939">		metadataDB.store(newBackend);</span>

		// Update cache
<span class="fc" id="L942">		currentExecutionEnvironments.put(newBackend.getDataClayID(), newBackend);</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">		if (newBackend.getLang() == Langs.LANG_JAVA) {</span>
<span class="fc" id="L944">			currentJavaExecutionEnvironments.put(newBackend.getAddress(), newBackend.getDataClayID());</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">		} else if (newBackend.getLang() == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L946">			currentPythonExecutionEnvironments.put(newBackend.getAddress(), newBackend.getDataClayID());</span>
		}
<span class="fc" id="L948">		return newBackend.getDataClayID();</span>
	}

	/**
	 * Unregisters an execution environment
	 * 
	 * @param execEnvID
	 *            id of the storage location to be unregistered
	 */
	public void unregisterExecutionEnvironment(final ExecutionEnvironmentID execEnvID) {
<span class="nc" id="L958">		metadataDB.deleteByID(execEnvID);</span>
<span class="nc" id="L959">	}</span>

	/**
	 * This operation queries a Storage Location by its name
	 * 
	 * @param stLocName
	 *            Name of the Storage Location to get
	 * @return The ID of the queried Storage Location
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             StorageLocationNotExistException: if a storage location with the given name does not exist
	 */
	public StorageLocationID getStorageLocationID(final String stLocName) {

<span class="nc bnc" id="L973" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L974">			logger.debug(&quot;Looking for Storage Location named: &quot; + stLocName);</span>
		}

		// Look up in the cache
<span class="nc bnc" id="L978" title="All 2 branches missed.">		for (final Entry&lt;StorageLocationID, StorageLocation&gt; stLocEntry : currentStorageLocations.entrySet()) {</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">			if (stLocEntry.getValue().getName().equals(stLocName)) {</span>
<span class="nc" id="L980">				return stLocEntry.getKey();</span>
			}
<span class="nc" id="L982">		}</span>

		// If it is not in the cache, query it
<span class="nc" id="L985">		final StorageLocation res = metadataDB.getStorageLocationByName(stLocName);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">		if (res == null) {</span>
<span class="nc" id="L987">			throw new StorageLocationNotExistException(stLocName);</span>
		} else {
			// Update cache
<span class="nc" id="L990">			currentStorageLocations.put(res.getDataClayID(), res);</span>
		}

<span class="nc" id="L993">		return res.getDataClayID();</span>
	}

	/**
	 * This operation retrieves the info of a storage location
	 * 
	 * @param storageLocationID
	 *            ID of the storage location
	 * @return the info of the storage location
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             StorageLocationNotExistException: if the storage location does not exist
	 */
	public StorageLocation getStorageLocationInfo(final StorageLocationID storageLocationID) {
<span class="nc" id="L1007">		final StorageLocation result = getStorageLocation(storageLocationID);</span>
<span class="nc" id="L1008">		return result;</span>
	}

	/**
	 * This operation retrieves the info of all the current registered storage locations.
	 * 
	 * @return info of the registered storage locations indexed by their IDs
	 */
	public Map&lt;StorageLocationID, StorageLocation&gt; getAllStorageLocationsInfo() {

<span class="nc" id="L1018">		final List&lt;StorageLocation&gt; backends = metadataDB.getAllStorageLocations();</span>
<span class="nc" id="L1019">		final Map&lt;StorageLocationID, StorageLocation&gt; result = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">		for (final StorageLocation backend : backends) {</span>
<span class="nc" id="L1021">			result.put(backend.getDataClayID(), backend);</span>
<span class="nc" id="L1022">		}</span>
<span class="nc" id="L1023">		return result;</span>
	}

	/**
	 * This operation retrieves the info of an execution environment
	 * 
	 * @param execEnvID
	 *            ID of the execution environment to get its info
	 * @return the info of the backend
	 * @throws Exception
	 *             if an exception occurs: &lt;br&gt;
	 *             ExecutionEnvironmentNotExistException: if backend does not exist
	 */
	public ExecutionEnvironment getExecutionEnvironmentInfo(final ExecutionEnvironmentID execEnvID) {
<span class="fc" id="L1037">		final ExecutionEnvironment result = getExecutionEnvironment(execEnvID);</span>
<span class="fc" id="L1038">		return result;</span>
	}

	/**
	 * This operation retrieves the info of all the current registered execution environments.
	 * @param execEnvLang language
	 * @return info of the registered execution environments indexed by their IDs
	 */
	public Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getAllExecutionEnvironmentsInfo(final Langs execEnvLang) {
		final List&lt;ExecutionEnvironment&gt; execEnvs;
<span class="nc bnc" id="L1048" title="All 4 branches missed.">		if (execEnvLang == Langs.LANG_NONE || execEnvLang == null) {</span>
<span class="nc" id="L1049">			execEnvs = metadataDB.getAllExecutionEnvironments();</span>
		} else {
<span class="nc" id="L1051">			execEnvs = metadataDB.getAllExecutionEnvironmentsByLang(execEnvLang);</span>
		}
<span class="nc" id="L1053">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; result = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1055" title="All 2 branches missed.">		for (final ExecutionEnvironment execEnv : execEnvs) {</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">			if (execEnv.getLang().equals(execEnvLang)) {</span>
<span class="nc" id="L1057">				result.put(execEnv.getDataClayID(), execEnv);</span>
			}
<span class="nc" id="L1059">		}</span>
<span class="nc" id="L1060">		return result;</span>
	}

	/**
	 * Retrieves a random execution environment
	 * 
	 * @return the execution environment spec
	 */
	public Tuple&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getRandomExecutionEnvironmentInfo(
			final Langs execEnvLang) {

		// Get random backend from registered ones
<span class="fc" id="L1072">		ExecutionEnvironmentID backendID = null;</span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">		if (execEnvLang == Langs.LANG_JAVA) {</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">			if (!currentJavaExecutionEnvironments.isEmpty()) {</span>
<span class="fc" id="L1075">				final int index = new Random().nextInt(currentJavaExecutionEnvironments.size());</span>
<span class="fc" id="L1076">				backendID = (ExecutionEnvironmentID) currentJavaExecutionEnvironments.values().toArray()[index];</span>
<span class="fc" id="L1077">			}</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">		} else if (execEnvLang == Langs.LANG_PYTHON) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">			if (!currentPythonExecutionEnvironments.isEmpty()) {</span>
<span class="nc" id="L1080">				final int index = new Random().nextInt(currentPythonExecutionEnvironments.size());</span>
<span class="nc" id="L1081">				backendID = (ExecutionEnvironmentID) currentPythonExecutionEnvironments.values().toArray()[index];</span>
			}
		}
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">		if (backendID == null) {</span>
			final ExecutionEnvironment backend;
<span class="nc" id="L1086">			final List&lt;ExecutionEnvironment&gt; backends = metadataDB.getAllExecutionEnvironmentsByLang(execEnvLang);</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">			if (backends.isEmpty()) {</span>
<span class="nc" id="L1088">				throw new ExecutionEnvironmentNotExistException(execEnvLang);</span>
			}
<span class="nc" id="L1090">			final int index = new Random().nextInt(backends.size());</span>
<span class="nc" id="L1091">			backend = backends.get(index);</span>

			// Update cache
<span class="nc bnc" id="L1094" title="All 2 branches missed.">			for (final ExecutionEnvironment curBackend : backends) {</span>
<span class="nc" id="L1095">				currentExecutionEnvironments.put(curBackend.getDataClayID(), curBackend);</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">				if (execEnvLang == Langs.LANG_JAVA) {</span>
<span class="nc" id="L1097">					currentJavaExecutionEnvironments.put(curBackend.getAddress(), curBackend.getDataClayID());</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">				} else if (execEnvLang == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L1099">					currentPythonExecutionEnvironments.put(curBackend.getAddress(), curBackend.getDataClayID());</span>
				}
<span class="nc" id="L1101">			}</span>

<span class="nc" id="L1103">			return new Tuple&lt;&gt;(backend.getDataClayID(), backend);</span>
		} else {
<span class="fc" id="L1105">			return new Tuple&lt;&gt;(backendID, getExecutionEnvironmentInfo(backendID));</span>
		}
	}

	// ===== OBEJCT FEDERATION OPS ======= //

	/**
	 * Register external dataclay
	 * @param dataClay instance to register
	 */
	public void registerExternalDataclay(final DataClayInstance dataClay) {
		try {

<span class="fc" id="L1118">			metadataDB.insertDataClayInstance(dataClay);</span>

			// update cache 
<span class="fc" id="L1121">			final DataClayInstance dClayInfo = metadataDB.getDataClayInfo(dataClay.getDcID());</span>
<span class="fc" id="L1122">			externalDataClaysCache.put(dataClay.getDcID(), dClayInfo);</span>

<span class="fc bfc" id="L1124" title="All 2 branches covered.">			for (int i = 0; i &lt; dClayInfo.getHosts().length; ++i) { </span>
<span class="fc" id="L1125">				final String host = dClayInfo.getHosts()[i];</span>
<span class="fc" id="L1126">				final Integer port = dClayInfo.getPorts()[i];</span>
<span class="fc" id="L1127">				final Tuple&lt;String, Integer&gt; key = new Tuple&lt;&gt;(host, port);</span>
<span class="fc" id="L1128">				final DataClayInstanceID id = dataClaysPerHostPortCache.get(key);</span>
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">				if (id == null) {</span>
<span class="fc" id="L1130">					dataClaysPerHostPortCache.put(key, dataClay.getDcID());</span>
				}
			}
<span class="nc" id="L1133">		} catch (final DbObjectAlreadyExistException ex1) {</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1135">				logger.debug(&quot;External dataClay {} already registered&quot;, dataClay);</span>
			}
<span class="nc" id="L1137">			return;</span>
<span class="fc" id="L1138">		}</span>
<span class="fc" id="L1139">	}</span>

	/**
	 * Unregister external dataClay address
	 * @param host Host
	 * @param port Port
	 */
	public void unregisterExternalDataClayAddress(final String host, final Integer port) {
		try {

<span class="nc" id="L1149">			metadataDB.deleteDataClayInstance(host, port);</span>
<span class="nc" id="L1150">		} catch (final Exception ex1) {</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1152">				logger.debug(&quot;External dataClay at {}:{} already unregistered: &quot;, host, port, ex1);</span>
			}
<span class="nc" id="L1154">			return;</span>
<span class="nc" id="L1155">		}</span>
<span class="nc" id="L1156">	}</span>

	/**
	 * Retrieves information about an external dataClay instance identified by provided id
	 * 
	 * @param extDataClayID
	 *            id of the external dataClay instance
	 * @return info of external dataClay instance
	 * @throws ExternalDataClayNotRegisteredException
	 *             if no info about dataClay instance is registered
	 */
	public DataClayInstance getExternalDataClayInfo(final DataClayInstanceID extDataClayID)
			throws ExternalDataClayNotRegisteredException {

<span class="nc" id="L1170">		DataClayInstance dClayInfo = externalDataClaysCache.get(extDataClayID);</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">		if (dClayInfo == null) {</span>
<span class="nc" id="L1172">			dClayInfo = metadataDB.getDataClayInfo(extDataClayID);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">			if (dClayInfo == null) {</span>
<span class="nc" id="L1174">				throw new ExternalDataClayNotRegisteredException(extDataClayID);</span>
			}
<span class="nc" id="L1176">			externalDataClaysCache.put(extDataClayID, dClayInfo);</span>
		}
<span class="nc" id="L1178">		return dClayInfo;</span>
	}

	/**
	 * Retrieves id of an external dataClay instance identified by host and port
	 * 
	 * @param host host 
	 * @param port port
	 * @return id of external dataClay instance
	 * @throws ExternalDataClayNotRegisteredException
	 *             if no info about dataClay instance is registered
	 */
	public DataClayInstanceID getExternalDataClayID(final String host, final int port)
			throws ExternalDataClayNotRegisteredException {

<span class="nc" id="L1193">		final Tuple&lt;String, Integer&gt; key = new Tuple&lt;&gt;(host, port);</span>
<span class="nc" id="L1194">		DataClayInstanceID id = dataClaysPerHostPortCache.get(key);</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">		if (id == null) {</span>
<span class="nc" id="L1196">			id = metadataDB.getDataClayID(host, port);</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">			if (id == null) {</span>
<span class="nc" id="L1198">				throw new ExternalDataClayNotRegisteredException(host, port);</span>
			}
<span class="nc" id="L1200">			dataClaysPerHostPortCache.put(key, id);</span>
		}
<span class="nc" id="L1202">		return id;</span>
	}

	/**
	 * Registers an object to be federated with an external dataClay identified with the given ID
	 * 
	 * @param objectID
	 *            id of the object to be federated
	 * @param dataClayID
	 *            id of the external dataClay
	 * @return false if the object cannot be federated, either because it was already federated or dataClayID is not registered
	 *         true otherwise.
	 */
	public boolean federateObjectWith(final ObjectID objectID, final DataClayInstanceID dataClayID) {
<span class="nc" id="L1216">		Set&lt;DataClayInstanceID&gt; dcIDs = federatedObjectsCache.get(objectID);</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">		if (dcIDs != null) {</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">			if (dcIDs.contains(dataClayID)) {</span>
<span class="nc" id="L1219">				return false;</span>
			}
		}

		// Check object exists
<span class="nc" id="L1224">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L1229">			throw new ObjectNotRegisteredException(objectID);</span>
		}

		// Get external dataClay info
<span class="nc" id="L1233">		final DataClayInstance di = getExternalDataClayInfo(dataClayID);</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">		if (di == null) {</span>
<span class="nc" id="L1235">			return false;</span>
		}
<span class="nc bnc" id="L1237" title="All 2 branches missed.">		if (!metadataDB.insertFederatedObject(objectID, dataClayID)) {</span>
<span class="nc" id="L1238">			return false;</span>
		}
<span class="nc" id="L1240">		dcIDs = federatedObjectsCache.get(objectID);</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">		if (dcIDs == null) {</span>
<span class="nc" id="L1242">			dcIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1243">			federatedObjectsCache.put(objectID, dcIDs);</span>
		}
<span class="nc" id="L1245">		dcIDs.add(dataClayID);</span>
<span class="nc" id="L1246">		return true;</span>
	}

	/**
	 * Unfederate object with an external dataClay identified with the given ID
	 * 
	 * @param objectID
	 *            id of the object to be unfederated
	 * @param dataClayID
	 *            id of the external dataClay
	 * @return false if the object cannot be unfederated, either because it was not federated or others. true otherwise.
	 */
	public boolean unfederateObjectWith(final ObjectID objectID, final DataClayInstanceID dataClayID) {

		// Check object exists
<span class="nc" id="L1261">		final ObjectMetaData objectMD = getObjectBasicMetaData(objectID);</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">		if (objectMD == null) {</span>
			// TODO: Need new design for this. since getObjectBasicMetadata is in critical
			// path, it is returning
			// null instead of exception to avoid penalty for serializing an exception.
<span class="nc" id="L1266">			throw new ObjectNotRegisteredException(objectID);</span>
		}

		// Get external dataClay info
<span class="nc" id="L1270">		final DataClayInstance di = getExternalDataClayInfo(dataClayID);</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">		if (di == null) {</span>
<span class="nc" id="L1272">			return false;</span>
		}

<span class="nc bnc" id="L1275" title="All 2 branches missed.">		if (!metadataDB.deleteFederatedObject(objectID, dataClayID)) {</span>
			// object already unfederated
<span class="nc" id="L1277">			return false;</span>
		}

<span class="nc" id="L1280">		federatedObjectsCache.remove(objectID);</span>

<span class="nc" id="L1282">		return true;</span>
	}

	/**
	 * Checks whether the object is actually federated with dataClay instance identified with given ID
	 * 
	 * @param objectID
	 *            id of the object
	 * @param dataClayID
	 *            id of the external dataClay instance
	 * @return true if the object is federated. false otherwise.
	 */
	public boolean checkIsFederatedWith(final ObjectID objectID, final DataClayInstanceID dataClayID) {
<span class="nc" id="L1295">		Set&lt;DataClayInstanceID&gt; dcIDs = federatedObjectsCache.get(objectID);</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">		if (dcIDs != null) {</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">			if (dcIDs.contains(dataClayID)) {</span>
<span class="nc" id="L1298">				return true;</span>
			}
		}
<span class="nc" id="L1301">		final boolean result = metadataDB.existsFederatedObjectWithDC(objectID, dataClayID);</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">		if (result) {</span>
<span class="nc" id="L1303">			dcIDs = federatedObjectsCache.get(objectID);</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">			if (dcIDs == null) {</span>
<span class="nc" id="L1305">				dcIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1306">				federatedObjectsCache.put(objectID, dcIDs);</span>
			}
<span class="nc" id="L1308">			dcIDs.add(dataClayID);</span>
		}
<span class="nc" id="L1310">		return result;</span>
	}

	/**
	 * Get all dataClays object provided is federated with
	 * @param objectID ID of the object 
	 * @return dataClay IDs the object is federated with
	 */
	public Set&lt;DataClayInstanceID&gt; getDataClaysOurObjectIsFederatedWith(final ObjectID objectID) {
<span class="nc" id="L1319">		return metadataDB.getDataClaysOurObjectIsFederatedWith(objectID);</span>
	}

	/**
	 * Get all dataClays current dataClay has objects federated with
	 * @return dataClay IDs current dataClay has objects federated with
	 */
	public Set&lt;DataClayInstanceID&gt; getAllExternalDataClays() {
<span class="nc" id="L1327">		return metadataDB.getAllExternalDataClays();</span>
	}

	/**
	 * Registers an object that is federated from an external dataClay instance.
	 * 
	 * @param objectID
	 *            ID of the federated object in the external dataClay
	 * @param dataClayID
	 *            id of the external source dataClay
	 */
	public void registerExternalObject(final ObjectID objectID, final DataClayInstanceID dataClayID) {
		// Check external dataClay is registered
<span class="nc" id="L1340">		getExternalDataClayInfo(dataClayID);</span>

<span class="nc" id="L1342">		metadataDB.insertExternalObject(objectID, dataClayID, false);</span>
<span class="nc" id="L1343">	}</span>

	/**
	 * Unregisters an object that is federated from an external dataClay instance.
	 * 
	 * @param objectID
	 *            ID of the federated object in the external dataClay
	 */
	public void unregisterExternalObject(final ObjectID objectID) {
<span class="nc" id="L1352">		metadataDB.deleteExternalObject(objectID);</span>
<span class="nc" id="L1353">	}</span>

	/**
	 * Checks if the object is actually a federated object
	 * 
	 * @param objectID
	 *            id of the object
	 * @return TRUE if object is external.
	 */
	public boolean existsExternalObject(final ObjectID objectID) {
<span class="nc bnc" id="L1363" title="All 2 branches missed.">		return metadataDB.existsExternalObject(objectID, true) </span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">				|| metadataDB.existsExternalObject(objectID, false);</span>
	}

	/**
	 * Checks if the object is actually a federated object with unregistered flag = false
	 * 
	 * @param objectID
	 *            id of the object
	 * @return TRUE if object is external.
	 */
	public boolean externalObjectIsRegistered(final ObjectID objectID) {
<span class="nc" id="L1375">		return metadataDB.existsExternalObject(objectID, false);</span>
	}

	/**
	 * Checks if the object is actually a federated object with unregistered flag = true
	 * 
	 * @param objectID
	 *            id of the object
	 * @return TRUE if object is external.
	 */
	public boolean externalObjectIsUnregistered(final ObjectID objectID) {
<span class="nc" id="L1386">		return metadataDB.existsExternalObject(objectID, true);</span>
	}

	/**
	 * Update external object to be marked as unregistered 
	 * 
	 * @param objectID
	 *            ID of the object to update
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void markExternalObjectAsUnregistered(final ObjectID objectID) { 
<span class="nc" id="L1398">		this.metadataDB.updateUnregisteredFlagExternalObject(objectID, true);</span>
<span class="nc" id="L1399">	}</span>

	/**
	 * Update external object to be marked as registered 
	 * 
	 * @param objectID
	 *            ID of the object to update
	 * @throws DbObjectNotExistException
	 *             if object does not exist
	 */
	public void markExternalObjectAsRegistered(final ObjectID objectID) { 
<span class="nc" id="L1410">		this.metadataDB.updateUnregisteredFlagExternalObject(objectID, false);</span>
<span class="nc" id="L1411">	}</span>

	/**
	 * Get unregistered external objects.
	 * @return id of external objects unregistered
	 */
	public Set&lt;ObjectID&gt; getUnregisteredExternalObjects() {
<span class="nc" id="L1418">		return metadataDB.getUnregisteredExternalObjects();</span>
	}

	/**
	 * Method that retrieves the info of external source dataClay of this object
	 * 
	 * @param objectID
	 *            id of the object
	 * @return info of the external source dataClay
	 */
	public DataClayInstanceID getExternalSourceDataClayOfObject(final ObjectID objectID) {
<span class="nc" id="L1429">		return metadataDB.getExternalDataClayOfObject(objectID);</span>
	}

	/**
	 * Method that retrieves all the objects federated/belonging to dataClay with ID provided.
	 * 
	 * @param extDataClayInstanceID
	 *            id of dataclay
	 * @return all the objects federated/belonging to dataClay with ID provided.
	 */
	public Set&lt;ObjectID&gt; getObjectsFederatedWithDataClay(final DataClayInstanceID extDataClayInstanceID) {
<span class="nc" id="L1440">		return metadataDB.getObjectsFederatedWithDataClay(extDataClayInstanceID);</span>
	}

	// ========= PRIVATE FUNCTIONS ========= //

	/**
	 * Builds a MetaDataInfo structure from ObjectMetaData
	 * 
	 * @param objectMD
	 *            the object metadata
	 * @return MetaDataInfo representation of the given object metadata
	 */
	private MetaDataInfo buildMetaDataInfo(final ObjectMetaData objectMD) {
<span class="fc" id="L1453">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; objectMDlocations = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1454" title="All 2 branches covered.">		for (final ExecutionEnvironmentID curLocID : objectMD.getExecutionEnvironmentIDs()) {</span>
<span class="fc" id="L1455">			final ExecutionEnvironment loc = getExecutionEnvironment(curLocID);</span>
<span class="fc" id="L1456">			objectMDlocations.put(curLocID, loc);</span>
<span class="fc" id="L1457">		}</span>
<span class="fc" id="L1458">		final MetaDataInfo result = new MetaDataInfo(objectMD.getDataClayID(), objectMD.getDataSetID(),</span>
<span class="fc" id="L1459">				objectMD.getMetaClassID(), objectMD.isReadOnly(), objectMDlocations, objectMD.getAlias(),</span>
<span class="fc" id="L1460">				objectMD.getOwnerID());</span>

<span class="fc" id="L1462">		return result;</span>
	}

	/**
	 * This method returns the metadata of an object.
	 * 
	 * @param objectID
	 *            the ID of the object to be retrieved
	 * @return the metadata of the specified object
	 * @throws ObjectNotRegisteredException
	 *             if the object is not registered
	 */
	private ObjectMetaData getObjectBasicMetaData(final ObjectID objectID) {
<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1476">			logger.debug(&quot;Retrieval of ObjectBasicMetaData for {}&quot;, objectID);</span>
		}

<span class="fc" id="L1479">		ObjectMetaData objectMD = objectMDCache.get(objectID);</span>
<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">		if (objectMD == null) {</span>
			// Query by example
<span class="fc" id="L1482">			objectMD = metadataDB.getByID(objectID);</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">			if (objectMD != null) {</span>
				// Update cache if necessary
<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1486">					logger.debug(&quot;[==Get metadata==] Adding version to cache of metadatas: {} -&gt; {}&quot;, objectID, objectMD);</span>
				}
<span class="fc" id="L1488">				objectMDCache.put(objectID, objectMD);</span>
<span class="fc" id="L1489">				final String alias = objectMD.getAlias();</span>
<span class="fc" id="L1490">				objectMDCacheByAlias.put(alias, objectMD);</span>
<span class="fc" id="L1491">			} else {</span>
<span class="fc" id="L1492">				return null; // do not send exception to avoid serializing it, critical path.</span>
			}

		} else { 
<span class="nc bnc" id="L1496" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1497">				logger.debug(&quot;Found metadata {} in cache for {}&quot;, objectMD, objectID);</span>
			}
		}

		/*
		 * } else { // Check cache objectMD = objectMDCache.get(objectID); if (objectMD == null) { // Query by example objectMD
		 * = metadataDB.getByID(objectID); if (objectMD != null) { // Update cache if necessary objectMDCache.put(objectID,
		 * objectMD); for (final String alias : objectMD.getAliases()) { objectMDCacheByAlias.put( new
		 * Tuple&lt;&gt;(objectMD.getMetaClassID(), alias), objectMD); } } else { throw new ObjectNotRegisteredException(objectID); }
		 * } }
		 */
<span class="fc" id="L1508">		return objectMD;</span>
	}

	/**
	 * Return the storage location specification identified by the provided ID
	 * 
	 * @param stLocID
	 *            ID of the storage location
	 * @return the storage location info
	 * @throws StorageLocationNotExistException:
	 *             if the storage location does not exist
	 */
	private StorageLocation getStorageLocation(final StorageLocationID stLocID) {

		// Check it from Cache
<span class="nc" id="L1523">		StorageLocation storageLocation = currentStorageLocations.get(stLocID);</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">		if (storageLocation == null) {</span>
<span class="nc" id="L1525">			storageLocation = metadataDB.getByID(stLocID);</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">			if (storageLocation == null) {</span>
<span class="nc" id="L1527">				throw new StorageLocationNotExistException(stLocID);</span>
			}
		}

		// Update cache
<span class="nc" id="L1532">		currentStorageLocations.put(stLocID, storageLocation);</span>

<span class="nc" id="L1534">		return storageLocation;</span>
	}

	/**
	 * Return the execution environment specification identified by the provided ID
	 * 
	 * @param execEnvID
	 *            ID of the execution environment
	 * @return the execution environment info
	 * @throws ExecutionEnvironmentNotExistException
	 *             if the execution environment does not exist
	 */
	private ExecutionEnvironment getExecutionEnvironment(final ExecutionEnvironmentID execEnvID) {
		// Check it from Cache
<span class="fc" id="L1548">		ExecutionEnvironment execEnv = currentExecutionEnvironments.get(execEnvID);</span>
<span class="fc bfc" id="L1549" title="All 2 branches covered.">		if (execEnv == null) {</span>
<span class="fc" id="L1550">			execEnv = metadataDB.getByID(execEnvID);</span>
<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">			if (execEnv == null) {</span>
<span class="nc" id="L1552">				throw new ExecutionEnvironmentNotExistException(execEnvID);</span>
			}
		}

		// Update cache
<span class="fc" id="L1557">		currentExecutionEnvironments.put(execEnvID, execEnv);</span>
<span class="pc bpc" id="L1558" title="1 of 2 branches missed.">		if (execEnv.getLang() == Langs.LANG_JAVA) {</span>
<span class="fc" id="L1559">			currentJavaExecutionEnvironments.put(execEnv.getAddress(), execEnvID);</span>
<span class="nc bnc" id="L1560" title="All 2 branches missed.">		} else if (execEnv.getLang() == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L1561">			currentPythonExecutionEnvironments.put(execEnv.getAddress(), execEnvID);</span>
		}

<span class="fc" id="L1564">		return execEnv;</span>
	}

	/**
	 * Migrate an object with ID and MetaData provided from the source backend specified to the destination backend specified.
	 * 
	 * @param objectID
	 *            ID of the object.
	 * @param objectMD
	 *            Object meta data.
	 * @param srcBackendID
	 *            ID of the source backend.
	 * @param destBackendID
	 *            ID of the destination backend.
	 * @throws ObjectNotRegisteredException
	 *             if object does not exist
	 */
	private void migrateObjectToBackend(final ObjectID objectID, final ObjectMetaData objectMD,
			final ExecutionEnvironmentID srcBackendID, final ExecutionEnvironmentID destBackendID)
					throws ObjectNotRegisteredException {

<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1586">			logger.debug(</span>
					&quot;[==MOVE==] Migrating metadata of &quot; + objectID + &quot; from &quot; + srcBackendID + &quot; to &quot; + destBackendID);
		}

		// Copy metadata
<span class="fc" id="L1591">		final Set&lt;ExecutionEnvironmentID&gt; newBackendIDs = new HashSet&lt;&gt;(objectMD.getExecutionEnvironmentIDs());</span>
<span class="fc" id="L1592">		newBackendIDs.remove(srcBackendID);</span>
<span class="fc" id="L1593">		newBackendIDs.add(destBackendID);</span>

		// Update db
		try {
<span class="fc" id="L1597">			metadataDB.updateLocationIDsByID(objectID, newBackendIDs);</span>
<span class="nc" id="L1598">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L1599">			throw new ObjectNotRegisteredException(objectID);</span>
<span class="fc" id="L1600">		}</span>

		// Update real metadata
<span class="fc" id="L1603">		objectMD.getExecutionEnvironmentIDs().add(destBackendID);</span>
<span class="fc" id="L1604">		objectMD.getExecutionEnvironmentIDs().remove(srcBackendID);</span>

		// Update cache
<span class="fc" id="L1607">		final ObjectID theobjectID = objectID;</span>
<span class="pc bpc" id="L1608" title="1 of 2 branches missed.">		if (objectMDCache.containsKey(theobjectID)) {</span>
<span class="fc" id="L1609">			objectMDCache.get(theobjectID).getExecutionEnvironmentIDs().remove(srcBackendID);</span>
<span class="fc" id="L1610">			objectMDCache.get(theobjectID).getExecutionEnvironmentIDs().add(destBackendID);</span>
<span class="fc" id="L1611">			String alias = objectMD.getAlias();</span>
<span class="fc" id="L1612">			objectMDCacheByAlias.put(alias, objectMDCache.get(theobjectID));</span>
		}
<span class="fc" id="L1614">	}</span>

	// ====== Getters for testing purposes ====== //

	/**
	 * Get the MetaDataService::backendCache
	 * 
	 * @return the Backend Cache
	 */
	public Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getBackendCache() {
<span class="fc" id="L1624">		return this.currentExecutionEnvironments;</span>
	}

	/**
	 * Get the MetaDataService::objectMDCache
	 * 
	 * @return the Object MetaData Cache
	 */
	public LruCache&lt;ObjectID, ObjectMetaData&gt; getObjectCache() {
<span class="nc" id="L1633">		return this.objectMDCache;</span>
	}

	// ====== OTHER ======= //

	/**
	 * Method used for unit testing.
	 * 
	 * @return The db handler reference of this manager.
	 */
	public MetaDataServiceDB getDbHandler() {
<span class="fc" id="L1644">		return this.metadataDB;</span>
	}

	/**
	 * Close DbHandler
	 */
	public void closeDbHandler() {
<span class="nc" id="L1651">		this.metadataDB.close();</span>
<span class="nc" id="L1652">	}</span>

	@Override
	public void cleanCaches() {
<span class="nc" id="L1656">		objectMDCache.clear();</span>
<span class="nc" id="L1657">		objectMDCacheByAlias.clear();</span>
<span class="nc" id="L1658">		currentStorageLocations.clear();</span>
<span class="nc" id="L1659">		currentExecutionEnvironments.clear();</span>
<span class="nc" id="L1660">		currentJavaExecutionEnvironments.clear();</span>
<span class="nc" id="L1661">		currentPythonExecutionEnvironments.clear();</span>
<span class="nc" id="L1662">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>