<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ContractManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.logic.contractmgr</a> &gt; <span class="el_source">ContractManager.java</span></div><h1>ContractManager.java</h1><pre class="source lang-java linenums">
package es.bsc.dataclay.logic.contractmgr;

import java.text.ParseException;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import es.bsc.dataclay.util.structs.MemoryCache;
import org.apache.commons.dbcp2.BasicDataSource;

import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.contractmgr.AccountAlreadyRegisteredInContract;
import es.bsc.dataclay.exceptions.logicmodule.contractmgr.AccountNotRegisteredInContract;
import es.bsc.dataclay.exceptions.logicmodule.contractmgr.ContractNotActiveException;
import es.bsc.dataclay.exceptions.logicmodule.contractmgr.ContractNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.contractmgr.ContractNotPublicException;
import es.bsc.dataclay.exceptions.logicmodule.contractmgr.InterfaceNotInContractException;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.ContractID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.InterfaceID;
import es.bsc.dataclay.util.ids.NamespaceID;
import es.bsc.dataclay.util.management.AbstractManager;
import es.bsc.dataclay.util.management.contractmgr.Contract;
import es.bsc.dataclay.util.management.contractmgr.InterfaceInContract;
import es.bsc.dataclay.util.management.contractmgr.OpImplementations;
import es.bsc.dataclay.util.structs.Tuple;
import es.bsc.dataclay.dbhandler.sql.sqlite.SQLiteDataSource;

/**
 * This class is responsible to manage contracts: add, remove and modify.
 * 
 */
public final class ContractManager extends AbstractManager {

	/** Db of Contracts. */
	private final ContractManagerDB contractDB;

	/** Contract cache. */
	private final MemoryCache&lt;ContractID, Contract&gt; contractCache;

	/** Contract cache by account. */
	private final MemoryCache&lt;AccountID, LinkedList&lt;Contract&gt;&gt; contractsOfAccountCache;

	/**
	 * Instantiates an Contract Manager that uses the Backend configuration provided.
	 * @post Creates an Contract manager and hash initializes the backend.
	 */
	public ContractManager(final SQLiteDataSource dataSource) {
<span class="fc" id="L58">		super(dataSource);</span>

<span class="fc" id="L60">		this.contractDB = new ContractManagerDB(dataSource);</span>
<span class="fc" id="L61">		this.contractDB.createTables();</span>

		// Init cache
		// this.lastContract = null;
<span class="fc" id="L65">		this.contractCache = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L66">		this.contractsOfAccountCache = new MemoryCache&lt;&gt;();</span>

<span class="fc" id="L68">	}</span>

	/**
	 * Method that creates a new private contract with the provided account. The contract contains a set of Interfaces with
	 *        its accessible methods, operations and properties. The Interfaces must refer to Metaclasses of the same Namespace,
	 *        which is also provided in the method.
	 * @param newContract
	 *            Information of the contract to create
	 * @return the id of the contract
	 * @throws ParseException
	 *             parse exception.
	 */
	public ContractID newPrivateContract(final Contract newContract) throws ParseException {

		// Register it into the database
<span class="fc" id="L83">		contractDB.store(newContract);</span>

		// Update cache
<span class="fc" id="L86">		final ContractID contractID = newContract.getDataClayID();</span>
<span class="fc" id="L87">		this.contractCache.put(contractID, newContract);</span>

<span class="fc bfc" id="L89" title="All 2 branches covered.">		for (final AccountID accountIDofTheApplicant : newContract.getApplicantsAccountsIDs()) {</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">			if (!this.contractsOfAccountCache.containsKey(accountIDofTheApplicant)) {</span>
<span class="fc" id="L91">				this.contractsOfAccountCache.put(accountIDofTheApplicant, new LinkedList&lt;Contract&gt;());</span>
			}
<span class="fc" id="L93">			this.contractsOfAccountCache.get(accountIDofTheApplicant).add(newContract);</span>
<span class="fc" id="L94">		}</span>
		// this.lastContract = newContract;

<span class="fc" id="L97">		return contractID;</span>
	}

	/**
	 * Method that creates a new public contract. The contract contains a set of Interfaces with its accessible methods,
	 *        operations and properties. The Interfaces must refer to Metaclasses of the same Namespace, which is also provided in
	 *        the method.
	 * @param newContract
	 *            Information of the contract to create
	 * @return the id of the contract
	 * @throws ParseException
	 *             parse exception.
	 */
	public ContractID newPublicContract(final Contract newContract) throws ParseException {

		// Register it into the database
<span class="fc" id="L113">		contractDB.store(newContract);</span>

		// Update cache
<span class="fc" id="L116">		final ContractID result = newContract.getDataClayID();</span>
<span class="fc" id="L117">		this.contractCache.put(result, newContract);</span>
		// this.lastContract = newContract;

<span class="fc" id="L120">		return result;</span>
	}

	/**
	 * Method that allows an account to register to a public contract.
	 * @param applicantAccountID
	 *            the id of the applicant account
	 * @param contractID
	 *            the id of the contract
	 * @throws Exception
	 *             if some exception occurs: &lt;br&gt;
	 *             ContractNotExistException: if the contract does not exist &lt;br&gt;
	 *             ContractNotPublicException: if the contract is not public &lt;br&gt;
	 *             ContractNotActiveException: if the contract has expired &lt;br&gt;
	 *             AccountAlreadyRegisteredInContract if the account is already registered to the contract
	 */
	public void registerToPublicContract(final AccountID applicantAccountID, final ContractID contractID) {
		// look for the contract in cache
<span class="fc" id="L138">		Contract contract = contractCache.get(contractID);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">		if (contract == null) {</span>
			// query the contract
<span class="fc" id="L141">			contract = contractDB.getContractByID(contractID);</span>
		}
		// check contract exists
<span class="fc bfc" id="L144" title="All 2 branches covered.">		if (contract == null) {</span>
<span class="fc" id="L145">			throw new ContractNotExistException(contractID);</span>
		} else {
			// check it is public
<span class="fc bfc" id="L148" title="All 2 branches covered.">			if (!contract.isPublicAvailable()) {</span>
<span class="fc" id="L149">				throw new ContractNotPublicException(contractID);</span>
			} else {
				// check it is active
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">				if (!contract.isActive()) {</span>
<span class="nc" id="L153">					throw new ContractNotActiveException(contractID);</span>
				} else {
					// get its applicants
<span class="fc" id="L156">					final Set&lt;AccountID&gt; applicantsAccountsIDs = contract.getApplicantsAccountsIDs();</span>

					// check applicant is not already registered
<span class="fc bfc" id="L159" title="All 2 branches covered.">					if (!applicantsAccountsIDs.add(applicantAccountID)) {</span>
<span class="fc" id="L160">						throw new AccountAlreadyRegisteredInContract(applicantAccountID, contractID);</span>
					} else {
						// update the modified part of the contract
<span class="fc" id="L163">						contract.setApplicantsAccountsIDs(applicantsAccountsIDs);</span>
						try {
<span class="fc" id="L165">							contractDB.updateContractsAddApplicant(contractID, applicantAccountID);</span>

							// Update cache
<span class="fc" id="L168">							final ContractID aux = contractID;</span>
<span class="fc" id="L169">							this.contractCache.put(aux, contract);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">							for (final AccountID accountID : contract.getApplicantsAccountsIDs()) {</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">								if (!contractsOfAccountCache.containsKey(accountID)) {</span>
<span class="fc" id="L172">									contractsOfAccountCache.put(accountID, new LinkedList&lt;Contract&gt;());</span>
								}
<span class="fc" id="L174">								contractsOfAccountCache.get(accountID).add(contract);</span>
<span class="fc" id="L175">							}</span>
							// this.lastContract = contract;

<span class="nc" id="L178">						} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L179">							throw new ContractNotExistException(contractID);</span>

<span class="fc" id="L181">						}</span>
					}
				}
			}
		}
<span class="fc" id="L186">	}</span>

	// ============= OPERATIONS FOR CHECKING ================= //

	/**
	 * This method checks whether the given contracts are active
	 * @param modelContracts
	 *            Contracts to be checked
	 * @throws Exception
	 *             if some exception occurs: &lt;br&gt;
	 *             ContractNotExistException: if some contract does not exist. &lt;br&gt;
	 *             ContractNotActiveException: if some contract is not active.
	 */
	public void checkActiveContracts(final HashSet&lt;ContractID&gt; modelContracts) {
<span class="nc bnc" id="L200" title="All 2 branches missed.">		for (final ContractID contractID : modelContracts) {</span>
			// look for the contract in cache
<span class="nc" id="L202">			Contract contract = contractCache.get(contractID);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">			if (contract == null) {</span>
				// query the contract
<span class="nc" id="L205">				contract = contractDB.getContractByID(contractID);</span>
			}
			// check contract exists
<span class="nc bnc" id="L208" title="All 2 branches missed.">			if (contract == null) {</span>
<span class="nc" id="L209">				throw new ContractNotExistException(contractID);</span>
			} else {
				// check it is active
<span class="nc bnc" id="L212" title="All 2 branches missed.">				if (!contract.isActive()) {</span>
<span class="nc" id="L213">					throw new ContractNotActiveException(contractID);</span>
				}
			}
<span class="nc" id="L216">		}</span>
<span class="nc" id="L217">	}</span>

	/**
	 * This method checks if there is no contract associated with the provided namespace
	 * @param namespaceID
	 *            the namespace to be checked
	 * @return true if there is no contract related with the namespace, false otherwise
	 * @throws Exception
	 *             if some exception occurs
	 */
	public boolean checkNamespaceHasNoContracts(final NamespaceID namespaceID) {
		// query the contract by using a prototype
<span class="fc" id="L229">		final List&lt;Contract&gt; contractsInNamespace = contractDB.getContractsOfNamespace(namespaceID);</span>
<span class="fc" id="L230">		return contractsInNamespace.isEmpty();</span>
	}

	/**
	 * This method checks that the provided interfaceID is not accessible from any contract.
	 * @param interfaceID
	 *            the id of the interface
	 * @return true if there is no contract related with the interface, false otherwise
	 * @throws Exception
	 *             if some exception occurs
	 */
	public boolean checkInterfaceHasNoContracts(final InterfaceID interfaceID) {

		// Query contracts that access the provided interface
<span class="fc" id="L244">		final List&lt;Contract&gt; contracts = contractDB.getContractsContainingInterface(interfaceID);</span>

		// Update cache
<span class="fc bfc" id="L247" title="All 2 branches covered.">		for (final Contract contract : contracts) {</span>
<span class="fc" id="L248">			final ContractID contractID = contract.getDataClayID();</span>
<span class="fc" id="L249">			this.contractCache.put(contractID, contract);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">			for (final AccountID accountID : contract.getApplicantsAccountsIDs()) {</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">				if (!contractsOfAccountCache.containsKey(accountID)) {</span>
<span class="fc" id="L252">					contractsOfAccountCache.put(accountID, new LinkedList&lt;Contract&gt;());</span>
				}
<span class="fc" id="L254">				contractsOfAccountCache.get(accountID).add(contract);</span>
<span class="fc" id="L255">			}</span>
<span class="fc" id="L256">		}</span>

<span class="fc" id="L258">		return contracts.isEmpty();</span>
	}

	/**
	 * This method checks if the provided implementation is accessible from any contract.
	 * @param implementationID
	 *            the id of the implementation
	 * @return true if there is no contract related with the implementation, false otherwise
	 * @throws Exception
	 *             if some exception occurs
	 */
	public boolean checkImplementationHasNoContracts(final ImplementationID implementationID) {
		// Init the prototype for implementationID as local implementation
<span class="fc" id="L271">		final OpImplementations opImpls = new OpImplementations();</span>
<span class="fc" id="L272">		opImpls.setLocalImplementationID(implementationID);</span>

		// Query the interfacesInContract that has some operation with the implementationID as local implementation
<span class="fc" id="L275">		final List&lt;OpImplementations&gt; opImplementations = contractDB.getOpImplementationsWithImpl(implementationID);</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">		if (!opImplementations.isEmpty()) {</span>
<span class="fc" id="L277">			return false;</span>
		}

<span class="fc" id="L280">		return true;</span>
	}

	/**
	 * This method checks if the provided implementation is accessible from any contract of the user provided.
	 * @param implementationID
	 *            the id of the implementation
	 * @param accountID
	 *            ID of account to check.
	 * @return true if there is a contract related with the implementation an user, false otherwise
	 * @throws Exception
	 *             if some exception occurs
	 */
	public boolean checkImplementationHasContractForAccount(
			final ImplementationID implementationID, final AccountID accountID) {

<span class="nc" id="L296">		final Map&lt;ContractID, Contract&gt; contracts = this.getInfoOfAllActiveContractsForAccount(accountID);</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">		for (final Contract contract : contracts.values()) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">			for (final InterfaceInContract ifaceInCon : contract.getInterfacesInContract().values()) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">				for (final OpImplementations opImpl : ifaceInCon.getAccessibleImplementations().values()) {</span>

<span class="nc bnc" id="L302" title="All 2 branches missed.">					if (opImpl.getLocalImplementationID().equals(implementationID)) {</span>
<span class="nc" id="L303">						return true;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">					} else if (opImpl.getRemoteImplementationID().equals(implementationID)) {</span>
<span class="nc" id="L305">						return true;</span>
					}
<span class="nc" id="L307">				}</span>
<span class="nc" id="L308">			}</span>
<span class="nc" id="L309">		}</span>

<span class="nc" id="L311">		return true;</span>
	}

	/**
	 * This method checks whether the provided account is registered in the contracts provided and such contracts are still
	 *        active and contain a specific interface.
	 * @param accountID
	 *            the account ID
	 * @param interfacesInContracts
	 *            the interface to be checked for each contract
	 * @return true if the provided account is registered in all the contracts provided, they are active, and every contract
	 *         contains the corresponding interface provided
	 * @throws Exception
	 *             if some exception occurs: &lt;br&gt;
	 *             ContractNotExistException: if the contract does not exist
	 */
	public boolean checkInterfacesInActiveContractsForAccount(final AccountID accountID,
			final Map&lt;ContractID, InterfaceID&gt; interfacesInContracts) {

<span class="fc bfc" id="L330" title="All 2 branches covered.">		for (final Entry&lt;ContractID, InterfaceID&gt; curEntry : interfacesInContracts.entrySet()) {</span>
<span class="fc" id="L331">			final ContractID contractID = curEntry.getKey();</span>
<span class="fc" id="L332">			final Contract contract = getContractAndUpdateCacheIfNecessary(contractID);</span>

<span class="fc" id="L334">			final InterfaceID ifaceID = curEntry.getValue();</span>
			// check the account id is associated with the contract
			// &amp;&amp; the contract is active &amp;&amp; it contains the corresponding interface
<span class="pc bpc" id="L337" title="1 of 4 branches missed.">			if (!(contract.getApplicantsAccountsIDs().contains(accountID) &amp;&amp; contract.isActive() &amp;&amp; contract</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">					.getInterfacesInContract().containsKey(ifaceID))) {</span>
<span class="fc" id="L339">				return false;</span>
			}

<span class="fc" id="L342">		}</span>
<span class="fc" id="L343">		return true;</span>
	}

	/**
	 * This method checks whether the provided account is registered in the contracts provided and such contracts are still
	 *        active and contain a specific interface. Finally returns the info of the contracts.
	 * @param accountID
	 *            ID of the account
	 * @param interfacesInContract
	 *            the interface to be checked for each contract
	 * @return info of the contracts
	 * @throws Exception
	 *             if some exception occurs
	 */
	public Map&lt;ContractID, Contract&gt; checkInterfacesInActiveContractsForAccountAndReturnContractsInfo(
			final AccountID accountID, final Map&lt;ContractID, InterfaceID&gt; interfacesInContract) {

<span class="nc" id="L360">		final HashMap&lt;ContractID, Contract&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">		for (final Entry&lt;ContractID, InterfaceID&gt; curEntry : interfacesInContract.entrySet()) {</span>
<span class="nc" id="L362">			final ContractID contractID = curEntry.getKey();</span>
<span class="nc" id="L363">			final Contract contract = getContractAndUpdateCacheIfNecessary(contractID);</span>

<span class="nc" id="L365">			final InterfaceID interfaceID = curEntry.getValue();</span>

			// check the account id is associated with the contract
<span class="nc bnc" id="L368" title="All 2 branches missed.">			if (!contract.getApplicantsAccountsIDs().contains(accountID)) {</span>
<span class="nc" id="L369">				throw new AccountNotRegisteredInContract(accountID, contractID);</span>
			}
			// check the contract is active
<span class="nc bnc" id="L372" title="All 2 branches missed.">			if (!contract.isActive()) {</span>
<span class="nc" id="L373">				throw new ContractNotActiveException(contractID);</span>
			}
			// check it contains the corresponding interface
<span class="nc bnc" id="L376" title="All 2 branches missed.">			if (!contract.getInterfacesInContract().containsKey(interfaceID)) {</span>
<span class="nc" id="L377">				throw new InterfaceNotInContractException(interfaceID, contractID);</span>
			}

			// Update result
<span class="nc" id="L381">			result.put(contractID, contract);</span>
<span class="nc" id="L382">		}</span>
<span class="nc" id="L383">		return result;</span>
	}

	// =============== OPS FOR RETRIEVING INFO ============== //

	/**
	 * This method returns the info of a contract
	 * @param contractID
	 *            ID of the contract
	 * @return info of the contract
	 * @throws Exception
	 *             if some exception occurs: &lt;br&gt;
	 *             ContractNotExistException: if the contract does not exist
	 */
	public Contract getContractInfo(final ContractID contractID) {
<span class="fc" id="L398">		final Contract contract = getContractAndUpdateCacheIfNecessary(contractID);</span>
<span class="fc" id="L399">		return contract;</span>
	}

	/**
	 * This method returns the info of the contracts if they are still active and the given account is registered on them.
	 * @param contractsIDs
	 *            IDs of the contracts
	 * @param accountID
	 *            ID of the account that must be registered in the contract
	 * @return the information about the contracts
	 * @throws Exception
	 *             if some exception occurs: &lt;br&gt;
	 *             ContractNotExistException: if the contract does not exist &lt;br&gt;
	 *             AccountNotRegisteredInContract: if the account is not registered in the contract &lt;br&gt;
	 *             ContractNotActiveException: if the contract is not active
	 */
	public LinkedHashMap&lt;ContractID, Contract&gt; getInfoOfSomeActiveContractsForAccount(
			final List&lt;ContractID&gt; contractsIDs, final AccountID accountID) {

<span class="fc" id="L418">		final LinkedHashMap&lt;ContractID, Contract&gt; result = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">		for (final ContractID contractID : contractsIDs) {</span>
<span class="fc" id="L420">			final Contract contract = getContractAndUpdateCacheIfNecessary(contractID);</span>

<span class="fc bfc" id="L422" title="All 2 branches covered.">			if (!contract.getApplicantsAccountsIDs().contains(accountID)) {</span>
<span class="fc" id="L423">				throw new AccountNotRegisteredInContract(accountID, contractID);</span>
			}
<span class="fc bfc" id="L425" title="All 2 branches covered.">			if (!contract.isActive()) {</span>
<span class="fc" id="L426">				throw new ContractNotActiveException(contractID);</span>
			}
<span class="fc" id="L428">			result.put(contractID, contract);</span>
<span class="fc" id="L429">		}</span>
<span class="fc" id="L430">		return result;</span>
	}

	/**
	 * This method returns the info of all the active contracts which account is applicant of.
	 * @param accountID
	 *            ID of the account that must be registered in the contract
	 * @return the information about the contracts
	 * @throws Exception
	 *             if some exception occurs
	 */
	public Map&lt;ContractID, Contract&gt; getInfoOfAllActiveContractsForAccount(final AccountID accountID) {
		// Check contracts in cache
		final List&lt;Contract&gt; contracts;
<span class="nc bnc" id="L444" title="All 2 branches missed.">		if (contractsOfAccountCache.containsKey(accountID)) {</span>
<span class="nc" id="L445">			contracts = contractsOfAccountCache.get(accountID);</span>
		} else {
<span class="nc" id="L447">			contracts = contractDB.getContractsWithApplicant(accountID);</span>
<span class="nc" id="L448">			contractsOfAccountCache.put(accountID, new LinkedList&lt;&gt;(contracts));</span>
		}

		// Update result
<span class="nc" id="L452">		final HashMap&lt;ContractID, Contract&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">		for (final Contract contract : contracts) {</span>
<span class="nc" id="L454">			final ContractID contractID = contract.getDataClayID();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">			if (contract.isActive()) {</span>
<span class="nc" id="L456">				result.put(contractID, contract);</span>
			}
<span class="nc" id="L458">		}</span>
<span class="nc" id="L459">		return result;</span>
	}

	/**
	 * Get info of all contracts of the namespace provided indexed by their id.
	 * @param namespaceIDofProvider
	 *            the namespace of the contract
	 * @return The info of the contracts of the account provided in the namespace provided
	 * @throws Exception
	 *             if some exception occurs
	 */
	public Map&lt;ContractID, Contract&gt; getContractIDsOfProvider(final NamespaceID namespaceIDofProvider) {
<span class="fc" id="L471">		final List&lt;Contract&gt; contracts = contractDB.getContractsOfNamespace(namespaceIDofProvider);</span>
<span class="fc" id="L472">		final Map&lt;ContractID, Contract&gt; finalContracts = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">		for (final Contract contract : contracts) {</span>
<span class="fc" id="L474">			finalContracts.put(contract.getDataClayID(), contract);</span>
<span class="fc" id="L475">		}</span>

<span class="fc" id="L477">		return finalContracts;</span>
	}

	/**
	 * Get info of all contracts of the namespace provided indexed by their id.
	 * @param namespaceIDofProvider
	 *            the namespace of the contract
	 * @return The info of the contracts of the account provided in the namespace provided
	 * @throws Exception
	 *             if some exception occurs
	 */
	public Map&lt;ContractID, Contract&gt; getPublicContractIDsOfProvider(final NamespaceID namespaceIDofProvider) {
<span class="nc" id="L489">		final List&lt;Contract&gt; contracts = contractDB.getContractsOfNamespace(namespaceIDofProvider);</span>
<span class="nc" id="L490">		final Map&lt;ContractID, Contract&gt; finalContracts = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">		for (final Contract contract : contracts) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">			if (contract.isPublicAvailable()) {</span>
<span class="nc" id="L493">				finalContracts.put(contract.getDataClayID(), contract);</span>
			}
<span class="nc" id="L495">		}</span>
<span class="nc" id="L496">		return finalContracts;</span>
	}

	/**
	 * Get all contract IDs of the user provided (as applicant)
	 * @param applicantAccountID
	 *            the applicant user
	 * @return The info of the contracts of the user (as applicant)
	 * @throws Exception
	 *             if some exception occurs
	 */
	public Map&lt;ContractID, Contract&gt; getContractIDsOfApplicant(final AccountID applicantAccountID) {

		final List&lt;Contract&gt; contracts;
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">		if (contractsOfAccountCache.containsKey(applicantAccountID)) {</span>
<span class="nc" id="L511">			contracts = contractsOfAccountCache.get(applicantAccountID);</span>
		} else {
<span class="fc" id="L513">			contracts = contractDB.getContractsWithApplicant(applicantAccountID);</span>
		}

<span class="fc" id="L516">		final Map&lt;ContractID, Contract&gt; finalContracts = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">		for (final Contract contract : contracts) {</span>

<span class="fc" id="L519">			finalContracts.put(contract.getDataClayID(), contract);</span>
<span class="fc" id="L520">		}</span>

<span class="fc" id="L522">		return finalContracts;</span>
	}

	/**
	 * Get all contract IDs of the user provided (as provider)
	 * @param providerAccountID
	 *            the provider user
	 * @return The info of the contracts of the user (as provider)
	 * @throws Exception
	 *             if some exception occurs
	 */
	public Map&lt;ContractID, Contract&gt; getContractIDsOfProvider(final AccountID providerAccountID) {

<span class="nc" id="L535">		final List&lt;Contract&gt; contracts = contractDB.getContractsWithProvider(providerAccountID);</span>

<span class="nc" id="L537">		final Map&lt;ContractID, Contract&gt; finalContracts = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">		for (final Contract contract : contracts) {</span>
<span class="nc" id="L539">			finalContracts.put(contract.getDataClayID(), contract);</span>
<span class="nc" id="L540">		}</span>

<span class="nc" id="L542">		return finalContracts;</span>
	}

	/**
	 * Get all contract IDs of the user provided (as applicant) with a namespace provider.
	 * @param applicantAccountID
	 *            the applicant user.
	 * @param namespaceIDofProvider
	 *            the ID of the namespace provider.
	 * @return The info of the contracts of the user (as applicant) with the given namespace.
	 * @throws Exception
	 *             if some exception occurs
	 */
	public Map&lt;ContractID, Contract&gt; getContractIDsOfApplicantWithProvider(final AccountID applicantAccountID,
			final NamespaceID namespaceIDofProvider) {

<span class="fc" id="L558">		final List&lt;Contract&gt; contracts = contractDB.getContractsWithApplicantAndNamespace(applicantAccountID, namespaceIDofProvider);</span>
<span class="fc" id="L559">		final Map&lt;ContractID, Contract&gt; finalContracts = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">		for (final Contract contract : contracts) {</span>
<span class="fc" id="L561">			finalContracts.put(contract.getDataClayID(), contract);</span>
<span class="fc" id="L562">		}</span>

<span class="fc" id="L564">		return finalContracts;</span>
	}

	/**
	 * This method checks whether the provided account is registered in the contracts provided and such contracts are still
	 *        active and contain the given interfaces. Finally, returns the information of such interfaces per contract.
	 * @param accountID
	 *            the account ID
	 * @param interfacesInContracts
	 *            the multiple interfaces per contract to be retrieved
	 * @return all the info related with the given interfaces in contract (if contracts are active and account is actually
	 *         registered on them)
	 * @throws Exception
	 *             if some exception occurs: &lt;br&gt;
	 *             ContractNotExistException: if the contract does not exist &lt;br&gt;
	 *             AccountNotRegisteredInContract: if the account is not registred in some of the contracts &lt;br&gt;
	 *             ContractNotActiveException: if any of the contracts is not active &lt;br&gt;
	 *             InterfaceNotInContractException: if any of the interfaces is not in the corresponding contract
	 */
	public Map&lt;ContractID, InterfaceInContract&gt; getInfoOfSubsetOfInterfacesThatAreInActiveContractsForAccount(
			final AccountID accountID, final Map&lt;ContractID, InterfaceID&gt; interfacesInContracts) {

<span class="nc" id="L586">		final HashMap&lt;ContractID, InterfaceInContract&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L588" title="All 2 branches missed.">		for (final Entry&lt;ContractID, InterfaceID&gt; curEntry : interfacesInContracts.entrySet()) {</span>
<span class="nc" id="L589">			final ContractID contractID = curEntry.getKey();</span>
<span class="nc" id="L590">			final InterfaceID interfaceID = curEntry.getValue();</span>

<span class="nc" id="L592">			final Contract contract = getContractAndUpdateCacheIfNecessary(contractID);</span>

			// check the account id is associated with the contract
			// &amp;&amp; the contract is active &amp;&amp; it contains the corresponding interface
<span class="nc bnc" id="L596" title="All 4 branches missed.">			if (contract.getApplicantsAccountsIDs().contains(accountID) &amp;&amp; contract.isActive()</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">					&amp;&amp; contract.getInterfacesInContract().containsKey(interfaceID)) {</span>
<span class="nc" id="L598">				result.put(contractID, contract.getInterfacesInContract().get(interfaceID));</span>
			}
<span class="nc" id="L600">		}</span>
<span class="nc" id="L601">		return result;</span>
	}

	/**
	 * This method checks whether the provided account is registered in the contracts provided and such contracts are still
	 *        active. Finally, returns the information of the interfaces in contract.
	 * @param accountID
	 *            the account ID
	 * @param contracts
	 *            the multiple contracts to be checked
	 * @return all the info related with the given contracts (if contracts are active and account is actually registered to them)
	 * @throws Exception
	 *             if some exception occurs: &lt;br&gt;
	 *             ContractNotExistException: if the contract does not exist &lt;br&gt;
	 *             AccountNotRegisteredInContract: if the account is not registred in some of the contracts &lt;br&gt;
	 *             ContractNotActiveException: if any of the contracts is not active &lt;br&gt;
	 */
	public Map&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; //
			getInfoOfMultipleContractsPerActiveContractsForAccount(final AccountID accountID, final Set&lt;ContractID&gt; contracts) {
<span class="fc" id="L620">		final Map&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; result = //</span>
				new HashMap&lt;&gt;();

<span class="fc bfc" id="L623" title="All 2 branches covered.">		for (final ContractID contractID : contracts) {</span>
<span class="fc" id="L624">			final Contract contract = getContractAndUpdateCacheIfNecessary(contractID);</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">			if (!(contract.getApplicantsAccountsIDs().contains(accountID))) {</span>
<span class="nc" id="L626">				throw new AccountNotRegisteredInContract(accountID, contractID);</span>
			}
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">			if (!contract.isActive()) {</span>
<span class="nc" id="L629">				throw new ContractNotActiveException(contractID);</span>
			}

<span class="fc" id="L632">			result.put(contractID,</span>
<span class="fc" id="L633">					new Tuple&lt;&gt;(contract.getInterfacesInContract(),</span>
<span class="fc" id="L634">							contract.getEndDate()));</span>
<span class="fc" id="L635">		}</span>
<span class="fc" id="L636">		return result;</span>
	}

	/**
	 * This method returns the information of those interfaces in (still active) contract having the given account registered
	 *        on them. If the any of the conditions is not satisfied, no error is produced but the info of such interface in
	 *        contract is not returned.
	 * @param accountID
	 *            the account ID
	 * @param interfacesInContracts
	 *            the interfaces per contract to be retrieved
	 * @return from the given interfaces in contracts, the info of those that are in active contracts and account is registered
	 * @throws Exception
	 *             if some exception occurs.
	 */
	public Map&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; //
			getInfoOfMultipleInterfacesPerActiveContractsForAccount(final AccountID accountID,
					final Map&lt;ContractID, HashSet&lt;InterfaceID&gt;&gt; interfacesInContracts) {

<span class="fc" id="L655">		final Map&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; result = //</span>
				new HashMap&lt;&gt;();

<span class="fc bfc" id="L658" title="All 2 branches covered.">		for (final Entry&lt;ContractID, HashSet&lt;InterfaceID&gt;&gt; curEntry : interfacesInContracts.entrySet()) {</span>
<span class="fc" id="L659">			final ContractID contractID = curEntry.getKey();</span>
<span class="fc" id="L660">			final Contract contract = getContractAndUpdateCacheIfNecessary(contractID);</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">			if (!(contract.getApplicantsAccountsIDs().contains(accountID))) {</span>
<span class="nc" id="L662">				throw new AccountNotRegisteredInContract(accountID, contractID);</span>
			}
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">			if (!contract.isActive()) {</span>
<span class="nc" id="L665">				throw new ContractNotActiveException(contractID);</span>
			}

<span class="fc" id="L668">			final HashMap&lt;InterfaceID, InterfaceInContract&gt; infoOfInterfacesInContract = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">			for (final InterfaceID interfaceID : curEntry.getValue()) {</span>
				// check the account id is associated with the contract
				// &amp;&amp; the contract is active &amp;&amp; it contains the corresponding interface

<span class="fc bfc" id="L673" title="All 2 branches covered.">				if (!contract.getInterfacesInContract().containsKey(interfaceID)) {</span>
<span class="fc" id="L674">					throw new InterfaceNotInContractException(interfaceID, contractID);</span>
				}
<span class="fc" id="L676">				infoOfInterfacesInContract.put(interfaceID, contract.getInterfacesInContract().get(interfaceID));</span>
<span class="fc" id="L677">			}</span>
<span class="fc" id="L678">			result.put(contractID, new Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;(infoOfInterfacesInContract,</span>
<span class="fc" id="L679">					contract.getEndDate()));</span>
<span class="fc" id="L680">		}</span>
<span class="fc" id="L681">		return result;</span>
	}

	// ============= OTHER =========== //

	/**
	 * Retrieves a contract and updates cache if necessary
	 * @param contractID
	 *            ID of the contract to be retrieved
	 * @return The contract with the ID passed
	 */
	private Contract getContractAndUpdateCacheIfNecessary(final ContractID contractID) {
		// Try getting contract from cache
		/*
		 * if (lastContract != null &amp;&amp; lastContract.getID().getId().equals(contractID.getId())) { return lastContract; }
		 */

<span class="fc" id="L698">		boolean isCached = true;</span>
<span class="fc" id="L699">		Contract contract = contractCache.get(contractID);</span>

<span class="pc bpc" id="L701" title="1 of 2 branches missed.">		if (contract == null) {</span>
<span class="fc" id="L702">			isCached = false;</span>

			// query the contract by ID
<span class="fc" id="L705">			contract = contractDB.getContractByID(contractID);</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">			if (contract == null) {</span>
<span class="nc" id="L707">				throw new ContractNotExistException(contractID);</span>
			}
		}

		// Update cache if necessary
<span class="fc" id="L712">		final ContractID aux = contract.getDataClayID();</span>
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">		if (!isCached) {</span>
<span class="fc" id="L714">			this.contractCache.put(aux, contract);</span>
		}
<span class="fc bfc" id="L716" title="All 2 branches covered.">		for (final AccountID accountID : contract.getApplicantsAccountsIDs()) {</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">			if (!contractsOfAccountCache.containsKey(accountID)) {</span>
<span class="fc" id="L718">				contractsOfAccountCache.put(accountID, new LinkedList&lt;Contract&gt;());</span>
			}
<span class="fc" id="L720">			contractsOfAccountCache.get(accountID).add(contract);</span>
<span class="fc" id="L721">		}</span>
		// this.lastContract = contract;
<span class="fc" id="L723">		return contract;</span>
	}

	/**
	 * Method used for unit testing.
	 * @return The db handler reference of this manager.
	 */
	public ContractManagerDB getDbHandler() {
<span class="fc" id="L731">		return contractDB;</span>
	}

	@Override
	public void cleanCaches() {
<span class="nc" id="L736">		this.contractCache.clear();</span>
<span class="nc" id="L737">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>