<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataClayObject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay</a> &gt; <span class="el_source">DataClayObject.java</span></div><h1>DataClayObject.java</h1><pre class="source lang-java linenums">package es.bsc.dataclay;

import java.io.InputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;
import java.util.Spliterator;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.yaml.snakeyaml.Yaml;

import es.bsc.dataclay.api.BackendID;
import es.bsc.dataclay.api.DataClay;
import es.bsc.dataclay.commonruntime.ClientRuntime;
import es.bsc.dataclay.commonruntime.DataClayRuntime;
import es.bsc.dataclay.logic.classmgr.bytecode.java.constants.ByteCodeFieldNames;
import es.bsc.dataclay.serialization.DataClaySerializable;
import es.bsc.dataclay.serialization.buffer.DataClayByteBuffer;
import es.bsc.dataclay.serialization.java.DataClayJavaWrapper;
import es.bsc.dataclay.serialization.lib.DataClayDeserializationLib;
import es.bsc.dataclay.serialization.lib.DataClaySerializationLib;
import es.bsc.dataclay.serialization.lib.SerializedParametersOrReturn;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.DataClayObjectMetaData;
import es.bsc.dataclay.util.ReferenceCounting;
import es.bsc.dataclay.util.classloaders.DataClayClassLoader;
import es.bsc.dataclay.util.classloaders.DataClayClassLoaderSrv;
import es.bsc.dataclay.util.filtering.ASTParser;
import es.bsc.dataclay.util.filtering.Condition;
import es.bsc.dataclay.util.filtering.ConditionParser;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.management.stubs.StubInfo;
import es.bsc.dataclay.util.yaml.CommonYAML;
import storage.StorageObject;
import storage.StubItf;

/**
 * This class represents a Object in DataClay.
 */
public class DataClayObject extends StorageObject implements DataClaySerializable, Serializable, StubItf {
	/** Indicates if debug is enabled. */
<span class="fc" id="L65">	protected static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

	/** Logger. */
<span class="fc" id="L68">	public static final Logger logger = LogManager.getLogger(&quot;DataClayObject&quot;);</span>

	/** Serial version UID. */
	private static final long serialVersionUID = 1772790872967833442L;

	// CHECKSTYLE:OF
	/** Client runtime. */
<span class="fc" id="L75">	public static DataClayRuntime clientRuntime = new ClientRuntime();</span>

	/** ObjectID of the stub instance. */
	protected ObjectID objectID;

	/** Indicates if the object is registered or not. */
<span class="nc" id="L81">	protected AtomicBoolean isPersistent = new AtomicBoolean(false);</span>

	/** Indicates if the object was filled with data. */
<span class="nc" id="L84">	protected AtomicBoolean isLoaded = new AtomicBoolean(false);</span>

	/** HINT: Indicates object Execution Location. */
	private BackendID hint;

	/**
	 * ID of dataset of object. Used for user to specify which DataSet to use in store.
	 */
	protected DataSetID dataSetID;

	/** StubInfos cache. */
<span class="fc" id="L95">	private static Map&lt;String, StubInfo&gt; stubInfosCache = new ConcurrentHashMap&lt;&gt;();</span>

	/** Exec.StubInfos cache. */
<span class="fc" id="L98">	private static Map&lt;String, StubInfo&gt; execStubInfosCache = new ConcurrentHashMap&lt;&gt;();</span>

	/** Main storage location for the object **/
	private BackendID masterLocation;

	/** 'LOCAL' location */
	public static BackendID LOCAL;

	/** dataClay instance */
	private DataClayInstanceID externalDataClayID;

	/**
	 * RT PREFETCHING FIELDS
	 */

<span class="fc" id="L113">	private static transient boolean isPrefetchingAccess = false;</span>
	
<span class="fc" id="L115">	private static transient long accessCount = 0;</span>
	
<span class="fc" id="L117">	private static transient long hitCount = 0;</span>

	// CHECKSTYLE:ON

	/**
	 * Constructor
	 */
<span class="nc" id="L124">	public DataClayObject() {</span>
<span class="nc" id="L125">		this.init(new ObjectID());</span>
		// Initialize as volatile
<span class="nc" id="L127">		initializeObjectAsVolatile();</span>
<span class="nc" id="L128">	}</span>

	/**
	 * Constructor
	 * 
	 * @param theobjectID
	 *            ID of the object
	 */
<span class="nc" id="L136">	public DataClayObject(final ObjectID theobjectID) {</span>
<span class="nc" id="L137">		this.init(theobjectID);</span>
<span class="nc" id="L138">	}</span>

	/**
	 * Initialize object
	 * 
	 * @param theobjectID
	 *            ID of the object
	 */
	private void init(final ObjectID theobjectID) {
<span class="nc" id="L147">		final ObjectID oid = theobjectID;</span>
<span class="nc" id="L148">		this.setObjectIDUnsafe(oid);</span>
		// Add object to dataClay's heap
<span class="nc" id="L150">		getLib().addToHeap(this);</span>
<span class="nc" id="L151">	}</span>

	/**
	 * Initialize object with state 'persistent' with proper flags. See same function in DataClayExecutionObject for a different
	 * initialization. This design is intended to be clear with object state. Usually, since constructors are calling
	 * initializeObjectAsVolatile, this function 'overrides' flags set
	 */
	public void initializeObjectAsPersistent() {
<span class="nc" id="L159">		this.setIsPersistent(true);</span>
<span class="nc" id="L160">	}</span>

	/**
	 * Initialize object with state 'volatile' with proper flags. Usually, volatile state is created by a stub, app, exec
	 * class,.. See same function in DataClayExecutionObject for a different initialization. This design is intended to be clear
	 * with object state.
	 */
	public void initializeObjectAsVolatile() {
<span class="nc" id="L168">		this.setLoaded(true);</span>
<span class="nc" id="L169">	}</span>

	/**
	 * Set the DataClayObject::isLoaded
	 * 
	 * @param newisLoaded
	 *            the isLoaded to set
	 */
	public final void setLoaded(final boolean newisLoaded) {
<span class="nc" id="L178">		this.isLoaded.set(newisLoaded);</span>
<span class="nc" id="L179">	}</span>

	/**
	 * Generic static method to instantiate a DataClayObject by its alias
	 * 
	 * @param className
	 *            real class of the instance
	 * @param alias
	 *            alias of the instance
	 * @param safe
	 *            if true, checks that an object with the provided alias exists
	 * @return the reference to persistent object of given class with given alias
	 */
	protected static DataClayObject getByAlias(final MetaClassID classID, final String alias, boolean safe) {
<span class="nc" id="L193">		return getLib().getObjectByAlias(alias, classID, safe);</span>
	}

	
	/**
	 * This method can be used from registered methods to access objects by alias, this method
	 * is parameterized in order to provide to the users a way to implement and compile an application using 
	 * a model to be registered (extending DataClayObject).
	 * 
	 * @param alias
	 *            alias of object to be requested
	 * @param &lt;E&gt; type of the object requested
	 * @return The object identified by the provided alias
	 */
	public static &lt;E&gt; E getByAliasExt(final String alias) {
<span class="nc" id="L208">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * This method can be used from registered methods to access objects by alias, this method
	 * is parameterized in order to provide to the users a way to implement and compile an application using 
	 * a model to be registered (extending DataClayObject).
	 *
	 * @param alias
	 *            alias of object to be requested
	 * @param safe
	 *            if true, checks that an object with the provided alias exists
	 * @param &lt;E&gt; type of the object requested
	 * @return The object identified by the provided alias
	 */
	public static &lt;E&gt; E getByAliasExt(final String alias, boolean safe) {
<span class="nc" id="L224">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}
	
	/**
	 * Deletes an alias of an object of a specific class
	 * 
	 * @param className
	 *            class name of the object
	 * @param alias
	 *            alias of the object
	 */
	public static void deleteAlias(final String className, final String alias) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L237">			logger.debug(&quot;Deleting alias &quot; + alias + &quot; of object of class &quot; + className);</span>
		}
<span class="nc" id="L239">		getLib().deleteAlias(alias);</span>
<span class="nc" id="L240">	}</span>

	/**
	 * Method to be specialized
	 * 
	 * @param alias
	 *            alias to be removed from this object
	 */
	public static void deleteAlias(final String alias) {
<span class="nc" id="L249">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Set the object's id
	 *
	 * This method is labeled as unsafe as the user should be aware
	 * it is just possible to change ids of non-persistent objects.
	 *
	 * There no warranty that, once persisted, an object will keep
	 * the same id.
	 *
	 * @param newObjectID
	 *        The ObjectID to set
	 */
	public void setObjectIDUnsafe(final ObjectID newObjectID) {
<span class="nc" id="L265">		this.objectID = newObjectID;</span>
<span class="nc" id="L266">	}</span>

	/**
	 * Debug start of running method
	 * 
	 * @param opNameAndDesc
	 *            Operation name and descriptor
	 */
	public final void debugStart(final String opNameAndDesc) {
<span class="nc" id="L275">		logger.debug(&quot;[==Internal Exec==] Starting method &quot; + opNameAndDesc + &quot; for &quot; + objectID);</span>
<span class="nc" id="L276">	}</span>

	/**
	 * Debug end of running method
	 * 
	 * @param opNameAndDesc
	 *            Operation name and descriptor
	 */
	public final void debugEnd(final String opNameAndDesc) {
<span class="nc" id="L285">		logger.debug(&quot;[==Internal Exec==] Finished method &quot; + opNameAndDesc + &quot; for &quot; + objectID);</span>
<span class="nc" id="L286">	}</span>

	/**
	 * Set a new object ID (used for remove objects)
	 */
	public final void setNewObjectID() {
<span class="nc" id="L292">		this.objectID = new ObjectID();</span>
<span class="nc" id="L293">	}</span>

	/**
	 * Get DataService client library
	 * 
	 * @return DataService client library
	 */
	public static final DataClayRuntime getLib() {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">		if (Configuration.mockTesting) {</span>
<span class="nc" id="L302">			final DataClayRuntime mockLib = DataClayMockObject.getLib();</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">			if (mockLib == null) {</span>
				// WARNING: this is intended to support client threads apps simulation
				// since in a real environment clientLib static field is not overriden
				// by servers lib.
<span class="nc" id="L307">				return clientRuntime;</span>
			} else {
<span class="nc" id="L309">				return mockLib;</span>
			}
		} else {
<span class="fc" id="L312">			return clientRuntime;</span>
		}

	}

	/**
	 * Set runtime
	 * 
	 * @param theruntime
	 *            the runtime to set
	 */
	public static void setLib(final DataClayRuntime theruntime) {
<span class="nc" id="L324">		clientRuntime = theruntime;</span>
<span class="nc" id="L325">		LOCAL = clientRuntime.getLocalBackend();</span>
<span class="nc" id="L326">	}</span>

	/**
	 * Get the ObjectID of the instance
	 * 
	 * @return The ObjectID
	 */
	@Override
	public final ObjectID getObjectID() {
<span class="nc" id="L335">		return objectID;</span>
	}

	/**
	 * Indicates the object is persistent.
	 * 
	 * @return TRUE if it is persistent. FALSE otherwise.
	 */
	public final boolean isPersistent() {
<span class="nc" id="L344">		return this.isPersistent.get();</span>
	}

	/**
	 * Set the DataClayObject:newisPersistent
	 * 
	 * @param newisPersistent
	 *            the isPersistent to set
	 */
	public final void setIsPersistent(final boolean newisPersistent) {
<span class="nc" id="L354">		this.isPersistent.set(newisPersistent);</span>
<span class="nc" id="L355">	}</span>

	// CHECKSTYLE:OFF

	/**
	 * Get metaclass ID
	 * 
	 * @return Class ID
	 */
	@Override
	public MetaClassID getMetaClassID() {
<span class="nc" id="L366">		final StubInfo stubInfo = getStubInfo();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">		if (stubInfo == null) {</span>
<span class="nc" id="L368">			return null;</span>
		}
<span class="nc" id="L370">		return stubInfo.getClassID();</span>
	}

	/**
	 * Get metaclass ID of the specified class name
	 * 
	 * @param className
	 *            name of the class
	 * @return ID of the class
	 */
	public static MetaClassID getMetaClassID(final String className) {
<span class="nc" id="L381">		return getStubInfoFromClass(className).getClassID();</span>
	}

	/**
	 * Runs the method with ID provided and params specified
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param params
	 *            Parameters of the method
	 * @return Result of the method
	 */
	public Object run(final ImplementationID implID, final Object[] params) {
<span class="nc" id="L394">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Runs the method with ID provided and params specified on a specific backend
	 * 
	 * @param location
	 *            target backend of execution
	 * @param implID
	 *            ID of the method to invoke
	 * @param params
	 *            Parameters of the method
	 * @return Result of the method
	 */
	public Object setInBackend(final BackendID location, final String implID, final Object[] params) {
<span class="nc" id="L409">		return getLib().callExecuteToDS(this, params, new ImplementationID(implID), location, false);</span>
	}

	/**
	 * Runs the method with ID provided and params specified on external dataClays where object is federated
	 * This function is only intended for calls in federation - replicated fields. 
	 * NOTE: A real call to remote dataClay would require a new design of exceptions/volatiles between dataClays.
	 * @param dcID
	 *            External dataClay where to call this
	 * @param implID
	 *            implementation ID to be invoked on federated object
	 * @param params
	 *            Parameters of the method
	 */
	public void setInDataClayInstance(final DataClayInstanceID dcID, final ImplementationID implID, final Object[] params) {
<span class="nc" id="L424">		getLib().synchronizeFederated(this, params, implID, dcID, true);</span>
<span class="nc" id="L425">	}</span>

	/**
	 * Wraps fields for serialization
	 * 
	 * @param wrapFields
	 *            [out] Wrapped fields
	 */
	public void wrapFieldsSerialization(final List&lt;DataClaySerializable&gt; wrapFields) {
<span class="nc" id="L434">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Wraps fields for deserialization
	 * 
	 * @param wrapFields
	 *            [out] Wrapped fields
	 */
	public void wrapFieldsDeserialization(final List&lt;DataClaySerializable&gt; wrapFields) {
<span class="nc" id="L444">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Set fields
	 * 
	 * @param fieldsToSet
	 *            Fields to set, in order.
	 */
	public void setFieldsDeserialization(final Queue&lt;Object&gt; fieldsToSet) {
<span class="nc" id="L454">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Wraps parameters for serialization
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param params
	 *            Parameters of the method
	 * @return Wrapped parameters
	 */
	public List&lt;DataClaySerializable&gt; wrapParameters(final ImplementationID implID, final Object[] params) {
<span class="nc" id="L467">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Wraps return for serialization
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param ret
	 *            Return of the method
	 * @return Wrapped return
	 */
	public List&lt;DataClaySerializable&gt; wrapReturn(final ImplementationID implID, final Object ret) {
<span class="nc" id="L480">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Unwraps parameters for deserialization
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param wrapParams
	 *            Wrapped Parameters of the method
	 */
	public void setWrappersParams(final ImplementationID implID, final SerializedParametersOrReturn wrapParams) {
<span class="nc" id="L492">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Unwraps return for deserialization
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param wrapReturn
	 *            Wrapped return of the method
	 */
	public void setWrappersReturn(final ImplementationID implID, final SerializedParametersOrReturn wrapReturn) {
<span class="nc" id="L504">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * This method set all fields with values of fields of provided object.
	 * 
	 * @param otherObject
	 *            object with values of fields to set.
	 */
	public void setAll(final DataClayObject otherObject) {
<span class="nc" id="L514">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Retrieves a copy of this object
	 * 
	 * @return a non-persistent copy of this object
	 */
	public DataClayObject dcClone() {
<span class="nc" id="L523">		return DataClayObject.getLib().getCopyOfObject(this.objectID, false);</span>
	}

	/**
	 * Retrieves a copy of this object
	 * 
	 * @param recursive
	 *            whether to also copy its subobjects or not
	 * @return a non-persistent copy of this object
	 */
	public DataClayObject dcClone(final boolean recursive) {
<span class="nc" id="L534">		return DataClayObject.getLib().getCopyOfObject(this.objectID, recursive);</span>
	}

	/**
	 * Retrieves a copy of this object (but not the subobjects)
	 * 
	 * @param alias
	 *            alias of the object to be retrieved
	 * @return a non-persistent copy of this object
	 */
	public static DataClayObject dcCloneByAlias(final String alias) {
<span class="nc" id="L545">		final DataClayObject byAlias = DataClayObject.getLib().getObjectByAlias(alias);</span>
<span class="nc" id="L546">		return byAlias.dcClone();</span>
	}

	/**
	 * Retrieves a copy of this object
	 * 
	 * @param alias
	 *            alias of the object to be retrieved
	 * @param recursive
	 *            whether to also copy its subobjects or not
	 * @return a non-persistent copy of this object
	 */
	public static DataClayObject dcCloneByAlias(final String alias, final boolean recursive) {
<span class="nc" id="L559">		final DataClayObject byAlias = DataClayObject.getLib().getObjectByAlias(alias);</span>
<span class="nc" id="L560">		return byAlias.dcClone(recursive);</span>
	}

	/**
	 * Updates this object alias with the values in argument object
	 * 
	 * @param fromObject
	 *            object to be copied to this object
	 */
	public final void dcUpdate(final DataClayObject fromObject) {
<span class="nc bnc" id="L570" title="All 2 branches missed.">		if (fromObject == null) {</span>
<span class="nc" id="L571">			return;</span>
		}
<span class="nc" id="L573">		DataClayObject.getLib().updateObject(this.getObjectID(), fromObject);</span>
<span class="nc" id="L574">	}</span>

	/**
	 * Updates the object identified by the given alias with the values in argument object
	 *
	 * @param alias
	 *            alias of the object to be updated
	 * @param fromObject
	 *            object to be copied to this object
	 */
	public static final void dcUpdateByAlias(final String alias, final DataClayObject fromObject) {
<span class="nc" id="L585">		final DataClayObject byAlias = DataClayObject.getLib().getObjectByAlias(alias);</span>
<span class="nc" id="L586">		byAlias.dcUpdate(fromObject);</span>
<span class="nc" id="L587">	}</span>

	/**
	 * Equivalent to {@link #makePersistent(String) makePersistent}
	 * 
	 * @param alias
	 *            alias for the object
	 */
	public final void dcPut(final String alias) {
<span class="nc" id="L596">		this.makePersistent(alias);</span>
<span class="nc" id="L597">	}</span>

	/**
	 * Equivalent to {@link #makePersistent(String, BackendID) makePersistent}
	 * 
	 * @param alias
	 *            alias for the object
	 * @param optBackendID
	 *            optional backend where to persist this object
	 */
	public final void dcPut(final String alias, final BackendID optBackendID) {
<span class="nc" id="L608">		this.makePersistent(alias, optBackendID);</span>
<span class="nc" id="L609">	}</span>

	/**
	 * Equivalent to {@link #makePersistent(String, boolean) makePersistent}
	 * 
	 * @param alias
	 *            alias for the object
	 * @param recursive
	 *            whether subobjects are also persisted or not
	 */
	public final void dcPut(final String alias, final boolean recursive) {
<span class="nc" id="L620">		this.makePersistent(alias, recursive);</span>
<span class="nc" id="L621">	}</span>

	/**
	 * Equivalent to {@link #makePersistent(String, BackendID, boolean) makePersistent}
	 * 
	 * @param alias
	 *            alias for the object
	 * @param optBackendID
	 *            optional backend where to persist this object
	 * @param recursive
	 *            whether subobjects are also persisted or not
	 */
	public final void dcPut(final String alias, final BackendID optBackendID, final boolean recursive) {
<span class="nc" id="L634">		this.makePersistent(alias, optBackendID, recursive);</span>
<span class="nc" id="L635">	}</span>

	@Override
	public String getID() {
<span class="nc bnc" id="L639" title="All 2 branches missed.">		if (isPersistent.get()) {</span>
<span class="nc" id="L640">			return DataClay.ids2String(this.objectID, this.hint, this.getMetaClassID());</span>
		} else {
<span class="nc" id="L642">			return null;</span>
		}
	}

	@Override
	public final void makePersistent() {
<span class="nc" id="L648">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, null, true, null);</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L650">			masterLocation = backendID;</span>
		}
<span class="nc" id="L652">	}</span>

	@Override
	public final void makePersistent(final BackendID optBackendID) {
<span class="nc" id="L656">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, optBackendID, true, null);</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L658">			masterLocation = backendID;</span>
		}
<span class="nc" id="L660">	}</span>

	@Override
	public final void makePersistent(final String alias) {
<span class="nc bnc" id="L664" title="All 4 branches missed.">		if (alias != null &amp;&amp; alias.isEmpty()) {</span>
<span class="nc" id="L665">			throw new IllegalArgumentException(&quot;Alias cannot be empty&quot;);</span>
		}
<span class="nc" id="L667">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, null, true, alias);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L669">			masterLocation = backendID;</span>
		}
<span class="nc" id="L671">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param recursive
	 *            Indicates if all referenced objects from this objects that are not already persistent must also be stored. If
	 *            true, all referenced objects are also stored. If the object is already persistent i.e. contains a DataClay
	 *            objectID this function will fail.
	 */
	@Override
	public final void makePersistent(final boolean recursive) {
<span class="nc" id="L683">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, null, recursive, null);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L685">			masterLocation = backendID;</span>
		}
<span class="nc" id="L687">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param recursive
	 *            Indicates if all referenced objects from this objects that are not already persistent must also be stored. If
	 *            true, all referenced objects are also stored. If the object is already persistent i.e. contains a DataClay
	 *            objectID this function will fail.
	 * @param optionalBackendID
	 *            ID of the backend in which the object must be stored. If null, any backend is accepted.
	 */
	@Override
	public final void makePersistent(final boolean recursive, final BackendID optionalBackendID) {
<span class="nc" id="L701">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, optionalBackendID, recursive, null);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L703">			masterLocation = backendID;</span>
		}
<span class="nc" id="L705">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param alias
	 *            alias for the object
	 * @param destBackendID
	 *            ID of the backend in which the object must be stored. If null, any backend is accepted.
	 */
	@Override
	public final void makePersistent(final String alias, final BackendID destBackendID) {
<span class="nc bnc" id="L717" title="All 4 branches missed.">		if (alias != null &amp;&amp; alias.isEmpty()) {</span>
<span class="nc" id="L718">			throw new IllegalArgumentException(&quot;Alias cannot be empty&quot;);</span>
		}
<span class="nc" id="L720">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, destBackendID, true, alias);</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L722">			masterLocation = backendID;</span>
		}
<span class="nc" id="L724">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param alias
	 *            alias for the object
	 * @param recursive
	 *            Indicates if all referenced objects from this objects that are not already persistent must also be stored. If
	 *            true, all referenced objects are also stored. If the object is already persistent i.e. contains a DataClay
	 *            objectID this function will fail.
	 */
	@Override
	public final void makePersistent(final String alias, final boolean recursive) {
<span class="nc bnc" id="L738" title="All 4 branches missed.">		if (alias != null &amp;&amp; alias.isEmpty()) {</span>
<span class="nc" id="L739">			throw new IllegalArgumentException(&quot;Alias cannot be empty&quot;);</span>
		}
<span class="nc" id="L741">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, null, recursive, alias);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L743">			masterLocation = backendID;</span>
		}
<span class="nc" id="L745">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param alias
	 *            alias for the object
	 * @param destBackendID
	 *            ID of the backend in which the object must be stored. If null, any backend is accepted.
	 * @param recursive
	 *            Indicates if all referenced objects from this objects that are not already persistent must also be stored. If
	 *            true, all referenced objects are also stored. If the object is already persistent i.e. contains a DataClay
	 *            objectID this function will fail.
	 */
	@Override
	public final void makePersistent(final String alias, final BackendID destBackendID, final boolean recursive) {
<span class="nc bnc" id="L761" title="All 4 branches missed.">		if (alias != null &amp;&amp; alias.isEmpty()) {</span>
<span class="nc" id="L762">			throw new IllegalArgumentException(&quot;Alias cannot be empty&quot;);</span>
		}
<span class="nc" id="L764">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, destBackendID, recursive, alias);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L766">			masterLocation = backendID;</span>
		}
<span class="nc" id="L768">	}</span>

	/**
	 * Creates a new replica of this persistent object and its subobjects in a certain backend.
	 * 
	 * @return The ID of the backend in which the replica was created.
	 */
	@Override
	public final BackendID newReplica() {
<span class="nc" id="L777">		return DataClayObject.getLib().newReplica(this.objectID, this.getMetaClassID(), this.hint, null, true);</span>
	}

	/**
	 * Creates a new replica of this persistent object in a certain backend.
	 * 
	 * @param recursive
	 *            Indicates if all sub-objects must be replicated as well.
	 * @return The ID of the backend in which the replica was created.
	 */
	@Override
	public final BackendID newReplica(final boolean recursive) {
<span class="nc" id="L789">		return DataClayObject.getLib().newReplica(this.objectID, this.getMetaClassID(), this.hint, null, recursive);</span>
	}

	/**
	 * Creates a new replica of this persistent object.
	 * 
	 * @param optionalBackendID
	 *            ID of the backend in which to create the replica. If null, any backend is accepted. If the object is not
	 *            persistent i.e. does not contain a DataClay objectID this function will fail.
	 * @return The ID of the backend in which the replica was created.
	 */
	@Override
	public final BackendID newReplica(final BackendID optionalBackendID) {
<span class="nc" id="L802">		return DataClayObject.getLib().newReplica(this.objectID, this.getMetaClassID(), this.hint, optionalBackendID,</span>
				true);
	}

	/**
	 * Create a new replica of this persistent object.
	 * 
	 * @param optionalBackendID
	 *            ID of the backend in which to create the replica. If null, any backend is accepted. If the object is not
	 *            persistent i.e. does not contain a DataClay objectID this function will fail.
	 * @param recursive
	 *            Indicates if all sub-objects must be replicated as well.
	 * @return The ID of the backend in which the replica was created.
	 */
	@Override
	public final BackendID newReplica(final BackendID optionalBackendID, final boolean recursive) {
<span class="nc" id="L818">		return DataClayObject.getLib().newReplica(this.objectID, this.getMetaClassID(), this.hint, optionalBackendID,</span>
				recursive);
	}

	/**
	 * Moves a persistent object and referenced objects from the source location to the destination location specified. If the
	 * object is not persistent i.e. does not contain a DataClay objectID this function will fail.
	 * 
	 * @param srcLocID
	 *            of the source location in which the object is stored.
	 * @param destLocID
	 *            of the destination location in which the object should be moved.
	 */
	@Override
	public final void moveObject(final BackendID srcLocID, final BackendID destLocID) {
<span class="nc" id="L833">		DataClayObject.getLib().moveObject(this.objectID, this.getMetaClassID(), this.hint, srcLocID, destLocID, true);</span>
<span class="nc bnc" id="L834" title="All 4 branches missed.">		if (masterLocation != null &amp;&amp; srcLocID.equals(masterLocation)) {</span>
<span class="nc" id="L835">			masterLocation = destLocID;</span>
		}
<span class="nc" id="L837">	}</span>

	/**
	 * Moves a persistent object from the source location to the destination location specified. If the object is not persistent
	 * i.e. does not contain a DataClay objectID this function will fail.
	 * 
	 * @param srcLocID
	 *            of the source location in which the object is stored.
	 * @param destLocID
	 *            of the destination location in which the object should be moved.
	 * @param recursive
	 *            Indicates if all sub-objects must be moved as well.
	 */
	@Override
	public final void moveObject(final BackendID srcLocID, final BackendID destLocID, final boolean recursive) {
<span class="nc" id="L852">		DataClayObject.getLib().moveObject(this.objectID, this.getMetaClassID(), this.hint, srcLocID, destLocID,</span>
				recursive);
<span class="nc bnc" id="L854" title="All 4 branches missed.">		if (masterLocation != null &amp;&amp; srcLocID.equals(masterLocation)) {</span>
<span class="nc" id="L855">			masterLocation = destLocID;</span>
		}
<span class="nc" id="L857">	}</span>

	/**
	 * Sets this persistent object to be read only. If the object is not persistent i.e. does not contain a DataClay objectID
	 * this function will fail.
	 */
	@Override
	public final void setObjectReadOnly() {
		// Make sure object is registered
<span class="nc" id="L866">		DataClayObject.getLib().setObjectReadOnly(this.objectID, this.getMetaClassID(), this.hint);</span>
<span class="nc" id="L867">	}</span>

	/**
	 * Sets this persistent object to be read write. If the object is not persistent i.e. does not contain a DataClay objectID
	 * this function will fail.
	 */
	@Override
	public final void setObjectReadWrite() {
<span class="nc" id="L875">		DataClayObject.getLib().setObjectReadWrite(this.objectID, this.getMetaClassID(), this.hint);</span>
<span class="nc" id="L876">	}</span>

	/**
	 * Gets the location of this persistent object.
	 * 
	 * @return ID of the backend in which the object is stored. If the object is not persistent i.e. does not contain a DataClay
	 *         objectID this function will fail.
	 */
	@Override
	public final BackendID getLocation() {
<span class="nc" id="L886">		return DataClayObject.getLib().getLocation(this.objectID);</span>
	}

	/**
	 * Gets the location of this persistent object and its replicas.
	 * 
	 * @return A set of IDs of the backend in which this object or its replicas are stored. If the object is not persistent i.e.
	 *         does not contain a DataClay objectID this function will fail.
	 */
	@Override
	public final Set&lt;BackendID&gt; getAllLocations() {
<span class="nc" id="L897">		return new HashSet&lt;&gt;(DataClayObject.getLib().getAllLocations(this.objectID));</span>
	}

	/**
	 * Federates this object with an external dataClay instance
	 * 
	 * @param extDataClayID
	 *            id of the external dataClay instance
	 * @param recursive
	 *            whether to federate recursively or not
	 */
	public void federate(final DataClayInstanceID extDataClayID, final boolean recursive) {
<span class="nc" id="L909">		DataClayObject.getLib().federateObject(this.objectID, extDataClayID, recursive, this.getMetaClassID(),</span>
<span class="nc" id="L910">				this.getHint());</span>
<span class="nc" id="L911">	}</span>
	
	/**
	 * Unfederate this object with the provided external dataClay
	 * @param extDataClayID  id of the external dataClay instance
	 * @param recursive
	 *            whether to unfederate recursively or not
	 */
	public void unfederate(final DataClayInstanceID extDataClayID, final boolean recursive) { 
<span class="nc" id="L920">		DataClayObject.getLib().unfederateObject(this.objectID, extDataClayID, recursive);</span>
<span class="nc" id="L921">	}</span>

	/**
	 * Unfederate this object with all external dataClays is registered with
	 * @param recursive
	 *            whether to unfederate recursively or not
	 */
	public void unfederate(final boolean recursive) { 
<span class="nc" id="L929">		DataClayObject.getLib().unfederateObjectWithAllDCs(this.objectID, recursive);</span>
<span class="nc" id="L930">	}</span>
	
	/**
	 * Federates this object with an external dataClay instance
	 * 
	 * @param extDataClayID
	 *            id of the external dataClay instance
	 */
	public void federate(final DataClayInstanceID extDataClayID) {
<span class="nc" id="L939">		DataClayObject.getLib().federateObject(this.objectID, extDataClayID, true, this.getMetaClassID(),</span>
<span class="nc" id="L940">				this.getHint());</span>
<span class="nc" id="L941">	}</span>

	/**
	 * Unfederate this object with the provided external dataClay
	 * @param extDataClayID  id of the external dataClay instance
	 */
	public void unfederate(final DataClayInstanceID extDataClayID) { 
<span class="nc" id="L948">		DataClayObject.getLib().unfederateObject(this.objectID, extDataClayID, true);</span>
<span class="nc" id="L949">	}</span>
	
	/**
	 * Retrieve dataClay instances where this object is federated
	 * 
	 * @return set of dataClay instances id
	 */
	public final Set&lt;DataClayInstanceID&gt; getFederationTargets() {
<span class="nc" id="L957">		return getLib().getLogicModuleAPI().getDataClaysObjectIsFederatedWith(this.getObjectID());</span>
	}
	
	/**
	 * Retrieve dataClay instances where a federated object comes from or NULL if object is from current dc.
	 * 
	 * @return id of origin dataclay of the object or null
	 */
	public final DataClayInstanceID getFederationSource() {
<span class="nc" id="L966">		return getLib().getLogicModuleAPI().getExternalSourceDataClayOfObject(this.getObjectID());</span>
	}
	
	/**
	 * Retrieve dataClay ID
	 * @param hostname Name of external dataclay 
	 * @param port Port of external dataclay
	 * @return ID of external dataclay
	 */
	public final DataClayInstanceID getExternalDataClayID(final String hostname, final int port) {
<span class="nc" id="L976">		return getLib().getExternalDataClayID(hostname, port);</span>
	}

	/**
	 * Override this function with code to be executed when a federated object arrives into a destination dataClay.
	 */
	public void whenFederated() {
<span class="nc bnc" id="L983" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L984">			logger.debug(</span>
<span class="nc" id="L985">					&quot;[==Federation==] Class &quot; + this.getClass().getName() + &quot; has no whenFederated behaviour defined.&quot;);</span>
		}

<span class="nc" id="L988">	}</span>

	/**
	 * Override this function with code to be executed when a federate object is unfederated in destination dataClay.
	 */
	public void whenUnfederated() {
<span class="nc bnc" id="L994" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L995">			logger.debug(</span>
<span class="nc" id="L996">					&quot;[==Federation==] Class &quot; + this.getClass().getName() + &quot; has no whenUnfederated behaviour defined.&quot;);</span>
		}
<span class="nc" id="L998">	}</span>

	/**
	 * If this object is iterable, returns the list of elements that satisfy the specified given conditions
	 * 
	 * @param conditions
	 *            a set of conditions representd in a String (e.g. &quot;field1 == 0, field2 &lt; 0&quot;)
	 * @return list of elements satisfying all the query conditions
	 */
	public List&lt;Object&gt; filter(final String conditions) {
<span class="nc bnc" id="L1008" title="All 2 branches missed.">		if (this.isPersistent()) {</span>
<span class="nc" id="L1009">			return getLib().filterObject(this, conditions);</span>
		} else {
<span class="nc" id="L1011">			return filterObject(conditions);</span>
		}
	}

	/**
	 * Protected method to be called either from EE or Client. If this object is iterable, returns the list of elements that
	 * satisfy the specified given conditions
	 * 
	 * @param conditions
	 *            a set of conditions representd in a String (e.g. &quot;field1 = 0,field2 &lt; 0&quot;)
	 * @return list of elements satisfying all the query conditions
	 */
	protected List&lt;Object&gt; filterObject(final String conditions) {
<span class="nc" id="L1024">		final List&lt;Object&gt; result = new ArrayList&lt;&gt;();</span>
		// Check iterable object
<span class="nc bnc" id="L1026" title="All 2 branches missed.">		if (!(this instanceof Iterable)) {</span>
<span class="nc" id="L1027">			return result;</span>
		}

		// Parse conditions
<span class="nc" id="L1031">		final List&lt;List&lt;Condition&gt;&gt; parsedConditions = ConditionParser.parseOrsOfAnds(conditions);</span>

		// Check each element
<span class="nc" id="L1034">		final Iterator&lt;?&gt; it = ((Iterable&lt;?&gt;) this).iterator();</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">		while (it.hasNext()) {</span>
<span class="nc" id="L1036">			final Object o = it.next();</span>
<span class="nc" id="L1037">			boolean matchOr = false;</span>

<span class="nc" id="L1039">			final Iterator&lt;List&lt;Condition&gt;&gt; itAnds = ((Iterable&lt;List&lt;Condition&gt;&gt;) parsedConditions).iterator();</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">			while (itAnds.hasNext()) {</span>

<span class="nc" id="L1042">				final List&lt;Condition&gt; subAndConditions = itAnds.next();</span>
<span class="nc" id="L1043">				boolean matchAnd = true;</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">				for (final Condition cond : subAndConditions) {</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">					if (!cond.matches(o)) { // if any AND condition is not met, then whole AND is not met</span>
<span class="nc" id="L1046">						matchAnd = false;</span>
<span class="nc" id="L1047">						break;</span>
					}
<span class="nc" id="L1049">				}</span>

<span class="nc bnc" id="L1051" title="All 2 branches missed.">				if (matchAnd) { // if all AND conditions of current AND are met, then OR is met, then break</span>
<span class="nc" id="L1052">					matchOr = true;</span>
<span class="nc" id="L1053">					break;</span>
				}
<span class="nc" id="L1055">			}</span>

<span class="nc bnc" id="L1057" title="All 2 branches missed.">			if (matchOr) {</span>
<span class="nc" id="L1058">				result.add(o);</span>
			}
<span class="nc" id="L1060">		}</span>
<span class="nc" id="L1061">		return result;</span>
	}

	/**
	 * Filter this object (assuming it is a collection) with the specified conditions
	 * 
	 * @param conditions
	 *            string-defined set of conditions compliant with ConditionParser
	 * @return the set of objects of this collection matching the specified conditions
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	public List&lt;Object&gt; filterStream(final String conditions) {
<span class="nc" id="L1073">		List&lt;Object&gt; result = new ArrayList&lt;&gt;();</span>
		try {
			// Check iterable object
<span class="nc bnc" id="L1076" title="All 2 branches missed.">			if (!(this instanceof Iterable)) {</span>
<span class="nc" id="L1077">				return result;</span>
			}
<span class="nc" id="L1079">			final Spliterator&lt;?&gt; it = ((Iterable&lt;?&gt;) this).spliterator();</span>

			// Parse conditions
<span class="nc" id="L1082">			final Predicate asAndedPredicate = ConditionParser.asOrOfAndsPredicate(conditions);</span>

			// Check each element
<span class="nc" id="L1085">			final Stream stream = StreamSupport.stream(it, false);</span>
<span class="nc" id="L1086">			result = (List&lt;Object&gt;) stream.filter(asAndedPredicate).collect(Collectors.toList());</span>
<span class="nc" id="L1087">		} catch (final Exception e) {</span>
<span class="nc" id="L1088">			e.printStackTrace();</span>
<span class="nc" id="L1089">		}</span>
<span class="nc" id="L1090">		return result;</span>
	}

	/**
	 * Filter this object (assuming it is a collection) with the specified AST
	 * 
	 * @param ast
	 *            an AST representation of the conditions compliant with ASTParser
	 * @return the set of objects matching the specified conditions
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
	public List&lt;Object&gt; filterByAST(final List&lt;Object&gt; ast) {
<span class="nc" id="L1102">		List&lt;Object&gt; result = new ArrayList&lt;&gt;();</span>
		// Check iterable object
<span class="nc bnc" id="L1104" title="All 2 branches missed.">		if (!(this instanceof Iterable)) {</span>
<span class="nc" id="L1105">			return result;</span>
		}
<span class="nc" id="L1107">		final Spliterator&lt;?&gt; it = ((Iterable&lt;?&gt;) this).spliterator();</span>

		// Parse conditions
<span class="nc" id="L1110">		final Predicate asAndedPredicate = ASTParser.asPredicate(ast);</span>

		// Check each element
<span class="nc" id="L1113">		final Stream stream = StreamSupport.stream(it, false);</span>
<span class="nc" id="L1114">		result = (List&lt;Object&gt;) stream.filter(asAndedPredicate).collect(Collectors.toList());</span>
<span class="nc" id="L1115">		return result;</span>
	}

	@Override
	public void serialize(final DataClayByteBuffer dcBuffer, final boolean ignoreUserTypes,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps, final IdentityHashMap&lt;Object, Integer&gt; curSerializedObjs,
			final ListIterator&lt;DataClayObject&gt; pendingObjs, final ReferenceCounting referenceCounting) {

		// === reference counting information ===
		// First integer represent the position in the buffer in which reference
		// counting starts
		// this is done to avoid &quot;holding&quot; unnecessary information during a store or
		// update in disk.
		// in new serialization, this will be done through padding
		// TODO: use padding instead once new serialization is implemented (dgasull
		// pierlauro 2018)
<span class="nc" id="L1131">		dcBuffer.writeInt(0); // index is updated in the end</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1133">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized first 4 bytes: writerindex=&quot; + dcBuffer.writerIndex());</span>
		}
		
		// === master location ==
<span class="nc bnc" id="L1137" title="All 2 branches missed.">		if (masterLocation != null) {</span>
<span class="nc" id="L1138">			dcBuffer.writeLong(masterLocation.getId().getLeastSignificantBits());</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">			if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1140">				DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized master location least: data=&quot;+  masterLocation.getId().getLeastSignificantBits() + &quot;, writerIndex=&quot; + dcBuffer.writerIndex());</span>
			}
<span class="nc" id="L1142">			dcBuffer.writeLong(masterLocation.getId().getMostSignificantBits());</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">			if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1144">				DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized master location most: data=&quot;+  masterLocation.getId().getMostSignificantBits() + &quot;, writerIndex=&quot; + dcBuffer.writerIndex());</span>
			}
		} else {
<span class="nc" id="L1147">			dcBuffer.writeLong(0L);</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">			if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1149">				DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized master location least: data=0, writerIndex=&quot; + dcBuffer.writerIndex());</span>
			}
<span class="nc" id="L1151">			dcBuffer.writeLong(0L);</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">			if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1153">				DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized master location most: data=0, writerIndex=&quot; + dcBuffer.writerIndex());</span>
			}
		}

<span class="nc" id="L1157">		final List&lt;DataClaySerializable&gt; wrapFields = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1158">		this.wrapFieldsSerialization(wrapFields);</span>

		// Calculate nulls bit set size
<span class="nc" id="L1161">		final int numBytes = (int) Math.ceil(wrapFields.size() / 8.0F);</span>
<span class="nc" id="L1162">		final BitSet notNullsBitSet = new BitSet(numBytes);</span>
<span class="nc" id="L1163">		dcBuffer.writeVLQInt(numBytes);</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1165">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized bitmap size: data=&quot; + numBytes + &quot;, writerIndex=&quot; + dcBuffer.writerIndex());</span>
		}
		
<span class="nc" id="L1168">		final int curWriterIndx = dcBuffer.writerIndex();</span>
<span class="nc" id="L1169">		dcBuffer.writeBytes(new byte[numBytes]);</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1171">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized empty bitmap: data=&quot; + notNullsBitSet + &quot;, writerIndex=&quot; + dcBuffer.writerIndex());</span>
		}
<span class="nc" id="L1173">		BitSet ifaceBitSet = null;</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">		if (ifaceBitMaps != null) {</span>
<span class="nc" id="L1175">			ifaceBitSet = BitSet.valueOf(ifaceBitMaps.get(getMetaClassID()));</span>
		}

<span class="nc bnc" id="L1178" title="All 2 branches missed.">		for (int i = 0; i &lt; wrapFields.size(); ++i) {</span>
<span class="nc bnc" id="L1179" title="All 4 branches missed.">			if (ifaceBitSet == null || ifaceBitSet.get(i)) {</span>
<span class="nc" id="L1180">				final DataClaySerializable wrappedField = wrapFields.get(i);</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">				if (wrappedField == null) {</span>
<span class="nc" id="L1182">					continue;</span>
				}

<span class="nc bnc" id="L1185" title="All 2 branches missed.">				if (wrappedField instanceof DataClayJavaWrapper) {</span>
					// ====== JAVA/IMMUTABLE/GENERIC FIELD ===== //
<span class="nc" id="L1187">					final DataClayJavaWrapper javaWrapper = (DataClayJavaWrapper) wrappedField;</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">					if (javaWrapper.isNull()) {</span>
<span class="nc" id="L1189">						continue;</span>
					}
<span class="nc" id="L1191">					notNullsBitSet.set(i);</span>
<span class="nc" id="L1192">					DataClaySerializationLib.serializeJavaField(javaWrapper, dcBuffer, ignoreUserTypes, ifaceBitMaps,</span>
							curSerializedObjs, pendingObjs, referenceCounting);

<span class="nc" id="L1195">				} else {</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">					if (ignoreUserTypes) {</span>
<span class="nc" id="L1197">						continue;</span>
					}
<span class="nc" id="L1199">					final DataClayObject dcObject = (DataClayObject) wrappedField;</span>
					// ====== DCOBJECT FIELD ===== //
<span class="nc" id="L1201">					notNullsBitSet.set(i);</span>
<span class="nc" id="L1202">					DataClaySerializationLib.serializeAssociation(dcObject, dcBuffer, ignoreUserTypes, ifaceBitMaps,</span>
							curSerializedObjs, pendingObjs, referenceCounting);
				}
			}
		}

<span class="nc" id="L1208">		int curIdx = dcBuffer.writerIndex();</span>
<span class="nc" id="L1209">		dcBuffer.setWriterIndex(curWriterIndx);</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1211">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Modified writerIndex=&quot; + dcBuffer.writerIndex());</span>
		}
<span class="nc" id="L1213">		dcBuffer.writeBytes(notNullsBitSet.toByteArray());</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1215">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized bitmap: data=&quot; + notNullsBitSet + &quot;, writerIndex=&quot; + dcBuffer.writerIndex());</span>
		}
<span class="nc" id="L1217">		dcBuffer.setWriterIndex(curIdx);</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1219">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Modified writerIndex=&quot; + dcBuffer.writerIndex());</span>
		}
		// == reference counting == //
		// TODO: IMPORTANT: this should be removed in new serialization by using
		// paddings to directly access reference counters inside metadata.

<span class="nc" id="L1225">		curIdx = dcBuffer.writerIndex();</span>
<span class="nc" id="L1226">		dcBuffer.setWriterIndex(0);</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1228">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Modified writerIndex=&quot; + dcBuffer.writerIndex());</span>
		}
<span class="nc" id="L1230">		dcBuffer.writeInt(curIdx);</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1232">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Serialized curIdx: data=&quot; + curIdx + &quot;, writerIndex=&quot; + dcBuffer.writerIndex());</span>
		}
<span class="nc" id="L1234">		dcBuffer.setWriterIndex(curIdx);</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">		if (DataClaySerializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1236">			DataClaySerializationLib.LOGGER.debug(&quot;[Serialization] --&gt; Modified writerIndex=&quot; + dcBuffer.writerIndex());</span>
		}
<span class="nc" id="L1238">		DataClaySerializationLib.serializeReferenceCounting(dcBuffer, referenceCounting);</span>

<span class="nc" id="L1240">	}</span>

	@Override
	public void deserialize(final DataClayByteBuffer dcBuffer, final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps,
			final DataClayObjectMetaData metadata, final Map&lt;Integer, Object&gt; curDeserializedJavaObjs) {

		// == reference counting == //
		// see serialize function to understand why we &quot;ignore&quot; first 4 bytes
<span class="nc" id="L1248">		dcBuffer.readInt();</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">		if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1250">			DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Ignored 4 first bytes deserialized: readerindex=&quot; + dcBuffer.readerIndex());</span>
		}
		// === master location ==
<span class="nc" id="L1253">		final long masterLocationLeast = dcBuffer.readLong();</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">		if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1255">			DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Master location least bytes deserialized: data=&quot;+  masterLocationLeast + &quot;, readerindex=&quot; + dcBuffer.readerIndex());</span>
		}
<span class="nc" id="L1257">		final long masterLocationMost = dcBuffer.readLong();</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">		if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1259">			DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Master location most bytes deserialized: data=&quot;+  masterLocationMost + &quot;, readerindex=&quot; + dcBuffer.readerIndex());</span>
		}
<span class="nc bnc" id="L1261" title="All 4 branches missed.">		if (masterLocationLeast == 0L &amp;&amp; masterLocationMost == 0L) {</span>
<span class="nc" id="L1262">			masterLocation = null;</span>
		} else {
<span class="nc" id="L1264">			final UUID uuid = new UUID(masterLocationMost, masterLocationLeast);</span>
<span class="nc" id="L1265">			masterLocation = new ExecutionEnvironmentID(uuid);</span>
		}

<span class="nc" id="L1268">		final List&lt;DataClaySerializable&gt; wrapFields = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1269">		this.wrapFieldsDeserialization(wrapFields);</span>

<span class="nc" id="L1271">		BitSet notNullsBitSet = null;</span>
<span class="nc" id="L1272">		BitSet ifaceBitSet = null;</span>
<span class="nc" id="L1273">		final int notNullsBitSetLength = dcBuffer.readVLQInt();</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">		if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1275">			DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Bitmap size deserialized: data=&quot;+  notNullsBitSetLength + &quot;, readerindex=&quot; + dcBuffer.readerIndex());</span>
		}
<span class="nc bnc" id="L1277" title="All 2 branches missed.">		if (notNullsBitSetLength &gt; 0) {</span>
<span class="nc" id="L1278">			notNullsBitSet = BitSet.valueOf(dcBuffer.readBytes(notNullsBitSetLength));</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">			if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1280">				DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Bitmap deserialized: data=&quot;+  notNullsBitSet + &quot;, readerindex=&quot; + dcBuffer.readerIndex());</span>
			}
		}
<span class="nc bnc" id="L1283" title="All 2 branches missed.">		if (ifaceBitMaps != null) {</span>
<span class="nc" id="L1284">			ifaceBitSet = BitSet.valueOf(ifaceBitMaps.get(getMetaClassID()));</span>
		}

<span class="nc" id="L1287">		int curFieldIdx = 0;</span>
<span class="nc" id="L1288">		final Queue&lt;Object&gt; queueFields = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">		for (final DataClaySerializable wrapper : wrapFields) {</span>

<span class="nc bnc" id="L1291" title="All 4 branches missed.">			final boolean isInIface = ifaceBitSet == null || ifaceBitSet.get(curFieldIdx);</span>
<span class="nc bnc" id="L1292" title="All 4 branches missed.">			final boolean isNotNull = notNullsBitSet == null || notNullsBitSet.get(curFieldIdx);</span>
<span class="nc bnc" id="L1293" title="All 4 branches missed.">			if (isInIface &amp;&amp; isNotNull) {</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">				if (wrapper == null) {</span>
					// ====== DCOBJECT FIELD ===== //
					// Means association, no wrappers
<span class="nc" id="L1297">					final DataClayObject obj = DataClayDeserializationLib.deserializeAssociation(dcBuffer, ifaceBitMaps,</span>
<span class="nc" id="L1298">							metadata, curDeserializedJavaObjs, getLib());</span>
<span class="nc" id="L1299">					queueFields.add(obj);</span>
<span class="nc" id="L1300">				} else {</span>
					// ====== JAVA/IMMUTABLE/PRIMITIVE FIELD ===== //
<span class="nc" id="L1302">					final DataClayJavaWrapper javaWrapper = (DataClayJavaWrapper) wrapper;</span>
<span class="nc" id="L1303">					final Object javaObj = DataClayDeserializationLib.deserializeJavaField(javaWrapper, dcBuffer,</span>
							ifaceBitMaps, metadata, curDeserializedJavaObjs);
<span class="nc" id="L1305">					queueFields.add(javaObj);</span>
<span class="nc" id="L1306">				}</span>
<span class="nc bnc" id="L1307" title="All 4 branches missed.">			} else if (isInIface &amp;&amp; !isNotNull) {</span>
<span class="nc" id="L1308">				queueFields.add(null);</span>
			}

<span class="nc" id="L1311">			curFieldIdx++;</span>
<span class="nc" id="L1312">		}</span>

		// Set fields
<span class="nc" id="L1315">		this.setFieldsDeserialization(queueFields);</span>

		// == ignore rest of bytes (like reference counting) == //
		// do not clear buffer since this can be an embedded object (maybe?).

<span class="nc" id="L1320">	}</span>

	/*
	 * @Override protected void finalize() throws Throwable { if (this.isServerObject) { this.ds.gcCollectObject(this); } }
	 */

	/**
	 * Get the DataClayObject::hint
	 * 
	 * @return the hint
	 */
	public BackendID getHint() {
<span class="nc" id="L1332">		return hint;</span>
	}

	/**
	 * Set the DataClayObject::hint
	 * 
	 * @param newhint
	 *            the hint to set
	 */
	public void setHint(final BackendID newhint) {
<span class="nc" id="L1342">		this.hint = newhint;</span>
<span class="nc" id="L1343">	}</span>

	/**
	 * Clear exec stub infos cache for enrichments.
	 */
	public static final void clearExecStubInfosCache() {
<span class="nc" id="L1349">		execStubInfosCache.clear();</span>
<span class="nc" id="L1350">	}</span>

	/**
	 * Clear stub infos cache for enrichments.
	 */
	public static final void clearStubInfosCache() {
<span class="nc" id="L1356">		stubInfosCache.clear();</span>
<span class="nc" id="L1357">	}</span>

	/**
	 * Get stub information of class
	 * 
	 * @return Stub information
	 */
	public final StubInfo getStubInfo() {
<span class="nc" id="L1365">		return getStubInfoFromClass(this.getClass().getName());</span>
	}

	/**
	 * Checks if class provided is stub or not.
	 * 
	 * @param clazz
	 *            Class to check.
	 * @return True if it is an stub. False otherwise.
	 */
	public static final boolean isStub(final Class&lt;?&gt; clazz) {
		try {
<span class="nc" id="L1377">			clazz.getField(ByteCodeFieldNames.IS_STUB_FIELDNAME);</span>
<span class="nc" id="L1378">			return true;</span>
<span class="nc" id="L1379">		} catch (final NoSuchFieldException e2) {</span>
<span class="nc" id="L1380">			return false;</span>
		}
	}

	/**
	 * Get stubinfo for class with name provided
	 * 
	 * @param className
	 *            Name of the class
	 * @return Stub information.
	 */
	public static final StubInfo getStubInfoFromClass(final String className) {
<span class="nc" id="L1392">		StubInfo stubInfo = null;</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">		if (getLib().isDSLib()) {</span>
<span class="nc" id="L1394">			stubInfo = execStubInfosCache.get(className);</span>
		} else {
<span class="nc" id="L1396">			stubInfo = stubInfosCache.get(className);</span>
		}
<span class="nc bnc" id="L1398" title="All 2 branches missed.">		if (stubInfo == null) {</span>
			try {
<span class="nc" id="L1400">				Class&lt;?&gt; currentClass = null;</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">				if (getLib().isDSLib()) {</span>
<span class="nc" id="L1402">					currentClass = DataClayClassLoaderSrv.getClass(className);</span>
				} else {
<span class="nc" id="L1404">					currentClass = DataClayClassLoader.getClass(className);</span>
				}
<span class="nc" id="L1406">				final Yaml yaml = CommonYAML.getYamlObject();</span>
<span class="nc" id="L1407">				final String path = currentClass.getSimpleName() + &quot;Yaml.yaml&quot;;</span>
<span class="nc" id="L1408">				final InputStream ios = currentClass.getResourceAsStream(path);</span>
<span class="nc" id="L1409">				stubInfo = (StubInfo) yaml.load(ios);</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">				if (getLib().isDSLib()) {</span>
<span class="nc" id="L1411">					execStubInfosCache.put(className, stubInfo);</span>
				} else {
<span class="nc" id="L1413">					stubInfosCache.put(className, stubInfo);</span>
				}
<span class="nc" id="L1415">			} catch (final Exception e) {</span>
<span class="nc" id="L1416">				e.printStackTrace();</span>
<span class="nc" id="L1417">			}</span>
		}
<span class="nc" id="L1419">		return stubInfo;</span>
	}

	/**
	 * Execute remote method
	 * 
	 * @param methodSignature
	 *            Signature of the method
	 * @param implIDAsStr
	 *            ImplementationID as string
	 * @param params
	 *            Parameters to send
	 * @return Return value.
	 */
	@Override
	public Object executeRemoteImplementation(final String methodSignature, final String implIDAsStr,
			final Object[] params) {
<span class="nc" id="L1436">		return getLib().executeRemoteImplementation(this, implIDAsStr, params);</span>
	}

	@Override
	public boolean equals(final Object obj) {
<span class="nc bnc" id="L1441" title="All 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L1442">			return false;</span>
		}
<span class="nc bnc" id="L1444" title="All 2 branches missed.">		if (!(obj instanceof DataClayObject)) {</span>
<span class="nc" id="L1445">			return false;</span>
		}
<span class="nc" id="L1447">		return this.objectID.equals(((DataClayObject) obj).getObjectID());</span>

	}

	@Override
	public int hashCode() {
<span class="nc" id="L1453">		return Objects.hashCode(this.objectID);</span>
	}

	/**
	 * Get DataSetID
	 * 
	 * @return DataSetID
	 */
	public DataSetID getDataSetID() {
<span class="nc" id="L1462">		return dataSetID;</span>
	}

	/**
	 * Set object DataSetID
	 * 
	 * @param newDataSetID
	 *            ID of DataSet this object belongs to
	 */
	public void setDataSetID(final DataSetID newDataSetID) {
<span class="nc" id="L1472">		this.dataSetID = newDataSetID;</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">		if (this.isPersistent()) {</span>
<span class="nc" id="L1474">			getLib().setDataSetID(this.objectID, newDataSetID);</span>
		}
<span class="nc" id="L1476">	}</span>

	/**
	 * @return the masterLocation
	 */
	public final BackendID getMasterLocation() {
<span class="nc" id="L1482">		return masterLocation;</span>
	}

	/**
	 * If called from client side will not have any effect.
	 * 
	 * @param newMasterLocation
	 *            the masterLocation to set
	 */
	public void setMasterLocation(final BackendID newMasterLocation) {
<span class="nc" id="L1492">		this.masterLocation = newMasterLocation;</span>
<span class="nc" id="L1493">	}</span>

	/**
	 * @return true if masterlocation is the current backend, false otherwise
	 */
	public final boolean isMasterLocation() {
<span class="nc bnc" id="L1499" title="All 2 branches missed.">		if (masterLocation != null) {</span>
<span class="nc" id="L1500">			return masterLocation.equals(DataClayObject.getLib().getHint());</span>
		}
<span class="nc" id="L1502">		return false;</span>
	}

	/**
	 * @return id of the external dataClay instance where the object resides. null if it is local.
	 */
	public DataClayInstanceID getExternalDataClayID() {
<span class="nc" id="L1509">		return externalDataClayID;</span>
	}

	/**
	 * @param newID
	 *            id of the external dataClay instance
	 */
	public void setExternalDataClayID(final DataClayInstanceID newID) {
<span class="nc" id="L1517">		this.externalDataClayID = newID;</span>
<span class="nc" id="L1518">	}</span>
	
	/**
	 * RT PREFETCHING FIELDS
	 */
	
	public boolean isPrefetchingAccess() {
<span class="nc" id="L1525">		return isPrefetchingAccess;</span>
	}
	
	public static void setPrefetchingAccess(final boolean value) {
<span class="nc" id="L1529">		isPrefetchingAccess = value;</span>
<span class="nc" id="L1530">	}</span>
	
	public static long getAccessCount() {
<span class="nc" id="L1533">		return accessCount;</span>
	}
	
	public static long getHitCount() {
<span class="nc" id="L1537">		return hitCount;</span>
	}
	
	protected void incrementAccessCount() {
<span class="nc" id="L1541">		accessCount++;</span>
<span class="nc" id="L1542">	}</span>

	protected void incrementHitCount() {
<span class="nc" id="L1545">		hitCount++;</span>
<span class="nc" id="L1546">	}</span>
	
	public static void resetObjectAccessStats() {
<span class="nc" id="L1549">		accessCount = 0;</span>
<span class="nc" id="L1550">		hitCount = 0;</span>
<span class="nc" id="L1551">	}</span>

	public static void printObjectAccessStats() {
<span class="nc" id="L1554">		logger.debug(&quot;[==PerfetchingInfo==] Object Hit Ratio: &quot;</span>
				+ (double)hitCount / (double)accessCount
				+ &quot;(&quot; + hitCount + &quot;/&quot; + accessCount + &quot;)&quot;);
<span class="nc" id="L1557">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>