<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataClayObject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay</a> &gt; <span class="el_source">DataClayObject.java</span></div><h1>DataClayObject.java</h1><pre class="source lang-java linenums">package es.bsc.dataclay;

import java.io.InputStream;
import java.io.Serializable;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import es.bsc.dataclay.util.structs.MemoryCache;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.yaml.snakeyaml.Yaml;

import es.bsc.dataclay.api.BackendID;
import es.bsc.dataclay.api.DataClay;
import es.bsc.dataclay.commonruntime.ClientRuntime;
import es.bsc.dataclay.commonruntime.DataClayRuntime;
import es.bsc.dataclay.logic.classmgr.bytecode.java.constants.ByteCodeFieldNames;
import es.bsc.dataclay.serialization.DataClaySerializable;
import es.bsc.dataclay.serialization.buffer.DataClayByteBuffer;
import es.bsc.dataclay.serialization.java.DataClayJavaWrapper;
import es.bsc.dataclay.serialization.lib.DataClayDeserializationLib;
import es.bsc.dataclay.serialization.lib.DataClaySerializationLib;
import es.bsc.dataclay.serialization.lib.SerializedParametersOrReturn;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.DataClayObjectMetaData;
import es.bsc.dataclay.util.ReferenceCounting;
import es.bsc.dataclay.util.classloaders.DataClayClassLoader;
import es.bsc.dataclay.util.classloaders.DataClayClassLoaderSrv;
import es.bsc.dataclay.util.filtering.ASTParser;
import es.bsc.dataclay.util.filtering.Condition;
import es.bsc.dataclay.util.filtering.ConditionParser;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.management.stubs.StubInfo;
import es.bsc.dataclay.util.yaml.CommonYAML;
import storage.StorageObject;
import storage.StubItf;

/**
 * This class represents a Object in DataClay.
 */
public class DataClayObject extends StorageObject implements DataClaySerializable, Serializable, StubItf {
	/** Indicates if debug is enabled. */
<span class="fc" id="L53">	protected static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

	/** Logger. */
<span class="fc" id="L56">	public static final Logger logger = LogManager.getLogger(&quot;DataClayObject&quot;);</span>

	/** Serial version UID. */
	private static final long serialVersionUID = 1772790872967833442L;

	// CHECKSTYLE:OF
	/** Client runtime. */
<span class="fc" id="L63">	public static DataClayRuntime clientRuntime = new ClientRuntime();</span>

	/** ObjectID of the stub instance. */
	protected ObjectID objectID;

	/** Indicates if the object is registered or not. */
<span class="nc" id="L69">	protected AtomicBoolean isPersistent = new AtomicBoolean(false);</span>

	/** Indicates if the object was filled with data. */
<span class="nc" id="L72">	protected AtomicBoolean isLoaded = new AtomicBoolean(false);</span>

	/** HINT: Indicates object Execution Location. */
	private BackendID hint;

	/**
	 * ID of dataset of object. Used for user to specify which DataSet to use in store.
	 */
	protected DataSetID dataSetID;

	/** StubInfos cache. */
<span class="fc" id="L83">	private static MemoryCache&lt;String, StubInfo&gt; stubInfosCache = new MemoryCache&lt;&gt;();</span>

	/** Exec.StubInfos cache. */
<span class="fc" id="L86">	private static MemoryCache&lt;String, StubInfo&gt; execStubInfosCache = new MemoryCache&lt;&gt;();</span>

	/** Main storage location for the object **/
	private BackendID masterLocation;

	/** 'LOCAL' location */
	public static BackendID LOCAL;

	/** Alias of the object. */
	private String alias;

	/** Indicates if object is read only. */
	private boolean isReadOnly;

	/** dataClay instance */
	private DataClayInstanceID externalDataClayID;

	/** Original objectID if object was versioned. */
	private ObjectID originalObjectID;

	/** ID of original object location. */
	private ExecutionEnvironmentID rootLocation;

	/** ID of origin object location (replicas): origin of the replica. */
	private ExecutionEnvironmentID originLocation;

	/** IDs of locations this replica-object was replicated to. */
	private Set&lt;ExecutionEnvironmentID&gt; replicaLocations;

	/**
	 * RT PREFETCHING FIELDS
	 */

<span class="fc" id="L119">	private static transient boolean isPrefetchingAccess = false;</span>
	
<span class="fc" id="L121">	private static transient long accessCount = 0;</span>
	
<span class="fc" id="L123">	private static transient long hitCount = 0;</span>

	// CHECKSTYLE:ON

	/**
	 * Constructor
	 */
<span class="nc" id="L130">	public DataClayObject() {</span>
<span class="nc" id="L131">		this.init(new ObjectID());</span>
		// Initialize as volatile
<span class="nc" id="L133">		initializeObjectAsVolatile();</span>
<span class="nc" id="L134">	}</span>

	/**
	 * Constructor
	 * 
	 * @param theobjectID
	 *            ID of the object
	 */
<span class="nc" id="L142">	public DataClayObject(final ObjectID theobjectID) {</span>
<span class="nc" id="L143">		this.init(theobjectID);</span>
<span class="nc" id="L144">	}</span>

	/**
	 * Initialize object
	 * 
	 * @param theobjectID
	 *            ID of the object
	 */
	private void init(final ObjectID theobjectID) {
<span class="nc" id="L153">		final ObjectID oid = theobjectID;</span>
<span class="nc" id="L154">		this.setObjectIDUnsafe(oid);</span>
		// Add object to dataClay's heap
<span class="nc" id="L156">		getLib().addToHeap(this);</span>
<span class="nc" id="L157">	}</span>

	/**
	 * Initialize object with state 'persistent' with proper flags. See same function in DataClayExecutionObject for a different
	 * initialization. This design is intended to be clear with object state. Usually, since constructors are calling
	 * initializeObjectAsVolatile, this function 'overrides' flags set
	 */
	public void initializeObjectAsPersistent() {
<span class="nc" id="L165">		this.setIsPersistent(true);</span>
<span class="nc" id="L166">	}</span>

	/**
	 * Initialize object with state 'volatile' with proper flags. Usually, volatile state is created by a stub, app, exec
	 * class,.. See same function in DataClayExecutionObject for a different initialization. This design is intended to be clear
	 * with object state.
	 */
	public void initializeObjectAsVolatile() {
<span class="nc" id="L174">		this.setLoaded(true);</span>
<span class="nc" id="L175">	}</span>

	/**
	 * Set the DataClayObject::isLoaded
	 * 
	 * @param newisLoaded
	 *            the isLoaded to set
	 */
	public final void setLoaded(final boolean newisLoaded) {
<span class="nc" id="L184">		this.isLoaded.set(newisLoaded);</span>
<span class="nc" id="L185">	}</span>

	/**
	 * Generic static method to instantiate a DataClayObject by its alias
	 * 
	 * @param classID
	 *            id of real class of the instance
	 * @param alias
	 *            alias of the instance
	 * @param safe
	 *            if true, checks that an object with the provided alias exists
	 * @return the reference to persistent object of given class with given alias
	 */
	protected static DataClayObject getByAlias(final MetaClassID classID, final String alias, boolean safe) {
<span class="nc" id="L199">		return getLib().getObjectByAlias(alias, classID, safe);</span>
	}

	
	/**
	 * This method can be used from registered methods to access objects by alias, this method
	 * is parameterized in order to provide to the users a way to implement and compile an application using 
	 * a model to be registered (extending DataClayObject).
	 * 
	 * @param alias
	 *            alias of object to be requested
	 * @param &lt;E&gt; type of the object requested
	 * @return The object identified by the provided alias
	 */
	public static &lt;E&gt; E getByAliasExt(final String alias) {
<span class="nc" id="L214">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * This method can be used from registered methods to access objects by alias, this method
	 * is parameterized in order to provide to the users a way to implement and compile an application using 
	 * a model to be registered (extending DataClayObject).
	 *
	 * @param alias
	 *            alias of object to be requested
	 * @param safe
	 *            if true, checks that an object with the provided alias exists
	 * @param &lt;E&gt; type of the object requested
	 * @return The object identified by the provided alias
	 */
	public static &lt;E&gt; E getByAliasExt(final String alias, boolean safe) {
<span class="nc" id="L230">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}
	
	/**
	 * Deletes an alias of an object of a specific class
	 * 
	 * @param className
	 *            class name of the object
	 * @param alias
	 *            alias of the object
	 */
	public static void deleteAlias(final String className, final String alias) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L243">			logger.debug(&quot;Deleting alias &quot; + alias + &quot; of object of class &quot; + className);</span>
		}
<span class="nc" id="L245">		getLib().deleteAlias(alias);</span>
<span class="nc" id="L246">	}</span>

	/**
	 * Method to be specialized
	 * 
	 * @param alias
	 *            alias to be removed from this object
	 */
	public static void deleteAlias(final String alias) {
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L256">			logger.debug(&quot;Deleting alias &quot; + alias);</span>
		}
<span class="nc" id="L258">		getLib().deleteAlias(alias);</span>
<span class="nc" id="L259">	}</span>


	/**
	 * Delete object's alias
	 */
	public void deleteAlias() {
<span class="nc bnc" id="L266" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L267">			logger.debug(&quot;Deleting alias in backend: &quot; + alias);</span>
		}
<span class="nc" id="L269">		getLib().deleteAlias(this);</span>
<span class="nc" id="L270">	}</span>

	/**
	 * Set the object's id
	 *
	 * This method is labeled as unsafe as the user should be aware
	 * it is just possible to change ids of non-persistent objects.
	 *
	 * There no warranty that, once persisted, an object will keep
	 * the same id.
	 *
	 * @param newObjectID
	 *        The ObjectID to set
	 */
	public void setObjectIDUnsafe(final ObjectID newObjectID) {
<span class="nc" id="L285">		this.objectID = newObjectID;</span>
<span class="nc" id="L286">	}</span>

	/**
	 * Debug start of running method
	 * 
	 * @param opNameAndDesc
	 *            Operation name and descriptor
	 */
	public final void debugStart(final String opNameAndDesc) {
<span class="nc" id="L295">		logger.debug(&quot;[==Internal Exec==] Starting method &quot; + opNameAndDesc + &quot; for &quot; + objectID);</span>
<span class="nc" id="L296">	}</span>

	/**
	 * Debug end of running method
	 * 
	 * @param opNameAndDesc
	 *            Operation name and descriptor
	 */
	public final void debugEnd(final String opNameAndDesc) {
<span class="nc" id="L305">		logger.debug(&quot;[==Internal Exec==] Finished method &quot; + opNameAndDesc + &quot; for &quot; + objectID);</span>
<span class="nc" id="L306">	}</span>

	/**
	 * Set a new object ID (used for remove objects)
	 */
	public final void setNewObjectID() {
<span class="nc" id="L312">		this.objectID = new ObjectID();</span>
<span class="nc" id="L313">	}</span>

	/**
	 * Get DataService client library
	 * 
	 * @return DataService client library
	 */
	public static final DataClayRuntime getLib() {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">		if (Configuration.mockTesting) {</span>
<span class="nc" id="L322">			final DataClayRuntime mockLib = DataClayMockObject.getLib();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">			if (mockLib == null) {</span>
				// WARNING: this is intended to support client threads apps simulation
				// since in a real environment clientLib static field is not overriden
				// by servers lib.
<span class="nc" id="L327">				return clientRuntime;</span>
			} else {
<span class="nc" id="L329">				return mockLib;</span>
			}
		} else {
<span class="fc" id="L332">			return clientRuntime;</span>
		}

	}

	/**
	 * Set runtime
	 * 
	 * @param theruntime
	 *            the runtime to set
	 */
	public static void setLib(final DataClayRuntime theruntime) {
<span class="nc" id="L344">		clientRuntime = theruntime;</span>
<span class="nc" id="L345">		LOCAL = clientRuntime.getLocalBackend();</span>
<span class="nc" id="L346">	}</span>

	/**
	 * Get the ObjectID of the instance
	 * 
	 * @return The ObjectID
	 */
	@Override
	public final ObjectID getObjectID() {
<span class="nc" id="L355">		return objectID;</span>
	}

	/**
	 * Indicates the object is persistent.
	 * 
	 * @return TRUE if it is persistent. FALSE otherwise.
	 */
	public final boolean isPersistent() {
<span class="nc" id="L364">		return this.isPersistent.get();</span>
	}

	/**
	 * Set the DataClayObject:newisPersistent
	 * 
	 * @param newisPersistent
	 *            the isPersistent to set
	 */
	public final void setIsPersistent(final boolean newisPersistent) {
<span class="nc" id="L374">		this.isPersistent.set(newisPersistent);</span>
<span class="nc" id="L375">	}</span>

	// CHECKSTYLE:OFF

	/**
	 * Get metaclass ID
	 * 
	 * @return Class ID
	 */
	@Override
	public MetaClassID getMetaClassID() {
<span class="nc" id="L386">		final StubInfo stubInfo = getStubInfo();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">		if (stubInfo == null) {</span>
<span class="nc" id="L388">			return null;</span>
		}
<span class="nc" id="L390">		return stubInfo.getClassID();</span>
	}

	/**
	 * Get metaclass ID of the specified class name
	 * 
	 * @param className
	 *            name of the class
	 * @return ID of the class
	 */
	public static MetaClassID getMetaClassID(final String className) {
<span class="nc" id="L401">		return getStubInfoFromClass(className).getClassID();</span>
	}

	/**
	 * Runs the method with ID provided and params specified
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param params
	 *            Parameters of the method
	 * @return Result of the method
	 */
	public Object run(final ImplementationID implID, final Object[] params) {
<span class="nc" id="L414">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Synchronize
	 * @param implID
	 *            implementation ID to be invoked on federated object
	 * @param params
	 *            Parameters of the method
	 */
	public void synchronize(final ImplementationID implID, final Object[] params) {
<span class="nc" id="L425">		getLib().synchronize(this, params, implID);</span>
<span class="nc" id="L426">	}</span>

	/**
	 * Wraps fields for serialization
	 * 
	 * @param wrapFields
	 *            [out] Wrapped fields
	 */
	public void wrapFieldsSerialization(final List&lt;DataClaySerializable&gt; wrapFields) {
<span class="nc" id="L435">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Wraps fields for deserialization
	 * 
	 * @param wrapFields
	 *            [out] Wrapped fields
	 */
	public void wrapFieldsDeserialization(final List&lt;DataClaySerializable&gt; wrapFields) {
<span class="nc" id="L445">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Set fields
	 * 
	 * @param fieldsToSet
	 *            Fields to set, in order.
	 */
	public void setFieldsDeserialization(final Queue&lt;Object&gt; fieldsToSet) {
<span class="nc" id="L455">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Wraps parameters for serialization
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param params
	 *            Parameters of the method
	 * @return Wrapped parameters
	 */
	public List&lt;DataClaySerializable&gt; wrapParameters(final ImplementationID implID, final Object[] params) {
<span class="nc" id="L468">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Wraps return for serialization
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param ret
	 *            Return of the method
	 * @return Wrapped return
	 */
	public List&lt;DataClaySerializable&gt; wrapReturn(final ImplementationID implID, final Object ret) {
<span class="nc" id="L481">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Unwraps parameters for deserialization
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param wrapParams
	 *            Wrapped Parameters of the method
	 */
	public void setWrappersParams(final ImplementationID implID, final SerializedParametersOrReturn wrapParams) {
<span class="nc" id="L493">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Unwraps return for deserialization
	 * 
	 * @param implID
	 *            ID of the method to invoke
	 * @param wrapReturn
	 *            Wrapped return of the method
	 */
	public void setWrappersReturn(final ImplementationID implID, final SerializedParametersOrReturn wrapReturn) {
<span class="nc" id="L505">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * This method set all fields with values of fields of provided object.
	 * 
	 * @param otherObject
	 *            object with values of fields to set.
	 */
	public void setAll(final DataClayObject otherObject) {
<span class="nc" id="L515">		throw new UnsupportedOperationException(&quot;DataClayObject must be specialized&quot;);</span>
	}

	/**
	 * Retrieves a copy of this object
	 * 
	 * @return a non-persistent copy of this object
	 */
	public DataClayObject dcClone() {
<span class="nc" id="L524">		return DataClayObject.getLib().getCopyOfObject(this.objectID, false);</span>
	}

	/**
	 * Retrieves a copy of this object
	 * 
	 * @param recursive
	 *            whether to also copy its subobjects or not
	 * @return a non-persistent copy of this object
	 */
	public DataClayObject dcClone(final boolean recursive) {
<span class="nc" id="L535">		return DataClayObject.getLib().getCopyOfObject(this.objectID, recursive);</span>
	}

	/**
	 * Retrieves a copy of this object (but not the subobjects)
	 * 
	 * @param alias
	 *            alias of the object to be retrieved
	 * @return a non-persistent copy of this object
	 */
	public static DataClayObject dcCloneByAlias(final String alias) {
<span class="nc" id="L546">		final DataClayObject byAlias = DataClayObject.getLib().getObjectByAlias(alias);</span>
<span class="nc" id="L547">		return byAlias.dcClone();</span>
	}

	/**
	 * Retrieves a copy of this object
	 * 
	 * @param alias
	 *            alias of the object to be retrieved
	 * @param recursive
	 *            whether to also copy its subobjects or not
	 * @return a non-persistent copy of this object
	 */
	public static DataClayObject dcCloneByAlias(final String alias, final boolean recursive) {
<span class="nc" id="L560">		final DataClayObject byAlias = DataClayObject.getLib().getObjectByAlias(alias);</span>
<span class="nc" id="L561">		return byAlias.dcClone(recursive);</span>
	}

	/**
	 * Updates this object alias with the values in argument object
	 * 
	 * @param fromObject
	 *            object to be copied to this object
	 */
	public final void dcUpdate(final DataClayObject fromObject) {
<span class="nc bnc" id="L571" title="All 2 branches missed.">		if (fromObject == null) {</span>
<span class="nc" id="L572">			return;</span>
		}
<span class="nc" id="L574">		DataClayObject.getLib().updateObject(this.getObjectID(), fromObject);</span>
<span class="nc" id="L575">	}</span>

	/**
	 * Updates the object identified by the given alias with the values in argument object
	 *
	 * @param alias
	 *            alias of the object to be updated
	 * @param fromObject
	 *            object to be copied to this object
	 */
	public static final void dcUpdateByAlias(final String alias, final DataClayObject fromObject) {
<span class="nc" id="L586">		final DataClayObject byAlias = DataClayObject.getLib().getObjectByAlias(alias);</span>
<span class="nc" id="L587">		byAlias.dcUpdate(fromObject);</span>
<span class="nc" id="L588">	}</span>

	/**
	 * Equivalent to {@link #makePersistent(String) makePersistent}
	 * 
	 * @param alias
	 *            alias for the object
	 */
	public final void dcPut(final String alias) {
<span class="nc" id="L597">		this.makePersistent(alias);</span>
<span class="nc" id="L598">	}</span>

	/**
	 * Equivalent to {@link #makePersistent(String, BackendID) makePersistent}
	 * 
	 * @param alias
	 *            alias for the object
	 * @param optBackendID
	 *            optional backend where to persist this object
	 */
	public final void dcPut(final String alias, final BackendID optBackendID) {
<span class="nc" id="L609">		this.makePersistent(alias, optBackendID);</span>
<span class="nc" id="L610">	}</span>

	/**
	 * Equivalent to {@link #makePersistent(String, boolean) makePersistent}
	 * 
	 * @param alias
	 *            alias for the object
	 * @param recursive
	 *            whether subobjects are also persisted or not
	 */
	public final void dcPut(final String alias, final boolean recursive) {
<span class="nc" id="L621">		this.makePersistent(alias, recursive);</span>
<span class="nc" id="L622">	}</span>

	/**
	 * Equivalent to {@link #makePersistent(String, BackendID, boolean) makePersistent}
	 * 
	 * @param alias
	 *            alias for the object
	 * @param optBackendID
	 *            optional backend where to persist this object
	 * @param recursive
	 *            whether subobjects are also persisted or not
	 */
	public final void dcPut(final String alias, final BackendID optBackendID, final boolean recursive) {
<span class="nc" id="L635">		this.makePersistent(alias, optBackendID, recursive);</span>
<span class="nc" id="L636">	}</span>

	@Override
	public String getID() {
<span class="nc bnc" id="L640" title="All 2 branches missed.">		if (isPersistent.get()) {</span>
<span class="nc" id="L641">			return DataClay.ids2String(this.objectID, this.hint, this.getMetaClassID());</span>
		} else {
<span class="nc" id="L643">			return null;</span>
		}
	}

	@Override
	public final void makePersistent() {
<span class="nc" id="L649">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, null, true, null);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L651">			masterLocation = backendID;</span>
		}
<span class="nc" id="L653">	}</span>

	@Override
	public final void makePersistent(final BackendID optBackendID) {
<span class="nc" id="L657">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, optBackendID, true, null);</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L659">			masterLocation = backendID;</span>
		}
<span class="nc" id="L661">	}</span>

	@Override
	public final void makePersistent(final String alias) {
<span class="nc bnc" id="L665" title="All 4 branches missed.">		if (alias != null &amp;&amp; alias.isEmpty()) {</span>
<span class="nc" id="L666">			throw new IllegalArgumentException(&quot;Alias cannot be empty&quot;);</span>
		}
<span class="nc" id="L668">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, null, true, alias);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L670">			masterLocation = backendID;</span>
		}
<span class="nc" id="L672">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param recursive
	 *            Indicates if all referenced objects from this objects that are not already persistent must also be stored. If
	 *            true, all referenced objects are also stored. If the object is already persistent i.e. contains a DataClay
	 *            objectID this function will fail.
	 */
	@Override
	public final void makePersistent(final boolean recursive) {
<span class="nc" id="L684">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, null, recursive, null);</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L686">			masterLocation = backendID;</span>
		}
<span class="nc" id="L688">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param recursive
	 *            Indicates if all referenced objects from this objects that are not already persistent must also be stored. If
	 *            true, all referenced objects are also stored. If the object is already persistent i.e. contains a DataClay
	 *            objectID this function will fail.
	 * @param optionalBackendID
	 *            ID of the backend in which the object must be stored. If null, any backend is accepted.
	 */
	@Override
	public final void makePersistent(final boolean recursive, final BackendID optionalBackendID) {
<span class="nc" id="L702">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, optionalBackendID, recursive, null);</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L704">			masterLocation = backendID;</span>
		}
<span class="nc" id="L706">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param alias
	 *            alias for the object
	 * @param destBackendID
	 *            ID of the backend in which the object must be stored. If null, any backend is accepted.
	 */
	@Override
	public final void makePersistent(final String alias, final BackendID destBackendID) {
<span class="nc bnc" id="L718" title="All 4 branches missed.">		if (alias != null &amp;&amp; alias.isEmpty()) {</span>
<span class="nc" id="L719">			throw new IllegalArgumentException(&quot;Alias cannot be empty&quot;);</span>
		}
<span class="nc" id="L721">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, destBackendID, true, alias);</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L723">			masterLocation = backendID;</span>
		}
<span class="nc" id="L725">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param alias
	 *            alias for the object
	 * @param recursive
	 *            Indicates if all referenced objects from this objects that are not already persistent must also be stored. If
	 *            true, all referenced objects are also stored. If the object is already persistent i.e. contains a DataClay
	 *            objectID this function will fail.
	 */
	@Override
	public final void makePersistent(final String alias, final boolean recursive) {
<span class="nc bnc" id="L739" title="All 4 branches missed.">		if (alias != null &amp;&amp; alias.isEmpty()) {</span>
<span class="nc" id="L740">			throw new IllegalArgumentException(&quot;Alias cannot be empty&quot;);</span>
		}
<span class="nc" id="L742">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, null, recursive, alias);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L744">			masterLocation = backendID;</span>
		}
<span class="nc" id="L746">	}</span>

	/**
	 * Store this object into DataClay.
	 * 
	 * @param alias
	 *            alias for the object
	 * @param destBackendID
	 *            ID of the backend in which the object must be stored. If null, any backend is accepted.
	 * @param recursive
	 *            Indicates if all referenced objects from this objects that are not already persistent must also be stored. If
	 *            true, all referenced objects are also stored. If the object is already persistent i.e. contains a DataClay
	 *            objectID this function will fail.
	 */
	@Override
	public final void makePersistent(final String alias, final BackendID destBackendID, final boolean recursive) {
<span class="nc bnc" id="L762" title="All 4 branches missed.">		if (alias != null &amp;&amp; alias.isEmpty()) {</span>
<span class="nc" id="L763">			throw new IllegalArgumentException(&quot;Alias cannot be empty&quot;);</span>
		}
<span class="nc" id="L765">		final BackendID backendID = DataClayObject.getLib().makePersistent(this, destBackendID, recursive, alias);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">		if (masterLocation == null) {</span>
<span class="nc" id="L767">			masterLocation = backendID;</span>
		}
<span class="nc" id="L769">	}</span>

	/**
	 * Creates a new replica of this persistent object and its subobjects in a certain backend.
	 *
	 * @return The ID of the backend in which the replica was created.
	 */
	@Override
	public final BackendID newReplica() {
<span class="nc" id="L778">		return DataClayObject.getLib().newReplica(this.objectID, this.hint, null,</span>
				null,true);
	}

	/**
	 * Creates a new replica of this persistent object in a certain backend.
	 *
	 * @param recursive
	 *            Indicates if all sub-objects must be replicated as well.
	 * @return The ID of the backend in which the replica was created.
	 */
	@Override
	public final BackendID newReplica(final boolean recursive) {
<span class="nc" id="L791">		return DataClayObject.getLib().newReplica(this.objectID, this.hint,</span>
				null, null, recursive);
	}

	/**
	 * Creates a new replica of this persistent object.
	 * 
	 * @param optionalBackendID
	 *            ID of the backend in which to create the replica. If null, any backend is accepted. If the object is not
	 *            persistent i.e. does not contain a DataClay objectID this function will fail.
	 * @return The ID of the backend in which the replica was created.
	 */
	@Override
	public final BackendID newReplica(final BackendID optionalBackendID) {
<span class="nc" id="L805">		return DataClayObject.getLib().newReplica(this.objectID, this.hint,</span>
				optionalBackendID, null, true);
	}

	/**
	 * Create a new replica of this persistent object.
	 * 
	 * @param optionalBackendID
	 *            ID of the backend in which to create the replica. If null, any backend is accepted. If the object is not
	 *            persistent i.e. does not contain a DataClay objectID this function will fail.
	 * @param recursive
	 *            Indicates if all sub-objects must be replicated as well.
	 * @return The ID of the backend in which the replica was created.
	 */
	@Override
	public final BackendID newReplica(final BackendID optionalBackendID, final boolean recursive) {
<span class="nc" id="L821">		return DataClayObject.getLib().newReplica(this.objectID, this.hint,</span>
				optionalBackendID,
				null, recursive);
	}

	/**
	 * Moves a persistent object and referenced objects from the source location to the destination location specified. If the
	 * object is not persistent i.e. does not contain a DataClay objectID this function will fail.
	 * 
	 * @param srcLocID
	 *            of the source location in which the object is stored.
	 * @param destLocID
	 *            of the destination location in which the object should be moved.
	 */
	@Override
	public final void moveObject(final BackendID srcLocID, final BackendID destLocID) {
<span class="nc" id="L837">		DataClayObject.getLib().moveObject(this.objectID, this.getMetaClassID(), this.hint, srcLocID, destLocID, true);</span>
<span class="nc bnc" id="L838" title="All 4 branches missed.">		if (masterLocation != null &amp;&amp; srcLocID.equals(masterLocation)) {</span>
<span class="nc" id="L839">			masterLocation = destLocID;</span>
		}
<span class="nc" id="L841">	}</span>

	/**
	 * Moves a persistent object from the source location to the destination location specified. If the object is not persistent
	 * i.e. does not contain a DataClay objectID this function will fail.
	 * 
	 * @param srcLocID
	 *            of the source location in which the object is stored.
	 * @param destLocID
	 *            of the destination location in which the object should be moved.
	 * @param recursive
	 *            Indicates if all sub-objects must be moved as well.
	 */
	@Override
	public final void moveObject(final BackendID srcLocID, final BackendID destLocID, final boolean recursive) {
<span class="nc" id="L856">		DataClayObject.getLib().moveObject(this.objectID, this.getMetaClassID(), this.hint, srcLocID, destLocID,</span>
				recursive);
<span class="nc bnc" id="L858" title="All 4 branches missed.">		if (masterLocation != null &amp;&amp; srcLocID.equals(masterLocation)) {</span>
<span class="nc" id="L859">			masterLocation = destLocID;</span>
		}
<span class="nc" id="L861">	}</span>

	/**
	 * Sets this persistent object to be read only. If the object is not persistent i.e. does not contain a DataClay objectID
	 * this function will fail.
	 */
	@Override
	public final void setObjectReadOnly() {
		// Make sure object is registered
<span class="nc" id="L870">		DataClayObject.getLib().setObjectReadOnly(this.objectID, this.getMetaClassID(), this.hint);</span>
<span class="nc" id="L871">	}</span>

	/**
	 * Sets this persistent object to be read write. If the object is not persistent i.e. does not contain a DataClay objectID
	 * this function will fail.
	 */
	@Override
	public final void setObjectReadWrite() {
<span class="nc" id="L879">		DataClayObject.getLib().setObjectReadWrite(this.objectID, this.getMetaClassID(), this.hint);</span>
<span class="nc" id="L880">	}</span>

	/**
	 * Gets the location of this persistent object.
	 * 
	 * @return ID of the backend in which the object is stored. If the object is not persistent i.e. does not contain a DataClay
	 *         objectID this function will fail.
	 */
	@Override
	public final BackendID getLocation() {
<span class="nc" id="L890">		return DataClayObject.getLib().getLocation(this.objectID);</span>
	}

	/**
	 * Gets the location of this persistent object and its replicas.
	 * 
	 * @return A set of IDs of the backend in which this object or its replicas are stored. If the object is not persistent i.e.
	 *         does not contain a DataClay objectID this function will fail.
	 */
	@Override
	public final Set&lt;BackendID&gt; getAllLocations() {
<span class="nc" id="L901">		return new HashSet&lt;&gt;(DataClayObject.getLib().getAllLocations(this.objectID));</span>
	}

	/**
	 * Federates this object with an external dataClay instance
	 * 
	 * @param extDataClayID
	 *            id of the external dataClay instance
	 * @param recursive
	 *            whether to federate recursively or not
	 */
	public void federate(final DataClayInstanceID extDataClayID, final boolean recursive) {
<span class="nc" id="L913">		DataClayObject.getLib().federateObject(this, extDataClayID, recursive);</span>
<span class="nc" id="L914">	}</span>
	
	/**
	 * Unfederate this object with the provided external dataClay
	 * @param extDataClayID  id of the external dataClay instance
	 * @param recursive
	 *            whether to unfederate recursively or not
	 */
	public void unfederate(final DataClayInstanceID extDataClayID, final boolean recursive) {
		//FIXME: specific unfederation
<span class="nc" id="L924">		DataClayObject.getLib().unfederateObject(this, null, recursive);</span>
<span class="nc" id="L925">	}</span>

	/**
	 * Unfederate this object with all external dataClays is registered with
	 * @param recursive
	 *            whether to unfederate recursively or not
	 */
	public void unfederate(final boolean recursive) { 
<span class="nc" id="L933">		DataClayObject.getLib().unfederateObject(this, null, recursive);</span>
<span class="nc" id="L934">	}</span>
	
	/**
	 * Federates this object with an external dataClay instance
	 * 
	 * @param extDataClayID
	 *            id of the external dataClay instance
	 */
	public void federate(final DataClayInstanceID extDataClayID) {
<span class="nc" id="L943">		DataClayObject.getLib().federateObject(this, extDataClayID, true);</span>
<span class="nc" id="L944">	}</span>


	/**
	 * Unfederate this object with the provided external dataClay
	 * @param extDataClayID  id of the external dataClay instance
	 */
	public void unfederate(final DataClayInstanceID extDataClayID) {
		//FIXME: specific unfederation
<span class="nc" id="L953">		DataClayObject.getLib().unfederateObject(this, null, true);</span>
<span class="nc" id="L954">	}</span>

	/**
	 * Federates this object with an external backend instance
	 *
	 * @param extBackendID
	 *            id of the external backend to federate
	 */
	public void federateToBackend(final BackendID extBackendID) {
<span class="nc" id="L963">		DataClayObject.getLib().federateToBackend(this,</span>
				(ExecutionEnvironmentID) extBackendID, true);
<span class="nc" id="L965">	}</span>

	/**
	 * Federates this object with an external backend instance
	 *
	 * @param extBackendID
	 *            id of the external backend to federate
	 * @param recursive Indicates if federation is recursive or not
	 */
	public void federateToBackend(final BackendID extBackendID, final boolean recursive) {
<span class="nc" id="L975">		DataClayObject.getLib().federateToBackend(this,</span>
				(ExecutionEnvironmentID) extBackendID, recursive);
<span class="nc" id="L977">	}</span>

	/**
	 * Unfederates this object with an external backend instance
	 *
	 * @param extBackendID
	 *            id of the external backend to federate
	 */
	public void unfederateFromBackend(final BackendID extBackendID) {
<span class="nc" id="L986">		DataClayObject.getLib().unfederateFromBackend(this,</span>
				(ExecutionEnvironmentID) extBackendID, true);
<span class="nc" id="L988">	}</span>


	/**
	 * Unfederates this object with an external backend instance
	 *
	 * @param extBackendID
	 *            id of the external backend to federate
	 * @param recursive Indicates if unfederation is recursive or not

	 */
	public void unfederateFromBackend(final BackendID extBackendID, final boolean recursive) {
<span class="nc" id="L1000">		DataClayObject.getLib().unfederateFromBackend(this,</span>
				(ExecutionEnvironmentID) extBackendID, recursive);
<span class="nc" id="L1002">	}</span>


	/**
	 * Retrieve dataClay ID
	 * @param hostname Name of external dataclay 
	 * @param port Port of external dataclay
	 * @return ID of external dataclay
	 */
	public final DataClayInstanceID getExternalDataClayID(final String hostname, final int port) {
<span class="nc" id="L1012">		return getLib().getExternalDataClayID(hostname, port);</span>
	}


	/**
	 * Detach object from session, i.e. remove reference from current session provided to current object,
	 * &quot;dear garbage-collector, the current session is not using this object anymore&quot;
	 *
	 */
	public final void sessionDetach() {
<span class="nc" id="L1022">		getLib().detachObjectFromSession(this.getObjectID(), (ExecutionEnvironmentID) this.getHint());</span>
<span class="nc" id="L1023">	}</span>

	/**
	 * Override this function with code to be executed when a federated object arrives into a destination dataClay.
	 */
	public void whenFederated() {
<span class="nc bnc" id="L1029" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1030">			logger.debug(</span>
<span class="nc" id="L1031">					&quot;[==Federation==] Class &quot; + this.getClass().getName() + &quot; has no whenFederated behaviour defined.&quot;);</span>
		}

<span class="nc" id="L1034">	}</span>

	/**
	 * Override this function with code to be executed when a federate object is unfederated in destination dataClay.
	 */
	public void whenUnfederated() {
<span class="nc bnc" id="L1040" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1041">			logger.debug(</span>
<span class="nc" id="L1042">					&quot;[==Federation==] Class &quot; + this.getClass().getName() + &quot; has no whenUnfederated behaviour defined.&quot;);</span>
		}
<span class="nc" id="L1044">	}</span>

	@Override
	public void serialize(final DataClayByteBuffer dcBuffer, final boolean ignoreUserTypes,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps, final IdentityHashMap&lt;Object, Integer&gt; curSerializedObjs,
			final ListIterator&lt;DataClayObject&gt; pendingObjs, final ReferenceCounting referenceCounting) {

		// === reference counting information ===
		// First integer represent the position in the buffer in which reference
		// counting starts
		// this is done to avoid &quot;holding&quot; unnecessary information during a store or
		// update in disk.
		// in new serialization, this will be done through padding
		// TODO: use padding instead once new serialization is implemented (dgasull
		// pierlauro 2018)
<span class="nc" id="L1059">		dcBuffer.writeInt(0); // index is updated in the end</span>
		
		// === master location ==
<span class="nc bnc" id="L1062" title="All 2 branches missed.">		if (masterLocation != null) {</span>
<span class="nc" id="L1063">			dcBuffer.writeLong(masterLocation.getId().getLeastSignificantBits());</span>
<span class="nc" id="L1064">			dcBuffer.writeLong(masterLocation.getId().getMostSignificantBits());</span>
		} else {
<span class="nc" id="L1066">			dcBuffer.writeLong(0L);</span>
<span class="nc" id="L1067">			dcBuffer.writeLong(0L);</span>
		}

<span class="nc" id="L1070">		final List&lt;DataClaySerializable&gt; wrapFields = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1071">		this.wrapFieldsSerialization(wrapFields);</span>

		// Calculate nulls bit set size
<span class="nc" id="L1074">		final int numBytes = (int) Math.ceil(wrapFields.size() / 8.0F);</span>
<span class="nc" id="L1075">		final BitSet notNullsBitSet = new BitSet(numBytes);</span>
<span class="nc" id="L1076">		dcBuffer.writeVLQInt(numBytes);</span>
		
<span class="nc" id="L1078">		final int curWriterIndx = dcBuffer.writerIndex();</span>
<span class="nc" id="L1079">		dcBuffer.writeBytes(new byte[numBytes]);</span>
<span class="nc" id="L1080">		BitSet ifaceBitSet = null;</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">		if (ifaceBitMaps != null) {</span>
<span class="nc" id="L1082">			ifaceBitSet = BitSet.valueOf(ifaceBitMaps.get(getMetaClassID()));</span>
		}

<span class="nc bnc" id="L1085" title="All 2 branches missed.">		for (int i = 0; i &lt; wrapFields.size(); ++i) {</span>
<span class="nc bnc" id="L1086" title="All 4 branches missed.">			if (ifaceBitSet == null || ifaceBitSet.get(i)) {</span>
<span class="nc" id="L1087">				final DataClaySerializable wrappedField = wrapFields.get(i);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">				if (wrappedField == null) {</span>
<span class="nc" id="L1089">					continue;</span>
				}

<span class="nc bnc" id="L1092" title="All 2 branches missed.">				if (wrappedField instanceof DataClayJavaWrapper) {</span>
					// ====== JAVA/IMMUTABLE/GENERIC FIELD ===== //
<span class="nc" id="L1094">					final DataClayJavaWrapper javaWrapper = (DataClayJavaWrapper) wrappedField;</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">					if (javaWrapper.isNull()) {</span>
<span class="nc" id="L1096">						continue;</span>
					}
<span class="nc" id="L1098">					notNullsBitSet.set(i);</span>
<span class="nc" id="L1099">					DataClaySerializationLib.serializeJavaField(javaWrapper, dcBuffer, ignoreUserTypes, ifaceBitMaps,</span>
							curSerializedObjs, pendingObjs, referenceCounting);

<span class="nc" id="L1102">				} else {</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">					if (ignoreUserTypes) {</span>
<span class="nc" id="L1104">						continue;</span>
					}
<span class="nc" id="L1106">					final DataClayObject dcObject = (DataClayObject) wrappedField;</span>
					// ====== DCOBJECT FIELD ===== //
<span class="nc" id="L1108">					notNullsBitSet.set(i);</span>
<span class="nc" id="L1109">					DataClaySerializationLib.serializeAssociation(dcObject, dcBuffer, ignoreUserTypes, ifaceBitMaps,</span>
							curSerializedObjs, pendingObjs, referenceCounting);
				}
			}
		}

<span class="nc" id="L1115">		int curIdx = dcBuffer.writerIndex();</span>
<span class="nc" id="L1116">		dcBuffer.setWriterIndex(curWriterIndx);</span>
<span class="nc" id="L1117">		dcBuffer.writeBytes(notNullsBitSet.toByteArray());</span>
<span class="nc" id="L1118">		dcBuffer.setWriterIndex(curIdx);</span>
		// == reference counting == //
		// TODO: IMPORTANT: this should be removed in new serialization by using
		// paddings to directly access reference counters inside metadata.

<span class="nc" id="L1123">		curIdx = dcBuffer.writerIndex();</span>
<span class="nc" id="L1124">		dcBuffer.setWriterIndex(0);</span>
<span class="nc" id="L1125">		dcBuffer.writeInt(curIdx);</span>
<span class="nc" id="L1126">		dcBuffer.setWriterIndex(curIdx);</span>
<span class="nc" id="L1127">		DataClaySerializationLib.serializeReferenceCounting(this, dcBuffer, referenceCounting);</span>

<span class="nc" id="L1129">	}</span>

	@Override
	public void deserialize(final DataClayByteBuffer dcBuffer, final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps,
			final DataClayObjectMetaData metadata, final Map&lt;Integer, Object&gt; curDeserializedJavaObjs) {

		// == reference counting == //
		// see serialize function to understand why we &quot;ignore&quot; first 4 bytes
<span class="nc" id="L1137">		dcBuffer.readInt();</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">		if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1139">			DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Ignored 4 first bytes deserialized: readerindex=&quot; + dcBuffer.readerIndex());</span>
		}
		// === master location ==
<span class="nc" id="L1142">		final long masterLocationLeast = dcBuffer.readLong();</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">		if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1144">			DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Master location least bytes deserialized: data=&quot;+  masterLocationLeast + &quot;, readerindex=&quot; + dcBuffer.readerIndex());</span>
		}
<span class="nc" id="L1146">		final long masterLocationMost = dcBuffer.readLong();</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">		if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1148">			DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Master location most bytes deserialized: data=&quot;+  masterLocationMost + &quot;, readerindex=&quot; + dcBuffer.readerIndex());</span>
		}
<span class="nc bnc" id="L1150" title="All 4 branches missed.">		if (masterLocationLeast == 0L &amp;&amp; masterLocationMost == 0L) {</span>
<span class="nc" id="L1151">			masterLocation = null;</span>
		} else {
<span class="nc" id="L1153">			final UUID uuid = new UUID(masterLocationMost, masterLocationLeast);</span>
<span class="nc" id="L1154">			masterLocation = new ExecutionEnvironmentID(uuid);</span>
		}

<span class="nc" id="L1157">		final List&lt;DataClaySerializable&gt; wrapFields = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1158">		this.wrapFieldsDeserialization(wrapFields);</span>

<span class="nc" id="L1160">		BitSet notNullsBitSet = null;</span>
<span class="nc" id="L1161">		BitSet ifaceBitSet = null;</span>
<span class="nc" id="L1162">		final int notNullsBitSetLength = dcBuffer.readVLQInt();</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">		if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1164">			DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Bitmap size deserialized: data=&quot;+  notNullsBitSetLength + &quot;, readerindex=&quot; + dcBuffer.readerIndex());</span>
		}
<span class="nc bnc" id="L1166" title="All 2 branches missed.">		if (notNullsBitSetLength &gt; 0) {</span>
<span class="nc" id="L1167">			notNullsBitSet = BitSet.valueOf(dcBuffer.readBytes(notNullsBitSetLength));</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">			if (DataClayDeserializationLib.DEBUG_ENABLED) { </span>
<span class="nc" id="L1169">				DataClayDeserializationLib.LOGGER.debug(&quot;[Deserialization] --&gt; Bitmap deserialized: data=&quot;+  notNullsBitSet + &quot;, readerindex=&quot; + dcBuffer.readerIndex());</span>
			}
		}
<span class="nc bnc" id="L1172" title="All 2 branches missed.">		if (ifaceBitMaps != null) {</span>
<span class="nc" id="L1173">			ifaceBitSet = BitSet.valueOf(ifaceBitMaps.get(getMetaClassID()));</span>
		}

<span class="nc" id="L1176">		int curFieldIdx = 0;</span>
<span class="nc" id="L1177">		final Queue&lt;Object&gt; queueFields = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">		for (final DataClaySerializable wrapper : wrapFields) {</span>

<span class="nc bnc" id="L1180" title="All 4 branches missed.">			final boolean isInIface = ifaceBitSet == null || ifaceBitSet.get(curFieldIdx);</span>
<span class="nc bnc" id="L1181" title="All 4 branches missed.">			final boolean isNotNull = notNullsBitSet == null || notNullsBitSet.get(curFieldIdx);</span>
<span class="nc bnc" id="L1182" title="All 4 branches missed.">			if (isInIface &amp;&amp; isNotNull) {</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">				if (wrapper == null) {</span>
					// ====== DCOBJECT FIELD ===== //
					// Means association, no wrappers
<span class="nc" id="L1186">					final DataClayObject obj = DataClayDeserializationLib.deserializeAssociation(dcBuffer, ifaceBitMaps,</span>
<span class="nc" id="L1187">							metadata, curDeserializedJavaObjs, getLib());</span>
<span class="nc" id="L1188">					queueFields.add(obj);</span>
<span class="nc" id="L1189">				} else {</span>
					// ====== JAVA/IMMUTABLE/PRIMITIVE FIELD ===== //
<span class="nc" id="L1191">					final DataClayJavaWrapper javaWrapper = (DataClayJavaWrapper) wrapper;</span>
<span class="nc" id="L1192">					final Object javaObj = DataClayDeserializationLib.deserializeJavaField(javaWrapper, dcBuffer,</span>
							ifaceBitMaps, metadata, curDeserializedJavaObjs);
<span class="nc" id="L1194">					queueFields.add(javaObj);</span>
<span class="nc" id="L1195">				}</span>
<span class="nc bnc" id="L1196" title="All 4 branches missed.">			} else if (isInIface &amp;&amp; !isNotNull) {</span>
<span class="nc" id="L1197">				queueFields.add(null);</span>
			}

<span class="nc" id="L1200">			curFieldIdx++;</span>
<span class="nc" id="L1201">		}</span>

		// Set fields
<span class="nc" id="L1204">		this.setFieldsDeserialization(queueFields);</span>

		// == ignore rest of bytes (like reference counting) == //
		// do not clear buffer since this can be an embedded object (maybe?).

<span class="nc" id="L1209">	}</span>

	/*
	 * @Override protected void finalize() throws Throwable { if (this.isServerObject) { this.ds.gcCollectObject(this); } }
	 */

	/**
	 * Get the DataClayObject::hint
	 * 
	 * @return the hint
	 */
	public BackendID getHint() {
<span class="nc" id="L1221">		return hint;</span>
	}

	/**
	 * Set the DataClayObject::hint
	 * 
	 * @param newhint
	 *            the hint to set
	 */
	public void setHint(final BackendID newhint) {
<span class="nc" id="L1231">		this.hint = newhint;</span>
<span class="nc" id="L1232">	}</span>

	/**
	 * Clear exec stub infos cache for enrichments.
	 */
	public static final void clearExecStubInfosCache() {
<span class="nc" id="L1238">		execStubInfosCache.clear();</span>
<span class="nc" id="L1239">	}</span>

	/**
	 * Clear stub infos cache for enrichments.
	 */
	public static final void clearStubInfosCache() {
<span class="nc" id="L1245">		stubInfosCache.clear();</span>
<span class="nc" id="L1246">	}</span>

	/**
	 * Get stub information of class
	 * 
	 * @return Stub information
	 */
	public final StubInfo getStubInfo() {
<span class="nc" id="L1254">		return getStubInfoFromClass(this.getClass().getName());</span>
	}

	/**
	 * Checks if class provided is stub or not.
	 * 
	 * @param clazz
	 *            Class to check.
	 * @return True if it is an stub. False otherwise.
	 */
	public static final boolean isStub(final Class&lt;?&gt; clazz) {
		try {
<span class="nc" id="L1266">			clazz.getField(ByteCodeFieldNames.IS_STUB_FIELDNAME);</span>
<span class="nc" id="L1267">			return true;</span>
<span class="nc" id="L1268">		} catch (final NoSuchFieldException e2) {</span>
<span class="nc" id="L1269">			return false;</span>
		}
	}

	/**
	 * Get stubinfo for class with name provided
	 * 
	 * @param className
	 *            Name of the class
	 * @return Stub information.
	 */
	public static final StubInfo getStubInfoFromClass(final String className) {
<span class="nc" id="L1281">		StubInfo stubInfo = null;</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">		if (getLib().isDSLib()) {</span>
<span class="nc" id="L1283">			stubInfo = execStubInfosCache.get(className);</span>
		} else {
<span class="nc" id="L1285">			stubInfo = stubInfosCache.get(className);</span>
		}
<span class="nc bnc" id="L1287" title="All 2 branches missed.">		if (stubInfo == null) {</span>
			try {
<span class="nc" id="L1289">				Class&lt;?&gt; currentClass = null;</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">				if (getLib().isDSLib()) {</span>
<span class="nc" id="L1291">					currentClass = DataClayClassLoaderSrv.getClass(className);</span>
				} else {
<span class="nc" id="L1293">					currentClass = DataClayClassLoader.getClass(className);</span>
				}
<span class="nc" id="L1295">				final Yaml yaml = CommonYAML.getYamlObject();</span>
<span class="nc" id="L1296">				final String path = currentClass.getSimpleName() + &quot;Yaml.yaml&quot;;</span>
<span class="nc" id="L1297">				logger.debug(&quot;Loading babel stub information from &quot; + path);</span>
<span class="nc" id="L1298">				final InputStream ios = currentClass.getResourceAsStream(path);</span>
<span class="nc" id="L1299">				stubInfo = (StubInfo) yaml.load(ios);</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">				if (getLib().isDSLib()) {</span>
<span class="nc" id="L1301">					execStubInfosCache.put(className, stubInfo);</span>
				} else {
<span class="nc" id="L1303">					stubInfosCache.put(className, stubInfo);</span>
				}
<span class="nc" id="L1305">			} catch (final Exception e) {</span>
<span class="nc" id="L1306">				e.printStackTrace();</span>
<span class="nc" id="L1307">			}</span>
		}
<span class="nc" id="L1309">		return stubInfo;</span>
	}

	/**
	 * Execute remote method
	 * 
	 * @param methodSignature
	 *            Signature of the method
	 * @param implIDAsStr
	 *            ImplementationID as string
	 * @param params
	 *            Parameters to send
	 * @return Return value.
	 */
	@Override
	public Object executeRemoteImplementation(final String methodSignature, final String implIDAsStr,
			final Object[] params) {
<span class="nc" id="L1326">		return getLib().executeRemoteImplementation(this, implIDAsStr, params);</span>
	}

	@Override
	public boolean equals(final Object obj) {
<span class="nc bnc" id="L1331" title="All 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L1332">			return false;</span>
		}
<span class="nc bnc" id="L1334" title="All 2 branches missed.">		if (!(obj instanceof DataClayObject)) {</span>
<span class="nc" id="L1335">			return false;</span>
		}
<span class="nc" id="L1337">		return this.objectID.equals(((DataClayObject) obj).getObjectID());</span>

	}

	@Override
	public int hashCode() {
<span class="nc" id="L1343">		return Objects.hashCode(this.objectID);</span>
	}

	/**
	 * Get DataSetID
	 * 
	 * @return DataSetID
	 */
	public DataSetID getDataSetID() {
<span class="nc" id="L1352">		return dataSetID;</span>
	}

	/**
	 * Set object DataSetID
	 * 
	 * @param newDataSetID
	 *            ID of DataSet this object belongs to
	 */
	public void setDataSetID(final DataSetID newDataSetID) {
<span class="nc" id="L1362">		this.dataSetID = newDataSetID;</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">		if (this.isPersistent()) {</span>
<span class="nc" id="L1364">			getLib().setDataSetID(this.objectID, newDataSetID);</span>
		}
<span class="nc" id="L1366">	}</span>

	/**
	 * @return the masterLocation
	 */
	public final BackendID getMasterLocation() {
<span class="nc" id="L1372">		return masterLocation;</span>
	}

	/**
	 * If called from client side will not have any effect.
	 * 
	 * @param newMasterLocation
	 *            the masterLocation to set
	 */
	public void setMasterLocation(final BackendID newMasterLocation) {
<span class="nc" id="L1382">		this.masterLocation = newMasterLocation;</span>
<span class="nc" id="L1383">	}</span>

	/**
	 * Get alias
	 * @return the alias of the object
	 */
	public String getAlias() {
<span class="nc" id="L1390">		return alias;</span>
	}

	/**
	 * Set the alias of the object
	 * @param alias the alias of the object
	 */
	public void setAlias(String alias) {
<span class="nc" id="L1398">		this.alias = alias;</span>
<span class="nc" id="L1399">	}</span>

	/**
	 * Get if object is read only
	 * @return boolean indicating if object is read only or not
	 */
	public boolean isReadOnly() {
<span class="nc" id="L1406">		return isReadOnly;</span>
	}

	/**
	 * Set if object is read only
	 * @param readOnly boolean indicating if object is read only or not
	 */
	public void setReadOnly(boolean readOnly) {
<span class="nc" id="L1414">		this.isReadOnly = readOnly;</span>
<span class="nc" id="L1415">	}</span>


	/**
	 * @return the original object id in case of new version
	 */
	public final ObjectID getOriginalObjectID() {
<span class="nc" id="L1422">		return this.originalObjectID;</span>
	}

	/**
	 *
	 * @param newOriginalObjectID
	 *            the original object id  to set
	 */
	public void setOriginalObjectID(final ObjectID newOriginalObjectID) {
<span class="nc" id="L1431">		this.originalObjectID = newOriginalObjectID;</span>
<span class="nc" id="L1432">	}</span>

	/**
	 *
	 * @return root location of the object or null if current is original
	 */
	public ExecutionEnvironmentID getRootLocation() {
<span class="nc" id="L1439">		return rootLocation;</span>
	}

	/**
	 * Set root location of the object
	 * @param rootLocation root location to set
	 */
	public void setRootLocation(ExecutionEnvironmentID rootLocation) {
<span class="nc" id="L1447">		this.rootLocation = rootLocation;</span>
<span class="nc" id="L1448">	}</span>

	/**
	 *
	 * @return origin location of the object or null if current is original
	 */
	public ExecutionEnvironmentID getOriginLocation() {
<span class="nc" id="L1455">		return originLocation;</span>
	}

	/**
	 * Set origin location of the object
	 * @param originLocation origin location to set
	 */
	public void setOriginLocation(ExecutionEnvironmentID originLocation) {
<span class="nc" id="L1463">		this.originLocation = originLocation;</span>
<span class="nc" id="L1464">	}</span>

	/**
	 * Get all replica locations
	 * @return Replica locations
	 */
	public Set&lt;ExecutionEnvironmentID&gt; getReplicaLocations() {
<span class="nc" id="L1471">		return replicaLocations;</span>
	}

	/**
	 * Set replica locations
	 * @param replicaLocations replica locations to set
	 */
	public void setReplicaLocations(Set&lt;ExecutionEnvironmentID&gt; replicaLocations) {
<span class="nc" id="L1479">		this.replicaLocations = replicaLocations;</span>
<span class="nc" id="L1480">	}</span>

	/**
	 * Add replica location
	 * @param replicaLocation replica location to add
	 */
	public void addReplicaLocations(ExecutionEnvironmentID replicaLocation) {
<span class="nc bnc" id="L1487" title="All 2 branches missed.">		if (this.replicaLocations == null) {</span>
<span class="nc" id="L1488">			this.replicaLocations = ConcurrentHashMap.newKeySet();</span>
		}
<span class="nc" id="L1490">		this.replicaLocations.add(replicaLocation);</span>
<span class="nc" id="L1491">	}</span>

	/**
	 * Remove replica location
	 * @param replicaLocation replica location to add
	 */
	public void removeReplicaLocation(ExecutionEnvironmentID replicaLocation) {
<span class="nc" id="L1498">		this.replicaLocations.remove(replicaLocation);</span>
<span class="nc" id="L1499">	}</span>

	/**
	 * Clear replica locations
	 */
	public void clearReplicaLocations() {
<span class="nc" id="L1505">		this.replicaLocations.clear();</span>
<span class="nc" id="L1506">	}</span>

	/**
	 * @return true if masterlocation is the current backend, false otherwise
	 */
	public final boolean isMasterLocation() {
<span class="nc bnc" id="L1512" title="All 2 branches missed.">		if (masterLocation != null) {</span>
<span class="nc" id="L1513">			return masterLocation.equals(DataClayObject.getLib().getHint());</span>
		}
<span class="nc" id="L1515">		return false;</span>
	}

	/**
	 * @return id of the external dataClay instance where the object resides. null if it is local.
	 */
	public DataClayInstanceID getExternalDataClayID() {
<span class="nc" id="L1522">		return externalDataClayID;</span>
	}

	/**
	 * @param newID
	 *            id of the external dataClay instance
	 */
	public void setExternalDataClayID(final DataClayInstanceID newID) {
<span class="nc" id="L1530">		this.externalDataClayID = newID;</span>
<span class="nc" id="L1531">	}</span>
	
	/**
	 * RT PREFETCHING FIELDS
	 */
	
	public boolean isPrefetchingAccess() {
<span class="nc" id="L1538">		return isPrefetchingAccess;</span>
	}
	
	public static void setPrefetchingAccess(final boolean value) {
<span class="nc" id="L1542">		isPrefetchingAccess = value;</span>
<span class="nc" id="L1543">	}</span>
	
	public static long getAccessCount() {
<span class="nc" id="L1546">		return accessCount;</span>
	}
	
	public static long getHitCount() {
<span class="nc" id="L1550">		return hitCount;</span>
	}
	
	protected void incrementAccessCount() {
<span class="nc" id="L1554">		accessCount++;</span>
<span class="nc" id="L1555">	}</span>

	protected void incrementHitCount() {
<span class="nc" id="L1558">		hitCount++;</span>
<span class="nc" id="L1559">	}</span>
	
	public static void resetObjectAccessStats() {
<span class="nc" id="L1562">		accessCount = 0;</span>
<span class="nc" id="L1563">		hitCount = 0;</span>
<span class="nc" id="L1564">	}</span>

	public static void printObjectAccessStats() {
<span class="nc" id="L1567">		logger.debug(&quot;[==PerfetchingInfo==] Object Hit Ratio: &quot;</span>
				+ (double)hitCount / (double)accessCount
				+ &quot;(&quot; + hitCount + &quot;/&quot; + accessCount + &quot;)&quot;);
<span class="nc" id="L1570">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>