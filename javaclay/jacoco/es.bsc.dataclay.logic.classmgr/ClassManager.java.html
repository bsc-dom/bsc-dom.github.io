<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.logic.classmgr</a> &gt; <span class="el_source">ClassManager.java</span></div><h1>ClassManager.java</h1><pre class="source lang-java linenums">
/**
 * @file ClassManager.java
 * @date Sep 6, 2012
 */

package es.bsc.dataclay.logic.classmgr;

import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import es.bsc.dataclay.DataClayObject;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.exceptions.DataClayRuntimeException;
import es.bsc.dataclay.exceptions.ErrorDefs.ERRORCODE;
import es.bsc.dataclay.exceptions.dbhandler.DbHandlerException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.ClassInIncludesException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.ClassNotExistsException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.ImplementationNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.NoMoreImplementationsInOperationException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.OperationAlreadyInClassException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.OperationNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.OperationNotInClassException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.PropertyAlreadyInClassException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.PropertyNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.PropertyNotInClassException;
import es.bsc.dataclay.exceptions.logicmodule.classmgr.SetterOrGetterOperationsCannotBeRemoved;
import es.bsc.dataclay.logic.classmgr.bytecode.java.ByteCodeConstants;
import es.bsc.dataclay.logic.classmgr.bytecode.java.ExecutionByteCodeManager;
import es.bsc.dataclay.logic.classmgr.bytecode.java.StubByteCodeManager;
import es.bsc.dataclay.logic.classmgr.bytecode.java.merger.ByteCodeMerger;
import es.bsc.dataclay.logic.classmgr.bytecode.pysrc.StubPySourceManager;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.NamespaceID;
import es.bsc.dataclay.util.ids.OperationID;
import es.bsc.dataclay.util.ids.PropertyID;
import es.bsc.dataclay.util.management.AbstractManager;
import es.bsc.dataclay.util.management.classmgr.AccessedImplementation;
import es.bsc.dataclay.util.management.classmgr.AccessedProperty;
import es.bsc.dataclay.util.management.classmgr.Implementation;
import es.bsc.dataclay.util.management.classmgr.MetaClass;
import es.bsc.dataclay.util.management.classmgr.Operation;
import es.bsc.dataclay.util.management.classmgr.PrefetchingInformation;
import es.bsc.dataclay.util.management.classmgr.Property;
import es.bsc.dataclay.util.management.classmgr.Type;
import es.bsc.dataclay.util.management.classmgr.UserType;
import es.bsc.dataclay.util.management.classmgr.features.Feature;
import es.bsc.dataclay.util.management.classmgr.features.LanguageFeature;
import es.bsc.dataclay.util.management.classmgr.features.QualitativeFeature;
import es.bsc.dataclay.util.management.classmgr.features.QuantitativeFeature;
import es.bsc.dataclay.util.management.classmgr.features.Feature.FeatureType;
import es.bsc.dataclay.util.management.classmgr.java.JavaImplementation;
import es.bsc.dataclay.util.management.classmgr.java.JavaOperationInfo;
import es.bsc.dataclay.util.management.stubs.StubInfo;
import es.bsc.dataclay.util.reflection.Reflector;
import es.bsc.dataclay.util.structs.MemoryCache;
import es.bsc.dataclay.util.structs.Triple;
import es.bsc.dataclay.util.structs.Tuple;
import es.bsc.dataclay.dbhandler.sql.sqlite.SQLiteDataSource;

/**
 * This class is responsible to manage Classes, Operations, Properties and
 * Implementations, and Properties: add, remove and modify.
 * 
 * @version 2.0
 */
public final class ClassManager extends AbstractManager {
<span class="fc" id="L83">	private static final Logger logger = LogManager.getLogger(&quot;managers.ClassManager&quot;);</span>

	/** Indicates if debug is enabled. */
<span class="fc" id="L86">	protected static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

	/** Prefix of the getters created in a Stub. */
	public static final String GETTER_PREFIX = &quot;$$get&quot;;
	/** Prefix of the setters created in a Stub. */
	public static final String SETTER_PREFIX = &quot;$$set&quot;;

	/** Class cache. */
	private final MemoryCache&lt;MetaClassID, MetaClass&gt; classCache;
	/** Class cache by name and namespace id. */
	private final MemoryCache&lt;Tuple&lt;NamespaceID, String&gt;, MetaClass&gt; classCacheByName;
	/** Class cache by name and namespace. */
	private final MemoryCache&lt;Tuple&lt;String, String&gt;, MetaClass&gt; classCacheByNameAndNamespace;
	/** Operations cache. */
	private final MemoryCache&lt;OperationID, Operation&gt; operationsCache;
	/** Implementations cache. */
	private final MemoryCache&lt;ImplementationID, Implementation&gt; implementationsCache;
	/** Properties cache. */
	private final MemoryCache&lt;PropertyID, Property&gt; propertiesCache;

	/** DbHandler for the management of Database. */
	private final ClassManagerDB classDB;

	/** Cache of Stubs. */
	private final MemoryCache&lt;StubInfo, Triple&lt;String, byte[], byte[]&gt;&gt; stubsCache;

	/**
	 * Instantiates an Class Manager that uses the Backend configuration
	 *        provided.
	 * @param dataSource data source
	 * @post Creates an Class manager and hash initializes the backend.
	 */
	public ClassManager(final SQLiteDataSource dataSource) {
<span class="fc" id="L119">		super(dataSource);</span>
<span class="fc" id="L120">		classCache = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L121">		classCacheByName = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L122">		classCacheByNameAndNamespace = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L123">		operationsCache = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L124">		propertiesCache = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L125">		implementationsCache = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L126">		stubsCache = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L127">		this.classDB = new ClassManagerDB(dataSource);</span>
<span class="fc" id="L128">		this.classDB.createTables();</span>
<span class="fc" id="L129">	}</span>

	/**
	 * Empty caches of all references to the class with id provided or
	 *        operations and properties associated.
	 * @param classID
	 *            ID of class to analyze
	 */
	private void emptyClassInCaches(final MetaClassID classID) {
		// IMPORTANT: elements updated must be removed from Cache since references
		// obtained and modified
		// (like operations) are not same references than the ones in cache and CHANGES
		// ARE NOT REFLECTED.
<span class="fc" id="L142">		final MetaClass mClass = getClassFromDatabaseOrCache(classID);</span>
<span class="fc" id="L143">		this.classCacheByName.remove(new Tuple&lt;&gt;(mClass.getNamespaceID(), mClass.getName()));</span>
<span class="fc" id="L144">		classCache.remove(classID);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">		for (final Operation op : mClass.getOperations()) {</span>
<span class="fc" id="L146">			operationsCache.remove(op.getDataClayID());</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">			for (final Implementation impl : op.getImplementations()) {</span>
<span class="fc" id="L148">				implementationsCache.remove(impl.getDataClayID());</span>
<span class="fc" id="L149">			}</span>
<span class="fc" id="L150">		}</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">		for (final Property prop : mClass.getProperties()) {</span>
<span class="fc" id="L152">			propertiesCache.remove(prop.getDataClayID());</span>
<span class="fc" id="L153">		}</span>
<span class="fc" id="L154">	}</span>

	/**
	 * Get a MetaClass from cache or database
	 * @param classID
	 *            ID of the class
	 * @return The MetaClass with ID provided
	 */
	private MetaClass getClassFromDatabaseOrCache(final MetaClassID classID) {
<span class="fc" id="L163">		MetaClass mClass = classCache.get(classID);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">		if (mClass == null) {</span>
<span class="fc" id="L165">			mClass = classDB.getMetaClassByID(classID);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">			if (mClass == null) {</span>
<span class="nc" id="L167">				throw new ClassNotExistsException(classID);</span>
			} else {
<span class="fc" id="L169">				classCache.put(classID, mClass);</span>
			}
		}
<span class="fc" id="L172">		return mClass;</span>
	}

	/**
	 * Get a Operation from cache or database
	 * @param operationID
	 *            ID of the Operation
	 * @return The Operation with ID provided
	 */
	private Operation getOperationFromDatabaseOrCache(final OperationID operationID) {
<span class="fc" id="L182">		Operation op = operationsCache.get(operationID);</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		if (op == null) {</span>
<span class="fc" id="L184">			op = classDB.getOperationByID(operationID);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">			if (op == null) {</span>
<span class="fc" id="L186">				throw new OperationNotExistException(operationID);</span>
			} else {
<span class="fc" id="L188">				operationsCache.put(operationID, op);</span>
			}
		}

<span class="fc" id="L192">		return op;</span>
	}

	/**
	 * Get a Implementation from cache or database
	 * @param implementationID
	 *            ID of the Implementation
	 * @return The Implementation with ID provided
	 */
	private Implementation getImplementationFromDatabaseOrCache(final ImplementationID implementationID) {
<span class="nc" id="L202">		Implementation impl = implementationsCache.get(implementationID);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">		if (impl == null) {</span>
<span class="nc" id="L204">			impl = classDB.getImplementationByID(implementationID);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">			if (impl == null) {</span>
<span class="nc" id="L206">				throw new ImplementationNotExistException(implementationID);</span>
			} else {
<span class="nc" id="L208">				implementationsCache.put(implementationID, impl);</span>
			}
		}
<span class="nc" id="L211">		return impl;</span>
	}

	/**
	 * Get a Property from cache or database
	 * @param propertyID
	 *            ID of the Property
	 * @return The Property with ID provided
	 */
	private Property getPropertyFromDatabaseOrCache(final PropertyID propertyID) {
<span class="nc" id="L221">		Property prop = propertiesCache.get(propertyID);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">		if (prop == null) {</span>
<span class="nc" id="L223">			prop = classDB.getPropertyByID(propertyID);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">			if (prop == null) {</span>
<span class="nc" id="L225">				throw new PropertyNotExistException(propertyID);</span>
			} else {
<span class="nc" id="L227">				propertiesCache.put(propertyID, prop);</span>
			}
		}

<span class="nc" id="L231">		return prop;</span>
	}

	// ============== Classes ==============//

	/**
	 * Creates a new class with specifications and IDs provided
	 * @param accountID
	 *            ID of the account registering the class to associate it with the
	 *            getters and setters implfaementations
	 * @param namespaceID
	 *            ID of the namespace of the new class
	 * @param namespace
	 *            Namespace of the class
	 * @param metaClass
	 *            ifications of the new class
	 * @param lang
	 *            Language of the class
	 * @return Information about the new class created with all the IDs.
	 */
	private MetaClass newClassInternal(final AccountID accountID, final NamespaceID namespaceID, final String namespace,
			final MetaClass metaClass, final Langs lang) {

		// If there are properties
<span class="nc bnc" id="L255" title="All 2 branches missed.">		for (final Property prop : metaClass.getProperties()) {</span>

			// if (lang.equals(Langs.LANG_JAVA)) {
			// We create the Getter Operation
<span class="nc" id="L259">			final Tuple&lt;Operation, Implementation&gt; newGetterOperationAndImpl = newGetterOperation(prop.getName(),</span>
<span class="nc" id="L260">					metaClass, prop.getType(), prop.getDataClayID(), namespaceID, accountID, lang);</span>
<span class="nc" id="L261">			final Operation newGetterOperation = newGetterOperationAndImpl.getFirst();</span>
<span class="nc" id="L262">			final Implementation newGetterImplementation = newGetterOperationAndImpl.getSecond();</span>
			// We create the Setter Operation
<span class="nc" id="L264">			final Tuple&lt;Operation, Implementation&gt; newSetterOperationAndImpl = newSetterOperation(prop.getName(),</span>
<span class="nc" id="L265">					metaClass, prop.getType(), prop.getDataClayID(), namespaceID, accountID, lang);</span>
<span class="nc" id="L266">			final Operation newSetterOperation = newSetterOperationAndImpl.getFirst();</span>
			// We create the update Operation

<span class="nc bnc" id="L269" title="All 2 branches missed.">			if (prop.isReplicated()) {</span>
<span class="nc" id="L270">				final Tuple&lt;Operation, Implementation&gt; newupdateOperationAndImpl = newSetterOperation(</span>
<span class="nc" id="L271">						ByteCodeConstants.DATACLAY_UPDATE + prop.getName(), metaClass, prop.getType(),</span>
<span class="nc" id="L272">						prop.getDataClayID(), namespaceID, accountID, lang);</span>
<span class="nc" id="L273">				prop.setUpdateImplementationID(newupdateOperationAndImpl.getSecond().getDataClayID());</span>
<span class="nc" id="L274">				prop.setUpdateOperationID(newupdateOperationAndImpl.getFirst().getDataClayID());</span>
<span class="nc" id="L275">				metaClass.addOperation(newupdateOperationAndImpl.getFirst());</span>

			}

<span class="nc" id="L279">			prop.setGetterOperationID(newGetterOperation.getDataClayID());</span>
<span class="nc" id="L280">			prop.setSetterOperationID(newSetterOperation.getDataClayID());</span>
<span class="nc" id="L281">			prop.setGetterImplementationID(newGetterImplementation.getDataClayID());</span>
<span class="nc" id="L282">			prop.setSetterImplementationID(newSetterOperationAndImpl.getSecond().getDataClayID());</span>

<span class="nc" id="L284">			metaClass.addOperation(newGetterOperation);</span>
<span class="nc" id="L285">			metaClass.addOperation(newSetterOperation);</span>
			// }

<span class="nc" id="L288">		}</span>

		// Set namespace
<span class="nc" id="L291">		metaClass.setNamespace(namespace);</span>

		// Fill caches
<span class="nc" id="L294">		classCache.put(metaClass.getDataClayID(), metaClass);</span>
<span class="nc" id="L295">		classCacheByName.put(new Tuple&lt;&gt;(metaClass.getNamespaceID(), metaClass.getName()), metaClass);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">		for (final Property newProp : metaClass.getProperties()) {</span>
<span class="nc" id="L297">			propertiesCache.put(newProp.getDataClayID(), newProp);</span>
<span class="nc" id="L298">		}</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">		for (final Operation newOperation : metaClass.getOperations()) {</span>
			// we create the Implementation in the System.
<span class="nc" id="L301">			int curImplPos = 0;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">			for (final Implementation newImplementation : newOperation.getImplementations()) {</span>
<span class="nc" id="L303">				newImplementation.setPosition(curImplPos);</span>
<span class="nc" id="L304">				implementationsCache.put(newImplementation.getDataClayID(), newImplementation);</span>
<span class="nc" id="L305">				curImplPos++;</span>
<span class="nc" id="L306">			}</span>
<span class="nc" id="L307">			operationsCache.put(newOperation.getDataClayID(), newOperation);</span>
<span class="nc" id="L308">		}</span>

		// We store now the new Metaclass on the Database
<span class="nc" id="L311">		classDB.storeMetaClass(metaClass);</span>

<span class="nc" id="L313">		logger.info(&quot;Registered class {} in namespace {} with ID {}&quot;, metaClass.getName(), namespace,</span>
<span class="nc" id="L314">				metaClass.getDataClayID());</span>

<span class="nc" id="L316">		return metaClass;</span>

	}

	/**
	 * Apply new enrichment to class specified
	 * @param newEnrichmentClass
	 *            Enrichment metaclass information
	 */
	public void newJavaEnrichment(final MetaClass newEnrichmentClass) {

		// Get original class
<span class="nc" id="L328">		final MetaClass originalClass = getMetaClassByName(newEnrichmentClass.getNamespaceID(),</span>
<span class="nc" id="L329">				newEnrichmentClass.getName());</span>
<span class="nc" id="L330">		final byte[] originalByteCode = originalClass.getJavaClassInfo().getClassByteCode();</span>
<span class="nc" id="L331">		final byte[] enrichmentByteCode = newEnrichmentClass.getJavaClassInfo().getClassByteCode();</span>

<span class="nc" id="L333">		final byte[] newBytecode = ByteCodeMerger.mergeByteCodes(originalByteCode, enrichmentByteCode);</span>
<span class="nc" id="L334">		originalClass.getJavaClassInfo().setClassByteCode(newBytecode);</span>

		// Update it
		try {
<span class="nc" id="L338">			classDB.updateJavaClassByteCode(originalClass.getJavaClassInfo().getId(), newBytecode);</span>
<span class="nc" id="L339">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L340">			throw new DbHandlerException(e.getMessage());</span>

<span class="nc" id="L342">		}</span>
<span class="nc" id="L343">	}</span>

	/**
	 * This operation creates a new MetaClass in the Namespace specified by
	 *        namespaceID using the provided specifications.
	 * @param accountID
	 *            ID of the account registering the class for associating it with
	 *            implementations of setters and getters
	 * @param namespaceID
	 *            ID of the namespace within we will create the MetaClass
	 * @param namespace
	 *            Namespace of the class
	 * @param metaClass
	 *            New Class specifications
	 * @param lang
	 *            Language of the class
	 * @pre All IDs provided do not have object reference. The namespace identified
	 *      by namespaceID exists and is correct. The metaClassSpec provided does
	 *      not have more than one property with same name and no more than one
	 *      operation with same name, parameter type names and return type names.
	 * @post A MetaClass with the specification provided is created
	 * @return All information of the new MetaClass if it was successfully created.
	 */
	public MetaClass newClass(final AccountID accountID, final NamespaceID namespaceID, final String namespace,
			final MetaClass metaClass, final Langs lang) {
<span class="nc" id="L368">		return newClassInternal(accountID, namespaceID, namespace, metaClass, lang);</span>
	}

	/**
	 * This function removes the MetaClass identified by metaClassID. It also
	 *        remove its associated operations, properties, implementations and
	 *        types.
	 * @param metaClassID
	 *            ID of the MetaClass of the Property to remove
	 * @pre All IDs provided do not have object reference.
	 * @pre The class exists
	 */
	public void removeClass(final MetaClassID metaClassID) {
		// First we must get the MetaClass
<span class="nc" id="L382">		final MetaClass metaclass = getClassFromDatabaseOrCache(metaClassID);</span>
		// Now we can remove the MetaClass.
<span class="nc" id="L384">		classDB.deleteClass(metaclass.getDataClayID());</span>
		// Remove from cache
		// this.metaClassCache.remove(metaClassID);
		/*
		 * for (Operation op : metaclass.getOperations()) {
		 * this.operationsCache.remove(op.getID()); for (Implementation impl :
		 * op.getImplementations()) { this.implementationsCache.remove(impl.getID()); }
		 * }
		 */
<span class="nc" id="L393">	}</span>

	/**
	 * This operation verifies if the namespace provided has some class
	 *        associated in the System.
	 * @param namespaceID
	 *            ID of the namespace
	 * @pre All IDs provided do not have object reference.
	 * @return TRUE if the provided Namespace has no classes in the database.FALSE
	 *         otherwise.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 * @note When you delete a MetaClass its namespaceID associated is deleted. Keep
	 *       in mind that a namespaceID associated to the MetaClass has no object
	 *       reference and can be replicated.
	 */
	public boolean checkNamespaceHasNothing(final NamespaceID namespaceID) {
<span class="nc" id="L410">		final boolean exists = classDB.existsClassInNamespace(namespaceID);</span>
		// If exists return false. True, otherwise.
<span class="nc bnc" id="L412" title="All 2 branches missed.">		return !exists;</span>
	}

	// ============== Properties =============//

	/**
	 * This operation creates a new Property in the System, its Types
	 *        specified and associates it to the MetaClass identified by the
	 *        metaClassID provided. It also creates new Getter and Setter Operations
	 *        for the Property provided.
	 * @pre All IDs provided do not have object reference. The propertySpec provided
	 *      has an associated TypeSpec. The TypeSpec indicates if it is primitive or
	 *      not, and must indicates its name.
	 * @param accountID
	 *            ID of the account registering the property to be associated with
	 *            the corresponding setter and getter implementations
	 * @param namespaceID
	 *            ID of the namespace in which the property is created
	 * @param newProperty
	 *            Specifications of the Property to add
	 * @param metaClassID
	 *            ID of the MetaClass that will contain the Property
	 * @post 1.- A Property with the specifications provided is created. &lt;br&gt;
	 *       2.- The Property is associated to the MetaClass provided. &lt;br&gt;
	 *       3.- The MetaClass is updated.
	 * @return information of the new Property.
	 */
	public Property newProperty(final AccountID accountID, final NamespaceID namespaceID, final MetaClassID metaClassID,
			final Property newProperty) {

		// We get the MetaClass in which to add the Property.
<span class="fc" id="L443">		final MetaClass clazz = getClassFromDatabaseOrCache(metaClassID);</span>

		// verify that no other Property with same name exists
<span class="fc bfc" id="L446" title="All 2 branches covered.">		if (clazz.existsPropertyInClass(newProperty.getName())) {</span>
<span class="fc" id="L447">			throw new PropertyAlreadyInClassException(newProperty.getName(), clazz.getDataClayID());</span>
		}

		// static final properties have no getter nor setter
		// We create the Getter Operation

		// TODO: ATTENTION! LANGUAGE OF GETTER IS ONLY JAVA BECAUSE NO ENRICHMENT IN
		// PYTHON
<span class="fc" id="L455">		final Tuple&lt;Operation, Implementation&gt; newGetterOperationAndImpl = newGetterOperation(newProperty.getName(),</span>
<span class="fc" id="L456">				clazz, newProperty.getType(), newProperty.getDataClayID(), namespaceID, accountID, Langs.LANG_JAVA);</span>
<span class="fc" id="L457">		final Operation newGetterOperation = newGetterOperationAndImpl.getFirst();</span>
<span class="fc" id="L458">		final Implementation newGetterImplementation = newGetterOperationAndImpl.getSecond();</span>

		// We create the Setter Operation
<span class="fc" id="L461">		final Tuple&lt;Operation, Implementation&gt; newSetterOperationAndImpl = newSetterOperation(newProperty.getName(),</span>
<span class="fc" id="L462">				clazz, newProperty.getType(), newProperty.getDataClayID(), namespaceID, accountID, Langs.LANG_JAVA);</span>
<span class="fc" id="L463">		final Operation newSetterOperation = newSetterOperationAndImpl.getFirst();</span>

		// We create the update Operation

<span class="fc" id="L467">		newProperty.setSetterOperationID(newSetterOperation.getDataClayID());</span>
<span class="fc" id="L468">		newProperty.setGetterOperationID(newGetterOperation.getDataClayID());</span>
<span class="fc" id="L469">		newProperty.setGetterImplementationID(newGetterImplementation.getDataClayID());</span>
<span class="fc" id="L470">		newProperty.setSetterImplementationID(newSetterOperationAndImpl.getSecond().getDataClayID());</span>
<span class="fc" id="L471">		newProperty.setNamespaceID(namespaceID);</span>

		// We add the PropertyID to the MetaClass obtained before
<span class="fc" id="L474">		clazz.addOperation(newGetterOperation);</span>
<span class="fc" id="L475">		clazz.addOperation(newSetterOperation);</span>
<span class="fc" id="L476">		clazz.addPropertyAsEnrichment(newProperty);</span>

<span class="fc" id="L478">		Operation newUpdateOperation = null;</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">		if (newProperty.isReplicated()) {</span>
<span class="nc" id="L480">			final Tuple&lt;Operation, Implementation&gt; newUpdateOperationAndImpl = newSetterOperation(</span>
<span class="nc" id="L481">					ByteCodeConstants.DATACLAY_UPDATE + newProperty.getName(), clazz, newProperty.getType(),</span>
<span class="nc" id="L482">					newProperty.getDataClayID(), namespaceID, accountID, Langs.LANG_JAVA);</span>
<span class="nc" id="L483">			newUpdateOperation = newUpdateOperationAndImpl.getFirst();</span>
<span class="nc" id="L484">			newProperty.setUpdateImplementationID(newUpdateOperationAndImpl.getSecond().getDataClayID());</span>
<span class="nc" id="L485">			newProperty.setUpdateOperationID(newUpdateOperation.getDataClayID());</span>
<span class="nc" id="L486">			clazz.addOperation(newUpdateOperation);</span>
		}

		try {

<span class="fc" id="L491">			classDB.updateClassPropertiesAndOperations(clazz.getDataClayID(), newProperty, newSetterOperation,</span>
					newGetterOperation, newUpdateOperation);

<span class="fc" id="L494">			classDB.updateJavaClassByteCode(clazz.getJavaClassInfo().getId(),</span>
<span class="fc" id="L495">					clazz.getJavaClassInfo().getClassByteCode());</span>
<span class="fc" id="L496">			emptyClassInCaches(clazz.getDataClayID());</span>

<span class="nc" id="L498">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L499">			throw new DbHandlerException(e.getMessage());</span>
<span class="fc" id="L500">		}</span>

<span class="fc" id="L502">		return newProperty;</span>

	}

	/**
	 * This function creates an implementation for the Getter property
	 *        operations.
	 * @param propName
	 *            Name of the property to get
	 * @param metaClass
	 *            MetaClass containing the Property
	 * @param returnType
	 *            Return Type of the getter.
	 * @param propertyID
	 *            Accessed propertyID
	 * @param originalNamespaceID
	 *            ID of the namespace in which the operation must be created
	 * @param responsibleOfProperty
	 *            ID of the account that registered the property
	 * @param lang
	 *            language of setter
	 * @return The Operation of the Getter Operation for the Property specified.
	 * 
	 */
	private Tuple&lt;Operation, Implementation&gt; newGetterOperation(final String propName, final MetaClass metaClass,
			final Type returnType, final PropertyID propertyID, final NamespaceID originalNamespaceID,
			final AccountID responsibleOfProperty, final Langs lang) {

<span class="fc" id="L530">		String opNameAndDescriptor = null;</span>
<span class="fc" id="L531">		String getterDesc = null;</span>
<span class="fc" id="L532">		String getterSignature = null;</span>

<span class="pc bpc" id="L534" title="1 of 2 branches missed.">		if (lang.equals(Langs.LANG_JAVA)) {</span>
			// TODO: Fix Python side to use signatures
<span class="fc" id="L536">			opNameAndDescriptor = GETTER_PREFIX + propName + &quot;()&quot; + returnType.getDescriptor();</span>
		} else {
<span class="nc" id="L538">			opNameAndDescriptor = GETTER_PREFIX + propName;</span>
		}

<span class="fc" id="L541">		getterDesc = &quot;()&quot; + returnType.getDescriptor();</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">		if (returnType.getSignature() != null) {</span>
<span class="fc" id="L543">			getterSignature = &quot;()&quot; + returnType.getSignature();</span>
		}
<span class="fc" id="L545">		final Operation getter = new Operation(GETTER_PREFIX + propName, getterDesc, getterSignature,</span>
<span class="fc" id="L546">				opNameAndDescriptor, metaClass.getNamespace(), metaClass.getName(), false);</span>
<span class="fc" id="L547">		getter.setMetaClassID(metaClass.getDataClayID());</span>
<span class="fc" id="L548">		getter.setDataClayID(new OperationID());</span>
<span class="fc" id="L549">		getter.setNamespaceID(metaClass.getNamespaceID());</span>
<span class="fc" id="L550">		final JavaOperationInfo javaOpInfo = new JavaOperationInfo(Modifier.PUBLIC);</span>
<span class="fc" id="L551">		getter.addLanguageDepInfo(javaOpInfo);</span>
<span class="fc" id="L552">		getter.setDataClayID(new OperationID());</span>

<span class="fc" id="L554">		final List&lt;AccessedProperty&gt; accessedProperties = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L555">		final AccessedProperty accProp = new AccessedProperty(metaClass.getNamespace(), metaClass.getName(), propName);</span>
<span class="fc" id="L556">		accProp.setPropertyID(propertyID);</span>
<span class="fc" id="L557">		accessedProperties.add(accProp);</span>

<span class="fc" id="L559">		final List&lt;Type&gt; includedTypes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">		if (returnType instanceof UserType) {</span>
<span class="fc" id="L561">			includedTypes.add(returnType);</span>
		}

		// IMPORTANT: GETTERS AND SETTERS CODE IS GENERATED WHILE CREATING
		// EXECUTION/STUBS CLASSES
<span class="fc" id="L566">		final Implementation implementation = new JavaImplementation(0, accessedProperties,</span>
				new ArrayList&lt;AccessedImplementation&gt;(), includedTypes, new PrefetchingInformation(),
				new HashMap&lt;FeatureType, QuantitativeFeature&gt;(), new HashMap&lt;FeatureType, QualitativeFeature&gt;(),
<span class="fc" id="L569">				metaClass.getNamespace(), metaClass.getName(), getter.getNameAndDescriptor());</span>

<span class="fc" id="L571">		implementation.setDataClayID(new ImplementationID());</span>
<span class="fc" id="L572">		implementation.setMetaClassID(metaClass.getDataClayID());</span>
<span class="fc" id="L573">		implementation.setNamespaceID(metaClass.getNamespaceID());</span>
<span class="fc" id="L574">		implementation.setOperationID(getter.getDataClayID());</span>
<span class="fc" id="L575">		implementation.setResponsibleAccountID(responsibleOfProperty);</span>

		// TODO: required feature for now in getter operations is Java 1.8
<span class="fc" id="L578">		implementation.getRequiredQualitativeFeatures().put(FeatureType.LANGUAGE, new LanguageFeature(&quot;Java&quot;, &quot;1.8&quot;));</span>
<span class="fc" id="L579">		getter.addImplementation(implementation);</span>
<span class="fc" id="L580">		getter.setReturnType(returnType);</span>

<span class="fc" id="L582">		return new Tuple&lt;&gt;(getter, implementation);</span>
	}

	/**
	 * This function creates an implementation for the Setter property
	 *        operations.
	 * @param propName
	 *            Name of the property to set
	 * @param metaClass
	 *            MetaClass containing the Property
	 * @param paramType
	 *            Param Type of the setter.
	 * @param propertyID
	 *            Accessed propertyID
	 * @param originalNamespaceID
	 *            ID of the namespace in which the operation must be created
	 * @param lang
	 *            language of setter
	 * @param responsibleOfProperty
	 *            ID of the account that registered the property
	 * @return The Operation of the Setter Operation for the Property specified.
	 */
	private Tuple&lt;Operation, Implementation&gt; newSetterOperation(final String propName, final MetaClass metaClass,
			final Type paramType, final PropertyID propertyID, final NamespaceID originalNamespaceID,
			final AccountID responsibleOfProperty, final Langs lang) {

<span class="fc" id="L608">		String opNameAndDescriptor = null;</span>

<span class="pc bpc" id="L610" title="1 of 2 branches missed.">		if (lang.equals(Langs.LANG_JAVA)) {</span>
			// TODO: Fix Python side to use signatures
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">			if (propName.contains(ByteCodeConstants.DATACLAY_UPDATE)) {</span>
<span class="nc" id="L613">				opNameAndDescriptor = SETTER_PREFIX + propName + &quot;(&quot; + paramType.getDescriptor()</span>
						+ &quot;Ljava/lang/Boolean;)V&quot;;
			} else {
<span class="fc" id="L616">				opNameAndDescriptor = SETTER_PREFIX + propName + &quot;(&quot; + paramType.getDescriptor() + &quot;)V&quot;;</span>
			}
		} else {
<span class="nc" id="L619">			opNameAndDescriptor = SETTER_PREFIX + propName;</span>
		}

<span class="fc" id="L622">		final String setterDesc = &quot;()&quot; + &quot;(&quot; + paramType.getDescriptor() + &quot;)V&quot;;</span>
<span class="fc" id="L623">		String setterSignature = null;</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">		if (paramType.getSignature() != null) {</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">			if (propName.contains(ByteCodeConstants.DATACLAY_UPDATE)) {</span>
<span class="nc" id="L626">				setterSignature = &quot;(&quot; + paramType.getSignature()</span>
					+ &quot;Ljava/lang/Boolean;)V&quot;;
			} else {
<span class="fc" id="L629">				setterSignature = &quot;(&quot; + paramType.getSignature() + &quot;)V&quot;;</span>
			}
		}
<span class="fc" id="L632">		final Operation setter = new Operation(SETTER_PREFIX + propName, setterDesc, setterSignature,</span>
<span class="fc" id="L633">				opNameAndDescriptor, metaClass.getNamespace(), metaClass.getName(), false);</span>
<span class="fc" id="L634">		setter.setMetaClassID(metaClass.getDataClayID());</span>
<span class="fc" id="L635">		setter.setDataClayID(new OperationID());</span>
<span class="fc" id="L636">		setter.setNamespaceID(metaClass.getNamespaceID());</span>
<span class="fc" id="L637">		final JavaOperationInfo javaOpInfo = new JavaOperationInfo(Modifier.PUBLIC);</span>
<span class="fc" id="L638">		setter.addLanguageDepInfo(javaOpInfo);</span>
<span class="fc" id="L639">		setter.setDataClayID(new OperationID());</span>

<span class="fc" id="L641">		final List&lt;AccessedProperty&gt; accessedProperties = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L642">		final AccessedProperty accProp = new AccessedProperty(metaClass.getNamespace(), metaClass.getName(), propName);</span>
<span class="fc" id="L643">		accProp.setPropertyID(propertyID);</span>
<span class="fc" id="L644">		accessedProperties.add(accProp);</span>

<span class="fc" id="L646">		final List&lt;Type&gt; includedTypes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">		if (paramType instanceof UserType) {</span>
<span class="fc" id="L648">			includedTypes.add(paramType);</span>
		}

		// IMPORTANT: GETTERS AND SETTERS CODE IS GENERATED WHILE CREATING
		// EXECUTION/STUBS CLASSES
<span class="fc" id="L653">		final Implementation implementation = new JavaImplementation(0, accessedProperties,</span>
				new ArrayList&lt;AccessedImplementation&gt;(), includedTypes, new PrefetchingInformation(),
				new HashMap&lt;FeatureType, QuantitativeFeature&gt;(), new HashMap&lt;FeatureType, QualitativeFeature&gt;(),
<span class="fc" id="L656">				metaClass.getNamespace(), metaClass.getName(), setter.getNameAndDescriptor());</span>

<span class="fc" id="L658">		implementation.setDataClayID(new ImplementationID());</span>
<span class="fc" id="L659">		implementation.setMetaClassID(metaClass.getDataClayID());</span>
<span class="fc" id="L660">		implementation.setNamespaceID(metaClass.getNamespaceID());</span>
<span class="fc" id="L661">		implementation.setOperationID(setter.getDataClayID());</span>
<span class="fc" id="L662">		implementation.setResponsibleAccountID(responsibleOfProperty);</span>

		// TODO: required feature for now in getter operations is Java 1.8
<span class="fc" id="L665">		implementation.getRequiredQualitativeFeatures().put(FeatureType.LANGUAGE, new LanguageFeature(&quot;Java&quot;, &quot;1.8&quot;));</span>
<span class="fc" id="L666">		setter.addImplementation(implementation);</span>
<span class="fc" id="L667">		setter.addParam(&quot;param0&quot;, paramType);</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">		if (propName.contains(ByteCodeConstants.DATACLAY_UPDATE)) {</span>
<span class="nc" id="L669">			setter.addParam(&quot;param1&quot;, </span>
<span class="nc" id="L670">					new Type(&quot;Ljava/lang/Boolean;&quot;, &quot;Ljava/lang/Boolean;&quot;, Reflector.getTypeNameFromSignatureOrDescriptor(&quot;Ljava/lang/Boolean;&quot;)));</span>
		}
<span class="fc" id="L672">		final Type returnType = new Type(&quot;V&quot;, null, &quot;void&quot;);</span>
<span class="fc" id="L673">		setter.setReturnType(returnType);</span>
<span class="fc" id="L674">		return new Tuple&lt;&gt;(setter, implementation);</span>
	}
	
	

	// ================== Operations ==================//

	/**
	 * This operation creates a new Operation in the System, its
	 *        Implementations and Types (arguments) specified and associates it to
	 *        the MetaClass identified by the metaClassID provided.
	 * @pre All IDs provided do not have object reference. OperationSpec provided
	 *      has N implementationSpec and K TypeSpec. The TypeSpecs must specify if
	 *      they are primitive or not and its name. The implementationSpec must have
	 *      the implementation code associated and not null.
	 * @param namespaceID
	 *            ID of the namespace in which the operation is created
	 * @param newOperation
	 *            Specification of the operation
	 * @param metaClassID
	 *            ID of the MetaClass that will contain the operation.
	 * @post 1.- An Operation with the provided specifications is created. &lt;br&gt;
	 *       2.- For each parameter, a new Type is created. &lt;br&gt;
	 *       3.- Each Type added to the System is associated to the Operation
	 *       created before. &lt;br&gt;
	 *       4.- The Operation is associated to the MetaClass identified by
	 *       metaClassID. &lt;br&gt;
	 *       5.- The MetaClass is updated.
	 * @return information of the new Operation.
	 */
	public Operation newOperation(final NamespaceID namespaceID, final MetaClassID metaClassID,
			final Operation newOperation) {

		// We get the MetaClass in which to add the Operation.
<span class="fc" id="L708">		final MetaClass clazz = getClassFromDatabaseOrCache(metaClassID);</span>

		// We verify that there is not another Operation in the MetaClass with
		// the same name, params and return.
<span class="fc bfc" id="L712" title="All 2 branches covered.">		for (final Operation operation : clazz.getOperations()) {</span>
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">			if (operation.getNameAndDescriptor().equals(newOperation.getNameAndDescriptor())) {</span>

<span class="fc" id="L715">				throw new OperationAlreadyInClassException(operation.getNameAndDescriptor(), operation.getNamespaceID(),</span>
<span class="fc" id="L716">						clazz.getDataClayID());</span>

			}

<span class="nc" id="L720">		}</span>

		// Now we can add the Operation to the System
<span class="fc" id="L723">		clazz.addOperation(newOperation);</span>

<span class="pc bpc" id="L725" title="1 of 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L726">			String log = &quot;Added new operation &quot; + newOperation.getName() + &quot; with OperationID &quot;</span>
<span class="nc" id="L727">					+ newOperation.getDataClayID() + &quot; and implementations: &quot;;</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">			for (final Implementation newImplementation : newOperation.getImplementations()) {</span>
<span class="nc" id="L729">				log += &quot; ,&quot; + newImplementation.getDataClayID();</span>
<span class="nc" id="L730">			}</span>
<span class="nc" id="L731">			logger.debug(log);</span>
		}

		// We update the MetaClass
		try {
<span class="fc" id="L736">			classDB.updateClassAddOperation(clazz.getDataClayID(), newOperation);</span>
<span class="fc" id="L737">			emptyClassInCaches(clazz.getDataClayID());</span>

<span class="nc" id="L739">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L740">			throw new DbHandlerException(e.getMessage());</span>

<span class="fc" id="L742">		}</span>

<span class="fc" id="L744">		return newOperation;</span>
	}

	/**
	 * This function deletes an Operation identified by the operationID
	 *        provided, and its associated arguments and implementations. The
	 *        operation's MetaClass is updated.
	 * @param operationID
	 *            ID of the operation to remove
	 * @pre All IDs provided do not have object reference. Operation identified by
	 *      operationID has a MetaClassID associated which exists and has the
	 *      OperationID in its list of operation IDs. The Operation in database has
	 *      its parameter Types, return Types and implementations as object
	 *      references.
	 * @pre The class exists
	 * @post 1.- The Implementations of the Operation identified by operationID are
	 *       removed from the System. &lt;br&gt;
	 *       2.- The Types (arguments) of the Operation identified by operationID
	 *       are removed from the System. &lt;br&gt;
	 *       3.- The Operation identified by operationID is removed from the System.
	 *       &lt;br&gt;
	 *       4.- The MetaClass associated to the Operation removes the Property from
	 *       its list of Operation and is updated in the System.
	 * @return Info of the removed operation
	 */
	public Operation removeOperation(final OperationID operationID) {

		// First we get the Operation and check if it exists
<span class="fc" id="L772">		final Operation operation = getOperationFromDatabaseOrCache(operationID);</span>

		// TODO Probably we should define setter/getter boolean flags to check this
		// better (28 Nov 2013 jmarti)
<span class="pc bpc" id="L776" title="2 of 4 branches missed.">		if (operation.getName().startsWith(GETTER_PREFIX) || operation.getName().startsWith(SETTER_PREFIX)) {</span>
<span class="nc" id="L777">			throw new SetterOrGetterOperationsCannotBeRemoved(operationID);</span>
		}

		// Now we must get the MetaClass (we know it exists and has the
		// operationID associated)
<span class="fc" id="L782">		final MetaClass metaClass = getClassFromDatabaseOrCache(operation.getMetaClassID());</span>
<span class="fc" id="L783">		metaClass.removeOperation(operationID);</span>

		// We update the MetaClass and remove the Operation from database
		try {
<span class="fc" id="L787">			classDB.updateClassRemoveOperation(metaClass.getDataClayID(), operationID);</span>
			// Remove return type, parameters and implementations of the operation.
<span class="fc" id="L789">			classDB.deleteOperation(operation.getDataClayID());</span>

<span class="fc" id="L791">			emptyClassInCaches(metaClass.getDataClayID());</span>

<span class="nc" id="L793">		} catch (final DbObjectNotExistException ex) {</span>
<span class="nc" id="L794">			logger.debug(&quot;removeOperation error&quot;, ex);</span>
<span class="nc" id="L795">			throw new DbHandlerException(ex.getMessage());</span>

<span class="fc" id="L797">		}</span>
		// classDB.deleteByID(operation.getID());
<span class="fc" id="L799">		return operation;</span>

	}

	/**
	 * This function gets the list of Implementation IDs of an Operation
	 *        identified by the OperationID provided.
	 * @param operationID
	 *            ID of the Operation.
	 * @pre All IDs provided do not have object reference. Operation identified by
	 *      operationID has a MetaClassID associated which exists and has the
	 *      OperationID in its list of operation IDs. The Operation in database has
	 *      its parameter Types, return Types and implementations as object
	 *      references.
	 * @return The list of Implementation IDs of the Operation
	 * @throws Exception
	 *             If the Operation identified by operationID does not exist or if
	 *             an internal error occurred while working with Database.
	 */
	public LinkedList&lt;ImplementationID&gt; getImplementationsOfOperation(final OperationID operationID) {

		// First we get the Operation and check if it exists
<span class="fc" id="L821">		final Operation operation = getOperationFromDatabaseOrCache(operationID);</span>

		// Since we cannot return object references we must create new iDs
<span class="fc" id="L824">		final LinkedList&lt;ImplementationID&gt; res = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L825">		final List&lt;Implementation&gt; impls = operation.getImplementations();</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">		for (final Implementation impl : impls) {</span>
<span class="fc" id="L827">			res.add(impl.getDataClayID());</span>
<span class="fc" id="L828">		}</span>

		// Now we get the return the Implementations of the Operation
<span class="fc" id="L831">		return res;</span>
	}

	// ================== Implementations ================== //

	/**
	 * This function creates a new Implementation in the System and
	 *        associates it to the Operation identified by the operationID provided.
	 * @param accountID
	 *            ID of the account responsible of the implementation
	 * @param namespaceID
	 *            ID of the namespace in which the implementation is created
	 * @param metaClassID
	 *            ID of the class containing the operation
	 * @param newImplementation
	 *            Specification of the Implementation
	 * @param operationID
	 *            ID of the Operation that will contain the Implementation.
	 * @param namespaceIDofOperation
	 *            the namespace ID of the operation
	 * @pre All IDs provided do not have object reference. The implementationSpec
	 *      provided must have implementation code different of null. Operation
	 *      identified by operationID has a MetaClassID associated which exists and
	 *      has the OperationID in its list of operation IDs. The Operation in
	 *      database has its parameter Types, return Types and implementations as
	 *      object references. does not belong to the class with ID provided (same
	 *      parameter type names and return type name) with the operation identified
	 *      by the ID provided.
	 * @post 1.- An Implementation with the provided specifications is created. &lt;br&gt;
	 *       2.- The Implementation is associated to the Operation identified by
	 *       operationID.&lt;br&gt;
	 *       3.- The Operation is updated with the new Implementation.
	 * @return information of the new Implementation.
	 * @throws Exception
	 *             If the Operation identified by operationID does not exist or does
	 *             not belong to the class with ID provided, If implementation is
	 *             not compatible or if an internal error occurred while working
	 *             with Database.
	 */
	public Implementation newImplementation(final AccountID accountID, final NamespaceID namespaceID,
			final MetaClassID metaClassID, final OperationID operationID, final NamespaceID namespaceIDofOperation,
			final Implementation newImplementation) {

		// We create a new Implementation and we get its generated
		// ImplementationID
<span class="nc" id="L876">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>
<span class="nc" id="L877">		final Operation operation = metaClass.getOperation(operationID);</span>

		// if the operation does not belong to the class with ID provided throw
		// an error
<span class="nc bnc" id="L881" title="All 4 branches missed.">		if (operation == null || !operation.getMetaClassID().equals(metaClassID)</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">				|| !operation.getNamespaceID().equals(namespaceIDofOperation)) {</span>
<span class="nc" id="L883">			throw new OperationNotExistException(operationID);</span>
		}

		// We add the ImplementationID to the Operation
<span class="nc" id="L887">		operation.addImplementation(newImplementation);</span>

<span class="nc bnc" id="L889" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L890">			String log = &quot;Added new implementation with ImplementationID &quot; + newImplementation.getDataClayID()</span>
<span class="nc" id="L891">					+ &quot; to operation &quot; + operation.getName() + &quot; with OperationID &quot; + operation.getDataClayID();</span>
<span class="nc" id="L892">			logger.debug(log);</span>
<span class="nc" id="L893">			log = &quot;Now operation &quot; + operation.getName() + &quot; with OperationID &quot; + operation.getDataClayID()</span>
					+ &quot; has implementations: &quot;;
<span class="nc bnc" id="L895" title="All 2 branches missed.">			for (final Implementation impl : operation.getImplementations()) {</span>
<span class="nc" id="L896">				log += &quot; ,&quot; + impl.getDataClayID();</span>
<span class="nc" id="L897">			}</span>
<span class="nc" id="L898">			logger.debug(log);</span>
		}

		// We update the Operation containing the implementation
		try {
<span class="nc" id="L903">			classDB.updateOperationAddImplementation(operation.getDataClayID(), newImplementation);</span>
<span class="nc" id="L904">			emptyClassInCaches(metaClass.getDataClayID());</span>

<span class="nc" id="L906">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L907">			throw new OperationNotExistException(operation.getDataClayID());</span>
<span class="nc" id="L908">		}</span>

<span class="nc" id="L910">		return newImplementation;</span>
	}

	/**
	 * This function removes an Implementation with the implementationID
	 *        provided from the System and updates the associated Operation.
	 * @param implementationID
	 *            ID of the Implementation to remove
	 * @pre All IDs provided do not have object reference. Implementation identified
	 *      by implementationID has an OperationID associated which exists and has
	 *      the implementationID in its list of implementation IDs. It also has a
	 *      MetaClassID associated which exists and has the OperationID in its list
	 *      of operation IDs. The Operation in database has its parameter Types,
	 *      return Types and implementations as object references. only has this
	 *      implementation
	 * @post 1.- The Type of the Property identified by propertyID is removed from
	 *       the System. &lt;br&gt;
	 *       2.- The Property identified by propertyID is removed from the System.
	 *       &lt;br&gt;
	 *       3.- The MetaClass associated to the Property removes the Property from
	 *       its list of Properties and is updated in the System.
	 * @throws Exception
	 *             If the Implementation identified by implementationID does not
	 *             exist, If the Operation associated to the Implementation does not
	 *             exist, If the implementation cannot be removed because the
	 *             Operation only has this implementation or if an internal error
	 *             occurred while working with Database.
	 */
	public void removeImplementation(final ImplementationID implementationID) {

		// First we get the Implementation and check if it exists
<span class="nc" id="L941">		final Implementation implementation = getImplementationFromDatabaseOrCache(implementationID);</span>

		// First we get the Operation (we know it exists and it is correct)
<span class="nc" id="L944">		final Operation operation = getOperationFromDatabaseOrCache(implementation.getOperationID());</span>

<span class="nc bnc" id="L946" title="All 2 branches missed.">		if (operation.getImplementations().size() == 1) {</span>
<span class="nc" id="L947">			throw new NoMoreImplementationsInOperationException(implementationID, operation.getDataClayID());</span>
		}

<span class="nc" id="L950">		final MetaClass metaClass = getClassFromDatabaseOrCache(operation.getMetaClassID());</span>

<span class="nc" id="L952">		operation.removeImplementation(implementation.getDataClayID());</span>

		// We update the Operation containing the implementation and remove the
		// implementation from database
		try {
<span class="nc" id="L957">			classDB.deleteImplementation(implementation);</span>
<span class="nc" id="L958">			classDB.updateOperationRemoveImplementation(operation.getDataClayID(), implementation.getDataClayID());</span>
<span class="nc" id="L959">			emptyClassInCaches(metaClass.getDataClayID());</span>

<span class="nc" id="L961">		} catch (final DbObjectNotExistException e) {</span>
<span class="nc" id="L962">			throw new OperationNotExistException(implementation.getOperationID());</span>
<span class="nc" id="L963">		}</span>
<span class="nc" id="L964">	}</span>

	/**
	 * This function gets the list of Requirements of an Implementation
	 *        identified by the ImplementationID provided.
	 * @param implementationID
	 *            ID of the Implementation.
	 * @pre All IDs provided do not have object reference. Implementation identified
	 *      by implementationID has an OperationID associated which exists and has
	 *      the implementationID in its list of implementation IDs. It also has a
	 *      MetaClassID associated which exists and has the OperationID in its list
	 *      of operation IDs. The Operation in database has its parameter Types,
	 *      return Types and implementations as object references.
	 * @return The list of Features (requirements) of the Implementation
	 * @throws Exception
	 *             If the Implementation identified by implementationID does not
	 *             exist or if an internal error occurred while working with
	 *             Database.
	 */
	public List&lt;Feature&gt; getRequirementsOfMethod(final ImplementationID implementationID) {

		// First we get the Implementation and check if it exists
<span class="nc" id="L986">		final Implementation implementation = getImplementationFromDatabaseOrCache(implementationID);</span>
<span class="nc" id="L987">		final List&lt;Feature&gt; allFeatures = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L988">		allFeatures.addAll(implementation.getRequiredQualitativeFeatures().values());</span>
<span class="nc" id="L989">		allFeatures.addAll(implementation.getRequiredQuantitativeFeatures().values());</span>
<span class="nc" id="L990">		return allFeatures;</span>
	}

	/**
	 * This function retrieves the information of the given implementations
	 * @param implementationsIDs
	 *            IDs of the implementations
	 * @return the information about every implementation
	 * @throws Exception
	 *             if any of the implementations does not exist
	 */
	public Map&lt;ImplementationID, Implementation&gt; getInfoOfImplementations(
			final Set&lt;ImplementationID&gt; implementationsIDs) {
<span class="nc" id="L1003">		final Map&lt;ImplementationID, Implementation&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">		for (final ImplementationID implementationID : implementationsIDs) {</span>
<span class="nc" id="L1005">			final Implementation implementation = getImplementationFromDatabaseOrCache(implementationID);</span>
<span class="nc" id="L1006">			result.put(implementationID, implementation);</span>
<span class="nc" id="L1007">		}</span>
<span class="nc" id="L1008">		return result;</span>
	}

	/**
	 * This function gets the MetaClass with name className and namespaceID
	 *        provided
	 * @param namespaceID
	 *            Namespace ID of the MetaClass to look for
	 * @param className
	 *            Name of the class to look for
	 * @return theMetaClass with name and namespace ID provided or NULL if not
	 *         found.
	 */
	private MetaClass getMetaClassByName(final NamespaceID namespaceID, final String className) {
<span class="nc" id="L1022">		final Tuple&lt;NamespaceID, String&gt; key = new Tuple&lt;&gt;(namespaceID, className);</span>
<span class="nc" id="L1023">		MetaClass metaclass = classCacheByName.get(new Tuple&lt;&gt;(namespaceID, className));</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">		if (metaclass == null) {</span>
<span class="nc" id="L1025">			metaclass = classDB.getClassByNameAndNamespaceID(className, namespaceID);</span>
<span class="nc" id="L1026">			classCacheByName.put(key, metaclass);</span>
		}
<span class="nc" id="L1028">		return metaclass;</span>
	}

	/**
	 * This function gets the MetaClass with name className and Namespace
	 *        provided
	 * @param namespace
	 *            Namespace of the MetaClass to look for
	 * @param className
	 *            Name of the class to look for
	 * @return theMetaClass with name and namespace ID provided or NULL if not
	 *         found.
	 */
	public MetaClass getMetaClassByNameAndNamespace(final String namespace, final String className) {
<span class="nc" id="L1042">		final Tuple&lt;String, String&gt; key = new Tuple&lt;&gt;(namespace, className);</span>
<span class="nc" id="L1043">		MetaClass metaclass = classCacheByNameAndNamespace.get(new Tuple&lt;&gt;(namespace, className));</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">		if (metaclass == null) {</span>
<span class="nc" id="L1045">			metaclass = classDB.getClassByNameAndNamespace(className, namespace);</span>
<span class="nc" id="L1046">			classCacheByNameAndNamespace.put(key, metaclass);</span>
		}
<span class="nc" id="L1048">		return metaclass;</span>
	}

	/**
	 * Retrieves the ID of a class given its name
	 * @pre All IDs provided do not have object reference.
	 * @param namespaceID
	 *            ID of the namespace containing the class
	 * @param className
	 *            Name of the MetaClass
	 * @return The ID of the class or NULL if class does not exist
	 */
	public MetaClassID getMetaClassID(final NamespaceID namespaceID, final String className) {
		// TODO Unify caches and only use namespaceIDs!! (jmarti 5 Apr 2018)
<span class="nc" id="L1062">		final MetaClass metaclass = classCacheByName.get(new Tuple&lt;&gt;(namespaceID, className));</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">		if (metaclass == null) {</span>
<span class="nc" id="L1064">			return classDB.getClassIDByNameAndNamespaceID(className, namespaceID);</span>
		} else {
<span class="nc" id="L1066">			return metaclass.getDataClayID();</span>
		}
	}

	/**
	 * Retrieves the id of a property given its name, name of the class
	 *        containing the property and the namespace where it belongs to.
	 * @pre All IDs provided do not have object reference.
	 * @pre The class exists
	 * @param metaClassName
	 *            Name of the class
	 * @param namespace
	 *            Namespace of the class
	 * @param propertyName
	 *            the name of the property
	 * @return The ID of the property
	 */
	public PropertyID getPropertyID(final String metaClassName, final String namespace, final String propertyName) {
<span class="nc" id="L1084">		final Property property = classDB.getPropertyByNames(propertyName, metaClassName, namespace);</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">		if (property == null) {</span>
<span class="nc" id="L1086">			throw new PropertyNotExistException(metaClassName, propertyName);</span>
		}
		// We just return the ID and not the ref. object.
<span class="nc" id="L1089">		return property.getDataClayID();</span>
	}

	/**
	 * Retrieves the id of a property given its name, name of the class
	 *        containing the property and the namespace where it belongs to.
	 * @pre All IDs provided do not have object reference.
	 * @pre The class exists
	 * @param metaClassID
	 *            ID of the class
	 * @param propertyName
	 *            the name of the property
	 * @return The ID of the property
	 */
	public PropertyID getPropertyID(final MetaClassID metaClassID, final String propertyName) {

		// Get the class
<span class="fc" id="L1106">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>

<span class="fc" id="L1108">		Property property = null;</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">		for (final Property prop : metaClass.getProperties()) {</span>
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">			if (prop.getName().equals(propertyName)) {</span>
<span class="fc" id="L1111">				property = prop;</span>
<span class="fc" id="L1112">				break;</span>
			}
<span class="nc" id="L1114">		}</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">		if (property == null) {</span>
<span class="fc" id="L1116">			throw new PropertyNotExistException(metaClass.getName(), propertyName);</span>
		}
		// We just return the ID and not the ref. object.
<span class="fc" id="L1119">		return property.getDataClayID();</span>
	}

	/**
	 * Retrieves the names of the properties with IDs provided.
	 * @param propertiesIDs
	 *            IDs of the properties
	 * @return Return the names of the properties with IDs provided
	 */
	public Map&lt;PropertyID, String&gt; getPropertiesNames(final Set&lt;PropertyID&gt; propertiesIDs) {

<span class="nc" id="L1130">		final Map&lt;PropertyID, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">		for (final PropertyID propertyID : propertiesIDs) {</span>
<span class="nc" id="L1132">			final Property property = getPropertyFromDatabaseOrCache(propertyID);</span>
<span class="nc" id="L1133">			result.put(propertyID, property.getName());</span>
<span class="nc" id="L1134">		}</span>
<span class="nc" id="L1135">		return result;</span>

	}

	/**
	 * Retrieves the id of an operation given its signature, id of the
	 *        namespace of the operation and id of the class containing the
	 *        operation and the namespace where it belongs to
	 * @param metaClassID
	 *            ID of the class
	 * @param operationSignature
	 *            the signature of the operation
	 * @pre All IDs provided do not have object reference.
	 * @return The ID of the operation
	 * @throws Exception
	 *             If operation does not exist
	 */
	public OperationID getOperationID(final MetaClassID metaClassID, final String operationSignature) {

		// Get the class
<span class="fc" id="L1155">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>
<span class="fc" id="L1156">		OperationID operation = null;</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">		for (final Operation op : metaClass.getOperations()) {</span>
<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">			if (op.getNameAndDescriptor().equals(operationSignature)) {</span>
<span class="fc" id="L1159">				operation = op.getDataClayID();</span>
<span class="fc" id="L1160">				break;</span>
			}

<span class="nc" id="L1163">		}</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">		if (operation == null) {</span>
<span class="fc" id="L1165">			throw new OperationNotExistException(metaClass.getName(), operationSignature);</span>
		}

<span class="fc" id="L1168">		return operation;</span>
	}

	/**
	 * Retrieves the id of an operation given its signature, id of the
	 *        namespace of the operation and id of the class containing the
	 *        operation and the namespace where it belongs to
	 * @param metaClassName
	 *            Name of the class
	 * @param namespace
	 *            Namespace of the class
	 * @param operationSignature
	 *            the signature of the operation
	 * @pre All IDs provided do not have object reference.
	 * @return The ID of the operation
	 * @throws Exception
	 *             If operation does not exist
	 */
	public OperationID getOperationID(final String metaClassName, final String namespace,
			final String operationSignature) {

<span class="nc" id="L1189">		final Operation operation = classDB.getOperationByNames(operationSignature, metaClassName, namespace);</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">		if (operation == null) {</span>
<span class="nc" id="L1191">			throw new OperationNotExistException(metaClassName, operationSignature);</span>
		}

<span class="nc" id="L1194">		return operation.getDataClayID();</span>
	}

	/**
	 * Returns the name of the MetaClass identified by ID provided
	 * @param metaClassID
	 *            ID of the MetaClass
	 * @return The name of the MetaClass identified by the ID provided
	 * @pre The class exists
	 */
	public String getClassname(final MetaClassID metaClassID) {
<span class="nc" id="L1205">		return getClassNameInternal(metaClassID);</span>
	}

	/**
	 * Returns the name and namespace of the MetaClass identified by ID
	 *        provided
	 * @param metaClassID
	 *            ID of the MetaClass
	 * @return The name and namespace of the MetaClass identified by the ID provided
	 * @pre The class exists
	 */
	public Tuple&lt;String, String&gt; getClassNameAndNamespace(final MetaClassID metaClassID) {
<span class="nc" id="L1217">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>
<span class="nc" id="L1218">		return new Tuple&lt;&gt;(metaClass.getName(), metaClass.getNamespace());</span>
	}

	/**
	 * Return the name of the class with Id provided
	 * @param metaClassID
	 *            ID of the class
	 * @return The name of the class with id proved
	 */
	private String getClassNameInternal(final MetaClassID metaClassID) {
<span class="nc" id="L1228">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>
<span class="nc" id="L1229">		return metaClass.getName();</span>
	}

	/**
	 * Generate a set of Java stubs with the provided informations
	 * @pre The class exists
	 * @param language
	 *            Language of the stub to generate
	 * @param stubInfos
	 *            Information associated to each stub (names, contract IDs,
	 *            interface IDs...)
	 * @return Byte code of the stubs of the classes with information provided and
	 *         its aspect
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Map&lt;MetaClassID, Triple&lt;String, byte[], byte[]&gt;&gt; generateStubs(final Langs language,
			final Map&lt;MetaClassID, StubInfo&gt; stubInfos) {

<span class="nc" id="L1248">		final Map&lt;MetaClassID, Triple&lt;String, byte[], byte[]&gt;&gt; stubs = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">		for (final Entry&lt;MetaClassID, StubInfo&gt; entry : stubInfos.entrySet()) {</span>

<span class="nc" id="L1251">			final MetaClassID metaClassID = entry.getKey();</span>
<span class="nc" id="L1252">			final StubInfo stubInfo = entry.getValue();</span>
			// Get the metaclass
<span class="nc" id="L1254">			final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>

<span class="nc" id="L1256">			Triple&lt;String, byte[], byte[]&gt; stubAndIncludes = stubsCache.get(stubInfo);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">			if (stubAndIncludes == null) {</span>
				// Get parent name
<span class="nc" id="L1259">				String realParentName = null;</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">				if (metaClass.getParentType() == null) {</span>
<span class="nc" id="L1261">					realParentName = DataClayObject.class.getName();</span>
				} else {
<span class="nc" id="L1263">					final MetaClass parentClass = getClassFromDatabaseOrCache(metaClass.getParentType().getClassID());</span>
<span class="nc" id="L1264">					realParentName = parentClass.getName();</span>
				}

<span class="nc" id="L1267">				final List&lt;MetaClass&gt; accessedClasses = getAllIncludes(metaClass);</span>

				final byte[] byteCode;
<span class="nc" id="L1270">				byte[] aspectBytes = null;</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">				if (language == Langs.LANG_JAVA) {</span>
<span class="nc" id="L1272">					byteCode = StubByteCodeManager.generateJavaStub(metaClass, stubInfo, accessedClasses, this);</span>
<span class="nc" id="L1273">					aspectBytes = StubByteCodeManager.generateStubAspect(metaClass, false, this);</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">				} else if (language == Langs.LANG_PYTHON) {</span>

					// TODO: MODIFY THIS FOR EMBEDDED
<span class="nc" id="L1277">					byteCode = StubPySourceManager.generatePythonClientStub(metaClass, realParentName,</span>
<span class="nc" id="L1278">							stubInfos.get(metaClassID));</span>
				} else {
<span class="nc" id="L1280">					throw new DataClayRuntimeException(ERRORCODE.CLASS_UNSUPPORTED_LANGUAGE,</span>
							&quot;Unknown language, could not genearte stub&quot;, false);
				}
<span class="nc" id="L1283">				stubAndIncludes = new Triple&lt;&gt;(metaClass.getName(), byteCode, aspectBytes);</span>

<span class="nc" id="L1285">				stubsCache.put(stubInfo, stubAndIncludes);</span>
			}
<span class="nc" id="L1287">			stubs.put(metaClassID, stubAndIncludes);</span>
<span class="nc" id="L1288">		}</span>
<span class="nc" id="L1289">		return stubs;</span>
	}

	/**
	 * Generate a set of Java stubs for Enrichments with the provided
	 *        informations
	 * @param language
	 *            Language of the stub to generate
	 * @param stubInfos
	 *            Information associated to each stub (names, contract IDs,
	 *            interface IDs...)
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 * @pre The class exists
	 * @return Byte code of the stubs of the stubs for enrichment with information
	 *         provided
	 */
	public Map&lt;MetaClassID, byte[]&gt; generateStubsForEnrichment(final Langs language,
			final Map&lt;MetaClassID, StubInfo&gt; stubInfos) {
<span class="nc" id="L1308">		throw new UnsupportedOperationException();</span>
	}

	/**
	 * Checks that there is no operation, implementation or property that
	 *        includes the class with name and Namespace specified.
	 * @param newClassName
	 *            Name of the class
	 * @param newNamespaceID
	 *            ID of the namespace of the class
	 * @return The ID of the class with Name and Namespace specified. If no class
	 *         with this name and namespace exists NULL is returned and the check is
	 *         skipped.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public MetaClassID checkClassNotInIncludesAndGetID(final String newClassName, final NamespaceID newNamespaceID) {

<span class="nc" id="L1326">		final MetaClass metaClass = getMetaClassByName(newNamespaceID, newClassName);</span>
<span class="nc" id="L1327">		final MetaClassID metaClassID = metaClass.getDataClayID();</span>

		// Verify there is no type using the class id
<span class="nc" id="L1330">		final boolean existsInIncludes = classDB.existsClassInSomeType(metaClassID);</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">		if (existsInIncludes) {</span>
<span class="nc" id="L1332">			throw new ClassInIncludesException(newNamespaceID, newClassName);</span>
		}

<span class="nc" id="L1335">		return metaClassID;</span>
	}

	/**
	 * For each property and operation ID provided verify they belong to the
	 *        Namespace of the Class with ID provided. Return those that do not
	 *        belong to the Namespace.
	 * @param metaClassID
	 *            ID of the MetaClass
	 * @param propertyIDs
	 *            IDs of the properties
	 * @param operationIDs
	 *            IDs of the operations
	 * @return IDs of operations and IDs of properties that do not belong to the
	 *         MetaClass with ID provided.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Tuple&lt;Set&lt;PropertyID&gt;, Set&lt;OperationID&gt;&gt; getOperationsAndPropertiesNotInNamespaceOfClass(
			final MetaClassID metaClassID, final Set&lt;PropertyID&gt; propertyIDs, final Set&lt;OperationID&gt; operationIDs) {
		// Get the metaClass
<span class="nc" id="L1356">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>
<span class="nc" id="L1357">		final Set&lt;PropertyID&gt; propertiesNotInClassNamespace = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">		for (final PropertyID propertyID : propertyIDs) {</span>
			// Verify the property belong to the metaClass with ID provided
<span class="nc" id="L1360">			boolean found = false;</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">			for (final Property property : metaClass.getProperties()) {</span>
<span class="nc" id="L1362">				final PropertyID propID = property.getDataClayID();</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">				if (propID.equals(propertyID)) {</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">					if (!property.getNamespaceID().equals(metaClass.getNamespaceID())) {</span>
<span class="nc" id="L1365">						propertiesNotInClassNamespace.add(propertyID);</span>
					}
<span class="nc" id="L1367">					found = true;</span>
<span class="nc" id="L1368">					break;</span>
				}
<span class="nc" id="L1370">			}</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">			if (!found) {</span>
<span class="nc" id="L1372">				throw new PropertyNotInClassException(propertyID, metaClassID);</span>
			}
<span class="nc" id="L1374">		}</span>

<span class="nc" id="L1376">		final Set&lt;OperationID&gt; operationsNotInClassNamespace = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">		for (final OperationID operationID : operationIDs) {</span>
			// Verify the operation belong to the metaClass with ID provided
<span class="nc" id="L1379">			boolean found = false;</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">			for (final Operation operation : metaClass.getOperations()) {</span>
<span class="nc" id="L1381">				final OperationID opID = operation.getDataClayID();</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">				if (opID.equals(operationID)) {</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">					if (!operation.getNamespaceID().equals(metaClass.getNamespaceID())) {</span>
<span class="nc" id="L1384">						operationsNotInClassNamespace.add(operationID);</span>
					}
<span class="nc" id="L1386">					found = true;</span>
<span class="nc" id="L1387">					break;</span>
				}
<span class="nc" id="L1389">			}</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">			if (!found) {</span>
<span class="nc" id="L1391">				throw new OperationNotInClassException(operationID, metaClassID);</span>
			}
<span class="nc" id="L1393">		}</span>

<span class="nc" id="L1395">		return new Tuple&lt;&gt;(propertiesNotInClassNamespace, operationsNotInClassNamespace);</span>
	}

	/**
	 * Verify if the type with ID provided is in namespace specified or not
	 *        and add it into one of the provided structures.
	 * @param includedTypeID
	 *            ID of the type to check
	 * @param namespaceID
	 *            ID of the namespace
	 * @param includesInNamespace
	 *            [out] Set of MetaClass informations of includes in same namespace
	 * @param includesNotInNamespace
	 *            [out] Set of MetaClass informations of includes not in same
	 *            namespace
	 */
	private void verifyTypeInclude(final MetaClassID includedTypeID, final NamespaceID namespaceID,
			final Set&lt;MetaClass&gt; includesInNamespace, final Set&lt;MetaClass&gt; includesNotInNamespace) {

		// Get the class
<span class="nc" id="L1415">		final MetaClass includedClass = getClassFromDatabaseOrCache(includedTypeID);</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">		if (includedClass != null) {</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">			if (includedClass.getNamespaceID().equals(namespaceID)) {</span>
<span class="nc" id="L1418">				includesInNamespace.add(includedClass);</span>
			} else {
<span class="nc" id="L1420">				includesNotInNamespace.add(includedClass);</span>
			}
		}

<span class="nc" id="L1424">	}</span>

	/**
	 * Verify the includes of the Implementation. Check if they are in
	 *        namespace specified or not and add it into one of the provided
	 *        structures.
	 * @param implementation
	 *            Implementation to check.
	 * @param namespaceID
	 *            ID of the namespace
	 * @param includesInNamespace
	 *            [out] Set of MetaClass informations of includes in same namespace
	 * @param includesNotInNamespace
	 *            [out] Set of MetaClass informations of includes not in same
	 *            namespace
	 * @param analyzedImplementations
	 *            [out] Set of implementations that have been already analyzed
	 */
	private void getClassIncludesOfImplementation(final Implementation implementation, final NamespaceID namespaceID,
			final Set&lt;MetaClass&gt; includesInNamespace, final Set&lt;MetaClass&gt; includesNotInNamespace,
			final Set&lt;ImplementationID&gt; analyzedImplementations) {

<span class="nc" id="L1446">		final ImplementationID implIDwithoutRef = implementation.getDataClayID();</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">		if (analyzedImplementations.contains(implIDwithoutRef)) {</span>
<span class="nc" id="L1448">			return;</span>
		} else {
<span class="nc" id="L1450">			analyzedImplementations.add(implementation.getDataClayID());</span>
		}

		// Verify implementation includes
<span class="nc bnc" id="L1454" title="All 2 branches missed.">		for (final Type implInclude : implementation.getIncludes()) {</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">			if (implInclude instanceof UserType) {</span>
<span class="nc" id="L1456">				final UserType implIncludeUType = (UserType) implInclude;</span>
<span class="nc" id="L1457">				verifyTypeInclude(implIncludeUType.getClassID(), namespaceID, includesInNamespace,</span>
						includesNotInNamespace);
			}
<span class="nc" id="L1460">		}</span>
		// Verify properties accessed by the implementation
<span class="nc" id="L1462">		final List&lt;AccessedProperty&gt; accessedProperties = implementation.getAccessedProperties();</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">		for (final AccessedProperty accProp : accessedProperties) {</span>
<span class="nc" id="L1464">			final PropertyID propertyID = accProp.getPropertyID();</span>
			// TODO: accessed properties cannot be properties that do not belong
			// to metaclass so it can be
			// improved the call &quot;getIncludesInDifferentNamespaces&quot;
<span class="nc" id="L1468">			final Property property = getPropertyFromDatabaseOrCache(propertyID);</span>

<span class="nc" id="L1470">			final Type propertyType = property.getType();</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">			if (propertyType instanceof UserType) {</span>
<span class="nc" id="L1472">				final UserType includeUType = (UserType) propertyType;</span>
<span class="nc" id="L1473">				verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace, includesNotInNamespace);</span>

			}

<span class="nc" id="L1477">		}</span>

		// Verify implementations accessed by the implementation
<span class="nc" id="L1480">		final List&lt;AccessedImplementation&gt; accessedImplementations = implementation.getAccessedImplementations();</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">		for (final AccessedImplementation accImpl : accessedImplementations) {</span>
<span class="nc" id="L1482">			final ImplementationID implID = accImpl.getImplementationID();</span>
<span class="nc" id="L1483">			final Implementation accessedImplementation = getImplementationFromDatabaseOrCache(implID);</span>
<span class="nc" id="L1484">			final Operation accessedOperation = getOperationFromDatabaseOrCache(</span>
<span class="nc" id="L1485">					accessedImplementation.getOperationID());</span>

			// Verify Operation arguments
<span class="nc" id="L1488">			final Map&lt;String, Type&gt; params = accessedOperation.getParams();</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">			for (final Entry&lt;String, Type&gt; entry : params.entrySet()) {</span>
<span class="nc" id="L1490">				final Type type = entry.getValue();</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">				if (type instanceof UserType) {</span>
<span class="nc" id="L1492">					final UserType includeUType = (UserType) type;</span>
<span class="nc" id="L1493">					verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace,</span>
							includesNotInNamespace);
				}
<span class="nc" id="L1496">			}</span>

			// Verify operation return type
<span class="nc" id="L1499">			final Type type = accessedOperation.getReturnType();</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">			if (type instanceof UserType) {</span>
<span class="nc" id="L1501">				final UserType includeUType = (UserType) type;</span>
<span class="nc" id="L1502">				verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace, includesNotInNamespace);</span>
			}

			// Recursive call
<span class="nc" id="L1506">			getClassIncludesOfImplementation(accessedImplementation, namespaceID, includesInNamespace,</span>
					includesNotInNamespace, analyzedImplementations);

<span class="nc" id="L1509">		}</span>
<span class="nc" id="L1510">	}</span>

	/**
	 * Get the includes of the operations and properties provided and for
	 *        those that belongs to the Namespace with ID provided return all its
	 *        information.
	 * @param operationsAndImpls
	 *            IDs of the operations and implementations
	 * @param propertyIDs
	 *            IDs of the properties
	 * @param namespaceID
	 *            ID of the namespace
	 * @param parentClassID
	 *            ID of the parent class
	 * @return A set of MetaClass information with only Class ID and Namespace ID
	 *         corresponding to imported classes, and a set of MetaClass information
	 *         with all information corresponding to the non imported classes.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Tuple&lt;Set&lt;MetaClass&gt;, Set&lt;MetaClass&gt;&gt; getClassIncludesOfOperationsPropsAndImpls(
			final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; operationsAndImpls, final Set&lt;PropertyID&gt; propertyIDs,
			final NamespaceID namespaceID, final MetaClassID parentClassID) {

<span class="nc" id="L1534">		final Set&lt;MetaClass&gt; includesInNamespace = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1535">		final Set&lt;MetaClass&gt; includesNotInNamespace = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1536">		final Set&lt;ImplementationID&gt; alreadyAnalyzedImpls = new HashSet&lt;&gt;();</span>

		// Analyze includes of properties
<span class="nc bnc" id="L1539" title="All 2 branches missed.">		for (final PropertyID propertyID : propertyIDs) {</span>
<span class="nc" id="L1540">			final Property property = getPropertyFromDatabaseOrCache(propertyID);</span>
<span class="nc" id="L1541">			final Type propertyType = property.getType();</span>
<span class="nc bnc" id="L1542" title="All 2 branches missed.">			if (propertyType instanceof UserType) {</span>
<span class="nc" id="L1543">				final UserType includeUType = (UserType) propertyType;</span>
<span class="nc" id="L1544">				verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace, includesNotInNamespace);</span>
			}

<span class="nc" id="L1547">		}</span>
		// Analyze includes of operations and implementations
<span class="nc bnc" id="L1549" title="All 2 branches missed.">		for (final Entry&lt;OperationID, Set&lt;ImplementationID&gt;&gt; entry : operationsAndImpls.entrySet()) {</span>

<span class="nc" id="L1551">			final OperationID operationID = entry.getKey();</span>
<span class="nc" id="L1552">			final Operation operation = getOperationFromDatabaseOrCache(operationID);</span>

			// Verify Operation arguments
<span class="nc" id="L1555">			final Map&lt;String, Type&gt; params = operation.getParams();</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">			for (final Entry&lt;String, Type&gt; curParam : params.entrySet()) {</span>
<span class="nc" id="L1557">				final Type type = curParam.getValue();</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">				if (type instanceof UserType) {</span>
<span class="nc" id="L1559">					final UserType includeUType = (UserType) type;</span>
<span class="nc" id="L1560">					verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace,</span>
							includesNotInNamespace);
				}
<span class="nc" id="L1563">			}</span>

			// Verify operation return type
<span class="nc" id="L1566">			final Type type = operation.getReturnType();</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">			if (type instanceof UserType) {</span>
<span class="nc" id="L1568">				final UserType includeUType = (UserType) type;</span>
<span class="nc" id="L1569">				verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace, includesNotInNamespace);</span>
			}

			// Now let's verify the implementation includes
<span class="nc" id="L1573">			final Set&lt;ImplementationID&gt; implementationIDs = entry.getValue();</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">			for (final ImplementationID implementationID : implementationIDs) {</span>
<span class="nc" id="L1575">				final Implementation implementation = getImplementationFromDatabaseOrCache(implementationID);</span>
<span class="nc" id="L1576">				getClassIncludesOfImplementation(implementation, namespaceID, includesInNamespace,</span>
						includesNotInNamespace, alreadyAnalyzedImpls);
<span class="nc" id="L1578">			}</span>

<span class="nc" id="L1580">		}</span>

		// Verify parent class (verify the ops and props of parent class is not
		// necessary since the implementations
		// will contain this information)
<span class="nc bnc" id="L1585" title="All 2 branches missed.">		if (parentClassID != null) {</span>
<span class="nc" id="L1586">			verifyTypeInclude(parentClassID, namespaceID, includesInNamespace, includesNotInNamespace);</span>
		}

<span class="nc" id="L1589">		return new Tuple&lt;&gt;(includesNotInNamespace, includesInNamespace);</span>
	}

	/**
	 * Get the Class name, Namespace ID and the IDs of the included classes
	 *        in different Namespaces than the one specified of the class with ID
	 *        provided.
	 * @param metaClassID
	 *            ID of the class
	 * @param propertiesIDs
	 *            properties to be analyzed
	 * @param operationsIDsAndImplementationsIDs
	 *            operations and their implementations to be analyzed
	 * @param namespaceID
	 *            ID of the namespace
	 * @return The class name, Namespace ID of class and a set of included classes
	 *         that are not in the namespace provided.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Triple&lt;String, NamespaceID, Set&lt;MetaClassID&gt;&gt; getIncludesInDifferentNamespaces(final MetaClassID metaClassID,
			final Set&lt;PropertyID&gt; propertiesIDs,
			final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; operationsIDsAndImplementationsIDs,
			final NamespaceID namespaceID) {
		// Get the class
<span class="nc" id="L1614">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>

<span class="nc" id="L1616">		final Set&lt;MetaClass&gt; includesInNamespace = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1617">		final Set&lt;MetaClass&gt; includesNotInNamespace = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1618">		final Set&lt;ImplementationID&gt; alreadyAnalyzedImpls = new HashSet&lt;&gt;();</span>

		// Analyze includes of properties
<span class="nc bnc" id="L1621" title="All 2 branches missed.">		for (final Property property : metaClass.getProperties()) {</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">			if (propertiesIDs.contains(property.getDataClayID())) {</span>
<span class="nc" id="L1623">				final Type propertyType = property.getType();</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">				if (propertyType instanceof UserType) {</span>
<span class="nc" id="L1625">					final UserType includeUType = (UserType) propertyType;</span>
<span class="nc" id="L1626">					verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace,</span>
							includesNotInNamespace);
				}
			}

<span class="nc" id="L1631">		}</span>
		// Analyze includes of operations and implementations
<span class="nc bnc" id="L1633" title="All 2 branches missed.">		for (final Operation operation : metaClass.getOperations()) {</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">			if (operationsIDsAndImplementationsIDs.containsKey(operation.getDataClayID())) {</span>
<span class="nc" id="L1635">				final Set&lt;ImplementationID&gt; implsIDs = operationsIDsAndImplementationsIDs</span>
<span class="nc" id="L1636">						.get(operation.getDataClayID());</span>

				// Verify Operation arguments
<span class="nc" id="L1639">				final Map&lt;String, Type&gt; params = operation.getParams();</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">				for (final Entry&lt;String, Type&gt; curParam : params.entrySet()) {</span>
<span class="nc" id="L1641">					final Type type = curParam.getValue();</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">					if (type instanceof UserType) {</span>
<span class="nc" id="L1643">						final UserType includeUType = (UserType) type;</span>
<span class="nc" id="L1644">						verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace,</span>
								includesNotInNamespace);
					}
<span class="nc" id="L1647">				}</span>

				// Verify operation return type
<span class="nc" id="L1650">				final Type type = operation.getReturnType();</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">				if (type instanceof UserType) {</span>
<span class="nc" id="L1652">					final UserType includeUType = (UserType) type;</span>
<span class="nc" id="L1653">					verifyTypeInclude(includeUType.getClassID(), namespaceID, includesInNamespace,</span>
							includesNotInNamespace);
				}

				// Now let's verify the implementation includes
<span class="nc bnc" id="L1658" title="All 2 branches missed.">				for (final Implementation implementation : operation.getImplementations()) {</span>
<span class="nc bnc" id="L1659" title="All 2 branches missed.">					if (implsIDs.contains(implementation.getDataClayID())) {</span>
<span class="nc" id="L1660">						getClassIncludesOfImplementation(implementation, namespaceID, includesInNamespace,</span>
								includesNotInNamespace, alreadyAnalyzedImpls);
					}
<span class="nc" id="L1663">				}</span>
			}

<span class="nc" id="L1666">		}</span>

		// Verify parent class (verify the ops and props of parent class is not
		// necessary since the implementations
		// will contain this information)
<span class="nc bnc" id="L1671" title="All 2 branches missed.">		if (metaClass.getParentType() != null) {</span>
<span class="nc" id="L1672">			verifyTypeInclude(metaClass.getParentType().getClassID(), namespaceID, includesInNamespace,</span>
					includesNotInNamespace);
		}

<span class="nc" id="L1676">		final Set&lt;MetaClassID&gt; includesIDsNotInNamespace = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L1678" title="All 2 branches missed.">		for (final MetaClass metaClassInfo : includesNotInNamespace) {</span>
<span class="nc" id="L1679">			includesIDsNotInNamespace.add(metaClassInfo.getDataClayID());</span>
<span class="nc" id="L1680">		}</span>

<span class="nc" id="L1682">		return new Triple&lt;&gt;(metaClass.getName(), metaClass.getNamespaceID(), includesIDsNotInNamespace);</span>
	}

	/**
	 * Verify if there is some implementation accessing the operation with ID
	 *        provided
	 * @param operationID
	 *            ID of the operation
	 * @return TRUE if there is some implementation accessing the operation. FALSE
	 *         otherwise.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public boolean existsImplementationAccessingOperation(final OperationID operationID) {

<span class="nc" id="L1697">		final Operation op = classDB.getOperationByID(operationID);</span>
		// If any implementation accesses some of the implementations of this operation,
		// return true.
<span class="nc bnc" id="L1700" title="All 2 branches missed.">		for (final Implementation impl : op.getImplementations()) {</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">			if (classDB.existsAccessedImplementationWithID(impl.getDataClayID())) {</span>
<span class="nc" id="L1702">				return true;</span>
			}
<span class="nc" id="L1704">		}</span>
<span class="nc" id="L1705">		return false;</span>

	}

	/**
	 * Get the properties, operations and implementations created as
	 *        enrichments of the specified class in the given namespace.
	 * @param metaClassID
	 *            ID of the class
	 * @param namespaceIDofEnrichments
	 *            ID of the namespace of the enrichments
	 * @return the set of properties, operations and implementations that enrich the
	 *         class in the given namespace. If there is no enrichment in the
	 *         specified namespace, return the corresponding empty sets.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Tuple&lt;Set&lt;PropertyID&gt;, Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt;&gt; getEnrichmentsInNamespaceOfClass(
			final MetaClassID metaClassID, final NamespaceID namespaceIDofEnrichments) {

		// Get properties of the MetaClass with ID provided whose original
		// Namespace is the one specified
<span class="nc" id="L1727">		final Set&lt;PropertyID&gt; propertyEnrichments = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1728">		final List&lt;Property&gt; resultProp = classDB.getPropertiesByClassIDAndNamespaceID(metaClassID,</span>
				namespaceIDofEnrichments);
<span class="nc bnc" id="L1730" title="All 2 branches missed.">		for (final Property property : resultProp) {</span>
<span class="nc" id="L1731">			propertyEnrichments.add(property.getDataClayID());</span>
<span class="nc" id="L1732">		}</span>

		// Get operations of the MetaClass with ID provided whose original
		// Namespace is the one specified
<span class="nc" id="L1736">		final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; operationAndImplEnrichments = //</span>
				new HashMap&lt;&gt;();
<span class="nc" id="L1738">		final List&lt;Operation&gt; resultOps = classDB.getOperationsByClassIDAndNamespaceID(metaClassID,</span>
				namespaceIDofEnrichments);
<span class="nc bnc" id="L1740" title="All 2 branches missed.">		for (final Operation operation : resultOps) {</span>

<span class="nc" id="L1742">			final Set&lt;ImplementationID&gt; implOfOperationEnrichments = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L1744" title="All 2 branches missed.">			for (final Implementation implementation : operation.getImplementations()) {</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">				if (implementation.getNamespaceID().equals(namespaceIDofEnrichments)) {</span>
<span class="nc" id="L1746">					implOfOperationEnrichments.add(implementation.getDataClayID());</span>
				}
<span class="nc" id="L1748">			}</span>

<span class="nc" id="L1750">			operationAndImplEnrichments.put(operation.getDataClayID(), implOfOperationEnrichments);</span>

<span class="nc" id="L1752">		}</span>

<span class="nc" id="L1754">		return new Tuple&lt;&gt;(propertyEnrichments, operationAndImplEnrichments);</span>
	}

	/**
	 * Return all information of a class
	 * @param metaClassID
	 *            ID of the metaclass
	 * @return Information of the class
	 * @pre There is a class with ID provided
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public MetaClass getClassInfo(final MetaClassID metaClassID) {
		// Get class
<span class="nc" id="L1768">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>
<span class="nc" id="L1769">		return metaClass;</span>

	}

	/**
	 * Return ID of class of the type of the property or NULL if type is not
	 *        user type.
	 * @param propertyID
	 *            ID of the property
	 * @return ID of class of the type or NULL if type is not user type.
	 * @pre There is a type with ID provided
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public MetaClassID getClassIDFromProperty(final PropertyID propertyID) {
<span class="nc" id="L1784">		final Property prop = this.getPropertyFromDatabaseOrCache(propertyID);</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">		if (prop.getType() instanceof UserType) {</span>
<span class="nc" id="L1786">			final UserType includeUType = (UserType) prop.getType();</span>
<span class="nc" id="L1787">			return includeUType.getClassID();</span>
		} else {
<span class="nc" id="L1789">			return null;</span>
		}
	}

	/**
	 * Return information of classes in the given namespace.
	 * @param namespaceID
	 *            ID of the namespace of the classes to be retrieved
	 * @return the info of the classes in the namespace provided.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Map&lt;MetaClassID, MetaClass&gt; getInfoOfClassesInNamespace(final NamespaceID namespaceID) {
		// Get classes
<span class="nc" id="L1803">		final List&lt;MetaClass&gt; classesInNamespace = classDB.getClassesInNamespace(namespaceID);</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">		if (classesInNamespace == null) {</span>
<span class="nc" id="L1805">			return null;</span>
		}

<span class="nc" id="L1808">		final Map&lt;MetaClassID, MetaClass&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">		for (final MetaClass curClass : classesInNamespace) {</span>
<span class="nc" id="L1810">			result.put(curClass.getDataClayID(), curClass);</span>
<span class="nc" id="L1811">		}</span>

<span class="nc" id="L1813">		return result;</span>
	}

	/**
	 * Return all information of an operation
	 * @param operationID
	 *            ID of the operation
	 * @return Information of the operation
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Operation getOperationInfo(final OperationID operationID) {
		// First we get the Operation and check if it exists
<span class="nc" id="L1826">		final Operation operation = getOperationFromDatabaseOrCache(operationID);</span>
<span class="nc" id="L1827">		return operation;</span>
	}

	/**
	 * Return all information of a property
	 * @param propertyID
	 *            ID of the property
	 * @return Information of the property
	 */
	public Property getPropertyInfo(final PropertyID propertyID) {
		// First we get the Property and check if it exists
<span class="nc" id="L1838">		final Property property = getPropertyFromDatabaseOrCache(propertyID);</span>
<span class="nc" id="L1839">		return property;</span>
	}

	/**
	 * For each property and operation ID of the metaclass with ID provided
	 *        return all those that belong to the namespace with ID specified
	 * @param metaClassID
	 *            ID of the MetaClass
	 * @param namespaceID
	 *            ID of the namespace
	 * @return IDs of operations and IDs of properties that belong to the Namespace
	 *         with ID provided and class with ID specified.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Tuple&lt;Set&lt;PropertyID&gt;, Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt;&gt; getOperationsAndPropertiesAndImplInNamespace(
			final MetaClassID metaClassID, final NamespaceID namespaceID) {

		// Get the class
<span class="nc" id="L1858">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>

<span class="nc" id="L1860">		final Set&lt;PropertyID&gt; propertyIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1861">		final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; operationIDs = //</span>
				new HashMap&lt;&gt;();

<span class="nc bnc" id="L1864" title="All 2 branches missed.">		for (final Operation operation : metaClass.getOperations()) {</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">			if (operation.getNamespaceID().equals(namespaceID)) {</span>

<span class="nc" id="L1867">				final Set&lt;ImplementationID&gt; implementationIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">				for (final Implementation implementation : operation.getImplementations()) {</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">					if (implementation.getNamespaceID().equals(namespaceID)) {</span>
<span class="nc" id="L1870">						implementationIDs.add(implementation.getDataClayID());</span>
					}
<span class="nc" id="L1872">				}</span>
<span class="nc" id="L1873">				operationIDs.put(operation.getDataClayID(), implementationIDs);</span>
			}
<span class="nc" id="L1875">		}</span>

<span class="nc bnc" id="L1877" title="All 2 branches missed.">		for (final Property property : metaClass.getProperties()) {</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">			if (property.getNamespaceID().equals(namespaceID)) {</span>
<span class="nc" id="L1879">				propertyIDs.add(property.getDataClayID());</span>
			}

<span class="nc" id="L1882">		}</span>

<span class="nc" id="L1884">		return new Tuple&lt;&gt;(propertyIDs, operationIDs);</span>
	}

	/**
	 * Return the operations IDs of the default getters and setters of the
	 *        given properties IDs
	 * @param metaClassID
	 *            ID of the class of the properties
	 * @param propertiesIDs
	 *            IDs of the properties
	 * @return The set of operations IDs corresponding to the getters and setters of
	 *         the specified properties.
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Set&lt;OperationID&gt; getOperationsIDsOfGettersAndSetters(final MetaClassID metaClassID,
			final Set&lt;PropertyID&gt; propertiesIDs) {
<span class="nc" id="L1901">		final Set&lt;OperationID&gt; gettersAndSetters = new HashSet&lt;&gt;();</span>

		// Get the class
<span class="nc" id="L1904">		final MetaClass metaClass = getClassFromDatabaseOrCache(metaClassID);</span>
<span class="nc bnc" id="L1905" title="All 2 branches missed.">		for (final Property property : metaClass.getProperties()) {</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">			if (propertiesIDs.contains(property.getDataClayID())) {</span>
<span class="nc" id="L1907">				gettersAndSetters.add(property.getGetterOperationID());</span>
<span class="nc" id="L1908">				gettersAndSetters.add(property.getSetterOperationID());</span>
			}
<span class="nc" id="L1910">		}</span>

<span class="nc" id="L1912">		return gettersAndSetters;</span>
	}

	/**
	 * Return the implementations of the operations of the getters and
	 *        setters of the given properties
	 * @param propertiesInClass
	 *            Properties which implementations of getters ands settes have to be
	 *            retrieved.
	 * @return The implementations of the operations of the getters and setters of
	 *         the given properties
	 * @throws Exception
	 *             if an internal error occurred while working with Database.
	 */
	public Map&lt;PropertyID, Map&lt;OperationID, ImplementationID&gt;&gt; getImplementationsOfGettersAndSetters(
			final Map&lt;MetaClassID, Set&lt;PropertyID&gt;&gt; propertiesInClass) {
<span class="nc" id="L1928">		final Map&lt;PropertyID, Map&lt;OperationID, ImplementationID&gt;&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">		for (final Entry&lt;MetaClassID, Set&lt;PropertyID&gt;&gt; curProperties : propertiesInClass.entrySet()) {</span>
<span class="nc" id="L1930">			final MetaClass metaClass = getClassFromDatabaseOrCache(curProperties.getKey());</span>
<span class="nc bnc" id="L1931" title="All 2 branches missed.">			for (final Property prop : metaClass.getProperties()) {</span>
<span class="nc bnc" id="L1932" title="All 2 branches missed.">				if (curProperties.getValue().contains(prop.getDataClayID())) {</span>
<span class="nc" id="L1933">					final Map&lt;OperationID, ImplementationID&gt; implsOfGettersAndSetters = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1934">					final OperationID getter = prop.getGetterOperationID();</span>
<span class="nc" id="L1935">					final OperationID setter = prop.getSetterOperationID();</span>
<span class="nc" id="L1936">					final Operation getterRef = this.getOperationFromDatabaseOrCache(getter);</span>
<span class="nc" id="L1937">					final Operation setterRef = this.getOperationFromDatabaseOrCache(setter);</span>
<span class="nc" id="L1938">					implsOfGettersAndSetters.put(getter,</span>
<span class="nc" id="L1939">							getterRef.getImplementations().iterator().next().getDataClayID());</span>
<span class="nc" id="L1940">					implsOfGettersAndSetters.put(setter,</span>
<span class="nc" id="L1941">							setterRef.getImplementations().iterator().next().getDataClayID());</span>

<span class="nc" id="L1943">					result.put(prop.getDataClayID(), implsOfGettersAndSetters);</span>
				}
<span class="nc" id="L1945">			}</span>
<span class="nc" id="L1946">		}</span>
<span class="nc" id="L1947">		return result;</span>
	}

	/**
	 * Generate execution class for Java MetaClasses. This function should be
	 *        used to install a class in DataService.
	 * @param metaClass
	 *            ID of the class
	 * @return The bytes of the generated execution class and its aspects.
	 * @throws Exception
	 *             If some exception occurs.
	 */
	public Tuple&lt;byte[], byte[]&gt; generateJavaExecutionClass(final MetaClass metaClass) {


		// Get parent name
<span class="nc" id="L1963">		String realParentName = null;</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">		if (metaClass.getParentType() == null) {</span>
<span class="nc" id="L1965">			realParentName = DataClayObject.class.getName();</span>
		} else {
<span class="nc" id="L1967">			final MetaClass parentClass = getClassFromDatabaseOrCache(metaClass.getParentType().getClassID());</span>
<span class="nc" id="L1968">			realParentName = parentClass.getNamespace() + &quot;.&quot; + parentClass.getName();</span>
		}
<span class="nc" id="L1970">		MetaClass curClass = metaClass;</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">		while (curClass.getParentType() != null) {</span>
<span class="nc" id="L1972">			MetaClassID parentID = null;</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">			if (metaClass.getParentType() != null) {</span>
<span class="nc" id="L1974">				parentID = curClass.getParentType().getClassID();</span>
			}
<span class="nc" id="L1976">			curClass = getClassFromDatabaseOrCache(parentID);</span>
<span class="nc" id="L1977">		}</span>

		// Once symbols were modified we must generate the execution class
<span class="nc" id="L1980">		Map&lt;MetaClassID, MetaClass&gt; allNamespaceClasses = this.getInfoOfClassesInNamespace(metaClass.getNamespaceID());</span>
<span class="nc bnc" id="L1981" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1982">			List&lt;String&gt; classNamesToUse = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">			for (MetaClass curDepClass : allNamespaceClasses.values()) {</span>
<span class="nc" id="L1984">				classNamesToUse.add(curDepClass.getName());</span>
<span class="nc" id="L1985">			}</span>
<span class="nc" id="L1986">			logger.debug(&quot;Class dependencies used to replace: &quot; + classNamesToUse);</span>

		}
<span class="nc" id="L1989">		final byte[] result = ExecutionByteCodeManager.generateExecutionClass(metaClass, realParentName, this,</span>
<span class="nc" id="L1990">				new ArrayList&lt;&gt;(allNamespaceClasses.values()));</span>
<span class="nc" id="L1991">		final byte[] aspects = StubByteCodeManager.generateStubAspect(metaClass, true, this);</span>
<span class="nc" id="L1992">		return new Tuple&lt;&gt;(result, aspects);</span>
	}

	/**
	 * Get all includes of the class
	 * @param metaClass
	 *            Class to check
	 * @return All includes of type
	 */
	private List&lt;MetaClass&gt; getAllIncludes(final MetaClass metaClass) {

<span class="nc" id="L2003">		final Set&lt;MetaClassID&gt; accClass = new HashSet&lt;&gt;();</span>

		// ======================== FIND ALL ACCESSED CLASSES
		// ==================================== //
<span class="nc" id="L2007">		MetaClass curMetaClass = metaClass;</span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">		while (curMetaClass != null) {</span>
<span class="nc" id="L2009">			accClass.add(curMetaClass.getDataClayID());</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">			if (curMetaClass.getParentType() == null) {</span>
<span class="nc" id="L2011">				curMetaClass = null;</span>
			} else {
<span class="nc" id="L2013">				curMetaClass = this.getClassInfo(curMetaClass.getParentType().getClassID());</span>
			}
		}
		
<span class="nc bnc" id="L2017" title="All 2 branches missed.">		if (metaClass.getJavaClassInfo() != null) {</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">			for (final Type ifaceInclude : metaClass.getJavaClassInfo().getIncludes()) {  </span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">				if (ifaceInclude instanceof UserType) {</span>
<span class="nc" id="L2020">					final UserType utype = (UserType) ifaceInclude;</span>
<span class="nc" id="L2021">					accClass.add(utype.getClassID());</span>
				}
<span class="nc" id="L2023">			}</span>
		}

<span class="nc bnc" id="L2026" title="All 2 branches missed.">		for (final Operation op : metaClass.getOperations()) {</span>
<span class="nc bnc" id="L2027" title="All 2 branches missed.">			if (op.getReturnType() instanceof UserType) {</span>
<span class="nc" id="L2028">				final UserType utype = (UserType) op.getReturnType();</span>
<span class="nc" id="L2029">				accClass.add(utype.getClassID());</span>
			}
<span class="nc bnc" id="L2031" title="All 2 branches missed.">			if (op.getReturnType().getIncludes() != null) {</span>
<span class="nc bnc" id="L2032" title="All 2 branches missed.">				for (final Type subInclude : op.getReturnType().getIncludes()) {</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">					if (subInclude instanceof UserType) {</span>
<span class="nc" id="L2034">						final UserType utype = (UserType) subInclude;</span>
<span class="nc" id="L2035">						accClass.add(utype.getClassID());</span>
					}
<span class="nc" id="L2037">				}</span>
			}
<span class="nc bnc" id="L2039" title="All 2 branches missed.">			for (final Type paramType : op.getParams().values()) {</span>
<span class="nc bnc" id="L2040" title="All 2 branches missed.">				if (paramType instanceof UserType) {</span>
<span class="nc" id="L2041">					final UserType utype = (UserType) paramType;</span>
<span class="nc" id="L2042">					accClass.add(utype.getClassID());</span>
				}
<span class="nc bnc" id="L2044" title="All 2 branches missed.">				if (paramType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">					for (final Type subInclude : paramType.getIncludes()) {</span>
<span class="nc bnc" id="L2046" title="All 2 branches missed.">						if (subInclude instanceof UserType) {</span>
<span class="nc" id="L2047">							final UserType utype = (UserType) subInclude;</span>
<span class="nc" id="L2048">							accClass.add(utype.getClassID());</span>
						}
<span class="nc" id="L2050">					}</span>
				}
<span class="nc" id="L2052">			}</span>

<span class="nc bnc" id="L2054" title="All 2 branches missed.">			if (op.getIsAbstract()) {</span>
<span class="nc" id="L2055">				continue;</span>
			}
<span class="nc bnc" id="L2057" title="All 2 branches missed.">			for (final Implementation impl : op.getImplementations()) {</span>
				// Get accessed implementation IDs
<span class="nc" id="L2059">				final List&lt;AccessedImplementation&gt; accImplems = impl.getAccessedImplementations();</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">				for (final AccessedImplementation accImplS : accImplems) {</span>
<span class="nc" id="L2061">					final ImplementationID accImplID = accImplS.getImplementationID();</span>
<span class="nc" id="L2062">					final Implementation accImpl = getImplementationFromDatabaseOrCache(accImplID);</span>
<span class="nc" id="L2063">					final Operation accOp = getOperationFromDatabaseOrCache(accImpl.getOperationID());</span>

					// Check accessed classes
<span class="nc" id="L2066">					accClass.add(accImpl.getMetaClassID());</span>
<span class="nc bnc" id="L2067" title="All 2 branches missed.">					if (accOp.getReturnType() instanceof UserType) {</span>
<span class="nc" id="L2068">						final UserType utype = (UserType) accOp.getReturnType();</span>
<span class="nc" id="L2069">						accClass.add(utype.getClassID());</span>
					}
<span class="nc bnc" id="L2071" title="All 2 branches missed.">					if (accOp.getReturnType().getIncludes() != null) {</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">						for (final Type subInclude : accOp.getReturnType().getIncludes()) {</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">							if (subInclude instanceof UserType) {</span>
<span class="nc" id="L2074">								final UserType utype = (UserType) subInclude;</span>
<span class="nc" id="L2075">								accClass.add(utype.getClassID());</span>
							}
<span class="nc" id="L2077">						}</span>
					}
<span class="nc bnc" id="L2079" title="All 2 branches missed.">					for (final Type paramType : accOp.getParams().values()) {</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">						if (paramType instanceof UserType) {</span>
<span class="nc" id="L2081">							final UserType utype = (UserType) paramType;</span>
<span class="nc" id="L2082">							accClass.add(utype.getClassID());</span>
						}
<span class="nc bnc" id="L2084" title="All 2 branches missed.">						if (paramType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">							for (final Type subInclude : paramType.getIncludes()) {</span>
<span class="nc bnc" id="L2086" title="All 2 branches missed.">								if (subInclude instanceof UserType) {</span>
<span class="nc" id="L2087">									final UserType utype = (UserType) subInclude;</span>
<span class="nc" id="L2088">									accClass.add(utype.getClassID());</span>
								}
<span class="nc" id="L2090">							}</span>
						}
<span class="nc" id="L2092">					}</span>
<span class="nc" id="L2093">				}</span>

<span class="nc bnc" id="L2095" title="All 2 branches missed.">				for (final AccessedProperty accProp : impl.getAccessedProperties()) {</span>
<span class="nc" id="L2096">					final PropertyID accPropertyID = accProp.getPropertyID();</span>
<span class="nc" id="L2097">					final Property accProperty = getPropertyFromDatabaseOrCache(accPropertyID);</span>
					// Check accessed classes
<span class="nc" id="L2099">					accClass.add(accProperty.getMetaClassID());</span>

<span class="nc" id="L2101">					final Type accTypeProp = accProperty.getType();</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">					if (accTypeProp instanceof UserType) {</span>

<span class="nc" id="L2104">						final UserType utype = (UserType) accTypeProp;</span>
<span class="nc" id="L2105">						accClass.add(utype.getClassID());</span>
					}
<span class="nc bnc" id="L2107" title="All 2 branches missed.">					if (accTypeProp.getIncludes() != null) {</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">						for (final Type subInclude : accTypeProp.getIncludes()) {</span>
<span class="nc bnc" id="L2109" title="All 2 branches missed.">							if (subInclude instanceof UserType) {</span>
<span class="nc" id="L2110">								final UserType utype = (UserType) subInclude;</span>
<span class="nc" id="L2111">								accClass.add(utype.getClassID());</span>
							}
<span class="nc" id="L2113">						}</span>
					}

<span class="nc" id="L2116">				}</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">				for (final Type accInclude : impl.getIncludes()) {</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">					if (accInclude instanceof UserType) {</span>
<span class="nc" id="L2119">						final UserType utype = (UserType) accInclude;</span>
<span class="nc" id="L2120">						accClass.add(utype.getClassID());</span>
					}
<span class="nc bnc" id="L2122" title="All 2 branches missed.">					if (accInclude.getIncludes() != null) {</span>
<span class="nc bnc" id="L2123" title="All 2 branches missed.">						for (final Type subInclude : accInclude.getIncludes()) {</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">							if (subInclude instanceof UserType) {</span>
<span class="nc" id="L2125">								final UserType utype = (UserType) subInclude;</span>
<span class="nc" id="L2126">								accClass.add(utype.getClassID());</span>
							}
<span class="nc" id="L2128">						}</span>
					}
<span class="nc" id="L2130">				}</span>

<span class="nc" id="L2132">			}</span>
<span class="nc" id="L2133">		}</span>
<span class="nc bnc" id="L2134" title="All 2 branches missed.">		for (final Property prop : metaClass.getProperties()) {</span>
<span class="nc" id="L2135">			final Type propType = prop.getType();</span>
<span class="nc bnc" id="L2136" title="All 2 branches missed.">			if (propType instanceof UserType) {</span>
<span class="nc" id="L2137">				final UserType utype = (UserType) propType;</span>
<span class="nc" id="L2138">				accClass.add(utype.getClassID());</span>
			}
<span class="nc bnc" id="L2140" title="All 2 branches missed.">			if (propType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">				for (final Type accInclude : propType.getIncludes()) {</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">					if (accInclude instanceof UserType) {</span>
<span class="nc" id="L2143">						final UserType utype = (UserType) accInclude;</span>
<span class="nc" id="L2144">						accClass.add(utype.getClassID());</span>
					}
<span class="nc" id="L2146">				}</span>
			}
<span class="nc" id="L2148">		}</span>

<span class="nc" id="L2150">		final List&lt;MetaClass&gt; accessedClasses = new ArrayList&lt;&gt;(); // Used later for replacing.</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">		for (final MetaClassID accClassID : accClass) {</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">			if (accClassID == null) {</span>
<span class="nc" id="L2153">				continue; // Can be null for java or DataCLay types</span>
			}
<span class="nc" id="L2155">			final MetaClass accessedClass = getClassFromDatabaseOrCache(accClassID);</span>
<span class="nc" id="L2156">			accessedClasses.add(accessedClass);</span>
<span class="nc" id="L2157">		}</span>

<span class="nc" id="L2159">		return accessedClasses;</span>
	}

	// ============= OTHER =========== //

	/**
	 * Return the cache of classes
	 * @return The cache of classes
	 */
	public MemoryCache&lt;MetaClassID, MetaClass&gt; getClassCache() {
<span class="nc" id="L2169">		return this.classCache;</span>
	}

	/**
	 * Method for unit testing.
	 * @return the db handler reference of this manager.
	 */
	public ClassManagerDB getDbHandler() {
<span class="fc" id="L2177">		return classDB;</span>
	}

	@Override
	public void cleanCaches() {
<span class="nc" id="L2182">		this.implementationsCache.clear();</span>
<span class="nc" id="L2183">		this.classCache.clear();</span>
<span class="nc" id="L2184">		this.operationsCache.clear();</span>
<span class="nc" id="L2185">		this.propertiesCache.clear();</span>
<span class="nc" id="L2186">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>