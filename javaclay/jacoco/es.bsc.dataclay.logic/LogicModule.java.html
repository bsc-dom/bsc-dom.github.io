<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogicModule.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.logic</a> &gt; <span class="el_source">LogicModule.java</span></div><h1>LogicModule.java</h1><pre class="source lang-java linenums">
/**
 * @file LogicModule.java
 * @date Sep 17, 2012
 */
package es.bsc.dataclay.logic;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.rmi.RemoteException;
import java.text.ParseException;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

import es.bsc.dataclay.api.BackendID;
import es.bsc.dataclay.dbhandler.sql.sqlite.SQLiteHandlerConfig;
import es.bsc.dataclay.exceptions.metadataservice.*;
import es.bsc.dataclay.logic.logicmetadata.LogicModuleMetadataMgr;
import es.bsc.dataclay.logic.server.LogicModuleSrv;
import es.bsc.dataclay.util.management.metadataservice.*;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import es.bsc.dataclay.dbhandler.sql.sqlite.SQLiteDataSource;
import org.yaml.snakeyaml.Yaml;

import es.bsc.dataclay.commonruntime.DataServiceRuntime;
import es.bsc.dataclay.communication.grpc.clients.CommonGrpcClient;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.dataservice.api.DataServiceAPI;
import es.bsc.dataclay.dbhandler.DBHandler;
import es.bsc.dataclay.dbhandler.DBHandlerConf;
import es.bsc.dataclay.dbhandler.sql.SQLHandler;
import es.bsc.dataclay.exceptions.DataClayException;
import es.bsc.dataclay.exceptions.DataClayRuntimeException;
import es.bsc.dataclay.exceptions.ErrorDefs.ERRORCODE;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectAlreadyExistException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.accountmgr.AccountAlreadyExistException;
import es.bsc.dataclay.exceptions.logicmodule.accountmgr.AccountNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.datacontractmgr.AccountAlreadyHasADataContractWithProvider;
import es.bsc.dataclay.exceptions.logicmodule.datasetmgr.DataSetExistsException;
import es.bsc.dataclay.exceptions.logicmodule.namespacemgr.AccountNotResponsibleOfNamespace;
import es.bsc.dataclay.exceptions.logicmodule.namespacemgr.NamespaceDoesNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.namespacemgr.NamespaceExistsException;
import es.bsc.dataclay.exceptions.logicmodule.sessionmgr.SessionNotExistException;
import es.bsc.dataclay.extrae.DataClayExtrae;
import es.bsc.dataclay.logic.accountmgr.AccountManager;
import es.bsc.dataclay.logic.accountmgr.AccountManagerDB;
import es.bsc.dataclay.logic.api.LogicModuleAPI;
import es.bsc.dataclay.logic.classmgr.ClassManager;
import es.bsc.dataclay.logic.classmgr.ClassManagerDB;
import es.bsc.dataclay.logic.contractmgr.ContractManager;
import es.bsc.dataclay.logic.contractmgr.ContractManagerDB;
import es.bsc.dataclay.logic.datacontractmgr.DataContractManager;
import es.bsc.dataclay.logic.datacontractmgr.DataContractManagerDB;
import es.bsc.dataclay.logic.datasetmgr.DataSetManager;
import es.bsc.dataclay.logic.datasetmgr.DataSetManagerDB;
import es.bsc.dataclay.logic.interfacemgr.InterfaceManager;
import es.bsc.dataclay.logic.interfacemgr.InterfaceManagerDB;
import es.bsc.dataclay.logic.logicmetadata.LogicMetadataDB;
import es.bsc.dataclay.logic.logicmetadata.LogicMetadataIDs;
import es.bsc.dataclay.logic.namespacemgr.NamespaceManager;
import es.bsc.dataclay.logic.namespacemgr.NamespaceManagerDB;
import es.bsc.dataclay.logic.notificationmgr.NotificationManager;
import es.bsc.dataclay.logic.notificationmgr.NotificationManagerDB;
import es.bsc.dataclay.logic.sessionmgr.SessionManager;
import es.bsc.dataclay.logic.sessionmgr.SessionManagerDB;
import es.bsc.dataclay.metadataservice.MetaDataService;
import es.bsc.dataclay.metadataservice.MetaDataServiceDB;
import es.bsc.dataclay.serialization.lib.DataClayDeserializationLib;
import es.bsc.dataclay.serialization.lib.ObjectWithDataParamOrReturn;
import es.bsc.dataclay.serialization.lib.SerializedParametersOrReturn;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.DataClayObjectMetaData;
import es.bsc.dataclay.util.FileAndAspectsUtils;
import es.bsc.dataclay.util.configs.CfgAdminEnvLoader;
import es.bsc.dataclay.util.events.listeners.ECA;
import es.bsc.dataclay.util.events.message.EventMessage;
import es.bsc.dataclay.util.events.type.EventType;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.ContractID;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.DataContractID;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.InterfaceID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.NamespaceID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.OperationID;
import es.bsc.dataclay.util.ids.PropertyID;
import es.bsc.dataclay.util.ids.SessionID;
import es.bsc.dataclay.util.ids.StorageLocationID;
import es.bsc.dataclay.util.info.VersionInfo;
import es.bsc.dataclay.util.management.accountmgr.Account;
import es.bsc.dataclay.util.management.accountmgr.AccountRole;
import es.bsc.dataclay.util.management.accountmgr.PasswordCredential;
import es.bsc.dataclay.util.management.classmgr.AccessedImplementation;
import es.bsc.dataclay.util.management.classmgr.AccessedProperty;
import es.bsc.dataclay.util.management.classmgr.Implementation;
import es.bsc.dataclay.util.management.classmgr.MetaClass;
import es.bsc.dataclay.util.management.classmgr.Operation;
import es.bsc.dataclay.util.management.classmgr.PrefetchingInformation;
import es.bsc.dataclay.util.management.classmgr.Property;
import es.bsc.dataclay.util.management.classmgr.Type;
import es.bsc.dataclay.util.management.classmgr.UserType;
import es.bsc.dataclay.util.management.contractmgr.Contract;
import es.bsc.dataclay.util.management.contractmgr.InterfaceInContract;
import es.bsc.dataclay.util.management.contractmgr.OpImplementations;
import es.bsc.dataclay.util.management.datacontractmgr.DataContract;
import es.bsc.dataclay.util.management.datasetmgr.DataSet;
import es.bsc.dataclay.util.management.interfacemgr.Interface;
import es.bsc.dataclay.util.management.namespacemgr.ImportedInterface;
import es.bsc.dataclay.util.management.namespacemgr.Namespace;
import es.bsc.dataclay.util.management.sessionmgr.SessionContract;
import es.bsc.dataclay.util.management.sessionmgr.SessionDataContract;
import es.bsc.dataclay.util.management.sessionmgr.SessionImplementation;
import es.bsc.dataclay.util.management.sessionmgr.SessionInfo;
import es.bsc.dataclay.util.management.sessionmgr.SessionInterface;
import es.bsc.dataclay.util.management.sessionmgr.SessionOperation;
import es.bsc.dataclay.util.management.sessionmgr.SessionProperty;
import es.bsc.dataclay.util.management.stubs.ImplementationStubInfo;
import es.bsc.dataclay.util.management.stubs.PropertyStubInfo;
import es.bsc.dataclay.util.management.stubs.StubClassLoader;
import es.bsc.dataclay.util.management.stubs.StubInfo;
import es.bsc.dataclay.util.reflection.Reflector;
import es.bsc.dataclay.util.structs.Triple;
import es.bsc.dataclay.util.structs.Tuple;
import es.bsc.dataclay.util.tools.java.JavaSpecGenerator;
import es.bsc.dataclay.util.yaml.CommonYAML;

/**
 * This class represents the entry point to the system.
 */
public class LogicModule implements LogicModuleAPI {

    /** Logger. */
<span class="nc" id="L144">    protected static final Logger LOGGER = LogManager.getLogger(&quot;LogicModule&quot;);</span>

    /** Indicates if debug is enabled. */
<span class="nc" id="L147">    protected static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

    /** LogicModule hostname. */
    protected String hostname;
    /** LogicModule port. */
    protected int port;

    /** Grpc client. */
    public final CommonGrpcClient grpcClient;

	/** DataService APIs, with associated StorageLocation. */
<span class="nc" id="L158">	private final Map&lt;StorageLocationID, Tuple&lt;DataServiceAPI, StorageLocation&gt;&gt; storageLocations = new ConcurrentHashMap&lt;&gt;();</span>

	/**
	 * DataService APIs, associated to ExecutionEnvironment (language dependent).
	 */
<span class="nc" id="L163">	private final Map&lt;Langs, Map&lt;ExecutionEnvironmentID, Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt;&gt;&gt; execEnvironments = new ConcurrentHashMap&lt;&gt;();</span>

	/** Active Backends splitted in execution environments per storage Locations. */
<span class="nc" id="L166">	private final Map&lt;StorageLocationID, Set&lt;ExecutionEnvironmentID&gt;&gt; activeBackends = new ConcurrentHashMap&lt;&gt;();</span>
	
	/** Name of public namespace DataClay (for DataClay classes). */
	public static final String DC_PUBLIC_NAMESPACE = &quot;DataClayNamespace&quot;;
	/** Name of DataClay registrator (for DataClay classes). */
	public static final String DC_REGISTRATOR = &quot;DataClayRegistrator&quot;;
	/** Suffix for default dataset. */
	public static final String DEFAULT_DS_SUFFIX = &quot;_ds&quot;;
	/** Suffix for default java namespace. */
	public static final String DEFAULT_JAVA_NS_SUFFIX = &quot;_java_ns&quot;;
	/** Suffix for default python namespace. */
	public static final String DEFAULT_PYTHON_NS_SUFFIX = &quot;_python_ns&quot;;

    /** Account Manager. */
    private final AccountManager accountMgrApi;
    /** Contract Manager. */
    private final ContractManager contractMgrApi;
    /** Interface Manager. */
    private final InterfaceManager interfaceMgrApi;
    /** Class Manager. */
    private final ClassManager classMgrApi;
    /** Namespace Manager. */
    private final NamespaceManager namespaceMgrApi;
    /** Session Manager. */
    private final SessionManager sessionMgrApi;
    /** MetaDataService. */
    private final MetaDataService metaDataSrvApi;
    /** DataSet Manager. */
    private final DataSetManager dataSetMgrApi;
    /** DataContract Manager. */
    private final DataContractManager datacontractMgrApi;
    /** NotificationManager. */
    private NotificationManager notificationMgrApi;
    /** LogicModule metadata mgr. */
    private LogicModuleMetadataMgr logicMetadataMgr;
    /**
     * LM public IDs (admin, contract, datasets...) This field contains all IDs that
     * must be the same even if we restart LM or for backups.
     */
<span class="nc" id="L205">    public LogicMetadataIDs publicIDs = new LogicMetadataIDs();</span>

    /** Credentials of DataClay registrator (for DataClay classes). */
<span class="nc" id="L208">    public PasswordCredential dcCredentials = new PasswordCredential(DC_REGISTRATOR);</span>

    /** IPs to be send to clients when information of a registered EE/SL is required. Can be null.*/
    private String exposedIPForClient;

    /** Account to register federation stuff. */
    private static final String FEDERATOR_ACCOUNT_USERNAME = &quot;Federator&quot;;
    /** Name of dataset for external objects. */
    private static final String EXTERNAL_OBJECTS_DATASET_NAME = &quot;ExternalObjects&quot;;
    /** Namespace of classes for federable Java class model. */
    private static final String JAVA_NAMESPACE_FOR_FEDERABLE_CLASSES = &quot;JavaFederableNamespace&quot;;
    /** Namespace of classes for federable Python class model. */
    private static final String PY_NAMESPACE_FOR_FEDERABLE_CLASSES = &quot;PythonFederableNamespace&quot;;

    /** Session ID for activity coming from external dataclays. */
    private static SessionID federationSessionID;

    /** Indicates if it is being shut down. */
<span class="nc" id="L226">    private boolean shuttingDown = false;</span>

    /** Indicates Logicmodule database is in memory. */
<span class="nc" id="L229">    private boolean inMemory = false;</span>

    /** SQL handler for management. */
    private SQLHandler&lt;SQLiteHandlerConfig&gt; mgmHandler;

    /** SQL handler for metadata. */
    private SQLHandler&lt;SQLiteHandlerConfig&gt; metadataHandler;

    /** Name of the LM */
    protected String name;

    /**
     * LogicModule constructor
     *
     * @param lmName
     *            LM name
     * @param thehostname
     *            Logic module host name
     * @param theport
     *            Logic Module port.
     * @param theexposedIPForClient
     * 			IPs to be send to clients when information of a registered EE/SL is required. Can be null.
     * @throws InterruptedException
     *             If GRPC client cannot be initialized for some reason
     */
    public LogicModule(final String lmName, final String thehostname, final int theport,
                       final boolean inMemory,
<span class="nc" id="L256">                       final String theexposedIPForClient) throws InterruptedException {</span>

        // ==== Initialization note === //
        // Here we set all variables read from configuration files (parameters) and
        // we check if LM has already an admin, a public dataset, a public contract...
        // by asking
        // to LogicMetadataDB.sh
        // If LogicMetadataDB has information about this logic module then
        // it means that we do not need to create admin, install dataclay collections
        // and others.
        // Otherwise, if there is no information about current LogicModule in the
        // database, we create
        // all needed ids (including DataClayInstanceID) and others.
<span class="nc" id="L269">        this.inMemory = inMemory;</span>

<span class="nc" id="L271">        this.name = lmName;</span>

<span class="nc" id="L273">        SQLiteHandlerConfig mgmDbConf = new SQLiteHandlerConfig(Configuration.Flags.STORAGE_METADATA_PATH.getStringValue(), name + &quot;_metadata&quot;, Configuration.Flags.SQLITE_IN_MEMORY.getBooleanValue());</span>
<span class="nc" id="L274">        mgmHandler = (SQLHandler) mgmDbConf.getDBHandler();</span>
<span class="nc" id="L275">        mgmHandler.open();</span>

<span class="nc" id="L277">        SQLiteHandlerConfig metadataDbConf = new SQLiteHandlerConfig(Configuration.Flags.STORAGE_PATH.getStringValue(), name, Configuration.Flags.SQLITE_IN_MEMORY.getBooleanValue());</span>
<span class="nc" id="L278">        metadataHandler = (SQLHandler) metadataDbConf.getDBHandler();</span>
<span class="nc" id="L279">        metadataHandler.open();</span>

		// TODO generalize when dbhandler will not be sql-based
<span class="nc" id="L282">		final SQLiteDataSource mgmDataSource = mgmHandler.getDataSource();</span>
<span class="nc" id="L283">        final SQLiteDataSource metadataDataSource = metadataHandler.getDataSource();</span>

<span class="nc" id="L285">        hostname = thehostname;</span>
<span class="nc" id="L286">        port = theport;</span>
<span class="nc bnc" id="L287" title="All 4 branches missed.">        if (theexposedIPForClient != null &amp;&amp; !theexposedIPForClient.isEmpty()) {</span>
<span class="nc" id="L288">            this.exposedIPForClient = theexposedIPForClient;</span>
        }
<span class="nc" id="L290">        grpcClient = new CommonGrpcClient(lmName);</span>
<span class="nc" id="L291">        accountMgrApi = new AccountManager(mgmDataSource);</span>
<span class="nc" id="L292">        sessionMgrApi = new SessionManager(mgmDataSource);</span>
<span class="nc" id="L293">        namespaceMgrApi = new NamespaceManager(mgmDataSource);</span>
<span class="nc" id="L294">        dataSetMgrApi = new DataSetManager(mgmDataSource);</span>
<span class="nc" id="L295">        classMgrApi = new ClassManager(mgmDataSource);</span>
<span class="nc" id="L296">        interfaceMgrApi = new InterfaceManager(mgmDataSource);</span>
<span class="nc" id="L297">        contractMgrApi = new ContractManager(mgmDataSource);</span>
<span class="nc" id="L298">        datacontractMgrApi = new DataContractManager(mgmDataSource);</span>
<span class="nc" id="L299">        logicMetadataMgr = new LogicModuleMetadataMgr(mgmDataSource);</span>
<span class="nc" id="L300">        metaDataSrvApi = new MetaDataService(metadataDataSource);</span>
        // Tricky initialization for the *ByLang table of tables
<span class="nc bnc" id="L302" title="All 2 branches missed.">        for (final Langs lang : Langs.values()) {</span>
<span class="nc" id="L303">            execEnvironments.put(lang, new HashMap&lt;ExecutionEnvironmentID, Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt;&gt;());</span>
        }

<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L307">            notificationMgrApi = new NotificationManager(this, mgmDataSource);</span>
        }

<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (!logicMetadataMgr.existsMetaData()) {</span>
<span class="nc" id="L311">            this.prepareLogicModuleFirstTime(lmName, thehostname, theport);</span>
        } else {
            // update registered nodes!
<span class="nc" id="L314">            LOGGER.info(&quot;Found logic module database already present, initializing&quot;);</span>
<span class="nc" id="L315">            this.publicIDs = this.logicMetadataMgr.getLogicMetadata();</span>
            //this.updateAPIsFromDB();
        }
<span class="nc" id="L318">        LOGGER.info(&quot;Initialized Logic Module for dataClay with id {}&quot;, publicIDs.dcID);</span>
<span class="nc" id="L319">        LOGGER.info(&quot;Initialized Logic Module with hostname {} and port {}&quot;, hostname, port);</span>

<span class="nc" id="L321">    }</span>

    /**
     * Prepare Lm for the first time (not for restart or others)
     *
     * @param lmName
     *            LM name
     * @param thehostname
     *            Logic module host name
     * @param theport
     *            Logic Module port.
     * @throws InterruptedException
     *             If GRPC client cannot be initialized for some reason
     */
    private void prepareLogicModuleFirstTime(final String lmName, final String thehostname, final int theport) {

        // TODO: review uneeded code for checking if admin, datasets and others are
        // already created since
        // this function is called when LogicModule is restarted or using an existing
        // DB.

<span class="nc" id="L342">        publicIDs.dcID = new DataClayInstanceID();</span>
<span class="nc" id="L343">        final Account adminAccount = CfgAdminEnvLoader.parseAdminUser();</span>
<span class="nc" id="L344">        LOGGER.info(&quot;Creating admin user with name &quot; + adminAccount.getUsername() + &quot; and password &quot;</span>
<span class="nc" id="L345">                + adminAccount.getCredential().toString());</span>
        try {
<span class="nc" id="L347">            publicIDs.dcAdminID = accountMgrApi.getAccountID(adminAccount.getUsername());</span>
<span class="nc" id="L348">            LOGGER.info(&quot;Account admin already exists&quot;);</span>
<span class="nc" id="L349">        } catch (final AccountNotExistException e) {</span>
            // Create Admin account
<span class="nc" id="L351">            publicIDs.dcAdminID = new AccountID();</span>
<span class="nc" id="L352">            adminAccount.setDataClayID(publicIDs.dcAdminID);</span>
<span class="nc" id="L353">            final AccountManagerDB accountDbHandler = accountMgrApi.getDbHandler();</span>
            try {
<span class="nc" id="L355">                accountDbHandler.store(adminAccount);</span>
<span class="nc" id="L356">            } catch (final DbObjectAlreadyExistException err) {</span>
                // ignore
<span class="nc" id="L358">            }</span>
<span class="nc" id="L359">        }</span>
        // Register dataSet for external objects (federated with us)
<span class="nc" id="L361">        final PasswordCredential fedCredential = new PasswordCredential(FEDERATOR_ACCOUNT_USERNAME);</span>
<span class="nc" id="L362">        final Account federator = new Account(FEDERATOR_ACCOUNT_USERNAME, AccountRole.NORMAL_ROLE,</span>
                fedCredential);
        try {
<span class="nc" id="L365">            federator.setDataClayID(newAccount(publicIDs.dcAdminID, adminAccount.getCredential(), federator));</span>
<span class="nc" id="L366">        } catch (final AccountAlreadyExistException | NamespaceExistsException ne) {</span>
            // namespace might exist in case of mf2c starting db
<span class="nc" id="L368">            federator.setDataClayID(accountMgrApi.getAccountID(FEDERATOR_ACCOUNT_USERNAME));</span>
<span class="nc" id="L369">            LOGGER.info(&quot;Account Federator already exists&quot;);</span>
<span class="nc" id="L370">        }</span>

<span class="nc" id="L372">        final DataSet dataset = new DataSet(EXTERNAL_OBJECTS_DATASET_NAME, federator.getDataClayID(), true);</span>
<span class="nc" id="L373">        DataContract dContract = null;</span>
        try {
<span class="nc" id="L375">            dataset.setDataClayID(newDataSet(federator.getDataClayID(), federator.getCredential(), dataset));</span>

<span class="nc" id="L377">            final Calendar beginDate = Calendar.getInstance();</span>
<span class="nc" id="L378">            beginDate.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L379">            final Calendar endDate = Calendar.getInstance();</span>
<span class="nc" id="L380">            endDate.add(Calendar.YEAR, 100);</span>
<span class="nc" id="L381">            dContract = new DataContract(dataset.getDataClayID(), federator.getDataClayID(),</span>
                    new HashSet&lt;&gt;(), beginDate, endDate, false);
<span class="nc" id="L383">            dContract.setPublicAvailable(true);</span>

<span class="nc" id="L385">            newDataContract(federator.getDataClayID(), federator.getCredential(), dContract);</span>

<span class="nc" id="L387">        } catch (final DataSetExistsException de) {</span>
            // Ignore it, for testing purposes
<span class="nc" id="L389">            dataset.setDataClayID(dataSetMgrApi.getDataSetID(EXTERNAL_OBJECTS_DATASET_NAME));</span>
<span class="nc" id="L390">            LOGGER.info(&quot;Dataset for external objects already exists&quot;);</span>
<span class="nc" id="L391">        }</span>

        // Register namespaces for the model of federated objects
<span class="nc" id="L394">        final Namespace jNamespace = new Namespace(JAVA_NAMESPACE_FOR_FEDERABLE_CLASSES, federator.getUsername(),</span>
                Langs.LANG_JAVA);
<span class="nc" id="L396">        final Namespace pyNamespace = new Namespace(PY_NAMESPACE_FOR_FEDERABLE_CLASSES, federator.getUsername(),</span>
                Langs.LANG_PYTHON);
        try {
<span class="nc" id="L399">            newNamespace(federator.getDataClayID(), federator.getCredential(), jNamespace);</span>
<span class="nc" id="L400">            newNamespace(federator.getDataClayID(), federator.getCredential(), pyNamespace);</span>
<span class="nc" id="L401">        } catch (final NamespaceExistsException ne) {</span>
            // Ignore it
<span class="nc" id="L403">            LOGGER.info(&quot;Namespace for federated objects already exists&quot;);</span>
<span class="nc" id="L404">        }</span>

<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (Configuration.Flags.REGISTER_DATACLAY_CLASSES.getBooleanValue()) {</span>
<span class="nc" id="L407">            registerDataClayPreinstalledClasses(adminAccount);</span>
        }

        // Store LogicModule information once prepared
<span class="nc" id="L411">        this.logicMetadataMgr.registerLogicModule(publicIDs);</span>

<span class="nc" id="L413">        final Set&lt;DataSetID&gt; dataSetIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L414">        dataSetIDs.add(dataset.getDataClayID());</span>
<span class="nc" id="L415">        final Set&lt;ContractID&gt; contracts = new HashSet&lt;&gt;();</span>
<span class="nc" id="L416">        federationSessionID = this.newSession(federator.getDataClayID(), fedCredential,</span>
<span class="nc" id="L417">                contracts, dataSetIDs, dataset.getDataClayID(), Langs.LANG_JAVA).getSessionID();</span>

<span class="nc" id="L419">    }</span>

    /**
     * Method that registers a set of preinstalled dataClay class model, including a
     * dataClay normal account responsible of it, plus a public namespace for the
     * classes.
     *
     * @param adminAccount Admin account
     */
    private void registerDataClayPreinstalledClasses(final Account adminAccount) {
        try {
            // Create the account for dataClay classes
            try {
<span class="nc" id="L432">                publicIDs.dcRegistratorID = accountMgrApi.getAccountID(DC_REGISTRATOR);</span>
<span class="nc" id="L433">            } catch (final AccountNotExistException e) {</span>
<span class="nc" id="L434">                final Account dcRegistrator = new Account(DC_REGISTRATOR, AccountRole.NORMAL_ROLE, dcCredentials);</span>
<span class="nc" id="L435">                publicIDs.dcRegistratorID = newAccount(publicIDs.dcAdminID, adminAccount.getCredential(),</span>
                        dcRegistrator);
<span class="nc" id="L437">            }</span>

            // Public Namespace ID
            try {
<span class="nc" id="L441">                publicIDs.dcPublicNamespaceID = namespaceMgrApi.getNamespaceID(DC_PUBLIC_NAMESPACE);</span>
<span class="nc" id="L442">            } catch (final NamespaceDoesNotExistException e) {</span>
                // Create new namespace ID
<span class="nc" id="L444">                final Namespace publicDataClayNamespace = new Namespace(DC_PUBLIC_NAMESPACE, DC_REGISTRATOR,</span>
                        Langs.LANG_JAVA);
<span class="nc" id="L446">                publicIDs.dcPublicNamespaceID = newNamespace(publicIDs.dcRegistratorID, dcCredentials,</span>
                        publicDataClayNamespace);
<span class="nc" id="L448">            }</span>

            // Generate MetaClassSpec for DataClay Classes
            // COMPILE
<span class="nc" id="L452">            LOGGER.info(&quot;[LOGICMODULE] Installing classes located at : &quot;</span>
<span class="nc" id="L453">                    + Configuration.Flags.DATACLAY_INSTALLED_CLASSES_SRC_PATH.getStringValue());</span>
<span class="nc" id="L454">            final File f = new File(Configuration.Flags.DATACLAY_INSTALLED_CLASSES_SRC_PATH.getStringValue());</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (f.exists()) {</span>
                // WARNING: do not remove this until a new script design is done. In case we
                // change Collections, this
                // is going to compile them again and make sure we use last collections. TODO:
                // better design.
<span class="nc" id="L460">                FileAndAspectsUtils.compileClasses(</span>
<span class="nc" id="L461">                        Configuration.Flags.DATACLAY_INSTALLED_CLASSES_SRC_PATH.getStringValue(),</span>
<span class="nc" id="L462">                        Configuration.Flags.DATACLAY_INSTALLED_CLASSES_BIN_PATH.getStringValue(),</span>
<span class="nc" id="L463">                        new String[]{Configuration.Flags.INCLUDE_THIS_PROJECT.getStringValue()},</span>
                        &quot;test&quot;);
<span class="nc" id="L465">                Map&lt;String, MetaClass&gt; newClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L466">                final Map&lt;MetaClassID, MetaClass&gt; installedClasses = classMgrApi</span>
<span class="nc" id="L467">                        .getInfoOfClassesInNamespace(publicIDs.dcPublicNamespaceID);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                if (installedClasses.isEmpty()) {</span>
                    // Init class loader
<span class="nc" id="L470">                    final String regClassPath = Configuration.Flags.DATACLAY_INSTALLED_CLASSES_BIN_PATH</span>
<span class="nc" id="L471">                            .getStringValue();</span>
<span class="nc" id="L472">                    final Set&lt;String&gt; classNames = new HashSet&lt;&gt;();</span>
<span class="nc" id="L473">                    final Set&lt;String&gt; exclusions = new HashSet&lt;&gt;();</span>

<span class="nc" id="L475">                    final Path inputPath = Paths.get(regClassPath).normalize();</span>
<span class="nc" id="L476">                    final Path fullSrcPath = inputPath.toAbsolutePath();</span>
<span class="nc" id="L477">                    final String fullPath = fullSrcPath.toString().replace(File.separatorChar + &quot;.&quot; + File.separatorChar,</span>
                            File.separator);
<span class="nc" id="L479">                    exclusions.add(&quot;test&quot;);</span>
<span class="nc" id="L480">                    StubClassLoader.getClasses(fullPath, new File(fullPath), classNames, &quot;.class&quot;, exclusions);</span>
<span class="nc" id="L481">                    LOGGER.info(&quot;[LOGICMODULE] Installing classes : &quot; + classNames);</span>
<span class="nc" id="L482">                    final JavaSpecGenerator jvspec = new JavaSpecGenerator(</span>
<span class="nc" id="L483">                            Configuration.Flags.DATACLAY_INSTALLED_CLASSES_BIN_PATH.getStringValue());</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                    for (final String className : classNames) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                        if (newClasses.containsKey(className)) {</span>
<span class="nc" id="L486">                            continue; // Avoid registering same class twice.</span>
                        }
<span class="nc" id="L488">                        final Map&lt;String, MetaClass&gt; classes = jvspec.generateMetaClassSpecForRegisterClass(DC_PUBLIC_NAMESPACE,</span>
                                className);
<span class="nc bnc" id="L490" title="All 2 branches missed.">                        if (classes.isEmpty()) {</span>
<span class="nc" id="L491">                            LOGGER.info(&quot;Could not create Class spec of {}.&quot;, className);</span>
                        }
<span class="nc" id="L493">                        newClasses.putAll(classes);</span>
<span class="nc" id="L494">                    }</span>
                    // Install them
                    try {
<span class="nc" id="L497">                        newClasses = this.newClass(publicIDs.dcRegistratorID, dcCredentials, Langs.LANG_JAVA,</span>
                                newClasses);
<span class="nc" id="L499">                    } catch (final Exception ex) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L501">                            LOGGER.debug(&quot;registerDataClayPreinstalledClasses error in newClass invocation&quot;, ex);</span>
                        }
<span class="nc" id="L503">                    }</span>
                }

                // Public Contract ID
<span class="nc" id="L507">                final Map&lt;ContractID, Contract&gt; contracts = this.getContractIDsOfProvider(publicIDs.dcRegistratorID,</span>
                        dcCredentials, publicIDs.dcPublicNamespaceID);
<span class="nc bnc" id="L509" title="All 2 branches missed.">                if (contracts.isEmpty()) {</span>
                    // CONTRACT

                    // Create interfaces of the contract
<span class="nc" id="L513">                    final List&lt;InterfaceInContract&gt; theInterfacesInContract = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                    for (final MetaClass metaClassInfo : newClasses.values()) {</span>

                        // OPERATIONS
                        // We assume that local and remote Impl are the same (first one) (23 Oct 2013
                        // jmarti)
<span class="nc" id="L519">                        final Set&lt;OpImplementations&gt; opImpls = new HashSet&lt;&gt;();</span>
<span class="nc" id="L520">                        final Set&lt;String&gt; accOpsSignatures = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                        for (final Operation opInfo : metaClassInfo.getOperations()) {</span>
<span class="nc" id="L522">                            opImpls.add(new OpImplementations(opInfo.getNameAndDescriptor(), 0, 0));</span>
<span class="nc" id="L523">                            accOpsSignatures.add(opInfo.getNameAndDescriptor());</span>
<span class="nc" id="L524">                        }</span>

                        // PROPERTIES
<span class="nc" id="L527">                        final Set&lt;String&gt; props = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                        for (final Property prop : metaClassInfo.getProperties()) {</span>
<span class="nc" id="L529">                            props.add(prop.getName());</span>
<span class="nc" id="L530">                        }</span>

                        // Register an interface for the contract
<span class="nc" id="L533">                        final Interface iface = new Interface(DC_REGISTRATOR, DC_PUBLIC_NAMESPACE, DC_PUBLIC_NAMESPACE,</span>
<span class="nc" id="L534">                                metaClassInfo.getName(), props, accOpsSignatures);</span>

<span class="nc" id="L536">                        this.newInterface(publicIDs.dcRegistratorID, dcCredentials, iface);</span>
<span class="nc" id="L537">                        final InterfaceInContract ifaceInContract = new InterfaceInContract(iface, opImpls);</span>

<span class="nc" id="L539">                        theInterfacesInContract.add(ifaceInContract);</span>
<span class="nc" id="L540">                    }</span>

                    // Prepare the dates of begin and end of a contract
<span class="nc" id="L543">                    final Calendar beginDateOfContract = Calendar.getInstance();</span>
<span class="nc" id="L544">                    beginDateOfContract.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L545">                    final Calendar endDateOfContract = Calendar.getInstance();</span>
                    // TODO: This contract should last forever (jmarti 1 Jul 2016)
<span class="nc" id="L547">                    endDateOfContract.add(Calendar.YEAR, 100);</span>

<span class="nc" id="L549">                    final Contract contract = new Contract(DC_PUBLIC_NAMESPACE, DC_REGISTRATOR, theInterfacesInContract,</span>
                            beginDateOfContract, endDateOfContract);
<span class="nc" id="L551">                    publicIDs.dcPublicContractID = this.newContract(publicIDs.dcRegistratorID, dcCredentials, contract);</span>
<span class="nc" id="L552">                } else {</span>
<span class="nc" id="L553">                    publicIDs.dcPublicContractID = contracts.entrySet().iterator().next().getKey();</span>
                }
            }
<span class="nc" id="L556">        } catch (final Exception ex) {</span>
<span class="nc" id="L557">            LOGGER.debug(&quot;registerDataClayPreinstalledClasses error&quot;, ex);</span>
<span class="nc" id="L558">        }</span>
<span class="nc" id="L559">    }</span>

    /**
     * Get remote DataService API
     *
     * @param backend
     *            Backend specification
     * @return API of remote DS
     * @throws Exception
     *             If DS not started
     */
    public DataServiceAPI getExecutionEnvironmentAPI(final ExecutionEnvironment backend) {
<span class="nc" id="L571">        final ExecutionEnvironmentID execID = backend.getDataClayID();</span>
<span class="nc" id="L572">        final Langs lang = backend.getLang();</span>
<span class="nc" id="L573">        final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; dsAPI = execEnvironments.get(lang).get(execID);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (dsAPI == null) {</span>
<span class="nc" id="L575">            LOGGER.warn(&quot;No DataServiceAPI. Current execution environments: {}&quot;, execEnvironments);</span>
<span class="nc" id="L576">            throw new DataClayRuntimeException(ERRORCODE.DATASERVICE_BACKEND_NOT_RESPONDS,</span>
<span class="nc" id="L577">                    &quot;DataService with ID &quot; + execID + &quot; is not initialized for language &quot; + lang.toString(), false);</span>
        }
<span class="nc" id="L579">        return dsAPI.getFirst();</span>
    }

    /**
     * Get DataService APIs for backend with support for a given language.
     *
     * @param lang
     *            The language required.
     * @return DataServiceAPIs, the ones compatible with the language
     */
    protected Map&lt;ExecutionEnvironmentID, Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt;&gt; getExecutionEnvironments(final Langs lang) {
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L591">            LOGGER.debug(&quot;[==GetExecutionEnvironments==] Execution environments in language &quot; + lang + &quot; : &quot; + execEnvironments.get(lang).keySet());</span>
        }
<span class="nc" id="L593">        return execEnvironments.get(lang);</span>
    }

    /**
     * Get DataService APIs for backend with support for a given language.
     *
     * @return DataServiceAPIs
     */
    protected Map&lt;StorageLocationID, Tuple&lt;DataServiceAPI, StorageLocation&gt;&gt; getStorageLocations() {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L603">            LOGGER.debug(&quot;[==GetStorageLocations==] Storage locations : &quot; + storageLocations.keySet());</span>
        }
<span class="nc" id="L605">        return this.storageLocations;</span>
    }

    /**
     * Update APIs for all registered environments/storage locations
     */
    protected void updateAPIsFromDB() {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        for (final ExecutionEnvironment execEnv : this.getAllExecutionEnvironmentsInfo(null, false, false).values()) {</span>
            try {
<span class="nc" id="L614">                initRemoteTCPExecutionEnvironment(execEnv.getDataClayID(),</span>
<span class="nc" id="L615">                        execEnv.getName(), execEnv.getHostname(), execEnv.getPort(), execEnv.getLang());</span>
<span class="nc" id="L616">            } catch (final InterruptedException e) {</span>
<span class="nc" id="L617">                e.printStackTrace();</span>
<span class="nc" id="L618">            }</span>
<span class="nc" id="L619">        }</span>

<span class="nc bnc" id="L621" title="All 2 branches missed.">        for (final StorageLocation stLoc : logicMetadataMgr.getAllStorageLocationsInfo().values()) {</span>
            try {
<span class="nc" id="L623">                initRemoteTCPStorageLocation(stLoc.getDataClayID(),</span>
<span class="nc" id="L624">                        stLoc.getName(), stLoc.getHostname(), stLoc.getStorageTCPPort());</span>
<span class="nc" id="L625">            } catch (final InterruptedException e) {</span>
<span class="nc" id="L626">                e.printStackTrace();</span>
<span class="nc" id="L627">            }</span>
<span class="nc" id="L628">        }</span>

<span class="nc" id="L630">    }</span>

    /**
     * Resume traces in services
     *
     * @param dsName
     *            Name of the data service to be cleaned
     * @throws RemoteException
     *             if exception occurs
     */
    public void cleanCachesOfDataService(final String dsName) {
<span class="nc" id="L641">        storageLocations.get(dsName).getFirst().cleanCaches();</span>
<span class="nc" id="L642">    }</span>

    // ========== Initialization by DataServices ==========//

    /**
     * This method adds an StorageLocation to the list of DS/extras.
     * @param id ID of backend to use in case of registration
     * @param dsName
     *            Name of the DataService
     * @param dsHostname
     *            Hostname of the DataService
     * @param dsTCPPort
     *            The TCP port
     * @return The StorageLocation for the DataService.
     * @throws InterruptedException
     *             if some remote initialization was interrupted
     */
    private StorageLocation initRemoteTCPStorageLocation(final StorageLocationID id,
                                                         final String dsName, final String dsHostname,
                                                         final int dsTCPPort) throws InterruptedException {
        // Test connection
<span class="nc" id="L663">        final DataServiceAPI dsApi = grpcClient.getDataServiceAPI(dsHostname, dsTCPPort);</span>
<span class="nc" id="L664">        final StorageLocation dsSL = new StorageLocation(dsHostname, dsName, dsTCPPort);</span>
<span class="nc" id="L665">        dsSL.setDataClayID(id);</span>
<span class="nc" id="L666">        storageLocations.put(id, new Tuple&lt;&gt;(dsApi, dsSL));</span>
<span class="nc" id="L667">        return dsSL;</span>
    }

    /**
     * This method adds an ExecutionEnvironment to the list of DS/extras.
     * @param execID Execution Environment ID
     * @param dsName
     *            Name of the DataService
     * @param dsHostname
     *            Hostname of the DataService
     * @param dsTCPPort
     *            The TCP port
     * @param dsLang
     *            The Language for the ExecutionEnvironment in this DataService
     * @return The StorageLocation for the DataService. (Itself for Java, the Java
     *         one for Python).
     * @throws InterruptedException
     *             if some remote initialization was interrupted
     */
    private ExecutionEnvironment initRemoteTCPExecutionEnvironment(final ExecutionEnvironmentID execID,
                                                                   final String dsName, final String dsHostname,
                                                                   final int dsTCPPort, final Langs dsLang) throws InterruptedException {

<span class="nc" id="L690">        final DataServiceAPI dsApi = grpcClient.getDataServiceAPI(dsHostname, dsTCPPort);</span>
<span class="nc" id="L691">        final ExecutionEnvironment dsEE = new ExecutionEnvironment(dsHostname, dsName, dsTCPPort, dsLang,</span>
<span class="nc" id="L692">                this.getDataClayID());</span>
<span class="nc" id="L693">        dsEE.setDataClayID(execID);</span>
<span class="nc" id="L694">        execEnvironments.get(dsLang).put(execID, new Tuple&lt;&gt;(dsApi, dsEE));</span>
<span class="nc" id="L695">        return dsEE;</span>
    }

    @Override
    public void checkAlive() {
        // Check database
<span class="nc bnc" id="L701" title="All 2 branches missed.">        if (!metadataHandler.databaseExists()) {</span>
<span class="nc" id="L702">            LogicModuleSrv.doExit(1);</span>
        }
<span class="nc" id="L704">        return;</span>
    }

    @Override
    public void publishAddress(final String thehostname, final int theport) {
<span class="nc" id="L709">        this.hostname = thehostname;</span>
<span class="nc" id="L710">        this.port = theport;</span>
<span class="nc" id="L711">        LOGGER.info(&quot;Published address {}:{}&quot;, thehostname, theport);</span>
<span class="nc" id="L712">    }</span>

	@Override
	public void autoregisterSL(final StorageLocationID id, final String dsName, 
			final String dsHostname, final Integer dsPort) {
<span class="nc" id="L717">		LOGGER.debug(&quot;==&gt; Starting autoregisterSL with name &quot; + dsName + &quot;, hostname &quot; + dsHostname + &quot; and port &quot; + dsPort);</span>

        // ===================== TRY CONNECTION ======================= //
        final StorageLocation storageLoc;
        try {
<span class="nc" id="L722">            storageLoc = initRemoteTCPStorageLocation(id, dsName, dsHostname, dsPort);</span>
<span class="nc" id="L723">        } catch (final Exception ex) {</span>
<span class="nc" id="L724">            LOGGER.debug(&quot;autoregisterDataService error while creating DataService&quot;, ex);</span>
<span class="nc" id="L725">            throw new DataClayRuntimeException(ERRORCODE.DATASERVICE_INIT_ERROR,</span>
                    &quot;Could not connect to DataService in the LogicModule&quot;, true);
<span class="nc" id="L727">        }</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (storageLoc == null) {</span>
<span class="nc" id="L729">            throw new DataClayRuntimeException(ERRORCODE.DATASERVICE_INIT_ERROR,</span>
                    &quot;The StorageLocation for this DataService is not satisfactory registered&quot;, true);
        }
        // ========== REGISTER ========== //
        try {
<span class="nc" id="L734">            logicMetadataMgr.registerStorageLocation(storageLoc);</span>
<span class="nc" id="L735">            LOGGER.info(&quot;[LOGICMODULE] Registered StorageLocation named &quot; + storageLoc + &quot; as &quot; + id.getId());</span>
<span class="nc" id="L736">        } catch (final StorageLocationAlreadyExistsException e) {</span>
<span class="nc" id="L737">            LOGGER.info(&quot;[LOGICMODULE] Found already registered StorageLocation &quot; + storageLoc + &quot; as &quot;</span>
<span class="nc" id="L738">                    + id.getId());</span>
<span class="nc" id="L739">            logicMetadataMgr.updateStorageLocation(id, dsHostname, dsPort);</span>
<span class="nc" id="L740">        }</span>

		// Activate storage location (execution environments cannot be activated before SL is ready)
<span class="nc" id="L743">		this.activeBackends.put(id, new HashSet&lt;ExecutionEnvironmentID&gt;());</span>
<span class="nc" id="L744">		LOGGER.debug(&quot;==&gt; AutoregisterSL finished for SL &quot; + storageLoc);</span>

<span class="nc" id="L746">	}</span>
	
	@Override
	public StorageLocationID getStorageLocationID(final String slName) {
<span class="nc" id="L750">		final StorageLocationID slID = logicMetadataMgr.getStorageLocationID(slName);</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">		if (!this.activeBackends.containsKey(slID)) {</span>
			// Still not active
<span class="nc" id="L753">            LOGGER.debug(&quot;==&gt; Not active storage location with name &quot; + slName + &quot; and id &quot; + slID);</span>
<span class="nc" id="L754">            throw new StorageLocationNotExistException(slName);</span>
		}
<span class="nc" id="L756">        LOGGER.debug(&quot;==&gt; Got StorageLocationID with name &quot; + slName + &quot; = &quot; + slID);</span>
<span class="nc" id="L757">		return slID;</span>
	}

	@Override
	public StorageLocationID autoregisterEE(final ExecutionEnvironmentID id, final String eeName, 
			final String eeHostname, final Integer eePort, final Langs language) {
<span class="nc" id="L763">		LOGGER.debug(&quot;==&gt; Starting autoregisterEE with dsName &quot; + eeName + &quot;, hostname &quot; + eeHostname + &quot; and port &quot; + eePort);</span>

<span class="nc" id="L765">		final StorageLocationID slID = getStorageLocationID(eeName);</span>

		// ===================== TRY CONNECTION ======================= //
		// Obtain or Register the Execution Environment
		final ExecutionEnvironment executionEnv;
		try {
<span class="nc" id="L771">			executionEnv = initRemoteTCPExecutionEnvironment(id, eeName, eeHostname, eePort, language);</span>
<span class="nc" id="L772">		} catch (final Exception ex) {</span>
<span class="nc" id="L773">			LOGGER.debug(&quot;autoregisterDataService interrupted while initializing remote ExecutionEnvironment&quot;, ex);</span>
<span class="nc" id="L774">			throw new DataClayRuntimeException(ERRORCODE.DATASERVICE_INIT_ERROR,</span>
					&quot;Could not create the DataService ExecutionEnvironment in the LogicModule&quot;, true);
<span class="nc" id="L776">		}</span>
		// ========== REGISTER ========== //
		// check it was already registered or not
<span class="nc" id="L779">		boolean newRegistration = false;</span>
		try {
<span class="nc" id="L781">            logicMetadataMgr.getExecutionEnvironmentInfo(executionEnv.getDataClayID());</span>
<span class="nc" id="L782">            logicMetadataMgr.updateExecutionEnvironment(id, eeHostname, eePort);</span>
<span class="nc" id="L783">			LOGGER.info(&quot;[LOGICMODULE] Found already registered EE. Updated to &quot; + executionEnv + &quot; as &quot;</span>
<span class="nc" id="L784">					+ id.getId());</span>
<span class="nc" id="L785">		} catch (ExecutionEnvironmentNotExistException e) {</span>
<span class="nc" id="L786">			newRegistration = true;</span>
<span class="nc" id="L787">		}</span>

		
		// ========== NEW REGISTRATION ========== //
<span class="nc bnc" id="L791" title="All 2 branches missed.">		if (newRegistration) {</span>
			try {
				// get all namespaces
<span class="nc" id="L794">				Set&lt;String&gt; allNamespaces = this.namespaceMgrApi.getNamespacesNames();</span>
				// get all classes
<span class="nc bnc" id="L796" title="All 2 branches missed.">				for (String namespace : allNamespaces) {</span>

<span class="nc" id="L798">					NamespaceID namespaceID = this.namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L799">					final Set&lt;NamespaceID&gt; namespacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L800">					namespacesIDs.add(namespaceID);</span>
<span class="nc" id="L801">					final Map&lt;NamespaceID, Namespace&gt; namespaceInfos = namespaceMgrApi.getNamespacesInfo(namespacesIDs);</span>
<span class="nc" id="L802">					Namespace currentNamespace = namespaceInfos.values().iterator().next();</span>
					// Check namespace belongs to current EE language
<span class="nc bnc" id="L804" title="All 2 branches missed.">					if (currentNamespace.getLanguage().equals(language)) {</span>
<span class="nc" id="L805">						final Map&lt;MetaClassID, MetaClass&gt; installedClasses = this.classMgrApi.getInfoOfClassesInNamespace(namespaceID);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">						if (!installedClasses.isEmpty()) {</span>
<span class="nc" id="L807">							LOGGER.info(&quot;[LOGICMODULE] Going to deploy registered classes in namespace &quot; + namespace);</span>
<span class="nc" id="L808">							final Set&lt;MetaClass&gt; allMetaClasses = new HashSet&lt;&gt;(installedClasses.values());</span>
<span class="nc" id="L809">							final Set&lt;String&gt; classesToDeploy = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">							for (final MetaClass curClass : allMetaClasses) {</span>
<span class="nc" id="L811">								classesToDeploy.add(curClass.getName());</span>
<span class="nc" id="L812">							}</span>
<span class="nc" id="L813">							final Langs eeLang = executionEnv.getLang();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">							if (eeLang.equals(Langs.LANG_JAVA)) {</span>
<span class="nc" id="L815">								outsourceClassesDeploymentJava(allMetaClasses, classesToDeploy, namespaceInfos, null, executionEnv);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">							} else if (eeLang.equals(Langs.LANG_PYTHON)) {</span>
<span class="nc" id="L817">								outsourceClassesDeploymentPython(allMetaClasses, classesToDeploy, namespaceInfos, null,</span>
										executionEnv);
							}
						}
					}
<span class="nc" id="L822">				}</span>

<span class="nc" id="L824">                logicMetadataMgr.registerExecutionEnvironment(executionEnv);</span>
<span class="nc" id="L825">				LOGGER.info(&quot;[LOGICMODULE] Registered ExecutionEnvironment &quot; + executionEnv + &quot; for language `&quot;</span>
<span class="nc" id="L826">						+ language + &quot;` as &quot; + id.getId() + &quot; associated to storage location &quot; + slID);</span>

<span class="nc" id="L828">			} catch (final Exception ex) {</span>
<span class="nc" id="L829">				LOGGER.debug(&quot;autoregisterDataService error during dataClay classes registration&quot;, ex);</span>
<span class="nc" id="L830">			}</span>
		}



		// Activate storage location (execution environments cannot be activated before SL is ready)
<span class="nc" id="L836">		this.activeBackends.get(slID).add(id);</span>

<span class="nc" id="L838">		LOGGER.debug(&quot;==&gt; Autoregister finished for EE &quot; + executionEnv);</span>
<span class="nc" id="L839">		return slID;</span>
	}

    @Override
    public void unregisterStorageLocation(final StorageLocationID stLocID) {
<span class="nc" id="L844">        logicMetadataMgr.unregisterStorageLocation(stLocID);</span>
        //TODO: remove from any cache in LM
<span class="nc" id="L846">    }</span>

    @Override
    public void unregisterExecutionEnvironment(final ExecutionEnvironmentID execEnvID) {
<span class="nc" id="L850">        logicMetadataMgr.unregisterExecutionEnvironment(execEnvID);</span>
        //TODO: remove from any cache in LM
<span class="nc" id="L852">    }</span>

    @Override
    public void notifyExecutionEnvironmentShutdown(final ExecutionEnvironmentID execEnvID) {
        // TODO: check if metadata service should be the one with information about active EEs and SLs
<span class="nc" id="L857">        LOGGER.info(&quot;Notified shutdown of execution environment &quot; + execEnvID);</span>
<span class="nc" id="L858">        ExecutionEnvironment eeInfo = logicMetadataMgr.getExecutionEnvironmentInfo(execEnvID);</span>
<span class="nc" id="L859">        StorageLocationID slID = this.getStorageLocationID(eeInfo.getName());</span>
<span class="nc" id="L860">        this.activeBackends.get(slID).remove(execEnvID);</span>
<span class="nc" id="L861">    }</span>

    @Override
    public void notifyStorageLocationShutdown(final StorageLocationID stLocID) {
<span class="nc" id="L865">        LOGGER.info(&quot;Notified shutdown of storage location &quot; + stLocID);</span>
<span class="nc" id="L866">        this.activeBackends.remove(stLocID);</span>
<span class="nc" id="L867">    }</span>

    @Override
    public boolean existsActiveEnvironmentsForSL(final StorageLocationID stLocID) {
<span class="nc bnc" id="L871" title="All 2 branches missed.">        if (this.activeBackends.isEmpty()) {</span>
<span class="nc" id="L872">            return false;</span>
        }
<span class="nc" id="L874">        int numEEs = this.activeBackends.get(stLocID).size();</span>
<span class="nc" id="L875">        LOGGER.info(&quot;Found &quot; + numEEs + &quot; active execution environments for SL &quot; + stLocID);</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">        return numEEs != 0;</span>
    }

    /**
     * Wait for all registered Storage locations and Execution environments to shut down.
     */
    public void waitForAllNodesShutdown() {
        while (true) {
<span class="nc" id="L884">            int numBackends = this.activeBackends.size();</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (numBackends == 0) {</span>
<span class="nc" id="L886">                break;</span>
            }
            try {
<span class="nc" id="L889">                LOGGER.info(&quot;Waiting for backends to shutdown. Active backends: &quot; + numBackends);</span>
<span class="nc" id="L890">                Thread.sleep(Configuration.Flags.SLEEP_WAIT_SHUTDOWN.getLongValue());</span>
<span class="nc" id="L891">            } catch (final InterruptedException ie) {</span>
<span class="nc" id="L892">                LOGGER.warn(&quot;Checking interrupted. Shutting down LM without waiting for backends.&quot;);</span>
<span class="nc" id="L893">                break;</span>
<span class="nc" id="L894">            }</span>
<span class="nc" id="L895">        }</span>
<span class="nc" id="L896">    }</span>

    // ========== Generic batch operations ==========//

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public byte[] performSetOfNewAccounts(final AccountID adminID, final PasswordCredential adminCredential,
                                          final byte[] yamlFile) {
<span class="nc" id="L904">        final Yaml yaml = CommonYAML.getYamlObject();</span>

        /*
         * The structure that we will return on the YAML response
         */
<span class="nc" id="L909">        final Map&lt;String, UUID&gt; returnIDs = new HashMap&lt;&gt;();</span>
        // Maps with account-uuid pairs

        // The YAML should be a list of accounts
        final List&lt;Object&gt; newAccounts;
        try {
<span class="nc" id="L915">            newAccounts = (List&lt;Object&gt;) yaml.load(new String(yamlFile));</span>
<span class="nc" id="L916">        } catch (final Exception e) {</span>
<span class="nc" id="L917">            LOGGER.warn(&quot;Received exception during deserialization&quot;, e);</span>
<span class="nc" id="L918">            LOGGER.debug(&quot;YAML document:\n{}&quot;, new String(yamlFile));</span>
<span class="nc" id="L919">            throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;Error when loading YAML file&quot;, true);</span>
<span class="nc" id="L920">        }</span>

<span class="nc bnc" id="L922" title="All 2 branches missed.">        for (final Object objAccount : newAccounts) {</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">            if (!(objAccount instanceof Account)) {</span>
<span class="nc" id="L924">                throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;This call only accepts Accounts&quot;,</span>
                        true);
            }
<span class="nc" id="L927">            final Account acc = (Account) objAccount;</span>

<span class="nc" id="L929">            final AccountID accountID = newAccount(adminID, adminCredential, (Account) objAccount);</span>
<span class="nc" id="L930">            returnIDs.put(acc.getUsername(), accountID.getId());</span>
<span class="nc" id="L931">        }</span>
<span class="nc" id="L932">        return yaml.dump(returnIDs).getBytes();</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public byte[] performSetOfOperations(final AccountID performerID, final PasswordCredential performerCredential,
                                         final byte[] yamlFile) {
<span class="nc" id="L939">        final Yaml yaml = CommonYAML.getYamlObject();</span>

        /*
         * The structure that we will return on the YAML response
         */
<span class="nc" id="L944">        final Map&lt;String, Object&gt; returnIDs = new HashMap&lt;&gt;();</span>

        // Initialize the potentially empty list //
        // Namespaces
<span class="nc" id="L948">        final Map&lt;String, UUID&gt; namespaceIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L949">        returnIDs.put(&quot;namespaces&quot;, namespaceIDs);</span>
        // DataSets
<span class="nc" id="L951">        final Map&lt;String, UUID&gt; datasetIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L952">        returnIDs.put(&quot;datasets&quot;, datasetIDs);</span>
        // Contracts
<span class="nc" id="L954">        final Map&lt;String, UUID&gt; contractIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L955">        returnIDs.put(&quot;contracts&quot;, contractIDs);</span>
        // DataContracts
<span class="nc" id="L957">        final Map&lt;String, UUID&gt; datacontractIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L958">        returnIDs.put(&quot;datacontracts&quot;, datacontractIDs);</span>
        // Interfaces
<span class="nc" id="L960">        final Map&lt;String, UUID&gt; interfaceIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L961">        returnIDs.put(&quot;interfaces&quot;, interfaceIDs);</span>
        // MetaClasses
<span class="nc" id="L963">        final Map&lt;String, UUID&gt; metaclassIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L964">        returnIDs.put(&quot;metaclasses&quot;, metaclassIDs);</span>

        // The YAML should be a dictionary, indexed by name
        final Map&lt;String, Object&gt; operations;
        try {
<span class="nc" id="L969">            operations = (Map&lt;String, Object&gt;) yaml.load(new String(yamlFile));</span>
<span class="nc" id="L970">        } catch (final Exception e) {</span>
<span class="nc" id="L971">            LOGGER.warn(&quot;Received exception during deserialization&quot;, e);</span>
<span class="nc" id="L972">            LOGGER.debug(&quot;YAML document:\n{}&quot;, new String(yamlFile));</span>
<span class="nc" id="L973">            throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;Error when loading YAML file&quot;, true);</span>
<span class="nc" id="L974">        }</span>

        // Note: This works well because snakeyaml implements the Map as a LinkedHashMap
        // and there is no anarchy on ordering. The registering must obey user-provided
        // order.
<span class="nc bnc" id="L979" title="All 2 branches missed.">        for (final Entry&lt;String, Object&gt; elem : operations.entrySet()) {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            if (elem.getValue() instanceof Namespace) {</span>
<span class="nc" id="L981">                final Namespace dom = (Namespace) elem.getValue();</span>
<span class="nc" id="L982">                dom.setName(elem.getKey());</span>

<span class="nc" id="L984">                final NamespaceID namespaceID = newNamespace(performerID, performerCredential, dom);</span>
<span class="nc" id="L985">                namespaceIDs.put(elem.getKey(), namespaceID.getId());</span>

<span class="nc bnc" id="L987" title="All 2 branches missed.">            } else if (elem.getValue() instanceof DataSet) {</span>
<span class="nc" id="L988">                LOGGER.info(&quot;[LM] Dataset &quot; + elem.getKey() + &quot; request to be created.&quot;);</span>
<span class="nc" id="L989">                final DataSet dset = (DataSet) elem.getValue();</span>
<span class="nc" id="L990">                dset.setName(elem.getKey());</span>

<span class="nc" id="L992">                final DataSetID datasetID = newDataSet(performerID, performerCredential, dset);</span>
<span class="nc" id="L993">                datasetIDs.put(elem.getKey(), datasetID.getId());</span>

<span class="nc bnc" id="L995" title="All 2 branches missed.">            } else if (elem.getValue() instanceof Contract) {</span>
<span class="nc" id="L996">                final Contract contr = (Contract) elem.getValue();</span>

<span class="nc" id="L998">                final ContractID contractID = newContract(performerID, performerCredential, contr);</span>
<span class="nc" id="L999">                contractIDs.put(elem.getKey(), contractID.getId());</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">            } else if (elem.getValue() instanceof DataContract) {</span>
<span class="nc" id="L1001">                final DataContract dcontr = (DataContract) elem.getValue();</span>

<span class="nc" id="L1003">                final DataContractID datacontractID = newDataContract(performerID, performerCredential, dcontr);</span>
<span class="nc" id="L1004">                datacontractIDs.put(elem.getKey(), datacontractID.getId());</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            } else if (elem.getValue() instanceof Interface) {</span>
<span class="nc" id="L1006">                final Interface iface = (Interface) elem.getValue();</span>

<span class="nc" id="L1008">                final InterfaceID interfaceID = newInterface(performerID, performerCredential, iface);</span>
<span class="nc" id="L1009">                interfaceIDs.put(elem.getKey(), interfaceID.getId());</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            } else if (elem.getValue() instanceof MetaClass) {</span>
<span class="nc" id="L1011">                final MetaClass mclass = (MetaClass) elem.getValue();</span>
<span class="nc" id="L1012">                mclass.setName(elem.getKey());</span>

                // newClass expects a Map
<span class="nc" id="L1015">                final Map&lt;String, MetaClass&gt; singleElement = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1016">                singleElement.put(elem.getKey(), mclass);</span>

                // TODO: (LASTTODO) fix this to add language!
<span class="nc" id="L1019">                final Map&lt;String, MetaClass&gt; metaclassResponse = newClass(performerID, performerCredential,</span>
                        Langs.LANG_NONE, singleElement);

                // We are only interested in the provided element
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                if (metaclassResponse.containsKey(elem.getKey())) {</span>
<span class="nc" id="L1024">                    metaclassIDs.put(elem.getKey(), metaclassResponse.get(elem.getKey()).getDataClayID().getId());</span>
                }
<span class="nc" id="L1026">            } else {</span>
<span class="nc" id="L1027">                throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION,</span>
                        &quot;Malformed YAML --not a valid dataClay set of operations&quot;, true);
            }
<span class="nc" id="L1030">        }</span>

<span class="nc" id="L1032">        LOGGER.debug(</span>
                &quot;Ready to return the following sets of IDs (count):\n&quot; + &quot;    - Namespaces:    #{}\n&quot;
                        + &quot;    - Datasets:      #{}\n&quot; + &quot;    - Contracts:     #{}\n&quot; + &quot;    - DataContracts: #{}\n&quot;
                        + &quot;    - Interfaces:    #{}\n&quot; + &quot;    - MetaClasses:   #{}&quot;,
<span class="nc" id="L1036">                () -&gt; namespaceIDs.size(), () -&gt; datasetIDs.size(), () -&gt; contractIDs.size(),</span>
<span class="nc" id="L1037">                () -&gt; datacontractIDs.size(), () -&gt; interfaceIDs.size(), () -&gt; metaclassIDs.size());</span>

<span class="nc" id="L1039">        return yaml.dump(returnIDs).getBytes();</span>
    }

    // ============== Account Manager ==============//

    @Override
    public AccountID newAccountNoAdmin(final Account newAccount) {

        // Create the new account (admin account validated during the newAccount op)
<span class="nc" id="L1048">        final Account adminAccount = accountMgrApi.getAccount(publicIDs.dcAdminID);</span>
<span class="nc" id="L1049">        final AccountID accountID = accountMgrApi.newAccount(publicIDs.dcAdminID, adminAccount.getCredential(),</span>
                newAccount);

        // Create a default dataset for the account
<span class="nc" id="L1053">        final DataSet ds = new DataSet(newAccount.getUsername() + DEFAULT_DS_SUFFIX, accountID, false);</span>
<span class="nc" id="L1054">        newDataSet(accountID, newAccount.getCredential(), ds);</span>
<span class="nc" id="L1055">        final Calendar begin = Calendar.getInstance();</span>
<span class="nc" id="L1056">        begin.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L1057">        final Calendar end = Calendar.getInstance();</span>
<span class="nc" id="L1058">        end.add(Calendar.YEAR, 100);</span>
<span class="nc" id="L1059">        final DataContract dc = new DataContract(ds.getDataClayID(), newAccount.getDataClayID(), new HashSet&lt;&gt;(),</span>
                begin, end, false);
<span class="nc" id="L1061">        newDataContract(accountID, newAccount.getCredential(), dc);</span>

        // Create default namespaces for the account
<span class="nc" id="L1064">        final Namespace ns1 = new Namespace(newAccount.getUsername() + DEFAULT_JAVA_NS_SUFFIX, newAccount.getUsername(),</span>
                Langs.LANG_JAVA);
        try {
<span class="nc" id="L1067">            newNamespace(accountID, newAccount.getCredential(), ns1);</span>
<span class="nc" id="L1068">        } catch (final NamespaceExistsException e) {</span>
            // FIXME: if the namespace exists, it means database was exported from another
            // dataClay
            // in a federation model. Note that namespace Mgr and Class Mgr are databases
            // than can be 'exported'
            // to allow federation.
            // in this case, we could find a namespace with same user name if two dataClays
            // have
            // accounts with same name (Bob) and we export from one to another (we export
            // BobNamespace)
            // we will try to create BobNamespace in both cases but BobNamespace could be
            // already
            // exported.
            // this will not be necessary once we register models and namespaces with
            // predefined IDs.
<span class="nc" id="L1083">            LOGGER.debug(&quot;Java namespace already exists (can be expected in Federation): &quot;, e);</span>
<span class="nc" id="L1084">        }</span>
<span class="nc" id="L1085">        final Namespace ns2 = new Namespace(newAccount.getUsername() + DEFAULT_PYTHON_NS_SUFFIX,</span>
<span class="nc" id="L1086">                newAccount.getUsername(), Langs.LANG_PYTHON);</span>
        try {
<span class="nc" id="L1088">            newNamespace(accountID, newAccount.getCredential(), ns2);</span>
<span class="nc" id="L1089">        } catch (final NamespaceExistsException e) {</span>
            // check comments in previous exception for Java
<span class="nc" id="L1091">            LOGGER.debug(&quot;Python Namespace already exists (can be expected in Federation): &quot;, e);</span>
<span class="nc" id="L1092">        }</span>
<span class="nc" id="L1093">        return accountID;</span>
    }

    @Override
    public AccountID newAccount(final AccountID adminAccountID, final PasswordCredential adminCredential,
                                final Account newAccount) {

        // Create the new account (admin account validated during the newAccount op)
<span class="nc" id="L1101">        final AccountID accountID = accountMgrApi.newAccount(adminAccountID, adminCredential, newAccount);</span>

        // Create a default dataset for the account
<span class="nc" id="L1104">        final DataSet ds = new DataSet(newAccount.getUsername() + DEFAULT_DS_SUFFIX, accountID, false);</span>
<span class="nc" id="L1105">        newDataSet(accountID, newAccount.getCredential(), ds);</span>
<span class="nc" id="L1106">        final Calendar begin = Calendar.getInstance();</span>
<span class="nc" id="L1107">        begin.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L1108">        final Calendar end = Calendar.getInstance();</span>
<span class="nc" id="L1109">        end.add(Calendar.YEAR, 100);</span>
<span class="nc" id="L1110">        final DataContract dc = new DataContract(ds.getDataClayID(), newAccount.getDataClayID(), new HashSet&lt;&gt;(),</span>
                begin, end, false);
<span class="nc" id="L1112">        newDataContract(accountID, newAccount.getCredential(), dc);</span>

        // Create default namespaces for the account
<span class="nc" id="L1115">        final Namespace ns1 = new Namespace(newAccount.getUsername() + DEFAULT_JAVA_NS_SUFFIX, newAccount.getUsername(),</span>
                Langs.LANG_JAVA);
<span class="nc" id="L1117">        newNamespace(accountID, newAccount.getCredential(), ns1);</span>
<span class="nc" id="L1118">        final Namespace ns2 = new Namespace(newAccount.getUsername() + DEFAULT_PYTHON_NS_SUFFIX,</span>
<span class="nc" id="L1119">                newAccount.getUsername(), Langs.LANG_PYTHON);</span>
<span class="nc" id="L1120">        newNamespace(accountID, newAccount.getCredential(), ns2);</span>
<span class="nc" id="L1121">        return accountID;</span>
    }

    @Override
    public AccountID getAccountID(final String accountName) {
<span class="nc" id="L1126">        return accountMgrApi.getAccountID(accountName);</span>
    }

    @Override
    public HashSet&lt;AccountID&gt; getAccountList(final AccountID adminAccountID, final PasswordCredential adminCredential) {
<span class="nc" id="L1131">        HashSet&lt;AccountID&gt; accountsIDs = null;</span>
        // Get the list of users
<span class="nc" id="L1133">        accountsIDs = accountMgrApi.getAccountList(adminAccountID, adminCredential);</span>
<span class="nc" id="L1134">        return accountsIDs;</span>
    }

    // ============== Session Manager ==============//

    @Override
    public SessionInfo newSession(final AccountID accountID, final PasswordCredential credential,
                                  final Set&lt;ContractID&gt; contracts, final Set&lt;DataSetID&gt; dataSetIDs, final DataSetID dataSetForStore,
                                  final Langs newsessionLang) {

<span class="nc" id="L1144">        final boolean valid = accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE);</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        if (!valid) {</span>
<span class="nc" id="L1146">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L1149">        return newSessionInternal(accountID, contracts, dataSetIDs, dataSetForStore, newsessionLang);</span>

    }

    /**
     * New session internal function.
     *
     * @param accountID
     *            ID of account of the session
     * @param contracts
     *            Contracts of the session
     * @param dataSets
     *            names of datasets of the session
     * @param dataSetForStore
     *            Name of dataset for store
     * @param newsessionLang
     *            Session language
     * @return Information of new session.
     */
    private SessionInfo newSessionInternal(final AccountID accountID, final Set&lt;ContractID&gt; contracts,
                                           final Set&lt;DataSetID&gt; dataSets, final DataSetID dataSetForStore, final Langs newsessionLang) {

        // Get datasets info
<span class="nc" id="L1172">        final Map&lt;String, DataSet&gt; datasetsInfo = dataSetMgrApi.getDataSetsInfo(dataSets);</span>

        // Obtain Set of DataSetID
<span class="nc" id="L1175">        final Set&lt;DataSetID&gt; datasetsIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        for (final DataSet datasetInfo : datasetsInfo.values()) {</span>
<span class="nc" id="L1177">            final DataSetID dsID = datasetInfo.getDataClayID();</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">            if (datasetsIDs.contains(dsID)) {</span>
<span class="nc" id="L1179">                continue;</span>
            }
<span class="nc" id="L1181">            datasetsIDs.add(dsID);</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">            if (datasetInfo.getIsPublic()) {</span>
<span class="nc" id="L1183">                final DataContractID datacontractID = datacontractMgrApi.getPublicDataContractIDOfProvider(dsID);</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                if (datacontractID == null) {</span>
<span class="nc" id="L1185">                    throw new DataClayRuntimeException(ERRORCODE.DATACONTRACT_NOT_PUBLIC,</span>
<span class="nc" id="L1186">                            &quot; Dataset &quot; + datasetInfo.getName() + &quot; has no public conract.&quot;, false);</span>
                }
                try {
<span class="nc" id="L1189">                    datacontractMgrApi.registerToPublicDataContract(accountID, datacontractID);</span>
<span class="nc" id="L1190">                } catch (final AccountAlreadyHasADataContractWithProvider ex) {</span>
                    // Ignore
<span class="nc" id="L1192">                }</span>
            }
<span class="nc" id="L1194">        }</span>

        // Validate data contracts and get info
<span class="nc" id="L1197">        final Map&lt;DataContractID, DataContract&gt; dataContractsInfo = datacontractMgrApi</span>
<span class="nc" id="L1198">                .getInfoOfSomeActiveDataContractsForAccountWithProviders(accountID, datasetsIDs);</span>

        // Validate dataSetForStore is among data contracts and calculate endDate from
        // them
<span class="nc" id="L1202">        final Tuple&lt;DataContractID, Calendar&gt; checkedDataSetAmongDataContracts = validateDataSetForStore(</span>
                dataContractsInfo, datasetsInfo, dataSetForStore);
<span class="nc" id="L1204">        final DataContractID dataContractIDforStore = checkedDataSetAmongDataContracts.getFirst();</span>
<span class="nc" id="L1205">        Calendar endDate = checkedDataSetAmongDataContracts.getSecond();</span>

        // Validate model contracts and get info
<span class="nc" id="L1208">        final Map&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; infoOfInterfacesInContracts = contractMgrApi</span>
<span class="nc" id="L1209">                .getInfoOfMultipleContractsPerActiveContractsForAccount(accountID, contracts);</span>

        // Index implementations and calculate endDate for the session
<span class="nc" id="L1212">        final HashSet&lt;InterfaceID&gt; interfacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1213">        final HashSet&lt;ImplementationID&gt; implementationsIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">        for (final Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt; interfacesInContract : infoOfInterfacesInContracts</span>
<span class="nc" id="L1215">                .values()) {</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">            for (final Entry&lt;InterfaceID, InterfaceInContract&gt; curEntry : interfacesInContract.getFirst().entrySet()) {</span>
<span class="nc" id="L1217">                final InterfaceID interfaceID = curEntry.getKey();</span>
<span class="nc" id="L1218">                final InterfaceInContract interfaceInContract = curEntry.getValue();</span>
<span class="nc" id="L1219">                interfacesIDs.add(interfaceID);</span>

                // Implementations
<span class="nc bnc" id="L1222" title="All 2 branches missed.">                for (final Entry&lt;OperationID, OpImplementations&gt; curOpImpls : interfaceInContract</span>
<span class="nc" id="L1223">                        .getAccessibleImplementations().entrySet()) {</span>
<span class="nc" id="L1224">                    implementationsIDs.add(curOpImpls.getValue().getRemoteImplementationID());</span>
<span class="nc" id="L1225">                    implementationsIDs.add(curOpImpls.getValue().getLocalImplementationID());</span>
<span class="nc" id="L1226">                }</span>
<span class="nc" id="L1227">            }</span>

            // End date
<span class="nc bnc" id="L1230" title="All 4 branches missed.">            if (endDate == null || interfacesInContract.getSecond().before(endDate)) {</span>
<span class="nc" id="L1231">                endDate = interfacesInContract.getSecond();</span>
            }
<span class="nc" id="L1233">        }</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">        if (endDate.before(Calendar.getInstance())) {</span>
<span class="nc" id="L1235">            throw new DataClayRuntimeException(ERRORCODE.APPLIABLE_END_DATE_FOR_SESSION_IS_BEFORE_CURRENT_DATE);</span>
        }

        // Get info of interfaces
<span class="nc" id="L1239">        final Map&lt;InterfaceID, Interface&gt; infoOfInterfaces = interfaceMgrApi.getInterfacesInfo(interfacesIDs);</span>

        // Get info of classes of interfaces
<span class="nc" id="L1242">        final Map&lt;MetaClassID, MetaClass&gt; classesInfo = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1243">        final Map&lt;MetaClassID, Set&lt;Interface&gt;&gt; interfacesPerClass = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        for (final Interface curInterface : infoOfInterfaces.values()) {</span>
<span class="nc" id="L1245">            final MetaClassID curClassID = curInterface.getMetaClassID();</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">            if (!classesInfo.containsKey(curClassID)) {</span>
<span class="nc" id="L1247">                final MetaClass classInfo = classMgrApi.getClassInfo(curClassID);</span>
<span class="nc" id="L1248">                classesInfo.put(curClassID, classInfo);</span>
            }
<span class="nc" id="L1250">            Set&lt;Interface&gt; ifacesOfClass = interfacesPerClass.get(curClassID);</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">            if (ifacesOfClass == null) {</span>
<span class="nc" id="L1252">                ifacesOfClass = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1253">                interfacesPerClass.put(curClassID, ifacesOfClass);</span>
            }
<span class="nc" id="L1255">            ifacesOfClass.add(curInterface);</span>
<span class="nc" id="L1256">        }</span>

        // CROSS-NAMESPACE STUFF
        // Get info of the implementations
<span class="nc" id="L1260">        final Map&lt;ImplementationID, Implementation&gt; infoOfImplementations = classMgrApi</span>
<span class="nc" id="L1261">                .getInfoOfImplementations(implementationsIDs);</span>

        // Get the info of namespaces of implementations
<span class="nc" id="L1264">        final Map&lt;ImplementationID, NamespaceID&gt; namespaceIDsOfImplementations = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">        for (final Entry&lt;ImplementationID, Implementation&gt; curImplementation : infoOfImplementations.entrySet()) {</span>
<span class="nc" id="L1266">            final ImplementationID curImplementationID = curImplementation.getKey();</span>
<span class="nc" id="L1267">            final NamespaceID curNamespaceID = curImplementation.getValue().getNamespaceID();</span>
<span class="nc" id="L1268">            namespaceIDsOfImplementations.put(curImplementationID, curNamespaceID);</span>
<span class="nc" id="L1269">        }</span>
<span class="nc" id="L1270">        final Set&lt;NamespaceID&gt; namespaceIDs = new HashSet&lt;&gt;(namespaceIDsOfImplementations.values());</span>
<span class="nc" id="L1271">        final Map&lt;NamespaceID, Namespace&gt; namespacesInfo = namespaceMgrApi.getNamespacesInfo(namespaceIDs);</span>

<span class="nc bnc" id="L1273" title="All 2 branches missed.">        if (dataSets.size() == 0) {</span>
<span class="nc" id="L1274">            throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION, &quot;Received information for #&quot;</span>
<span class="nc" id="L1275">                    + namespacesInfo.size() + &quot; namespace(s) and #&quot; + dataSets.size() + &quot; dataset(s)&quot;, true);</span>
        }

        // Build model contract session stuff and bitsets for every class
<span class="nc" id="L1279">        final Map&lt;ContractID, SessionContract&gt; sessionContracts = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1280">        final Map&lt;MetaClassID, BitSet&gt; bitsetsPerClass = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1282" title="All 2 branches missed.">        for (final Entry&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; curEntry : infoOfInterfacesInContracts</span>
<span class="nc" id="L1283">                .entrySet()) {</span>

<span class="nc" id="L1285">            final ContractID curContractID = curEntry.getKey();</span>
<span class="nc" id="L1286">            final Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt; curNamespaceAndInterfacesInContract = curEntry</span>
<span class="nc" id="L1287">                    .getValue();</span>
<span class="nc" id="L1288">            final Map&lt;InterfaceID, InterfaceInContract&gt; curInterfacesInContract = curNamespaceAndInterfacesInContract</span>
<span class="nc" id="L1289">                    .getFirst();</span>

            // Build session interfaces for every contract
<span class="nc" id="L1292">            final Map&lt;InterfaceID, SessionInterface&gt; sessionInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">            for (final Entry&lt;InterfaceID, InterfaceInContract&gt; curInterfaceInContractEntry : curInterfacesInContract</span>
<span class="nc" id="L1294">                    .entrySet()) {</span>

<span class="nc" id="L1296">                final InterfaceID curInterfaceID = curInterfaceInContractEntry.getKey();</span>
<span class="nc" id="L1297">                final InterfaceInContract curInterfaceInContract = curInterfaceInContractEntry.getValue();</span>
<span class="nc" id="L1298">                final Interface curInterface = infoOfInterfaces.get(curInterfaceID);</span>

                // Add BitSet if it is the first time we explore the class of the interface
<span class="nc bnc" id="L1301" title="All 2 branches missed.">                if (!bitsetsPerClass.containsKey(curInterface.getMetaClassID())) {</span>
<span class="nc" id="L1302">                    bitsetsPerClass.put(curInterface.getMetaClassID(), new BitSet());</span>
                }
<span class="nc" id="L1304">                final BitSet curBitSet = bitsetsPerClass.get(curInterface.getMetaClassID());</span>

                // Build session properties for every interface and update bitset of class
<span class="nc" id="L1307">                final Map&lt;PropertyID, SessionProperty&gt; sessionProperties = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1308">                final MetaClass classInfo = classesInfo.get(curInterface.getMetaClassID());</span>
<span class="nc" id="L1309">                final List&lt;Property&gt; propertiesInfo = classInfo.getProperties();</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">                for (final Property curProp : propertiesInfo) {</span>
<span class="nc" id="L1311">                    final PropertyID propertyID = curProp.getDataClayID();</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">                    if (curInterface.getPropertiesIDs().contains(propertyID)) {</span>
<span class="nc" id="L1313">                        final SessionProperty sessionProperty = new SessionProperty(propertyID);</span>
<span class="nc" id="L1314">                        sessionProperties.put(propertyID, sessionProperty);</span>
                    }
<span class="nc" id="L1316">                }</span>

<span class="nc" id="L1318">                setIfacesBitMap(curInterface, classesInfo, curBitSet, interfacesPerClass, 0);</span>

                // Build session operations for every interface
<span class="nc" id="L1321">                final Map&lt;OperationID, SessionOperation&gt; sessionOperations = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">                for (final OperationID operationID : curInterface.getOperationsIDs()) {</span>
<span class="nc" id="L1323">                    final OpImplementations opImpls = curInterfaceInContract.getAccessibleImplementations()</span>
<span class="nc" id="L1324">                            .get(operationID);</span>
<span class="nc" id="L1325">                    final ImplementationID localImplID = opImpls.getLocalImplementationID();</span>
<span class="nc" id="L1326">                    final NamespaceID namespaceIDofLocalImplID = infoOfImplementations.get(localImplID)</span>
<span class="nc" id="L1327">                            .getNamespaceID();</span>

<span class="nc" id="L1329">                    final ImplementationID remoteImplID = opImpls.getRemoteImplementationID();</span>
<span class="nc" id="L1330">                    final NamespaceID namespaceIDofRemoteImplID = infoOfImplementations.get(remoteImplID)</span>
<span class="nc" id="L1331">                            .getNamespaceID();</span>

<span class="nc" id="L1333">                    final SessionImplementation localImpl = new SessionImplementation(localImplID,</span>
                            namespaceIDofLocalImplID,
<span class="nc" id="L1335">                            namespacesInfo.get(namespaceIDofLocalImplID).getProviderAccountID());</span>
<span class="nc" id="L1336">                    final SessionImplementation remoteImpl = new SessionImplementation(remoteImplID,</span>
                            namespaceIDofRemoteImplID,
<span class="nc" id="L1338">                            namespacesInfo.get(namespaceIDofRemoteImplID).getProviderAccountID());</span>
<span class="nc" id="L1339">                    final SessionOperation sessionOperation = new SessionOperation(operationID, localImpl, remoteImpl);</span>

<span class="nc" id="L1341">                    sessionOperations.put(operationID, sessionOperation);</span>

<span class="nc" id="L1343">                    implementationsIDs.add(localImplID);</span>
<span class="nc" id="L1344">                    implementationsIDs.add(remoteImplID);</span>
<span class="nc" id="L1345">                }</span>

                // Build the current sessionInterface
<span class="nc" id="L1348">                final SessionInterface sessionInterface = new SessionInterface(curInterfaceID,</span>
<span class="nc" id="L1349">                        curInterface.getMetaClassID());</span>

<span class="nc" id="L1351">                sessionInterface.setSessionProperties(sessionProperties);</span>
<span class="nc" id="L1352">                sessionInterface.setSessionOperations(sessionOperations);</span>

                // Add sessionInterface to session interfaces
<span class="nc" id="L1355">                sessionInterfaces.put(curInterfaceID, sessionInterface);</span>
<span class="nc" id="L1356">            }</span>

            // Build the current session contract
<span class="nc" id="L1359">            final SessionContract sessionContract = new SessionContract(curContractID);</span>
<span class="nc" id="L1360">            sessionContract.setSessionInterfaces(sessionInterfaces);</span>

            // Add sessionContract to session contracts
<span class="nc" id="L1363">            sessionContracts.put(curContractID, sessionContract);</span>
<span class="nc" id="L1364">        }</span>

        // Build data contract session stuff
<span class="nc" id="L1367">        final Map&lt;DataContractID, SessionDataContract&gt; sessionDataContracts = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">        for (final Entry&lt;DataContractID, DataContract&gt; curDataContract : dataContractsInfo.entrySet()) {</span>
<span class="nc" id="L1369">            final DataContractID dataContractID = curDataContract.getKey();</span>
<span class="nc" id="L1370">            final DataContract dataContract = curDataContract.getValue();</span>
<span class="nc" id="L1371">            final DataSetID dataSetIDofProvider = dataContract.getProviderDataSetID();</span>
<span class="nc" id="L1372">            final SessionDataContract sessionDataContract = new SessionDataContract(dataContractID,</span>
                    dataSetIDofProvider);
<span class="nc" id="L1374">            sessionDataContracts.put(dataContractID, sessionDataContract);</span>
<span class="nc" id="L1375">        }</span>

        // Finally register the new session
        // Generate bitmaps for interfaces of stubs
<span class="nc" id="L1379">        final Map&lt;MetaClassID, byte[]&gt; bitmapsPerClass = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        for (final Entry&lt;MetaClassID, BitSet&gt; curEntry : bitsetsPerClass.entrySet()) {</span>
<span class="nc" id="L1381">            bitmapsPerClass.put(curEntry.getKey(), curEntry.getValue().toByteArray());</span>
<span class="nc" id="L1382">        }</span>
<span class="nc" id="L1383">        final SessionInfo result = sessionMgrApi.newSession(accountID, sessionContracts, sessionDataContracts,</span>
                dataContractIDforStore, endDate, newsessionLang, bitmapsPerClass);
<span class="nc" id="L1385">        return result;</span>
    }

    @Override
    public void closeSession(final SessionID sessionID) {

<span class="nc" id="L1391">        LOGGER.debug(&quot;==&gt; Closing session &quot; + sessionID);</span>
<span class="nc" id="L1392">        sessionMgrApi.closeSession(sessionID);</span>

        // Broadcast closing of session
<span class="nc bnc" id="L1395" title="All 2 branches missed.">        for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_JAVA).values()) {</span>
            try {
<span class="nc" id="L1397">                elem.getFirst().closeSessionInDS(sessionID);</span>
<span class="nc" id="L1398">            } catch (final StatusRuntimeException e) {</span>
                // if unavailabe, ignore
<span class="nc bnc" id="L1400" title="All 2 branches missed.">                if (e.getStatus().getCode().equals(Status.UNAVAILABLE.getCode())) {</span>
<span class="nc" id="L1401">                    LOGGER.debug(&quot;Execution environment {} is not available. Not closing session there.&quot;, elem.getSecond());</span>
                } else {
<span class="nc" id="L1403">                    throw new RuntimeException(e.getMessage());</span>
                }
<span class="nc" id="L1405">            }</span>
<span class="nc" id="L1406">        }</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">        for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_PYTHON).values()) {</span>
            try {
<span class="nc" id="L1409">                elem.getFirst().closeSessionInDS(sessionID);</span>
<span class="nc" id="L1410">            } catch (final StatusRuntimeException e) {</span>
                // if unavailabe, ignore
<span class="nc bnc" id="L1412" title="All 2 branches missed.">                if (e.getStatus().getCode().equals(Status.UNAVAILABLE.getCode())) {</span>
<span class="nc" id="L1413">                    LOGGER.debug(&quot;Execution environment {} is not available. Not closing session there.&quot;, elem.getSecond());</span>
                } else {
<span class="nc" id="L1415">                    throw new RuntimeException(e.getMessage());</span>
                }
<span class="nc" id="L1417">            }</span>
<span class="nc" id="L1418">        }</span>
<span class="nc" id="L1419">        LOGGER.debug(&quot;&lt;== Closed session &quot; + sessionID);</span>
<span class="nc" id="L1420">    }</span>

    /**
     * Set iface bitmap for session.
     *
     * @param curInterface
     *            Current interface
     * @param classesInfo
     *            Information of classes
     * @param curBitSet
     *            Current bitset being set
     * @param ifacesPerClass
     *            Interfaces per class
     * @param initialPosition
     *            Initial position (used for embbeded)
     */
    private void setIfacesBitMap(final Interface curInterface, final Map&lt;MetaClassID, MetaClass&gt; classesInfo,
                                 final BitSet curBitSet, final Map&lt;MetaClassID, Set&lt;Interface&gt;&gt; ifacesPerClass, final int initialPosition) {

<span class="nc" id="L1439">        int curPosition = initialPosition;</span>
<span class="nc" id="L1440">        final MetaClass classInfo = classesInfo.get(curInterface.getMetaClassID());</span>
<span class="nc" id="L1441">        final List&lt;Property&gt; propertiesInfo = classInfo.getProperties();</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">        for (final Property curProp : propertiesInfo) {</span>
<span class="nc" id="L1443">            final PropertyID propertyID = curProp.getDataClayID();</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">            if (curInterface.getPropertiesIDs().contains(propertyID)) {</span>
                // Update bitset for calculating the final bitmap afterwards

                // Also, in case of embeded this is setting the boolean indicating if it is null
<span class="nc" id="L1448">                curBitSet.set(curPosition);</span>

                // === EMBEDDED FIELDS === //
                /*
                 * if (curProp.getType().getClassID() != null) { MetaClass clazz =
                 * classesInfo.get(curProp.getType().getClassID()); if (clazz.isImmutable()) {
                 * // Get interface of the embedded class Set&lt;Interface&gt; newIfaces =
                 * ifacesPerClass.get(clazz.getID()); for (Interface iface : newIfaces) {
                 * setIfacesBitMap(iface, classesInfo, curBitSet, ifacesPerClass,
                 * curProp.getPosition() + 1); } curPosition = curPosition +
                 * clazz.getProperties().size(); } }
                 */
            }

<span class="nc" id="L1462">            curPosition++;</span>
<span class="nc" id="L1463">        }</span>
<span class="nc" id="L1464">    }</span>

    @Override
    public Tuple&lt;Tuple&lt;DataSetID, Set&lt;DataSetID&gt;&gt;, Calendar&gt; getInfoOfSessionForDS(final SessionID sessionID) {
        // TODO We have to ensure that only a DataService is able to access this method
        // (30 May 2014 jmarti)
<span class="nc" id="L1470">        final HashSet&lt;DataSetID&gt; visibleDataSets = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1471">        final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L1472">        DataSetID dataSetForStore = null;</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">        for (final SessionDataContract sessionDataContract : sessionInfo.getSessionDataContracts().values()) {</span>
<span class="nc" id="L1474">            visibleDataSets.add(sessionDataContract.getDataSetOfProvider());</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">            if (sessionDataContract.getDataContractID().equals(sessionInfo.getDataContractIDforStore())) {</span>
<span class="nc" id="L1476">                dataSetForStore = sessionDataContract.getDataSetOfProvider();</span>
            }
<span class="nc" id="L1478">        }</span>
<span class="nc" id="L1479">        return new Tuple&lt;&gt;(new Tuple&lt;DataSetID, Set&lt;DataSetID&gt;&gt;(dataSetForStore, visibleDataSets),</span>
<span class="nc" id="L1480">                sessionInfo.getEndDate());</span>
    }

    // ============== Namespace Manager ==============//

    @Override
    public NamespaceID newNamespace(final AccountID accountID, final PasswordCredential credential,
                                    final Namespace newNamespace) {
        // Validate account
<span class="nc bnc" id="L1489" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L1490">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

        // =========== CHECK AND SET IDS =========== //
<span class="nc" id="L1494">        final String providerAccountName = newNamespace.getProviderAccountName();</span>
<span class="nc bnc" id="L1495" title="All 4 branches missed.">        if (providerAccountName == null || providerAccountName.isEmpty()) {</span>
<span class="nc" id="L1496">            throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                    &quot;Namespace wrong specification: Provider account name cannot be null nor empty&quot;, false);
        }
<span class="nc" id="L1499">        final AccountID provAccountID = accountMgrApi.getAccountID(providerAccountName);</span>
<span class="nc" id="L1500">        newNamespace.setProviderAccountID(provAccountID);</span>

<span class="nc" id="L1502">        final String namespaceName = newNamespace.getName();</span>
<span class="nc bnc" id="L1503" title="All 4 branches missed.">        if (namespaceName == null || namespaceName.isEmpty()) {</span>
<span class="nc" id="L1504">            throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                    &quot;Namespace wrong specification: name cannot be null&quot;, false);
        }
        // =========== =========== //

        // Generate ID
<span class="nc" id="L1510">        newNamespace.setDataClayID(new NamespaceID());</span>
        // Set correctly the responsible account
<span class="nc" id="L1512">        newNamespace.setProviderAccountID(accountID);</span>

        // Create the new namespace
<span class="nc" id="L1515">        NamespaceID newNamespaceID = namespaceMgrApi.newNamespace(newNamespace);</span>
<span class="nc" id="L1516">        LOGGER.info(&quot;[LOGICMODULE] Created new namespace called &quot; + namespaceName);</span>

<span class="nc" id="L1518">        return newNamespaceID;</span>


    }

    @Override
    public Set&lt;String&gt; getNamespaces(final AccountID accountID, final PasswordCredential credential) {

        // Validate account
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L1528">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L1531">        return namespaceMgrApi.getNamespacesNames();</span>
    }

    @Override
    public void removeNamespace(final AccountID accountID, final PasswordCredential credential,
                                final String namespaceName) {
        // Get the namespaceID of the namespace
<span class="nc" id="L1538">        final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespaceName);</span>

        // Validate account (ADMIN || NAMESPACE RESPONSIBLE)
        try {
<span class="nc" id="L1542">            accountMgrApi.validateAccount(accountID, credential, AccountRole.ADMIN_ROLE);</span>
<span class="nc" id="L1543">        } catch (final Exception ex) {</span>
<span class="nc" id="L1544">            checkNamespaceResponsible(accountID, credential, namespaceID);</span>
<span class="nc" id="L1545">        }</span>

        // Check the namespace can be removed
        // Check namespace is not related with any contract
<span class="nc bnc" id="L1549" title="All 2 branches missed.">        if (!contractMgrApi.checkNamespaceHasNoContracts(namespaceID)) {</span>
<span class="nc" id="L1550">            throw new DataClayRuntimeException(ERRORCODE.NAMESPACE_WITH_CONTRACTS);</span>
        }
        // Check namespace has nothing
<span class="nc bnc" id="L1553" title="All 2 branches missed.">        if (!classMgrApi.checkNamespaceHasNothing(namespaceID)) {</span>
<span class="nc" id="L1554">            throw new DataClayRuntimeException(ERRORCODE.NAMESPACE_WITH_CLASSES);</span>
        }

        // Remove namespace
<span class="nc" id="L1558">        namespaceMgrApi.removeNamespace(namespaceID);</span>

<span class="nc" id="L1560">    }</span>

    @Override
    public NamespaceID getNamespaceID(final AccountID accountID, final PasswordCredential credential,
                                      final String namespaceName) {
        // Validate account
<span class="nc bnc" id="L1566" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1567">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }
<span class="nc" id="L1569">        return namespaceMgrApi.getNamespaceID(namespaceName);</span>

    }

    @Override
    public Langs getNamespaceLang(final AccountID accountID, final PasswordCredential credential,
                                  final String namespaceName) {
        // Validate account
<span class="nc bnc" id="L1577" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1578">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }
<span class="nc" id="L1580">        return namespaceMgrApi.getNamespaceLang(namespaceName);</span>
    }

    @Override
    public void importInterface(final AccountID accountID, final PasswordCredential credential,
                                final NamespaceID namespaceID, final ContractID contractID, final InterfaceID interfaceID) {
        // Check namespace responsible
<span class="nc" id="L1587">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

        // Check interface in contract of import and get contract info
<span class="nc" id="L1590">        final Map&lt;ContractID, InterfaceID&gt; aux = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1591">        aux.put(contractID, interfaceID);</span>
<span class="nc" id="L1592">        final Contract contractInfo = contractMgrApi</span>
<span class="nc" id="L1593">                .checkInterfacesInActiveContractsForAccountAndReturnContractsInfo(accountID, aux).get(contractID);</span>
<span class="nc" id="L1594">        final Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInContract = contractInfo.getInterfacesInContract();</span>

        // Check compatibility between namespaces (language)
<span class="nc" id="L1597">        final HashSet&lt;NamespaceID&gt; namespacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1598">        namespacesIDs.add(namespaceID);</span>
<span class="nc" id="L1599">        namespacesIDs.add(contractInfo.getNamespaceID());</span>

        // Init interfaces to be imported with the explicitly specified one
<span class="nc" id="L1602">        final HashSet&lt;InterfaceID&gt; interfacesIDsToBeImported = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1603">        interfacesIDsToBeImported.add(interfaceID);</span>

<span class="nc bnc" id="L1605" title="All 2 branches missed.">        while (!interfacesIDsToBeImported.isEmpty()) {</span>
<span class="nc" id="L1606">            final Set&lt;InterfaceID&gt; nextInterfacesIDsToBeImported = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1607">            final Map&lt;InterfaceID, ImportedInterface&gt; currentImportss = new HashMap&lt;&gt;();</span>

            // Get info of current interfaces to be imported
<span class="nc" id="L1610">            final Map&lt;InterfaceID, Interface&gt; interfacesInfo = interfaceMgrApi</span>
<span class="nc" id="L1611">                    .getInterfacesInfo(interfacesIDsToBeImported);</span>

<span class="nc bnc" id="L1613" title="All 2 branches missed.">            for (final InterfaceID curInterfaceID : interfacesIDsToBeImported) {</span>
<span class="nc" id="L1614">                final Interface interfaceInfo = interfacesInfo.get(curInterfaceID);</span>
<span class="nc" id="L1615">                final InterfaceInContract interfaceInContract = interfacesInContract.get(curInterfaceID);</span>
<span class="nc" id="L1616">                final MetaClassID classIDofInterface = interfaceInfo.getMetaClassID();</span>

                // Check interface actually comes from another namespace
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                if (interfaceInfo.getNamespaceID().equals(namespaceID)) {</span>
<span class="nc" id="L1620">                    throw new DataClayRuntimeException(ERRORCODE.IMPORTED_INTERFACE_WAS_CREATED_IN_TARGET_NAMESPACE);</span>
                }

                // Get info of class of interface and its includes filtering by real needs of
                // interface in contract (properties, operations, implementations)
<span class="nc" id="L1625">                final Set&lt;PropertyID&gt; propertiesIDsOfInterface = interfaceInfo.getPropertiesIDs();</span>
<span class="nc" id="L1626">                final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; opsIDsandImplsIDsOfInterfaceInContract = //</span>
                        new HashMap&lt;&gt;();
<span class="nc bnc" id="L1628" title="All 2 branches missed.">                for (final Entry&lt;OperationID, OpImplementations&gt; curEntry : interfaceInContract</span>
<span class="nc" id="L1629">                        .getAccessibleImplementations().entrySet()) {</span>
<span class="nc" id="L1630">                    final HashSet&lt;ImplementationID&gt; implsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1631">                    implsIDs.add(curEntry.getValue().getLocalImplementationID());</span>
<span class="nc" id="L1632">                    implsIDs.add(curEntry.getValue().getRemoteImplementationID());</span>
<span class="nc" id="L1633">                    opsIDsandImplsIDsOfInterfaceInContract.put(curEntry.getKey(), implsIDs);</span>
<span class="nc" id="L1634">                }</span>
<span class="nc" id="L1635">                final Triple&lt;String, NamespaceID, Set&lt;MetaClassID&gt;&gt; classInfoAndIncludesOfDifferentNamespace = classMgrApi</span>
<span class="nc" id="L1636">                        .getIncludesInDifferentNamespaces(classIDofInterface, propertiesIDsOfInterface,</span>
                                opsIDsandImplsIDsOfInterfaceInContract, namespaceID);
<span class="nc" id="L1638">                final String className = classInfoAndIncludesOfDifferentNamespace.getFirst();</span>
<span class="nc" id="L1639">                final NamespaceID namespaceIDofClass = classInfoAndIncludesOfDifferentNamespace.getSecond();</span>
<span class="nc" id="L1640">                final Set&lt;MetaClassID&gt; includesIDs = classInfoAndIncludesOfDifferentNamespace.getThird();</span>

                // Check namespace of class is different than target namespace for the import
<span class="nc bnc" id="L1643" title="All 2 branches missed.">                if (namespaceID.equals(namespaceIDofClass)) {</span>
<span class="nc" id="L1644">                    throw new DataClayRuntimeException(</span>
                            ERRORCODE.CLASS_OF_IMPORTED_INTERFACE_WAS_CREATED_IN_TARGET_NAMESPACE);
                }

                // Check there is no class created in target namespace with the same name as
                // imported class
<span class="nc bnc" id="L1650" title="All 2 branches missed.">                if (classMgrApi.getMetaClassID(namespaceID, className) != null) {</span>
<span class="nc" id="L1651">                    throw new DataClayRuntimeException(ERRORCODE.CLASS_WITH_SAME_NAME_IN_NAMESPACE);</span>
                }

                // Filter subset of interfaces of the contract that are needed given the
                // includes
                // for the current one to be imported
<span class="nc" id="L1657">                nextInterfacesIDsToBeImported.addAll(interfaceMgrApi.getSubsetInterfacesOfClasses(</span>
<span class="nc" id="L1658">                        new HashSet&lt;&gt;(contractInfo.getInterfacesInContract().keySet()), includesIDs));</span>

                // Filter current interfaceID to be imported
<span class="nc" id="L1661">                nextInterfacesIDsToBeImported.removeAll(interfacesIDsToBeImported);</span>

                // Filter those that were already imported in the namespace
<span class="nc" id="L1664">                final Set&lt;ImportedInterface&gt; interfacesImported = namespaceMgrApi</span>
<span class="nc" id="L1665">                        .getImportedInterfaces(namespaceIDofClass, className);</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                for (final ImportedInterface importedInterface : interfacesImported) {</span>
<span class="nc" id="L1667">                    nextInterfacesIDsToBeImported.remove(importedInterface.getInterfaceID());</span>
<span class="nc" id="L1668">                }</span>

<span class="nc" id="L1670">                final ImportedInterface currentInterface = new ImportedInterface(className, curInterfaceID, contractID,</span>
                        classIDofInterface, namespaceIDofClass);
<span class="nc" id="L1672">                currentImportss.put(curInterfaceID, currentInterface);</span>
<span class="nc" id="L1673">            }</span>

<span class="nc" id="L1675">            final HashSet&lt;ImportedInterface&gt; importss = new HashSet&lt;&gt;(currentImportss.values());</span>

            // Deploy imported class
<span class="nc" id="L1678">            final HashSet&lt;NamespaceID&gt; domIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1679">            domIDs.add(namespaceID);</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">            for (final ImportedInterface impInterface : importss) {</span>
<span class="nc" id="L1681">                final NamespaceID domID = impInterface.getNamespaceIDofClass();</span>
<span class="nc" id="L1682">                domIDs.add(domID);</span>
<span class="nc" id="L1683">            }</span>

            // Register current imports
<span class="nc" id="L1686">            namespaceMgrApi.importInterfaces(namespaceID, new HashSet&lt;&gt;(currentImportss.values()));</span>

            // Update interfacesIDsToBeImported
<span class="nc" id="L1689">            interfacesIDsToBeImported.addAll(nextInterfacesIDsToBeImported);</span>
<span class="nc" id="L1690">            interfacesIDsToBeImported.removeAll(currentImportss.keySet());</span>
<span class="nc" id="L1691">        }</span>

<span class="nc" id="L1693">    }</span>

    @Override
    public void importContract(final AccountID accountID, final PasswordCredential credential,
                               final NamespaceID namespaceID, final ContractID contractID) {
        // Check namespace responsible
<span class="nc" id="L1699">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

        // Check compatibility between namespaces (language)
<span class="nc" id="L1702">        final LinkedList&lt;ContractID&gt; contractsIDs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1703">        contractsIDs.add(contractID);</span>
<span class="nc" id="L1704">        final Contract contractInfo = contractMgrApi.getInfoOfSomeActiveContractsForAccount(contractsIDs, accountID)</span>
<span class="nc" id="L1705">                .get(contractID);</span>
<span class="nc" id="L1706">        final Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInContract = contractInfo.getInterfacesInContract();</span>

        // Check compatibility between namespaces
<span class="nc" id="L1709">        final HashSet&lt;NamespaceID&gt; namespacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1710">        namespacesIDs.add(namespaceID);</span>
<span class="nc" id="L1711">        namespacesIDs.add(contractInfo.getNamespaceID());</span>

        // Get info of interfaces
<span class="nc" id="L1714">        final Map&lt;InterfaceID, Interface&gt; interfacesInfo = interfaceMgrApi</span>
<span class="nc" id="L1715">                .getInterfacesInfo(new HashSet&lt;&gt;(contractInfo.getInterfacesInContract().keySet()));</span>

        // Check no interface was created on target namespace
<span class="nc" id="L1718">        final HashSet&lt;ImportedInterface&gt; importss = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1719" title="All 2 branches missed.">        for (final Entry&lt;InterfaceID, Interface&gt; curInterface : interfacesInfo.entrySet()) {</span>
<span class="nc" id="L1720">            final InterfaceID interfaceID = curInterface.getKey();</span>
<span class="nc" id="L1721">            final Interface interfaceInfo = curInterface.getValue();</span>
<span class="nc" id="L1722">            final InterfaceInContract interfaceInContract = interfacesInContract.get(interfaceID);</span>
<span class="nc" id="L1723">            final MetaClassID classIDofInterface = interfaceInfo.getMetaClassID();</span>

            // Check interface was not created in same namespace as target one
<span class="nc bnc" id="L1726" title="All 2 branches missed.">            if (interfaceInfo.getNamespaceID().equals(namespaceID)) {</span>
<span class="nc" id="L1727">                throw new DataClayRuntimeException(ERRORCODE.IMPORTED_INTERFACE_WAS_CREATED_IN_TARGET_NAMESPACE);</span>
            }

            // Get info of class of interface and its includes filtering by
            // real needs of
            // interface in contract (properties, operations,
            // implementations)
<span class="nc" id="L1734">            final Set&lt;PropertyID&gt; propertiesIDsOfInterface = interfaceInfo.getPropertiesIDs();</span>
<span class="nc" id="L1735">            final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; opsIDsandImplsIDsOfInterfaceInContract = //</span>
                    new HashMap&lt;&gt;();
<span class="nc bnc" id="L1737" title="All 2 branches missed.">            for (final Entry&lt;OperationID, OpImplementations&gt; curEntry : interfaceInContract</span>
<span class="nc" id="L1738">                    .getAccessibleImplementations().entrySet()) {</span>
<span class="nc" id="L1739">                final HashSet&lt;ImplementationID&gt; implsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1740">                implsIDs.add(curEntry.getValue().getLocalImplementationID());</span>
<span class="nc" id="L1741">                implsIDs.add(curEntry.getValue().getRemoteImplementationID());</span>
<span class="nc" id="L1742">                opsIDsandImplsIDsOfInterfaceInContract.put(curEntry.getKey(), implsIDs);</span>
<span class="nc" id="L1743">            }</span>
<span class="nc" id="L1744">            final Triple&lt;String, NamespaceID, Set&lt;MetaClassID&gt;&gt; classInfoAndIncludesOfDifferentNamespace = classMgrApi</span>
<span class="nc" id="L1745">                    .getIncludesInDifferentNamespaces(classIDofInterface, propertiesIDsOfInterface,</span>
                            opsIDsandImplsIDsOfInterfaceInContract, namespaceID);
<span class="nc" id="L1747">            final String className = classInfoAndIncludesOfDifferentNamespace.getFirst();</span>
<span class="nc" id="L1748">            final NamespaceID namespaceIDofClass = classInfoAndIncludesOfDifferentNamespace.getSecond();</span>
            // BEWARE: If contract is correct, we do not have to check
            // includes are in contract in this point
            // HashSet&lt;MetaClassID&gt; includesIDs =
            // classInfoAndIncludesOfDifferentNamespace.getThird();

<span class="nc bnc" id="L1754" title="All 2 branches missed.">            if (namespaceIDofClass.equals(namespaceID)) {</span>
<span class="nc" id="L1755">                throw new DataClayRuntimeException(</span>
                        ERRORCODE.CLASS_OF_IMPORTED_INTERFACE_WAS_CREATED_IN_TARGET_NAMESPACE);
            } else {
<span class="nc" id="L1758">                final ImportedInterface importInterface = new ImportedInterface(className, interfaceID, contractID,</span>
<span class="nc" id="L1759">                        interfaceInfo.getMetaClassID(), namespaceIDofClass);</span>
<span class="nc" id="L1760">                importss.add(importInterface);</span>
            }
<span class="nc" id="L1762">        }</span>

        // Deploy imported class
<span class="nc" id="L1765">        final HashSet&lt;NamespaceID&gt; domIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1766">        domIDs.add(namespaceID);</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">        for (final ImportedInterface impInterface : importss) {</span>
<span class="nc" id="L1768">            final NamespaceID domID = impInterface.getNamespaceIDofClass();</span>
<span class="nc" id="L1769">            domIDs.add(domID);</span>
<span class="nc" id="L1770">        }</span>

<span class="nc" id="L1772">        namespaceMgrApi.importInterfaces(namespaceID, importss);</span>

<span class="nc" id="L1774">    }</span>

    // ============== DataSet Manager ==============//

    @Override
    public DataSetID newDataSet(final AccountID accountID, final PasswordCredential credential,
                                final DataSet newDataSet) {

        // Validate account
<span class="nc bnc" id="L1783" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L1784">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

        // ================================================ //
<span class="nc bnc" id="L1788" title="All 2 branches missed.">        if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L1789">            this.notificationMgrApi.removeSessionInCache(accountID);</span>
        }

<span class="nc" id="L1792">        final String dataSetName = newDataSet.getName();</span>
<span class="nc bnc" id="L1793" title="All 4 branches missed.">        if (dataSetName == null || dataSetName.isEmpty()) {</span>
<span class="nc" id="L1794">            throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                    &quot;DataSet wrong specification: DataSet name cannot be null&quot;, false);
        }
        // =========== =========== //

        // Create ID
<span class="nc bnc" id="L1800" title="All 2 branches missed.">        if (newDataSet.getDataClayID() == null) {</span>
<span class="nc" id="L1801">            newDataSet.setDataClayID(new DataSetID());</span>
        }
        // Set the responsible account correctly
<span class="nc" id="L1804">        newDataSet.setProviderAccountID(accountID);</span>

        // Create the new dataset
<span class="nc" id="L1807">        final DataSetID dsID = dataSetMgrApi.newDataSet(newDataSet);</span>

<span class="nc" id="L1809">        LOGGER.info(&quot;[LOGICMODULE] Created new dataset called &quot; + newDataSet.getName() + &quot; with ID &quot; + dsID);</span>

<span class="nc" id="L1811">        return dsID;</span>
    }

    @Override
    public void removeDataSet(final AccountID accountID, final PasswordCredential credential,
                              final String datasetName) {
        // Get the namespaceID of the namespace
<span class="nc" id="L1818">        final DataSetID datasetID = dataSetMgrApi.getDataSetID(datasetName);</span>

        // Validate account (ADMIN || NAMESPACE RESPONSIBLE)
        try {
<span class="nc" id="L1822">            accountMgrApi.validateAccount(accountID, credential, AccountRole.ADMIN_ROLE);</span>
<span class="nc" id="L1823">        } catch (final Exception ex) {</span>
<span class="nc" id="L1824">            checkDataSetResponsible(accountID, credential, datasetID);</span>
<span class="nc" id="L1825">        }</span>

        // Check the dataset can be removed
        // Check dataset is not related with any contract
<span class="nc bnc" id="L1829" title="All 2 branches missed.">        if (!datacontractMgrApi.checkDataSetHasNoDataContracts(datasetID)) {</span>
<span class="nc" id="L1830">            throw new DataClayRuntimeException(ERRORCODE.DATASET_WITH_DATACONTRACTS);</span>
        }
        // Check dataset has nothing
<span class="nc bnc" id="L1833" title="All 2 branches missed.">        if (!metaDataSrvApi.checkDatasetIsEmpty(datasetID)) {</span>
<span class="nc" id="L1834">            throw new DataClayRuntimeException(ERRORCODE.DATASET_NOT_EMPTY);</span>
        }

        // Remove dataset
<span class="nc" id="L1838">        dataSetMgrApi.removeDataSet(datasetID);</span>

<span class="nc" id="L1840">    }</span>

    @Override
    public DataSetID getDataSetID(final AccountID accountID, final PasswordCredential credential,
                                  final String datasetName) {
        // Validate account
<span class="nc bnc" id="L1846" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1847">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

        // Get the datasetID of the namespace
<span class="nc" id="L1851">        return dataSetMgrApi.getDataSetID(datasetName);</span>
    }

    @Override
    public boolean checkDataSetIsPublic(final DataSetID datasetID) {
<span class="nc" id="L1856">        return dataSetMgrApi.checkDataSetIsPublic(datasetID);</span>
    }

    @Override
    public Set&lt;String&gt; getPublicDataSets(final AccountID accountID, final PasswordCredential credential) {
        // Validate account
<span class="nc bnc" id="L1862" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1863">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }
<span class="nc" id="L1865">        final Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">        for (final DataSet ds : dataSetMgrApi.getPublicDataSets()) {</span>
<span class="nc" id="L1867">            result.add(ds.getName());</span>
<span class="nc" id="L1868">        }</span>
<span class="nc" id="L1869">        return result;</span>
    }

    @Override
    public Set&lt;String&gt; getAccountDataSets(final AccountID accountID, final PasswordCredential credential) {
        // Validate account
<span class="nc bnc" id="L1875" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1876">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }
<span class="nc" id="L1878">        final Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">        for (final DataSet ds : dataSetMgrApi.getAllDataSetsOfAccount(accountID)) {</span>
<span class="nc" id="L1880">            result.add(ds.getName());</span>
<span class="nc" id="L1881">        }</span>
<span class="nc" id="L1882">        return result;</span>
    }

    @Override
    public DataSetID getObjectDataSetID(final SessionID sessionID, final ObjectID oid) {
        // Check session if needed
<span class="nc" id="L1888">        SessionInfo sessionInfo = null;</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L1890">            sessionInfo = getSessionInfo(sessionID);</span>
        }

<span class="nc" id="L1893">        final MetaDataInfo metadataInfo = getObjectMetadata(oid);</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">        if (metadataInfo == null) {</span>
<span class="nc" id="L1895">            throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
        }

        // Check dataset if needed
<span class="nc bnc" id="L1899" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L1900">            checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
        }

<span class="nc" id="L1903">        return metadataInfo.getDatasetID();</span>
    }

    // ============== Class Manager ==============//

    @Override
    public Map&lt;String, MetaClass&gt; newClass(final AccountID accountID, final PasswordCredential credential,
                                           final Langs language, final Map&lt;String, MetaClass&gt; newClasses) {
<span class="nc" id="L1911">        return registerAndUpdateDependencies(accountID, credential, language, newClasses, null, null);</span>
    }

	/**
	 * Manage the class deployment (to all DataServices) of Java classes.
	 *
	 * @param allMetaClasses
	 *            all the MetaClasses related to this deployment.
	 * @param classesToDeploy
	 *            the name for all the classes which should be deployed (this should
	 *            be a subset of the previous set).
	 * @param namespaceInfos
	 *            all the namespace information of the namespaces of the classes
	 *            (although the deployment should be only on a specific one).
	 * @param enrichmentNamespaceID
	 *            NamespaceID for the enrichment when applicable.
	 * @param specificLocationOnly
	 *            Indicates only to deploy to a specific location
	 * @throws RemoteException
	 *             from the ClassManager calls, when things go wrong.
	 */
	private void outsourceClassesDeploymentJava(final Set&lt;MetaClass&gt; allMetaClasses, final Set&lt;String&gt; classesToDeploy,
			final Map&lt;NamespaceID, Namespace&gt; namespaceInfos, final NamespaceID enrichmentNamespaceID,
			final ExecutionEnvironment specificLocationOnly) {

<span class="nc" id="L1936">        final Map&lt;Tuple&lt;String, MetaClassID&gt;, byte[]&gt; bytecodes = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1937">        final Map&lt;String, byte[]&gt; aspects = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1938">        final Map&lt;String, byte[]&gt; yamls = new HashMap&lt;&gt;();</span>

<span class="nc" id="L1940">        Namespace namespaceInfo = null;</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">        if (enrichmentNamespaceID != null) {</span>
<span class="nc" id="L1942">            namespaceInfo = namespaceInfos.get(enrichmentNamespaceID);</span>

        }
<span class="nc bnc" id="L1945" title="All 2 branches missed.">        for (final MetaClass curMetaClass : allMetaClasses) {</span>
<span class="nc" id="L1946">            final String className = curMetaClass.getName();</span>
<span class="nc" id="L1947">            final MetaClassID classID = curMetaClass.getDataClayID();</span>
<span class="nc bnc" id="L1948" title="All 2 branches missed.">            if (classesToDeploy.contains(curMetaClass.getName())) {</span>

<span class="nc bnc" id="L1950" title="All 2 branches missed.">                if (namespaceInfo == null) {</span>
                    // WARNING!!!! Precondition: all classes belongs to the same namespace
<span class="nc" id="L1952">                    namespaceInfo = namespaceInfos.get(curMetaClass.getNamespaceID());</span>
                }
                /*
                 * Get the execution class for Java
                 */
<span class="nc" id="L1957">                final Tuple&lt;byte[], byte[]&gt; classAndAspectsToDeploy = classMgrApi</span>
<span class="nc" id="L1958">                        .generateJavaExecutionClass(curMetaClass);</span>
<span class="nc" id="L1959">                bytecodes.put(new Tuple&lt;&gt;(className, classID), classAndAspectsToDeploy.getFirst());</span>
<span class="nc" id="L1960">                aspects.put(className, classAndAspectsToDeploy.getSecond());</span>
                // Yamls
<span class="nc" id="L1962">                final StubInfo execStubInfo = this.getStubInfoForExecutionClass(curMetaClass.getDataClayID());</span>
<span class="nc" id="L1963">                final Yaml yaml = CommonYAML.getYamlObject();</span>
<span class="nc" id="L1964">                final String yamlStr = yaml.dump(execStubInfo);</span>
<span class="nc" id="L1965">                yamls.put(className, yamlStr.getBytes());</span>
            }
<span class="nc" id="L1967">        }</span>

		// First deploy the class at the adequate Execution Environments
<span class="nc bnc" id="L1970" title="All 2 branches missed.">		if (specificLocationOnly == null) {</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">			for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_JAVA).values()) {</span>
<span class="nc" id="L1972">				LOGGER.debug(&quot;Sending classes to {}&quot;, elem.getSecond());</span>
<span class="nc" id="L1973">				elem.getFirst().deployClasses(namespaceInfo.getName(), bytecodes, aspects, yamls);</span>
<span class="nc" id="L1974">			}</span>
		} else {
<span class="nc" id="L1976">			final DataServiceAPI elem = getExecutionEnvironments(Langs.LANG_JAVA).get(specificLocationOnly.getDataClayID()).getFirst();</span>
<span class="nc" id="L1977">			LOGGER.debug(&quot;Sending classes to {}&quot;, specificLocationOnly);</span>
<span class="nc" id="L1978">			elem.deployClasses(namespaceInfo.getName(), bytecodes, aspects, yamls);</span>
		}
<span class="nc" id="L1980">	}</span>

	/**
	 * Manage the class deployment (to all DataServices) of Java classes.
	 *
	 * @param allMetaClasses
	 *            all the MetaClasses related to this deployment.
	 * @param classesToDeploy
	 *            the name for all the classes which should be deployed (this should
	 *            be a subset of the previous set).
	 * @param namespaceInfos
	 *            all the namespace information of the namespaces of the classes
	 *            (although the deployment should be only on a specific one).
	 * @param enrichmentNamespaceID
	 *            NamespaceID for the enrichment when applicable.
	 * @param specificEnvironmentOnly
	 *            specific environment if required (optional)
	 *
	 * @throws RemoteException
	 *             from the ClassManager calls, when things go wrong.
	 */
	private void outsourceClassesDeploymentPython(final Set&lt;MetaClass&gt; allMetaClasses,
			final Set&lt;String&gt; classesToDeploy, final Map&lt;NamespaceID, Namespace&gt; namespaceInfos,
			final NamespaceID enrichmentNamespaceID, final ExecutionEnvironment specificEnvironmentOnly) {

<span class="nc" id="L2005">        final Map&lt;String, MetaClass&gt; deploymentPack = new HashMap&lt;&gt;();</span>

<span class="nc" id="L2007">        Namespace namespaceInfo = null;</span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">        if (enrichmentNamespaceID != null) {</span>
<span class="nc" id="L2009">            namespaceInfo = namespaceInfos.get(enrichmentNamespaceID);</span>
        }

<span class="nc bnc" id="L2012" title="All 2 branches missed.">        for (final MetaClass curMetaClass : allMetaClasses) {</span>
<span class="nc" id="L2013">            final String className = curMetaClass.getName();</span>
<span class="nc bnc" id="L2014" title="All 2 branches missed.">            if (classesToDeploy.contains(curMetaClass.getName())) {</span>

<span class="nc bnc" id="L2016" title="All 2 branches missed.">                if (namespaceInfo == null) {</span>
                    // WARNING!!!! Precondition: all classes belongs to the same namespace
<span class="nc" id="L2018">                    namespaceInfo = namespaceInfos.get(curMetaClass.getNamespaceID());</span>
                }

<span class="nc" id="L2021">				deploymentPack.put(className, curMetaClass);</span>
			}
<span class="nc" id="L2023">		}</span>
<span class="nc bnc" id="L2024" title="All 2 branches missed.">		if (specificEnvironmentOnly == null) {</span>
			// First deploy the classes at the adequate Execution Environments
<span class="nc bnc" id="L2026" title="All 2 branches missed.">			for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_PYTHON).values()) {</span>
<span class="nc" id="L2027">				LOGGER.debug(&quot;Sending classes to {}&quot;, elem.getFirst());</span>
<span class="nc" id="L2028">				elem.getFirst().deployMetaClasses(namespaceInfo.getName(), deploymentPack);</span>
<span class="nc" id="L2029">			}</span>
		} else {
<span class="nc" id="L2031">			final DataServiceAPI elem = getExecutionEnvironments(Langs.LANG_PYTHON).get(specificEnvironmentOnly.getDataClayID()).getFirst();</span>
<span class="nc" id="L2032">			LOGGER.debug(&quot;Sending classes to {}&quot;, specificEnvironmentOnly);</span>
<span class="nc" id="L2033">			elem.deployMetaClasses(namespaceInfo.getName(), deploymentPack);</span>
		}
<span class="nc" id="L2035">	}</span>

    /**
     * This internal operation recursively registers all the required dependencies
     * of a metaClass to be usable.
     *
     * @param accountID
     *            ID of the account of the user that calls the operation
     * @param credentials
     *            Credentials of the account provided
     * @param language
     *            Language of the classes provided
     * @param metaClasses
     *            ifications of classes to create
     * @param enrichmentNamespaceID
     *            ID of the Namespace of the enrichment (can be NULL)
     * @param enrichedClassName
     *            if we are executing the method from en enrichment process, the
     *            name of the enriched class
     *
     * @return the id or information of the new metaclass if the operation succeeds.
     *         null otherwise.
     * @throws RemoteException
     *             if some exception occurs
     */
    public Map&lt;String, MetaClass&gt; registerAndUpdateDependencies(final AccountID accountID,
                                                                final PasswordCredential credentials, final Langs language, final Map&lt;String, MetaClass&gt; metaClasses,
                                                                final NamespaceID enrichmentNamespaceID, final String enrichedClassName) {

        // IDs structures
<span class="nc" id="L2065">        final Map&lt;String, MetaClassID&gt; classIDsSet = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2066">        final Map&lt;String, PropertyID&gt; propIDsSet = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2067">        final Map&lt;String, ImplementationID&gt; implIDsSet = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2068">        final Map&lt;String, MetaClass&gt; infoOfRegisteredClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2069">        final Set&lt;String&gt; createdClasses = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2070">        final Map&lt;NamespaceID, Namespace&gt; namespaceInfos = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L2072" title="All 2 branches missed.">        for (final MetaClass curMetaClass : metaClasses.values()) {</span>

<span class="nc" id="L2074">            final String namespace = curMetaClass.getNamespace();</span>
<span class="nc" id="L2075">            final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L2076">            final Namespace namespaceInfo = namespaceMgrApi.getNamespaceInfo(namespaceID);</span>
            // TODO: Check namespace responsible or imports
<span class="nc" id="L2078">            namespaceInfos.put(namespaceID, namespaceInfo);</span>
<span class="nc" id="L2079">        }</span>

<span class="nc bnc" id="L2081" title="All 2 branches missed.">        if (enrichmentNamespaceID != null) {</span>
<span class="nc" id="L2082">            final Namespace namespaceInfo = checkNamespaceResponsible(accountID, credentials, enrichmentNamespaceID);</span>
<span class="nc" id="L2083">            namespaceInfos.put(enrichmentNamespaceID, namespaceInfo);</span>
        }

        // ===================================================== //
        // ====== CHECK CLASSES THAT EXISTS AND SET IDS ======== //
        // ===================================================== //

<span class="nc" id="L2090">        final Set&lt;MetaClass&gt; metaClassesToInstall = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2091" title="All 2 branches missed.">        for (final MetaClass curMetaClass : metaClasses.values()) {</span>
<span class="nc" id="L2092">            final String namespace = curMetaClass.getNamespace();</span>
<span class="nc" id="L2093">            final String signature = Reflector.getSignatureFromTypeName(curMetaClass.getName());</span>
<span class="nc" id="L2094">            final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L2095">            MetaClassID classID = null;</span>

<span class="nc" id="L2097">            final UserType uType = new UserType(namespace, curMetaClass.getName(), signature, signature, null);</span>
<span class="nc" id="L2098">            final boolean typeExists = checkTypeIsRegistered(accountID, credentials, uType);</span>

<span class="nc bnc" id="L2100" title="All 4 branches missed.">            if (enrichedClassName != null &amp;&amp; curMetaClass.getName().equals(enrichedClassName)) {</span>
                // =================== ENRICHMENT SET IDS ====================== //

                // GET IDS OF THE CLASS (in case it is accessed)
<span class="nc" id="L2104">                classID = classMgrApi.getMetaClassID(namespaceID, enrichedClassName);</span>
<span class="nc" id="L2105">                getIDsOfAlreadyRegisteredClass(accountID, credentials, namespaceID, curMetaClass, classIDsSet,</span>
                        propIDsSet, implIDsSet, classID);

                // Set IDs
                // GENERATE IDS FOR PROPERTIES AND IMPLEMENTATIONS OF THE CLASS TO REGISTER
<span class="nc" id="L2110">                generateIDsToRegister(curMetaClass, propIDsSet, implIDsSet, namespaceInfos, classID, namespaceID,</span>
                        accountID);
<span class="nc" id="L2112">                metaClassesToInstall.add(curMetaClass);</span>

<span class="nc bnc" id="L2114" title="All 2 branches missed.">            } else if (!typeExists) {</span>

                // =================== NEW CLASS ====================== //

                // Set ClassID
<span class="nc" id="L2119">                classID = new MetaClassID();</span>
<span class="nc" id="L2120">                curMetaClass.setDataClayID(classID);</span>
<span class="nc" id="L2121">                classIDsSet.put(curMetaClass.getNamespace() + &quot;$&quot; + curMetaClass.getName(), classID);</span>
                // GENERATE IDS FOR PROPERTIES AND IMPLEMENTATIONS OF THE CLASS TO REGISTER
<span class="nc" id="L2123">                generateIDsToRegister(curMetaClass, propIDsSet, implIDsSet, namespaceInfos, classID, namespaceID,</span>
                        accountID);
<span class="nc" id="L2125">                metaClassesToInstall.add(curMetaClass);</span>

            } else {
                // =================== ALREADY EXISTANT CLASS GET IDS ====================== //

                // GET IDS OF THE CLASS (in case it is accessed)
<span class="nc" id="L2131">                classID = classMgrApi.getMetaClassID(namespaceID, curMetaClass.getName());</span>
<span class="nc" id="L2132">                getIDsOfAlreadyRegisteredClass(accountID, credentials, namespaceID, curMetaClass, classIDsSet,</span>
                        propIDsSet, implIDsSet, classID);
            }
<span class="nc" id="L2135">        }</span>

<span class="nc bnc" id="L2137" title="All 2 branches missed.">        for (final MetaClass curMetaClass : metaClassesToInstall) {</span>
            // Set ClassID of all associated metaclass
            // Also set PropertyIDs and ImplementationIDs for accessed props and impls
<span class="nc" id="L2140">            setIDs(accountID, credentials, curMetaClass, classIDsSet, propIDsSet, implIDsSet, language);</span>
<span class="nc" id="L2141">        }</span>

<span class="nc bnc" id="L2143" title="All 2 branches missed.">        for (final MetaClass curMetaClass : metaClassesToInstall) {</span>
<span class="nc" id="L2144">            final NamespaceID namespaceID = curMetaClass.getNamespaceID();</span>
            // Update with classIDs dependencies
<span class="nc" id="L2146">            updateDependencies(curMetaClass, classIDsSet, propIDsSet, implIDsSet, language);</span>
<span class="nc bnc" id="L2147" title="All 4 branches missed.">            if (enrichedClassName == null</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">                    || (enrichedClassName != null &amp;&amp; !curMetaClass.getName().equals(enrichedClassName))) {</span>

                // Register class
<span class="nc" id="L2151">                final MetaClass curInfo = newClassInternal(accountID, credentials, namespaceID, curMetaClass,</span>
<span class="nc" id="L2152">                        namespaceInfos.get(namespaceID), language);</span>
<span class="nc" id="L2153">                infoOfRegisteredClasses.put(curInfo.getName(), curInfo);</span>
<span class="nc" id="L2154">                createdClasses.add(curInfo.getName());</span>
            }
<span class="nc" id="L2156">        }</span>

<span class="nc bnc" id="L2158" title="All 2 branches missed.">        if (createdClasses.size() &gt; 0) {</span>
            // There are classes to deploy
<span class="nc bnc" id="L2160" title="All 2 branches missed.">            if (language == Langs.LANG_JAVA) {</span>
<span class="nc" id="L2161">                outsourceClassesDeploymentJava(metaClassesToInstall, createdClasses, namespaceInfos,</span>
                        enrichmentNamespaceID, null);

                // outsourceClassesDeploymentPython(metaClassesToInstall, createdClasses,
                // namespaceInfos, enrichmentNamespaceID,
                // null);

<span class="nc bnc" id="L2168" title="All 2 branches missed.">            } else if (language == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L2169">                outsourceClassesDeploymentPython(metaClassesToInstall, createdClasses, namespaceInfos,</span>
                        enrichmentNamespaceID, null);
                // @TODO: real cross-language in both directions
                // outsourceClassesDeploymentJava(languagelessMetaClassesToInstall,
                // createdClasses, namespaceInfos, enrichmentNamespaceID, null);
            } // else {
            // WARNING
            // IGNORE it: used for outsource of classes without language
            // throw new DataClayRuntimeException(ERRORCODE.CLASS_UNSUPPORTED_LANGUAGE,
            // &quot;The provided class' language is not supported for registration&quot;);
            // }
        }

        // ===================================================== //
        // ====== SET ECAS IDS ======== //
        // ===================================================== //
<span class="nc bnc" id="L2185" title="All 2 branches missed.">        if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc bnc" id="L2186" title="All 2 branches missed.">            for (final MetaClass curMetaClass : metaClassesToInstall) {</span>
<span class="nc" id="L2187">                final List&lt;ECA&gt; ecas = curMetaClass.getEcas();</span>
<span class="nc bnc" id="L2188" title="All 2 branches missed.">                if (ecas == null) {</span>
<span class="nc" id="L2189">                    continue;</span>
                }
<span class="nc bnc" id="L2191" title="All 2 branches missed.">                for (final ECA eca : ecas) {</span>
<span class="nc" id="L2192">                    final EventType evType = eca.getEventType();</span>

                    // Initialize IDs
<span class="nc" id="L2195">                    evType.init(accountID, credentials, curMetaClass.getNamespace(), this);</span>

                    // Set operationIDs of filter and action
<span class="nc bnc" id="L2198" title="All 2 branches missed.">                    if (eca.getFilterMethodSignature() != null) {</span>
<span class="nc" id="L2199">                        final OperationID filterOpID = classMgrApi.getOperationID(curMetaClass.getDataClayID(),</span>
<span class="nc" id="L2200">                                eca.getFilterMethodSignature());</span>
<span class="nc" id="L2201">                        eca.setFilterMethod(filterOpID);</span>
                    }

<span class="nc bnc" id="L2204" title="All 2 branches missed.">                    if (eca.getActionSignature() == null) {</span>
<span class="nc" id="L2205">                        throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                                &quot;ECA action signature cannot be null&quot;, false);
                    }

<span class="nc" id="L2209">                    final OperationID actionOpID = classMgrApi.getOperationID(curMetaClass.getDataClayID(),</span>
<span class="nc" id="L2210">                            eca.getActionSignature());</span>
<span class="nc" id="L2211">                    eca.setAction(actionOpID);</span>

                    // Set target class: the same used in new class
<span class="nc" id="L2214">                    eca.setTargetClass(curMetaClass.getDataClayID());</span>

                    // Now Register ECA
<span class="nc" id="L2217">                    this.registerEventListenerImplementation(accountID, credentials, eca);</span>

<span class="nc" id="L2219">                }</span>
<span class="nc" id="L2220">            }</span>
        }

        /******** RT: Store Prefetching Info ********/
<span class="nc" id="L2224">        return infoOfRegisteredClasses;</span>
    }

    /**
     * Generate IDs of properties, implementations, namespaces to register
     *
     * @param curMetaClass
     *            MetaClass to process
     * @param propIDsSet
     *            Currently set PropertyIDs (for enrichments)
     * @param implIDsSet
     *            Currently set ImplementationIDs (for enrichments)
     * @param namespaceInfos
     *            Information of namespaces of the classes to install
     * @param classID
     *            ID of the class to set
     * @param namespaceID
     *            ID of the namespace to set
     * @param accountID
     *            ID of the account
     */
    private void generateIDsToRegister(final MetaClass curMetaClass, final Map&lt;String, PropertyID&gt; propIDsSet,
                                       final Map&lt;String, ImplementationID&gt; implIDsSet, final Map&lt;NamespaceID, Namespace&gt; namespaceInfos,
                                       final MetaClassID classID, final NamespaceID namespaceID, final AccountID accountID) {
<span class="nc bnc" id="L2248" title="All 2 branches missed.">        for (final Property property : curMetaClass.getProperties()) {</span>

<span class="nc" id="L2250">            final String propNamespace = property.getNamespace();</span>
<span class="nc" id="L2251">            final NamespaceID propNamespaceID = namespaceMgrApi.getNamespaceID(propNamespace);</span>
<span class="nc" id="L2252">            property.setNamespaceID(propNamespaceID);</span>
<span class="nc" id="L2253">            property.setMetaClassID(classID);</span>
<span class="nc" id="L2254">            property.setDataClayID(new PropertyID());</span>

<span class="nc" id="L2256">            final String key = propNamespace + &quot;$&quot; + curMetaClass.getName() + &quot;$&quot; + property.getName();</span>
<span class="nc bnc" id="L2257" title="All 2 branches missed.">            if (!propIDsSet.containsKey(key)) {</span>
                // For accessed props
<span class="nc" id="L2259">                propIDsSet.put(key, property.getDataClayID());</span>
            }

<span class="nc" id="L2262">        }</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">        for (final Operation operation : curMetaClass.getOperations()) {</span>
            // Set IDs
<span class="nc" id="L2265">            operation.setDataClayID(new OperationID());</span>
<span class="nc" id="L2266">            final String opNamespace = operation.getNamespace();</span>
<span class="nc" id="L2267">            final NamespaceID opNamespaceID = namespaceMgrApi.getNamespaceID(opNamespace);</span>
<span class="nc" id="L2268">            operation.setNamespaceID(opNamespaceID);</span>

<span class="nc bnc" id="L2270" title="All 2 branches missed.">            for (final Implementation implementation : operation.getImplementations()) {</span>

<span class="nc" id="L2272">                final String implNamespace = implementation.getNamespace();</span>
<span class="nc" id="L2273">                final NamespaceID implNamespaceID = namespaceMgrApi.getNamespaceID(implNamespace);</span>
<span class="nc" id="L2274">                implementation.setNamespaceID(implNamespaceID);</span>
<span class="nc" id="L2275">                implementation.setDataClayID(new ImplementationID());</span>
<span class="nc" id="L2276">                implementation.setOperationID(operation.getDataClayID());</span>
<span class="nc" id="L2277">                implementation.setResponsibleAccountID(accountID);</span>
<span class="nc" id="L2278">                implementation.setMetaClassID(classID);</span>
<span class="nc" id="L2279">                final String key = implementation.getNamespace() + &quot;$&quot; + implementation.getClassName() + &quot;$&quot;</span>
<span class="nc" id="L2280">                        + implementation.getOpNameAndDescriptor() + &quot;$&quot; + implementation.getPosition();</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">                if (!implIDsSet.containsKey(key)) {</span>
                    // For accessed impls
<span class="nc" id="L2283">                    implIDsSet.put(key, implementation.getDataClayID());</span>
                }

<span class="nc" id="L2286">            }</span>
<span class="nc" id="L2287">            operation.setMetaClassID(classID);</span>
<span class="nc" id="L2288">        }</span>
<span class="nc" id="L2289">        curMetaClass.setNamespaceID(namespaceID);</span>
<span class="nc" id="L2290">        curMetaClass.setNamespace(namespaceInfos.get(namespaceID).getName());</span>
<span class="nc" id="L2291">    }</span>

    /**
     * Set the Class IDs of all included types to register recursively
     *
     * @param accountID
     *            ID of the account of the user that calls the operation
     * @param credentials
     *            Credentials of the account provided
     * @param metaClass
     *            Current class spec
     * @param classIDsSet
     *            IDs of the classes
     * @param propsIDsSet
     *            Map of PropertyIDs by className + PropertyName. Used to set
     *            accessed properties.
     * @param implsIDsSet
     *            Map of ImplementationIDs by className + opName. Used to set
     *            accessed implementations.
     * @param language
     *            Language of the classes to register
     * @throws RemoteException
     *             if some exception occurs
     */
    private void setIDs(final AccountID accountID, final PasswordCredential credentials, final MetaClass metaClass,
                        final Map&lt;String, MetaClassID&gt; classIDsSet, final Map&lt;String, PropertyID&gt; propsIDsSet,
                        final Map&lt;String, ImplementationID&gt; implsIDsSet, final Langs language) {

        // =================================== //
        // ==== GET ALREADY INSTALLED IDS ==== //
        // =================================== //

        // ================ GET IDS FOR CLASSES ASSOCIATED TO ATTRIBUTES =============
        // //
<span class="nc bnc" id="L2325" title="All 2 branches missed.">        for (final Property property : metaClass.getProperties()) {</span>
<span class="nc" id="L2326">            checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet, propsIDsSet,</span>
<span class="nc" id="L2327">                    implsIDsSet, property.getType(), language);</span>

            // ================ PROPERTY INCLUDES TYPES ============= //
<span class="nc bnc" id="L2330" title="All 2 branches missed.">            if (property.getType().getIncludes() != null) {</span>
<span class="nc bnc" id="L2331" title="All 2 branches missed.">                for (final Type subincludeType : property.getType().getIncludes()) {</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">                    if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2333">                        checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
                                propsIDsSet, implsIDsSet, subincludeType, language);
                    }
<span class="nc" id="L2336">                }</span>
            }

<span class="nc" id="L2339">        }</span>
        // ================ GET IDS FOR CLASSES ASSOCIATED TO METHODS ============= //
<span class="nc bnc" id="L2341" title="All 2 branches missed.">        for (final Operation operation : metaClass.getOperations()) {</span>

            // ================ RETURN TYPE ============= //
<span class="nc" id="L2344">            final Type returnType = operation.getReturnType();</span>
<span class="nc bnc" id="L2345" title="All 2 branches missed.">            if (returnType instanceof UserType) {</span>
<span class="nc" id="L2346">                checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet, propsIDsSet,</span>
                        implsIDsSet, returnType, language);
            }
<span class="nc bnc" id="L2349" title="All 2 branches missed.">            if (returnType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2350" title="All 2 branches missed.">                for (final Type subincludeType : returnType.getIncludes()) {</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">                    if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2352">                        checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
                                propsIDsSet, implsIDsSet, subincludeType, language);
                    }
<span class="nc" id="L2355">                }</span>
            }

            // ================ PARAMETER TYPES ============= //
<span class="nc bnc" id="L2359" title="All 2 branches missed.">            for (final Type paramType : operation.getParams().values()) {</span>
<span class="nc bnc" id="L2360" title="All 2 branches missed.">                if (paramType instanceof UserType) {</span>
<span class="nc" id="L2361">                    checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet, propsIDsSet,</span>
                            implsIDsSet, paramType, language);
                }
<span class="nc bnc" id="L2364" title="All 2 branches missed.">                if (paramType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">                    for (final Type subincludeType : paramType.getIncludes()) {</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">                        if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2367">                            checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
                                    propsIDsSet, implsIDsSet, subincludeType, language);
                        }
<span class="nc" id="L2370">                    }</span>
                }
<span class="nc" id="L2372">            }</span>

<span class="nc bnc" id="L2374" title="All 2 branches missed.">            for (final Implementation impl : operation.getImplementations()) {</span>
                // ================ IMPLEMENTATION INCLUDES TYPES ============= //
<span class="nc bnc" id="L2376" title="All 2 branches missed.">                for (final Type includeType : impl.getIncludes()) {</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">                    if (includeType instanceof UserType) {</span>
<span class="nc" id="L2378">                        checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
                                propsIDsSet, implsIDsSet, includeType, language);
                    }
<span class="nc bnc" id="L2381" title="All 2 branches missed.">                    if (includeType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">                        for (final Type subincludeType : includeType.getIncludes()) {</span>
<span class="nc bnc" id="L2383" title="All 2 branches missed.">                            if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2384">                                checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
                                        propsIDsSet, implsIDsSet, subincludeType, language);
                            }
<span class="nc" id="L2387">                        }</span>
                    }
<span class="nc" id="L2389">                }</span>

                // TODO: (LASTTODO) check accessed properties types
<span class="nc bnc" id="L2392" title="All 2 branches missed.">                for (final AccessedProperty accProperty : impl.getAccessedProperties()) {</span>
<span class="nc" id="L2393">                    final String typeName = accProperty.getClassName();</span>
<span class="nc" id="L2394">                    final String signature = Reflector.getSignatureFromTypeName(typeName);</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">                    final boolean isUserType = !Reflector.isJavaPrimitiveOrArraySignature(signature);</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">                    if (isUserType) {</span>
<span class="nc" id="L2397">                        final Type accType = new UserType(accProperty.getNamespace(), typeName, signature, signature,</span>
                                null);
<span class="nc" id="L2399">                        checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
                                propsIDsSet, implsIDsSet, accType, language);
                    }
<span class="nc" id="L2402">                }</span>

<span class="nc bnc" id="L2404" title="All 2 branches missed.">                for (final AccessedImplementation accImpl : impl.getAccessedImplementations()) {</span>
<span class="nc" id="L2405">                    final String typeName = accImpl.getClassName();</span>
<span class="nc" id="L2406">                    final String signature = Reflector.getSignatureFromTypeName(typeName);</span>
<span class="nc bnc" id="L2407" title="All 2 branches missed.">                    final boolean isUserType = !Reflector.isJavaPrimitiveOrArraySignature(signature);</span>
<span class="nc bnc" id="L2408" title="All 2 branches missed.">                    if (isUserType) {</span>
<span class="nc" id="L2409">                        final Type accType = new UserType(accImpl.getNamespace(), typeName, signature, signature, null);</span>
                        // JavaConstantSignature sig = new JavaConstantSignature(signature);
                        // JavaTypeInfo jTypeInfo = new JavaTypeInfo(sig);
                        // accType.addLanguageDepInfo(jTypeInfo);
<span class="nc" id="L2413">                        checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
                                propsIDsSet, implsIDsSet, accType, language);
                    }
<span class="nc" id="L2416">                }</span>

                // ==== PREFETCHING INFO === //
<span class="nc bnc" id="L2419" title="All 4 branches missed.">                if (impl.getPrefetchingInfo() != null &amp;&amp; impl.getPrefetchingInfo().getInjectPrefetchingCall()) {</span>
<span class="nc" id="L2420">                    final String typeName = impl.getClassName();</span>
<span class="nc" id="L2421">                    final String signature = Reflector.getSignatureFromTypeName(typeName);</span>
<span class="nc" id="L2422">                    final Type accType = new UserType(impl.getNamespace(), typeName, signature, signature, null);</span>

<span class="nc" id="L2424">                    checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet, propsIDsSet,</span>
                            implsIDsSet, accType, language);

                }

<span class="nc" id="L2429">            }</span>
<span class="nc" id="L2430">        }</span>

<span class="nc" id="L2432">    }</span>

    /**
     * Recursively get the IDs of an already registered class (operationIDs,
     * propertyIDs, ...)
     *
     * @param accountID
     *            ID of the account registering the class that imports this class
     * @param credentials
     *            Credentials fo the account
     * @param namespaceID
     *            ID of the namespace in which the class is being registered
     * @param metaClass
     *            s of the class to register
     * @param classIDsSet
     *            Structure of imported class ids
     * @param propsIDsSet
     *            IDs of properties
     * @param implsIDsSet
     *            IDs of implementations
     * @param classID
     *            ID of the already registered class
     * @throws RemoteException
     *             if some exception occurs
     */
    private void getIDsOfAlreadyRegisteredClass(final AccountID accountID, final PasswordCredential credentials,
                                                final NamespaceID namespaceID, final MetaClass metaClass, final Map&lt;String, MetaClassID&gt; classIDsSet,
                                                final Map&lt;String, PropertyID&gt; propsIDsSet, final Map&lt;String, ImplementationID&gt; implsIDsSet,
                                                final MetaClassID classID) {
        // If already processed
<span class="nc bnc" id="L2462" title="All 2 branches missed.">        if (classIDsSet.containsValue(classID)) {</span>
<span class="nc" id="L2463">            return;</span>
        }
        // Get PropertyIDs and ImplementationIDs
<span class="nc" id="L2466">        final MetaClass classInfo = classMgrApi.getClassInfo(classID);</span>
<span class="nc" id="L2467">        final String className = classInfo.getName();</span>

        // Modify the ID
<span class="nc" id="L2470">        classIDsSet.put(classInfo.getNamespace() + &quot;$&quot; + className, classID);</span>

        // Get ImplementationIDs
<span class="nc bnc" id="L2473" title="All 2 branches missed.">        for (final Operation opInfo : classInfo.getOperations()) {</span>
<span class="nc bnc" id="L2474" title="All 2 branches missed.">            for (final Implementation implInfo : opInfo.getImplementations()) {</span>
<span class="nc" id="L2475">                implsIDsSet.put(</span>
<span class="nc" id="L2476">                        implInfo.getNamespace() + &quot;$&quot; + implInfo.getClassName() + &quot;$&quot;</span>
<span class="nc" id="L2477">                                + implInfo.getOpNameAndDescriptor() + &quot;$&quot; + implInfo.getPosition(),</span>
<span class="nc" id="L2478">                        implInfo.getDataClayID());</span>
<span class="nc" id="L2479">            }</span>
<span class="nc" id="L2480">        }</span>
        // Get PropertyIDs
<span class="nc bnc" id="L2482" title="All 2 branches missed.">        for (final Property propInfo : classInfo.getProperties()) {</span>
<span class="nc" id="L2483">            propsIDsSet.put(propInfo.getNamespace() + &quot;$&quot; + propInfo.getClassName() + &quot;$&quot; + propInfo.getName(),</span>
<span class="nc" id="L2484">                    propInfo.getDataClayID());</span>

<span class="nc" id="L2486">            final MetaClassID propclassID = classMgrApi.getClassIDFromProperty(propInfo.getDataClayID());</span>
            // If classID is null it is not a user type property
<span class="nc bnc" id="L2488" title="All 2 branches missed.">            if (propclassID != null) {</span>
                // If not already checked
<span class="nc" id="L2490">                getIDsOfAlreadyRegisteredClass(accountID, credentials, namespaceID, metaClass, classIDsSet, propsIDsSet,</span>
                        implsIDsSet, propclassID);

            }
<span class="nc" id="L2494">        }</span>
<span class="nc" id="L2495">    }</span>

    /**
     * Check if specification provided is an already registered class and in case it
     * is, get the IDs (operationIDs, propertyIDs, ...)
     *
     * @param accountID
     *            ID of the account registering the class that imports this class
     * @param credentials
     *            Credentials fo the account
     * @param metaClass
     *            s of the class to register
     * @param classIDsSet
     *            Structure of imported class ids
     * @param propsIDsSet
     *            IDs of properties
     * @param implsIDsSet
     *            IDs of implementations
     * @param type
     *            ification of the already registered class
     * @param language
     *            Language of the new classes
     * @throws RemoteException
     *             if some exception occurs
     */
    private void checkClassIsAlreadyRegisteredAndGetID(final AccountID accountID, final PasswordCredential credentials,
                                                       final MetaClass metaClass, final Map&lt;String, MetaClassID&gt; classIDsSet,
                                                       final Map&lt;String, PropertyID&gt; propsIDsSet, final Map&lt;String, ImplementationID&gt; implsIDsSet, final Type type,
                                                       final Langs language) {
        // If type specification already contains Class ID, do not check.
<span class="nc bnc" id="L2525" title="All 2 branches missed.">        if (type instanceof UserType) {</span>
<span class="nc" id="L2526">            final UserType uType = (UserType) type;</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">            if (uType.getClassID() != null) {</span>
<span class="nc" id="L2528">                return;</span>
            }
<span class="nc" id="L2530">            final boolean typeExists = checkTypeIsRegistered(accountID, credentials, uType);</span>
            // CHECKSTYLE:ON
<span class="nc bnc" id="L2532" title="All 2 branches missed.">            if (typeExists) {</span>
                // GET IDS OF THE CLASS (in case it is accessed)
<span class="nc bnc" id="L2534" title="All 2 branches missed.">                if (type instanceof UserType) {</span>
<span class="nc" id="L2535">                    final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(uType.getNamespace());</span>
<span class="nc" id="L2536">                    MetaClassID classID = classMgrApi.getMetaClassID(namespaceID, uType.getTypeName());</span>
<span class="nc bnc" id="L2537" title="All 2 branches missed.">                    if (classID == null) {</span>
                        // if class manager cannot obtain the class id in namespaceID check imports
<span class="nc" id="L2539">                        final Set&lt;ImportedInterface&gt; importedInterfaces = namespaceMgrApi</span>
<span class="nc" id="L2540">                                .getImportedInterfaces(namespaceID, uType.getTypeName());</span>
<span class="nc" id="L2541">                        classID = importedInterfaces.iterator().next().getClassOfImportID();</span>
                    }

<span class="nc" id="L2544">                    getIDsOfAlreadyRegisteredClass(accountID, credentials, namespaceID, metaClass, classIDsSet,</span>
                            propsIDsSet, implsIDsSet, classID);
<span class="nc" id="L2546">                }</span>
            } else {
<span class="nc" id="L2548">                LOGGER.trace(&quot;Class {} is not registered&quot;, type.getTypeName());</span>
<span class="nc" id="L2549">                return;</span>
            }
        }
<span class="nc" id="L2552">    }</span>

    /**
     * Method that updates the dependencies of types with the corresponding classIDs
     *
     * @param metaClass
     *            the spec to be updated
     * @param newClassIDs
     *            the IDs to be used
     * @param propsIDsSet
     *            Map of PropertyIDs by className + PropertyName. Used to set
     *            accessed properties.
     * @param implsIDsSet
     *            Map of ImplementationIDs by className + opName. Used to set
     *            accessed implementations.
     * @param language
     *            Language of the class
     */
    private void updateDependencies(final MetaClass metaClass, final Map&lt;String, MetaClassID&gt; newClassIDs,
                                    final Map&lt;String, PropertyID&gt; propsIDsSet, final Map&lt;String, ImplementationID&gt; implsIDsSet,
                                    final Langs language) {

        // Update properties
<span class="nc bnc" id="L2575" title="All 2 branches missed.">        for (final Property property : metaClass.getProperties()) {</span>
<span class="nc" id="L2576">            final Type propertyType = property.getType();</span>
<span class="nc bnc" id="L2577" title="All 2 branches missed.">            if (propertyType instanceof UserType) {</span>
<span class="nc" id="L2578">                final UserType uType = (UserType) propertyType;</span>
<span class="nc bnc" id="L2579" title="All 2 branches missed.">                if (uType.getClassID() == null) {</span>
<span class="nc" id="L2580">                    final String typename = uType.getTypeName();</span>
<span class="nc" id="L2581">                    final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                    if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2583">                        LOGGER.error(&quot;Unable to find property type {}${} in class ids structure&quot;, typenamespace,</span>
                                typename);
                    }
<span class="nc" id="L2586">                    uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                }
            }

<span class="nc bnc" id="L2590" title="All 2 branches missed.">            if (propertyType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2591" title="All 2 branches missed.">                for (final Type includeType : propertyType.getIncludes()) {</span>
<span class="nc bnc" id="L2592" title="All 2 branches missed.">                    if (includeType instanceof UserType) {</span>
<span class="nc" id="L2593">                        final UserType uType = (UserType) includeType;</span>
<span class="nc bnc" id="L2594" title="All 2 branches missed.">                        if (uType.getClassID() == null) {</span>
<span class="nc" id="L2595">                            final String typename = uType.getTypeName();</span>
<span class="nc" id="L2596">                            final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">                            if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2598">                                LOGGER.error(&quot;Unable to find property includes type {}${} in class ids structure&quot;,</span>
                                        typenamespace, typename);
                            }
<span class="nc" id="L2601">                            uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                        }
                    }
<span class="nc" id="L2604">                }</span>
            }
<span class="nc" id="L2606">        }</span>

        // Update operations
<span class="nc bnc" id="L2609" title="All 2 branches missed.">        for (final Operation operation : metaClass.getOperations()) {</span>
<span class="nc" id="L2610">            final Type returnType = operation.getReturnType();</span>
<span class="nc bnc" id="L2611" title="All 2 branches missed.">            if (returnType instanceof UserType) {</span>
<span class="nc" id="L2612">                final UserType uType = (UserType) returnType;</span>

<span class="nc bnc" id="L2614" title="All 2 branches missed.">                if (uType.getClassID() == null) {</span>
<span class="nc" id="L2615">                    final String typename = uType.getTypeName();</span>
<span class="nc" id="L2616">                    final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2617" title="All 2 branches missed.">                    if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2618">                        LOGGER.error(&quot;Unable to find operation return type {}${} in class ids structure&quot;, typenamespace,</span>
                                typename);
                    }
<span class="nc" id="L2621">                    uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                }
            }
<span class="nc bnc" id="L2624" title="All 2 branches missed.">            if (returnType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">                for (final Type includeType : returnType.getIncludes()) {</span>
<span class="nc bnc" id="L2626" title="All 2 branches missed.">                    if (includeType instanceof UserType) {</span>
<span class="nc" id="L2627">                        final UserType uType = (UserType) includeType;</span>
<span class="nc bnc" id="L2628" title="All 2 branches missed.">                        if (uType.getClassID() == null) {</span>
<span class="nc" id="L2629">                            final String typename = uType.getTypeName();</span>
<span class="nc" id="L2630">                            final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">                            if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2632">                                LOGGER.error(</span>
                                        &quot;Unable to found operation return include type {}${} in class ids structure&quot;,
                                        typenamespace, typename);
                            }
<span class="nc" id="L2636">                            uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                        }
                    }
<span class="nc" id="L2639">                }</span>
            }

<span class="nc bnc" id="L2642" title="All 2 branches missed.">            for (final Type paramType : operation.getParams().values()) {</span>
<span class="nc bnc" id="L2643" title="All 2 branches missed.">                if (paramType instanceof UserType) {</span>
<span class="nc" id="L2644">                    final UserType uType = (UserType) paramType;</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">                    if (uType.getClassID() == null) {</span>
<span class="nc" id="L2646">                        final String typename = uType.getTypeName();</span>
<span class="nc" id="L2647">                        final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2648" title="All 2 branches missed.">                        if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2649">                            LOGGER.error(&quot;Unable to found operation param type {}${} in class ids structure&quot;,</span>
                                    typenamespace, typename);
                        }
<span class="nc" id="L2652">                        uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                    }
                }
<span class="nc bnc" id="L2655" title="All 2 branches missed.">                if (paramType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2656" title="All 2 branches missed.">                    for (final Type includeType : paramType.getIncludes()) {</span>
<span class="nc bnc" id="L2657" title="All 2 branches missed.">                        if (includeType instanceof UserType) {</span>
<span class="nc" id="L2658">                            final UserType uType = (UserType) includeType;</span>
<span class="nc bnc" id="L2659" title="All 2 branches missed.">                            if (uType.getClassID() == null) {</span>
<span class="nc" id="L2660">                                final String typename = uType.getTypeName();</span>
<span class="nc" id="L2661">                                final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2662" title="All 2 branches missed.">                                if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2663">                                    LOGGER.error(</span>
                                            &quot;Unable to found operation param include type {}${} in class ids structure&quot;,
                                            typenamespace, typename);
                                }
<span class="nc" id="L2667">                                uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                            }
                        }
<span class="nc" id="L2670">                    }</span>
                }
<span class="nc" id="L2672">            }</span>

            // Update implementations of current operation
<span class="nc bnc" id="L2675" title="All 2 branches missed.">            for (final Implementation impl : operation.getImplementations()) {</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">                for (final Type includeType : impl.getIncludes()) {</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">                    if (includeType instanceof UserType) {</span>
<span class="nc" id="L2678">                        final UserType uType = (UserType) includeType;</span>
<span class="nc bnc" id="L2679" title="All 2 branches missed.">                        if (uType.getClassID() == null) {</span>
<span class="nc" id="L2680">                            final String typename = uType.getTypeName();</span>
<span class="nc" id="L2681">                            final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2682" title="All 2 branches missed.">                            if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2683">                                LOGGER.error(&quot;Unable to found implementation include type {}${} in class ids structure&quot;,</span>
                                        typenamespace, typename);
                            }
<span class="nc" id="L2686">                            uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                        }
                    }
<span class="nc bnc" id="L2689" title="All 2 branches missed.">                    if (includeType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2690" title="All 2 branches missed.">                        for (final Type subincludeType : includeType.getIncludes()) {</span>
<span class="nc bnc" id="L2691" title="All 2 branches missed.">                            if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2692">                                final UserType uType = (UserType) subincludeType;</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">                                if (uType.getClassID() == null) {</span>
<span class="nc" id="L2694">                                    final String typename = uType.getTypeName();</span>
<span class="nc" id="L2695">                                    final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2696" title="All 2 branches missed.">                                    if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2697">                                        LOGGER.error(</span>
                                                &quot;Unable to found implementation subinclude type {}${} in class ids structure&quot;,
                                                typenamespace, typename);
                                    }
<span class="nc" id="L2701">                                    uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                                }
                            }
<span class="nc" id="L2704">                        }</span>
                    }
<span class="nc" id="L2706">                }</span>

                // Update accessed properties
<span class="nc bnc" id="L2709" title="All 2 branches missed.">                for (final AccessedProperty accProperty : impl.getAccessedProperties()) {</span>
<span class="nc bnc" id="L2710" title="All 4 branches missed.">                    if (accProperty.getPropertyID() == null &amp;&amp; accProperty.getPropertyID() == null) {</span>
<span class="nc" id="L2711">                        final String propClassname = accProperty.getClassName();</span>
<span class="nc" id="L2712">                        final String propNamespace = accProperty.getNamespace();</span>
<span class="nc" id="L2713">                        final String propName = accProperty.getName();</span>

<span class="nc" id="L2715">                        final PropertyID accPropertyID = propsIDsSet</span>
<span class="nc" id="L2716">                                .get(propNamespace + &quot;$&quot; + propClassname + &quot;$&quot; + propName);</span>

<span class="nc bnc" id="L2718" title="All 2 branches missed.">                        if (accPropertyID == null) {</span>
<span class="nc" id="L2719">                            throw new DataClayRuntimeException(ERRORCODE.PROPERTY_NOT_EXIST,</span>
<span class="nc" id="L2720">                                    &quot;Property &quot; + accProperty.getName() + &quot; does not exist in registered class &quot;</span>
<span class="nc" id="L2721">                                            + accProperty.getClassName() + &quot;. You might be registering a class that &quot;</span>
                                            + &quot; imports another class which is already registered. &quot;,
                                    true);

                        }
<span class="nc" id="L2726">                        accProperty.setPropertyID(accPropertyID);</span>
                    }
<span class="nc" id="L2728">                }</span>

                // Update accessed implementations
<span class="nc bnc" id="L2731" title="All 2 branches missed.">                for (final AccessedImplementation accImpl : impl.getAccessedImplementations()) {</span>
<span class="nc bnc" id="L2732" title="All 4 branches missed.">                    if (accImpl.getImplementationID() == null &amp;&amp; accImpl.getImplementationID() == null) {</span>
<span class="nc" id="L2733">                        final String implClassname = accImpl.getClassName();</span>
<span class="nc" id="L2734">                        final String implNamespace = accImpl.getNamespace();</span>
<span class="nc" id="L2735">                        final String implOpSignature = accImpl.getOpSignature();</span>
<span class="nc" id="L2736">                        final int implementationPos = accImpl.getImplPosition();</span>
<span class="nc" id="L2737">                        final ImplementationID accImplID = implsIDsSet.get(</span>
                                implNamespace + &quot;$&quot; + implClassname + &quot;$&quot; + implOpSignature + &quot;$&quot; + implementationPos);
<span class="nc bnc" id="L2739" title="All 2 branches missed.">                        if (accImplID == null) {</span>
<span class="nc" id="L2740">                            throw new DataClayRuntimeException(ERRORCODE.OPERATION_NOT_EXIST,</span>
<span class="nc" id="L2741">                                    &quot;Operation &quot; + accImpl.getOpSignature() + &quot; does not exist in registered class &quot;</span>
<span class="nc" id="L2742">                                            + accImpl.getClassName() + &quot;. You might be registering a class that &quot;</span>
                                            + &quot; imports another class which is already registered. &quot;,
                                    true);
                        }
<span class="nc" id="L2746">                        accImpl.setImplementationID(accImplID);</span>
                    }
<span class="nc" id="L2748">                }</span>

                // Update prefetching info
<span class="nc bnc" id="L2751" title="All 4 branches missed.">                if (impl.getPrefetchingInfo() != null &amp;&amp; impl.getPrefetchingInfo().getInjectPrefetchingCall()) {</span>
<span class="nc" id="L2752">                    final PrefetchingInformation pfInfo = impl.getPrefetchingInfo();</span>
<span class="nc" id="L2753">                    final String implClassname = pfInfo.getPrefetchingClassName();</span>
<span class="nc" id="L2754">                    final String implNamespace = pfInfo.getPrefetchingNameSpace();</span>
<span class="nc" id="L2755">                    final String implOpSignature = pfInfo.getPrefetchingMethodSignature();</span>
<span class="nc" id="L2756">                    final int implementationPos = 0;</span>
<span class="nc" id="L2757">                    final ImplementationID accImplID = implsIDsSet</span>
<span class="nc" id="L2758">                            .get(implNamespace + &quot;$&quot; + implClassname + &quot;$&quot; + implOpSignature + &quot;$&quot; + implementationPos);</span>
<span class="nc bnc" id="L2759" title="All 2 branches missed.">                    if (accImplID == null) {</span>
<span class="nc" id="L2760">                        throw new DataClayRuntimeException(ERRORCODE.OPERATION_NOT_EXIST,</span>
<span class="nc" id="L2761">                                &quot;Operation &quot; + pfInfo.getPrefetchingMethodSignature()</span>
<span class="nc" id="L2762">                                        + &quot; does not exist in registered class &quot; + pfInfo.getPrefetchingClassName()</span>
                                        + &quot;. You might be registering a class that &quot;
                                        + &quot; imports another class which is already registered. &quot;,
                                true);
                    }
<span class="nc" id="L2767">                    pfInfo.setPrefetchingImplementationID(accImplID);</span>
<span class="nc" id="L2768">                    pfInfo.setPrefetchingClassID(newClassIDs.get(implNamespace + &quot;$&quot; + implClassname));</span>
                }

<span class="nc" id="L2771">            }</span>
<span class="nc" id="L2772">        }</span>

<span class="nc bnc" id="L2774" title="All 2 branches missed.">        if (metaClass.getJavaClassInfo() != null) {</span>
<span class="nc bnc" id="L2775" title="All 2 branches missed.">            for (final Type ifaceInclude : metaClass.getJavaClassInfo().getIncludes()) {</span>
<span class="nc bnc" id="L2776" title="All 2 branches missed.">                if (ifaceInclude instanceof UserType) {</span>
<span class="nc" id="L2777">                    final UserType uType = (UserType) ifaceInclude;</span>
<span class="nc bnc" id="L2778" title="All 2 branches missed.">                    if (uType.getClassID() == null) {</span>
<span class="nc" id="L2779">                        final String typename = uType.getTypeName();</span>
<span class="nc" id="L2780">                        final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2781" title="All 2 branches missed.">                        if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2782">                            LOGGER.error(</span>
                                    &quot;Unable to found implementation subinclude type {}${} in class ids structure&quot;,
                                    typenamespace, typename);
                        }
<span class="nc" id="L2786">                        uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
                    }
                }
<span class="nc" id="L2789">            }</span>
        }


        // Update parent
<span class="nc" id="L2794">        final UserType parentType = metaClass.getParentType();</span>
<span class="nc bnc" id="L2795" title="All 2 branches missed.">        if (parentType != null) {</span>
            // We get the name without parsing since parent are not
            // signature
<span class="nc" id="L2798">            final MetaClassID m = newClassIDs.get(parentType.getNamespace() + &quot;$&quot; + parentType.getTypeName());</span>
<span class="nc" id="L2799">            parentType.setClassID(m);</span>
        }
<span class="nc" id="L2801">    }</span>

    /**
     * Creates a new metaclass in the system with the provided specifications and
     * associates it to the Namespace provided.
     *
     * @param accountID
     *            ID of the account of the user that calls the operation
     * @param credential
     *            Credential of the account provided
     * @param namespaceID
     *            id of the namespace in which to create the metaclass
     * @param namespaceInfo
     *            Information of namespace
     * @param newClass
     *            New class specifications
     * @param language
     *            Language of the new class
     * @return info of the new MetaClass if it was successfully created.
     */
    private MetaClass newClassInternal(final AccountID accountID, final PasswordCredential credential,
                                       final NamespaceID namespaceID, final MetaClass newClass, final Namespace namespaceInfo,
                                       final Langs language) {

        // Check language of namespace
<span class="nc bnc" id="L2826" title="All 2 branches missed.">        if (namespaceInfo.getLanguage() != language) {</span>
<span class="nc" id="L2827">            throw new DataClayRuntimeException(ERRORCODE.INCOMPATIBLE_LANGUAGE_FOR_CLASS_WITH_NAMESPACE);</span>
        }

        // Register class in class manager
<span class="nc" id="L2831">        final MetaClass newClassInfo = classMgrApi.newClass(accountID, namespaceID, namespaceInfo.getName(), newClass,</span>
                language);
<span class="nc" id="L2833">        return newClassInfo;</span>

    }

    @Override
    public void removeClass(final AccountID accountID, final PasswordCredential credential,
                            final NamespaceID namespaceID, final String className) {
        // Check namespace responsible
<span class="nc" id="L2841">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

<span class="nc" id="L2843">        Set&lt;ImportedInterface&gt; importedInterfaces = null;</span>
        // Check the class is not in use and get the classID (checks the class belongs
        // to the namespace)
<span class="nc" id="L2846">        MetaClassID classID = classMgrApi.checkClassNotInIncludesAndGetID(className, namespaceID);</span>
<span class="nc bnc" id="L2847" title="All 2 branches missed.">        if (classID == null) {</span>
            // if class manager cannot obtain the class id in namespaceID look for imports
            // and check they are not used
<span class="nc" id="L2850">            importedInterfaces = namespaceMgrApi.checkImportsOfClassAreNotUsedAndGet(namespaceID, className);</span>
<span class="nc bnc" id="L2851" title="All 2 branches missed.">            if (importedInterfaces.isEmpty()) {</span>
<span class="nc" id="L2852">                throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_CREATED_IN_NAMESPACE_NOR_IMPORTED);</span>
            }
<span class="nc" id="L2854">            classID = importedInterfaces.iterator().next().getClassOfImportID();</span>
        }

        // Check there is no interface of the class related with a contract
<span class="nc" id="L2858">        final Set&lt;InterfaceID&gt; interfacesIDs = interfaceMgrApi.getInterfacesOfClass(namespaceID, classID);</span>
<span class="nc bnc" id="L2859" title="All 2 branches missed.">        for (final InterfaceID interfaceID : interfacesIDs) {</span>
<span class="nc bnc" id="L2860" title="All 2 branches missed.">            if (!contractMgrApi.checkInterfaceHasNoContracts(interfaceID)) {</span>
<span class="nc" id="L2861">                throw new DataClayRuntimeException(ERRORCODE.INTERFACE_WITH_CONTRACTS);</span>
            }
<span class="nc" id="L2863">        }</span>

        // Remove the interfaces of the class
<span class="nc bnc" id="L2866" title="All 2 branches missed.">        for (final InterfaceID interfaceID : interfacesIDs) {</span>
<span class="nc" id="L2867">            interfaceMgrApi.removeInterface(namespaceID, interfaceID);</span>
<span class="nc" id="L2868">        }</span>

<span class="nc bnc" id="L2870" title="All 2 branches missed.">        if (importedInterfaces == null) {</span>
            // Remove the class
<span class="nc" id="L2872">            classMgrApi.removeClass(classID);</span>
        } else {
            // Remote imports
<span class="nc" id="L2875">            namespaceMgrApi.removeImportedInterfaces(namespaceID, importedInterfaces);</span>
        }

        // Unregister associations with the imports it used if any
<span class="nc" id="L2879">        final HashSet&lt;MetaClassID&gt; metaClassesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2880">        metaClassesIDs.add(classID);</span>
<span class="nc" id="L2881">        namespaceMgrApi.unregisterSubClassesFromUsingAnyImportedClassInNamespace(namespaceID, metaClassesIDs);</span>

<span class="nc" id="L2883">    }</span>

    @Override
    public void removeOperation(final AccountID accountID, final PasswordCredential credential,
                                final NamespaceID namespaceID, final String className, final String operationSignature) {
        // Check namespace responsible
<span class="nc" id="L2889">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

        // Get metaClassID either because it is created in namespace or imported in it
<span class="nc" id="L2892">        final MetaClassID classID = getMetaClassID(namespaceID, className);</span>

        // Get the operationID (checks the operation belongs to the class)
<span class="nc" id="L2895">        final OperationID operationID = classMgrApi.getOperationID(classID, operationSignature);</span>

        // Check there is no implementation accessing the operation
<span class="nc bnc" id="L2898" title="All 2 branches missed.">        if (classMgrApi.existsImplementationAccessingOperation(operationID)) {</span>
<span class="nc" id="L2899">            throw new DataClayRuntimeException(ERRORCODE.SOME_IMPLEMENTATIONS_ACCESS_OPERATION);</span>
        }

        // Check there is no interface related with the operation
<span class="nc" id="L2903">        final Set&lt;InterfaceID&gt; interfacesIDs = interfaceMgrApi.getInterfacesAccessingOperation(namespaceID, classID,</span>
                operationID);
<span class="nc bnc" id="L2905" title="All 2 branches missed.">        if (!interfacesIDs.isEmpty()) {</span>
<span class="nc" id="L2906">            throw new DataClayRuntimeException(ERRORCODE.OPERATION_ALREADY_IN_INTERFACE);</span>
        }

        // Remove the operation
<span class="nc" id="L2910">        final Operation opInfo = classMgrApi.removeOperation(operationID);</span>

        // Unregister associations with the imports it used
        // TODO Do this in a single op (24 Jul 2013 jmarti)
<span class="nc" id="L2914">        final HashSet&lt;OperationID&gt; operationsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2915">        operationsIDs.add(operationID);</span>
<span class="nc" id="L2916">        namespaceMgrApi.unregisterOperationsFromUsingAnyImportedClassInNamespace(namespaceID, operationsIDs);</span>

<span class="nc" id="L2918">        final HashSet&lt;ImplementationID&gt; implIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2919" title="All 2 branches missed.">        for (final Implementation impl : opInfo.getImplementations()) {</span>
<span class="nc" id="L2920">            implIDs.add(impl.getDataClayID());</span>
<span class="nc" id="L2921">        }</span>
<span class="nc" id="L2922">        namespaceMgrApi.unregisterImplementationsFromUsingAnyImportedClassInNamespace(namespaceID, implIDs);</span>

<span class="nc" id="L2924">    }</span>

    @Override
    public void removeImplementation(final AccountID accountID, final PasswordCredential credential,
                                     final NamespaceID namespaceID, final ImplementationID implementationID) {
        // Check namespace responsible
<span class="nc" id="L2930">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

        // Check the method is not related with contracts
<span class="nc bnc" id="L2933" title="All 2 branches missed.">        if (!contractMgrApi.checkImplementationHasNoContracts(implementationID)) {</span>
<span class="nc" id="L2934">            throw new DataClayRuntimeException(ERRORCODE.IMPL_ACCESSIBLE_FROM_CONTRACTS);</span>
        }

        // Remove the method
<span class="nc" id="L2938">        classMgrApi.removeImplementation(implementationID);</span>

        // Unregister associations with the imports it used
<span class="nc" id="L2941">        final HashSet&lt;ImplementationID&gt; implementationsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2942">        implementationsIDs.add(implementationID);</span>
<span class="nc" id="L2943">        namespaceMgrApi.unregisterImplementationsFromUsingAnyImportedClassInNamespace(namespaceID, implementationsIDs);</span>

<span class="nc" id="L2945">    }</span>

    @Override
    public OperationID getOperationID(final AccountID accountID, final PasswordCredential credential,
                                      final NamespaceID namespaceID, final String className, final String operationSignature) {
        // Check namespace responsible
<span class="nc" id="L2951">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

        // Get metaClassID either because it is created in namespace or imported in it
<span class="nc" id="L2954">        final MetaClassID classID = getMetaClassID(namespaceID, className);</span>

        // Get the operationID (checks the operation belongs to the class)
<span class="nc" id="L2957">        return classMgrApi.getOperationID(classID, operationSignature);</span>

    }

    @Override
    public PropertyID getPropertyID(final AccountID accountID, final PasswordCredential credential,
                                    final NamespaceID namespaceID, final String className, final String propertyName) {
        // Check namespace responsible
<span class="nc" id="L2965">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

        // Get metaClassID either because it is created in namespace or imported in it
<span class="nc" id="L2968">        final MetaClassID classID = getMetaClassID(namespaceID, className);</span>

        // Get the propertyID (checks the property belongs to the class)
<span class="nc" id="L2971">        return classMgrApi.getPropertyID(classID, propertyName);</span>

    }

    @Override
    public MetaClassID getClassID(final AccountID accountID, final PasswordCredential credential,
                                  final NamespaceID namespaceID, final String className) {
        // Check namespace responsible
<span class="nc" id="L2979">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

        // Get the classID (checks the class belongs to the namespace)
<span class="nc" id="L2982">        final MetaClassID classID = classMgrApi.getMetaClassID(namespaceID, className);</span>
<span class="nc bnc" id="L2983" title="All 2 branches missed.">        if (classID == null) {</span>
<span class="nc" id="L2984">            throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_EXIST);</span>
        } else {
<span class="nc" id="L2986">            return classID;</span>
        }

    }

    @Override
    public MetaClass getClassInfo(final AccountID accountID, final PasswordCredential credential,
                                  final NamespaceID namespaceID, final String className) {
<span class="nc" id="L2994">        final MetaClassID classID = classMgrApi.getMetaClassID(namespaceID, className);</span>
<span class="nc bnc" id="L2995" title="All 2 branches missed.">        if (classID == null) {</span>
<span class="nc" id="L2996">            throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_EXIST,</span>
<span class="nc" id="L2997">                    &quot;Class &quot; + className + &quot; (at namespace: {&quot; + namespaceID.toString() + &quot;})&quot;, false);</span>
        } else {
<span class="nc" id="L2999">            return classMgrApi.getClassInfo(classID);</span>
        }
    }

    @Override
    public Map&lt;MetaClassID, MetaClass&gt; getInfoOfClassesInNamespace(final AccountID accountID,
                                                                   final PasswordCredential credential, final NamespaceID namespaceID) {
        try {
            // Check namespace responsible
<span class="nc" id="L3008">            checkNamespaceResponsible(accountID, credential, namespaceID);</span>

<span class="nc" id="L3010">            return classMgrApi.getInfoOfClassesInNamespace(namespaceID);</span>
<span class="nc" id="L3011">        } catch (final Exception ex) {</span>
<span class="nc" id="L3012">            LOGGER.debug(&quot;getInfoOfClassesInNamespace error&quot;, ex);</span>
<span class="nc" id="L3013">            throw ex;</span>
        }

    }


    /**
     * Method that check if type with signature provided exists and set Class ID if
     * needed.
     *
     * @param accountID
     *            the account ID just in case it is an import and we need to check
     *            if it is registered to any of the corresponding contracts
     * @param credential
     *            the credential of the account
     * @param userType
     *            Type to check
     * @return TRUE if type is already registered in DataClay.
     */
    private boolean checkTypeIsRegistered(final AccountID accountID, final PasswordCredential credential,
                                          final UserType userType) {

<span class="nc" id="L3035">        final String typeName = userType.getTypeName();</span>
<span class="nc" id="L3036">        final String namespace = userType.getNamespace();</span>
<span class="nc" id="L3037">        final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
        // Get the metaClassID (checks the class belongs to the namespace)
<span class="nc" id="L3039">        final MetaClassID metaClassID = classMgrApi.getMetaClassID(namespaceID, typeName);</span>
<span class="nc bnc" id="L3040" title="All 2 branches missed.">        if (metaClassID != null) {</span>
<span class="nc" id="L3041">            return true;</span>
        } else {
            // if class manager cannot obtain the class id in namespaceID check imports
<span class="nc" id="L3044">            final Set&lt;ImportedInterface&gt; importedInterfaces = namespaceMgrApi.getImportedInterfaces(namespaceID,</span>
                    typeName);
<span class="nc bnc" id="L3046" title="All 2 branches missed.">            if (!importedInterfaces.isEmpty()) {</span>
<span class="nc" id="L3047">                return true;</span>
            }
        }
<span class="nc" id="L3050">        return false;</span>

    }

    // ============== Contract Manager ==============//

    // TODO ROLLBACK IF IT FAILS (2 Jul 2013 jmarti)
    @Override
    public ContractID newContract(final AccountID accountID, final PasswordCredential credential,
                                  final Contract newContract) {

        try {
            // =========== CHECK AND FILL WITH IDS =========== //
            // Set IDs of accounts and namespaces (check it is properly specified)
            // Namespace
<span class="nc" id="L3065">            final String namespace = newContract.getNamespace();</span>
<span class="nc bnc" id="L3066" title="All 4 branches missed.">            if (namespace == null || namespace.isEmpty()) {</span>
<span class="nc" id="L3067">                throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                        &quot;Contract specification: Namespace cannot null or empty&quot;, false);
            }
<span class="nc" id="L3070">            final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L3071">            newContract.setNamespaceID(namespaceID);</span>
<span class="nc" id="L3072">            newContract.setProviderAccountID(accountID);</span>

            // Provider account ID
<span class="nc bnc" id="L3075" title="All 2 branches missed.">            if (newContract.getProviderAccountID() == null) {</span>
<span class="nc" id="L3076">                throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                        &quot;Contract specification: Provider account id cannot be null or empty&quot;, false);
            }

            // Interfaces in contract
<span class="nc" id="L3081">            final Map&lt;InterfaceID, InterfaceInContract&gt; ifacesWithIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3082">            final List&lt;InterfaceInContract&gt; ifacesInContract = newContract.getInterfacesInContractSpecs();</span>
<span class="nc bnc" id="L3083" title="All 2 branches missed.">            for (final InterfaceInContract ifaceInContract : ifacesInContract) {</span>
                // Get interface IDs

<span class="nc" id="L3086">                final Interface ifaceSpec = ifaceInContract.getIface();</span>

                /**** rtouma ****/
                // Set provider account name if null
<span class="nc bnc" id="L3090" title="All 4 branches missed.">                if (ifaceSpec.getProviderAccountName() == null || ifaceSpec.getProviderAccountName().isEmpty()) {</span>
<span class="nc" id="L3091">                    final AccountID providerID = ifaceSpec.getProviderAccountID();</span>
<span class="nc bnc" id="L3092" title="All 2 branches missed.">                    if (providerID == null) {</span>
<span class="nc" id="L3093">                        throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                                &quot;Contract specification: Provider account ID cannot be null or empty&quot;, false);
                    }
<span class="nc" id="L3096">                    final String providerName = accountMgrApi.getAccount(providerID).getUsername();</span>
<span class="nc" id="L3097">                    ifaceSpec.setProviderAccountName(providerName);</span>
                }
                /****************/

<span class="nc" id="L3101">                final InterfaceID ifaceID = interfaceMgrApi.getInterfaceID(ifaceSpec.getProviderAccountName(),</span>
<span class="nc" id="L3102">                        ifaceSpec.getNamespace(), ifaceSpec.getClassName(), ifaceSpec.getPropertiesInIface(),</span>
<span class="nc" id="L3103">                        ifaceSpec.getOperationsSignatureInIface());</span>
<span class="nc" id="L3104">                final Interface iface = interfaceMgrApi.getInterfaceInfo(ifaceID);</span>
<span class="nc" id="L3105">                ifaceInContract.setInterfaceID(iface.getDataClayID());</span>

                // Set actual iface
<span class="nc" id="L3108">                ifaceInContract.setIface(iface);</span>
<span class="nc" id="L3109">                final MetaClassID classID = iface.getMetaClassID();</span>

                // OpImplementations
<span class="nc" id="L3112">                final Map&lt;OperationID, OpImplementations&gt; opImpls = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3113">                final Set&lt;OpImplementations&gt; implSpecOps = ifaceInContract.getImplementationsSpecPerOperation();</span>
<span class="nc bnc" id="L3114" title="All 2 branches missed.">                for (final OpImplementations opImpl : implSpecOps) {</span>
<span class="nc" id="L3115">                    final String opSignature = opImpl.getOperationSignature();</span>
<span class="nc" id="L3116">                    final int numLocalImpl = opImpl.getNumLocalImpl();</span>
<span class="nc" id="L3117">                    final int numRemoteImpl = opImpl.getNumRemoteImpl();</span>

<span class="nc" id="L3119">                    final OperationID opID = classMgrApi.getOperationID(classID, opSignature);</span>
<span class="nc" id="L3120">                    final Operation operation = classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L3121">                    int curImpl = 0;</span>
<span class="nc bnc" id="L3122" title="All 2 branches missed.">                    for (final Implementation impl : operation.getImplementations()) {</span>
<span class="nc bnc" id="L3123" title="All 2 branches missed.">                        if (curImpl == numLocalImpl) {</span>
<span class="nc" id="L3124">                            opImpl.setLocalImplementationID(impl.getDataClayID());</span>
                        }
<span class="nc bnc" id="L3126" title="All 2 branches missed.">                        if (curImpl == numRemoteImpl) {</span>
<span class="nc" id="L3127">                            opImpl.setRemoteImplementationID(impl.getDataClayID());</span>
                        }
<span class="nc bnc" id="L3129" title="All 4 branches missed.">                        if (opImpl.getLocalImplementationID() != null &amp;&amp; opImpl.getRemoteImplementationID() != null) {</span>
<span class="nc" id="L3130">                            break;</span>
                        }
<span class="nc" id="L3132">                        curImpl++;</span>
<span class="nc" id="L3133">                    }</span>
<span class="nc" id="L3134">                    opImpls.put(opID, opImpl);</span>

<span class="nc" id="L3136">                }</span>
<span class="nc" id="L3137">                ifaceInContract.setAccessibleImplementations(opImpls);</span>
<span class="nc" id="L3138">                ifacesWithIDs.put(ifaceID, ifaceInContract);</span>
<span class="nc" id="L3139">            }</span>
<span class="nc" id="L3140">            newContract.setInterfacesInContract(ifacesWithIDs);</span>
            // =========== =========== =========== =========== //

            // Validate proprietary and check it is the responsible of the namespace
<span class="nc" id="L3144">            final Namespace namespaceInfo = checkNamespaceResponsible(accountID, credential,</span>
<span class="nc" id="L3145">                    newContract.getNamespaceID());</span>

            // Update contract with the implementations of the default getters and setters
<span class="nc bnc" id="L3148" title="All 2 branches missed.">            if (namespaceInfo.getLanguage() == Langs.LANG_JAVA) { // Getters/setters do not apply to Python codes</span>
                // (jcosta
                // 17/jun/2014)
<span class="nc" id="L3151">                final Map&lt;InterfaceID, Interface&gt; infoOfInterfaces = interfaceMgrApi</span>
<span class="nc" id="L3152">                        .getInterfacesInfo(new HashSet&lt;&gt;(newContract.getInterfacesInContract().keySet()));</span>
<span class="nc" id="L3153">                final Map&lt;MetaClassID, Set&lt;PropertyID&gt;&gt; propertiesInInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L3154" title="All 2 branches missed.">                for (final Interface ifaceInfo : infoOfInterfaces.values()) {</span>
<span class="nc" id="L3155">                    final MetaClassID curClassID = ifaceInfo.getMetaClassID();</span>
<span class="nc" id="L3156">                    final Set&lt;PropertyID&gt; curPropsIDs = ifaceInfo.getPropertiesIDs();</span>
<span class="nc" id="L3157">                    propertiesInInterfaces.put(curClassID, curPropsIDs);</span>
<span class="nc" id="L3158">                }</span>
<span class="nc" id="L3159">                final Map&lt;PropertyID, Map&lt;OperationID, ImplementationID&gt;&gt; implsOfGettersSetters = classMgrApi</span>
<span class="nc" id="L3160">                        .getImplementationsOfGettersAndSetters(propertiesInInterfaces);</span>
<span class="nc bnc" id="L3161" title="All 2 branches missed.">                for (final Entry&lt;InterfaceID, InterfaceInContract&gt; ifaceInContract : newContract</span>
<span class="nc" id="L3162">                        .getInterfacesInContract().entrySet()) {</span>
<span class="nc" id="L3163">                    final InterfaceID curIfaceID = ifaceInContract.getKey();</span>
<span class="nc" id="L3164">                    final Interface ifaceInfo = infoOfInterfaces.get(curIfaceID);</span>
<span class="nc" id="L3165">                    final InterfaceInContract curIfaceInContract = ifaceInContract.getValue();</span>
<span class="nc bnc" id="L3166" title="All 2 branches missed.">                    for (final PropertyID propertyInInterface : ifaceInfo.getPropertiesIDs()) {</span>
<span class="nc" id="L3167">                        final Map&lt;OperationID, ImplementationID&gt; implsOfGetterSetter = implsOfGettersSetters</span>
<span class="nc" id="L3168">                                .get(propertyInInterface);</span>
<span class="nc bnc" id="L3169" title="All 2 branches missed.">                        for (final Entry&lt;OperationID, ImplementationID&gt; curImplOfGetterSetter : implsOfGetterSetter</span>
<span class="nc" id="L3170">                                .entrySet()) {</span>
<span class="nc" id="L3171">                            final OperationID opID = curImplOfGetterSetter.getKey();</span>
<span class="nc" id="L3172">                            final Operation op = classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L3173">                            final OpImplementations opImplementationGetterSetter = new OpImplementations(</span>
<span class="nc" id="L3174">                                    op.getNameAndDescriptor(), 0, 0);</span>
<span class="nc" id="L3175">                            final ImplementationID implID = op.getImplementations().get(0).getDataClayID();</span>
<span class="nc" id="L3176">                            opImplementationGetterSetter.setLocalImplementationID(implID);</span>
<span class="nc" id="L3177">                            opImplementationGetterSetter.setRemoteImplementationID(implID);</span>
<span class="nc" id="L3178">                            curIfaceInContract.getAccessibleImplementations().put(curImplOfGetterSetter.getKey(),</span>
                                    opImplementationGetterSetter);
<span class="nc" id="L3180">                        }</span>
<span class="nc" id="L3181">                    }</span>
<span class="nc" id="L3182">                }</span>
            }

            // Check contract
<span class="nc" id="L3186">            final Map&lt;InterfaceID, Interface&gt; infoOfInterfacesInContract = checkContract(newContract);</span>

            // Generate interfaces that must be automatically added in the contract
<span class="nc" id="L3189">            final Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInContract = updateInterfacesForTheContract(accountID,</span>
<span class="nc" id="L3190">                    credential, newContract.getNamespaceID(), newContract.getInterfacesInContract(),</span>
                    infoOfInterfacesInContract);

<span class="nc" id="L3193">            newContract.setInterfacesInContract(interfacesInContract);</span>

            // Create the contract
<span class="nc" id="L3196">            ContractID newContractID = new ContractID();</span>
<span class="nc" id="L3197">            newContract.setDataClayID(newContractID);</span>

<span class="nc bnc" id="L3199" title="All 2 branches missed.">            if (!newContract.isPublicAvailable()) {</span>
<span class="nc" id="L3200">                newContractID = contractMgrApi.newPrivateContract(newContract);</span>
            } else {
<span class="nc" id="L3202">                newContractID = contractMgrApi.newPublicContract(newContract);</span>
            }

<span class="nc" id="L3205">            return newContractID;</span>

<span class="nc" id="L3207">        } catch (final ParseException e) {</span>
<span class="nc" id="L3208">            throw new DataClayRuntimeException(ERRORCODE.BAD_DATES);</span>
        }
    }

    @Override
    public void registerToPublicContract(final AccountID accountID, final PasswordCredential credential,
                                         final ContractID contractID) {
        // Validate proprietary account
<span class="nc bnc" id="L3216" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3217">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L3220">        contractMgrApi.registerToPublicContract(accountID, contractID);</span>
<span class="nc" id="L3221">    }</span>

    @Override
    public ContractID registerToPublicContractOfNamespace(final AccountID accountID,
                                                          final PasswordCredential credential, final NamespaceID namespaceID) {
        // Validate proprietary account
<span class="nc bnc" id="L3227" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3228">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L3231">        final Map&lt;ContractID, Contract&gt; pubContracts = contractMgrApi.getPublicContractIDsOfProvider(namespaceID);</span>
<span class="nc bnc" id="L3232" title="All 2 branches missed.">        if (pubContracts.size() == 0) {</span>
<span class="nc" id="L3233">            throw new DataClayRuntimeException(ERRORCODE.CONTRACT_NOT_EXIST);</span>
        }
<span class="nc" id="L3235">        final ContractID pubContractID = pubContracts.keySet().iterator().next();</span>
<span class="nc" id="L3236">        contractMgrApi.registerToPublicContract(accountID, pubContractID);</span>
<span class="nc" id="L3237">        return pubContractID;</span>
    }

    @Override
    public Map&lt;ContractID, Contract&gt; getContractIDsOfProvider(final AccountID accountID,
                                                              final PasswordCredential credential, final NamespaceID namespaceIDofProvider) {
        // Validate account and check it is the responsible of the namespace
<span class="nc" id="L3244">        checkNamespaceResponsible(accountID, credential, namespaceIDofProvider);</span>

<span class="nc" id="L3246">        return contractMgrApi.getContractIDsOfProvider(namespaceIDofProvider);</span>
    }

    @Override
    public Map&lt;ContractID, Contract&gt; getContractIDsOfApplicant(final AccountID applicantAccountID,
                                                               final PasswordCredential credential) {
        // Validate account
<span class="nc bnc" id="L3253" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(applicantAccountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3254">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L3257">        return contractMgrApi.getContractIDsOfApplicant(applicantAccountID);</span>

    }

    @Override
    public Map&lt;ContractID, Contract&gt; getContractIDsOfApplicantWithProvider(final AccountID applicantAccountID,
                                                                           final PasswordCredential credential, final NamespaceID namespaceIDofProvider) {
        // Validate account
<span class="nc bnc" id="L3265" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(applicantAccountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3266">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L3269">        return contractMgrApi.getContractIDsOfApplicantWithProvider(applicantAccountID, namespaceIDofProvider);</span>
    }

    // ============== DataContract Manager ==============//

    // TODO ROLLBACK IF IT FAILS (2 Jul 2013 jmarti)
    @Override
    public DataContractID newDataContract(final AccountID accountID, final PasswordCredential credential,
                                          final DataContract newDataContract) {
        try {

            // ================================================ //
<span class="nc bnc" id="L3281" title="All 2 branches missed.">            if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L3282">                this.notificationMgrApi.removeSessionInCache(accountID);</span>
            }

<span class="nc" id="L3285">            final DataSetID datasetID = newDataContract.getProviderDataSetID();</span>

            // Validate proprietary and check it is the responsible of the namespace
<span class="nc" id="L3288">            checkDataSetResponsible(accountID, credential, datasetID);</span>

            // Check applicants exist (if any)
<span class="nc bnc" id="L3291" title="All 2 branches missed.">            if (newDataContract.isPublicAvailable()) {</span>
<span class="nc bnc" id="L3292" title="All 2 branches missed.">                for (final AccountID applicantAccountID : newDataContract.getApplicantsAccountsIDs()) {</span>
<span class="nc bnc" id="L3293" title="All 2 branches missed.">                    if (applicantAccountID != null) {</span>
<span class="nc bnc" id="L3294" title="All 2 branches missed.">                        if (!accountMgrApi.existsAccount(applicantAccountID)) {</span>
<span class="nc" id="L3295">                            throw new DataClayRuntimeException(ERRORCODE.ACCOUNT_NOT_EXIST);</span>
                        }
                    }
<span class="nc" id="L3298">                }</span>
            }

            // Create the contract
<span class="nc" id="L3302">            DataContractID newDataContractID = new DataContractID();</span>
<span class="nc" id="L3303">            newDataContract.setDataClayID(newDataContractID);</span>
<span class="nc bnc" id="L3304" title="All 2 branches missed.">            if (newDataContract.isPublicAvailable()) {</span>
<span class="nc" id="L3305">                newDataContractID = datacontractMgrApi.newPublicDataContract(newDataContract);</span>
            } else {
<span class="nc" id="L3307">                newDataContractID = datacontractMgrApi.newPrivateDataContract(newDataContract);</span>
            }

<span class="nc" id="L3310">            LOGGER.info(&quot;[LOGICMODULE] Created new datacontract called&quot; + &quot; with ID &quot; + newDataContractID);</span>

<span class="nc" id="L3312">            return newDataContractID;</span>

<span class="nc" id="L3314">        } catch (final ParseException e) {</span>
<span class="nc" id="L3315">            throw new DataClayRuntimeException(ERRORCODE.BAD_DATES);</span>
        }
    }

    @Override
    public void registerToPublicDataContract(final AccountID accountID, final PasswordCredential credential,
                                             final DataContractID datacontractID) {
        // Validate proprietary account
<span class="nc bnc" id="L3323" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3324">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L3327">        datacontractMgrApi.registerToPublicDataContract(accountID, datacontractID);</span>

<span class="nc" id="L3329">    }</span>

    @Override
    public Map&lt;DataContractID, DataContract&gt; getDataContractIDsOfProvider(final AccountID accountID,
                                                                          final PasswordCredential credential, final DataSetID datasetIDofProvider) {
        // Validate account and check it is the responsible of the namespace
<span class="nc" id="L3335">        checkDataSetResponsible(accountID, credential, datasetIDofProvider);</span>

<span class="nc" id="L3337">        return datacontractMgrApi.getDataContractIDsOfProvider(datasetIDofProvider);</span>

    }

    @Override
    public Map&lt;DataContractID, DataContract&gt; getDataContractIDsOfApplicant(final AccountID applicantAccountID,
                                                                           final PasswordCredential credential) {
        // Validate account
<span class="nc bnc" id="L3345" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(applicantAccountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3346">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L3349">        return datacontractMgrApi.getDataContractIDsOfApplicant(applicantAccountID);</span>

    }

    @Override
    public DataContract getDataContractInfoOfApplicantWithProvider(final AccountID applicantAccountID,
                                                                   final PasswordCredential credential, final DataSetID datasetIDofProvider) {
        // Validate account
<span class="nc bnc" id="L3357" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(applicantAccountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3358">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

<span class="nc" id="L3361">        return datacontractMgrApi.getDataContractInfoOfApplicantWithProvider(applicantAccountID, datasetIDofProvider);</span>

    }

    // ============== Interface Manager ==============//

    @Override
    public InterfaceID newInterface(final AccountID accountID, final PasswordCredential credential,
                                    final Interface newInterface) {
        // =========== CHECK AND FILL WITH IDS =========== //

        // Account ID
<span class="nc bnc" id="L3373" title="All 2 branches missed.">        if (newInterface.getProviderAccountID() == null) {</span>
<span class="nc" id="L3374">            final String accountName = newInterface.getProviderAccountName();</span>
<span class="nc bnc" id="L3375" title="All 4 branches missed.">            if (accountName == null || accountName.isEmpty()) {</span>
<span class="nc" id="L3376">                throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty account name&quot;, false);</span>
            }
<span class="nc" id="L3378">            final AccountID accID = accountMgrApi.getAccountID(accountName);</span>
<span class="nc" id="L3379">            newInterface.setProviderAccountID(accID);</span>
        }

        /**** rtouma ****/
        // Account name
<span class="nc bnc" id="L3384" title="All 2 branches missed.">        if (newInterface.getProviderAccountName() == null) {</span>
<span class="nc" id="L3385">            final AccountID accID = newInterface.getProviderAccountID();</span>
<span class="nc bnc" id="L3386" title="All 2 branches missed.">            if (accID == null) {</span>
<span class="nc" id="L3387">                throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty account ID&quot;, false);</span>
            }
<span class="nc" id="L3389">            final String accName = accountMgrApi.getAccount(accID).getUsername();</span>
<span class="nc" id="L3390">            newInterface.setProviderAccountName(accName);</span>
        }
        /****************/

        // Namespace
<span class="nc" id="L3395">        final String namespace = newInterface.getNamespace();</span>
<span class="nc bnc" id="L3396" title="All 4 branches missed.">        if (namespace == null || namespace.isEmpty()) {</span>
<span class="nc" id="L3397">            throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty interface namespace&quot;, false);</span>
        }
<span class="nc" id="L3399">        final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L3400">        newInterface.setNamespaceID(namespaceID);</span>

        // Interface ID of class
<span class="nc" id="L3403">        final String classNamespace = newInterface.getClassNamespace();</span>
<span class="nc bnc" id="L3404" title="All 4 branches missed.">        if (classNamespace == null || classNamespace.isEmpty()) {</span>
<span class="nc" id="L3405">            throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty class namespace&quot;, false);</span>
        }
<span class="nc" id="L3407">        final NamespaceID classNamespaceID = namespaceMgrApi.getNamespaceID(classNamespace);</span>
<span class="nc" id="L3408">        newInterface.setClassNamespaceID(classNamespaceID);</span>

        // Class ID
<span class="nc" id="L3411">        final String className = newInterface.getClassName();</span>
<span class="nc bnc" id="L3412" title="All 4 branches missed.">        if (className == null || className.isEmpty()) {</span>
<span class="nc" id="L3413">            throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty interface class&quot;, false);</span>
        }
<span class="nc" id="L3415">        MetaClassID metaClassID = classMgrApi.getMetaClassID(classNamespaceID, className);</span>
<span class="nc" id="L3416">        newInterface.setMetaClassID(metaClassID);</span>

        // Property IDs
<span class="nc" id="L3419">        final Set&lt;PropertyID&gt; propIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3420" title="All 2 branches missed.">        if (newInterface.getPropertiesInIface() == null) {</span>
<span class="nc" id="L3421">            throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null properties list&quot;, false);</span>
        }
<span class="nc bnc" id="L3423" title="All 2 branches missed.">        for (final String propName : newInterface.getPropertiesInIface()) {</span>
<span class="nc" id="L3424">            final PropertyID propID = classMgrApi.getPropertyID(metaClassID, propName);</span>
<span class="nc" id="L3425">            propIDs.add(propID);</span>
<span class="nc" id="L3426">        }</span>
<span class="nc" id="L3427">        newInterface.setPropertiesIDs(propIDs);</span>

        // Operation IDs
<span class="nc" id="L3430">        final Set&lt;OperationID&gt; opIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3431" title="All 2 branches missed.">        if (newInterface.getOperationsSignatureInIface() == null) {</span>
<span class="nc" id="L3432">            throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null operations list&quot;, false);</span>
        }
<span class="nc bnc" id="L3434" title="All 2 branches missed.">        for (final String opSignature : newInterface.getOperationsSignatureInIface()) {</span>
<span class="nc" id="L3435">            final OperationID opID = classMgrApi.getOperationID(metaClassID, opSignature);</span>
<span class="nc" id="L3436">            opIDs.add(opID);</span>
<span class="nc" id="L3437">        }</span>
<span class="nc" id="L3438">        newInterface.setOperationsIDs(opIDs);</span>

        // =========== =========== //

        // Check interface exists
<span class="nc bnc" id="L3443" title="All 2 branches missed.">        if (interfaceMgrApi.existsInterface(newInterface.getProviderAccountName(), newInterface.getNamespace(),</span>
<span class="nc" id="L3444">                newInterface.getClassName(), newInterface.getPropertiesInIface(),</span>
<span class="nc" id="L3445">                newInterface.getOperationsSignatureInIface())) {</span>
<span class="nc" id="L3446">            throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Interface already exists&quot;, false);</span>
        }

        // Check namespace responsible =&gt; validates account
<span class="nc" id="L3450">        final HashSet&lt;InterfaceID&gt; interfacesOfImports = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3451">        Namespace namespaceInfo = null;</span>
        try {
<span class="nc" id="L3453">            namespaceInfo = checkNamespaceResponsible(accountID, credential, namespaceID);</span>
<span class="nc" id="L3454">        } catch (final AccountNotResponsibleOfNamespace e) {</span>
            // class ID does not exist in namespace, look for it in the imports
<span class="nc" id="L3456">            final Set&lt;ImportedInterface&gt; importedInterfaces = namespaceMgrApi.getImportedInterfaces(namespaceID,</span>
                    className);
<span class="nc bnc" id="L3458" title="All 2 branches missed.">            if (importedInterfaces.isEmpty()) {</span>
<span class="nc" id="L3459">                throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_CREATED_IN_NAMESPACE_NOR_IMPORTED,</span>
                        &quot;Class &quot; + className + &quot; not created in namespace {&quot; + namespaceID + &quot;}&quot;, false);
            }

            // Check imports
<span class="nc" id="L3464">            final Map&lt;ContractID, InterfaceID&gt; interfacesInContracts = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L3465" title="All 2 branches missed.">            for (final ImportedInterface importedInterface : importedInterfaces) {</span>
<span class="nc bnc" id="L3466" title="All 2 branches missed.">                if (metaClassID == null) { // first iteration</span>
<span class="nc" id="L3467">                    metaClassID = importedInterface.getClassOfImportID();</span>
                }

<span class="nc" id="L3470">                final InterfaceID previousValue = interfacesInContracts.put(importedInterface.getContractID(),</span>
<span class="nc" id="L3471">                        importedInterface.getInterfaceID());</span>
<span class="nc bnc" id="L3472" title="All 2 branches missed.">                if (previousValue != null) {</span>
                    // WARNING: This should not happen ever (18 Jun 2013 jmarti)
<span class="nc" id="L3474">                    throw new DataClayRuntimeException(ERRORCODE.CONTRACT_DUPLICATION);</span>
                }

<span class="nc" id="L3477">                interfacesOfImports.add(importedInterface.getInterfaceID());</span>
<span class="nc" id="L3478">            }</span>

            // Check interfaces in contracts
<span class="nc bnc" id="L3481" title="All 2 branches missed.">            if (!contractMgrApi.checkInterfacesInActiveContractsForAccount(accountID, interfacesInContracts)) {</span>
<span class="nc" id="L3482">                throw new DataClayRuntimeException(ERRORCODE.BAD_CONTRACT);</span>
            }

<span class="nc" id="L3485">        }</span>

<span class="nc" id="L3487">        final Set&lt;PropertyID&gt; propertiesIDs = newInterface.getPropertiesIDs();</span>
<span class="nc" id="L3488">        final Set&lt;OperationID&gt; operationsIDs = newInterface.getOperationsIDs();</span>
<span class="nc bnc" id="L3489" title="All 2 branches missed.">        if (namespaceInfo.getLanguage() == Langs.LANG_JAVA) { // Getters/setters do not apply to Python codes (jcosta</span>
            // 17/jun/2014)
            // Get operations IDs of default setters and getters
<span class="nc" id="L3492">            final Set&lt;OperationID&gt; gettersAndSetters = classMgrApi.getOperationsIDsOfGettersAndSetters(metaClassID,</span>
                    propertiesIDs);
<span class="nc" id="L3494">            operationsIDs.addAll(gettersAndSetters);</span>
        }

<span class="nc" id="L3497">        final InterfaceID ifaceID = interfaceMgrApi.newInterface(newInterface);</span>
<span class="nc" id="L3498">        return ifaceID;</span>

    }

    @Override
    public Interface getInterfaceInfo(final AccountID accountID, final PasswordCredential credential,
                                      final InterfaceID interfaceID) {
        // Validate account
<span class="nc bnc" id="L3506" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3507">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

        // Get contracts of account
<span class="nc" id="L3511">        final Map&lt;ContractID, Contract&gt; contractsOfAccount = contractMgrApi.getContractIDsOfApplicant(accountID);</span>

        // Check interface is present within the contracts of account
<span class="nc" id="L3514">        boolean found = false;</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">        for (final Entry&lt;ContractID, Contract&gt; curContract : contractsOfAccount.entrySet()) {</span>
<span class="nc" id="L3516">            final Contract contractInfo = curContract.getValue();</span>
<span class="nc" id="L3517">            found = contractInfo.getInterfacesInContract().containsKey(interfaceID);</span>
<span class="nc bnc" id="L3518" title="All 2 branches missed.">            if (found) {</span>
<span class="nc" id="L3519">                break;</span>
            }
<span class="nc" id="L3521">        }</span>
<span class="nc bnc" id="L3522" title="All 2 branches missed.">        if (!found) {</span>
<span class="nc" id="L3523">            throw new DataClayRuntimeException(ERRORCODE.INTERFACE_NOT_ACCESSIBLE);</span>
        }

<span class="nc" id="L3526">        final HashSet&lt;InterfaceID&gt; interfacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3527">        interfacesIDs.add(interfaceID);</span>
<span class="nc" id="L3528">        final Interface ifaceInfo = interfaceMgrApi.getInterfacesInfo(interfacesIDs).values().iterator().next();</span>

<span class="nc" id="L3530">        return ifaceInfo;</span>

    }

    @Override
    public void removeInterface(final AccountID accountID, final PasswordCredential credential,
                                final NamespaceID namespaceID, final InterfaceID interfaceID) {
        // Check namespace responsible
<span class="nc" id="L3538">        checkNamespaceResponsible(accountID, credential, namespaceID);</span>

        // Check there is no contract associated with the interface
<span class="nc bnc" id="L3541" title="All 2 branches missed.">        if (!contractMgrApi.checkInterfaceHasNoContracts(interfaceID)) {</span>
<span class="nc" id="L3542">            throw new DataClayRuntimeException(ERRORCODE.INTERFACE_WITH_CONTRACTS);</span>
        }

<span class="nc" id="L3545">        interfaceMgrApi.removeInterface(namespaceID, interfaceID);</span>

<span class="nc" id="L3547">    }</span>

    // ============== Metadata Service ==============//

	@Override
	public List&lt;ObjectID&gt; registerObjects(final List&lt;RegistrationInfo&gt; regInfos, final ExecutionEnvironmentID backendID,
			final Langs lang) {
<span class="nc" id="L3554">        LOGGER.debug(&quot;==&gt; Registering &quot; + regInfos.size() + &quot; objects on EE &quot; + backendID + &quot; of language &quot; + lang);</span>
<span class="nc" id="L3555">        List&lt;ObjectID&gt; newObjectIDs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3556" title="All 2 branches missed.">        for (RegistrationInfo regInfo : regInfos) {</span>
<span class="nc" id="L3557">            ObjectID newOID = registerObject(regInfo, backendID, lang);</span>
<span class="nc" id="L3558">            newObjectIDs.add(newOID);</span>
<span class="nc" id="L3559">        }</span>
<span class="nc" id="L3560">        LOGGER.debug(&quot;==&gt; Finished registration of objects &quot;);</span>
<span class="nc" id="L3561">        return newObjectIDs;</span>
    }

    private ObjectID registerObject(final RegistrationInfo regInfo, final ExecutionEnvironmentID backendID,
                                    final Langs lang) {

<span class="nc" id="L3567">		LOGGER.debug(&quot;==&gt; Registering object explicit call: &quot; + regInfo);</span>

		// Register the object in the metadataservice
<span class="nc" id="L3570">		final HashSet&lt;ExecutionEnvironmentID&gt; backendIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3571">		backendIDs.add(backendID);</span>
<span class="nc" id="L3572">		ObjectID objectIDofNewObject = regInfo.getObjectID();</span>
<span class="nc" id="L3573">		final SessionID ownerSessionID = regInfo.getStoreSessionID();</span>
<span class="nc" id="L3574">		final MetaClassID metaClassID = regInfo.getClassID();</span>
<span class="nc" id="L3575">		final String alias = regInfo.getAlias();</span>
<span class="nc" id="L3576">		DataSetID datasetIDforStore = null;</span>
<span class="nc" id="L3577">		AccountID ownerAccountID = null;</span>
<span class="nc bnc" id="L3578" title="All 2 branches missed.">		if (ownerSessionID == null) {</span>
			// objects created in federation or without session
			// TODO: create a general dataClay dataset and account
<span class="nc" id="L3581">			datasetIDforStore = dataSetMgrApi.getDataSetID(EXTERNAL_OBJECTS_DATASET_NAME);</span>
<span class="nc" id="L3582">			ownerAccountID = accountMgrApi.getAccountID(FEDERATOR_ACCOUNT_USERNAME);</span>
		} else {
		    try {
<span class="nc" id="L3585">                final SessionInfo sessionInfo = getSessionInfo(ownerSessionID);</span>
<span class="nc" id="L3586">                final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>
<span class="nc" id="L3587">                final DataContractID dataContractIDforStore = sessionInfo.getDataContractIDforStore();</span>
<span class="nc" id="L3588">                final SessionDataContract sessionDataContractOfStore = sessionDataInfo.get(dataContractIDforStore);</span>
<span class="nc" id="L3589">                datasetIDforStore = sessionDataContractOfStore.getDataSetOfProvider();</span>
<span class="nc" id="L3590">                ownerAccountID = sessionInfo.getAccountID();</span>
<span class="nc" id="L3591">            } catch (SessionNotExistException ex) {</span>
                // TODO: create a general dataClay dataset and account
<span class="nc" id="L3593">                datasetIDforStore = dataSetMgrApi.getDataSetID(EXTERNAL_OBJECTS_DATASET_NAME);</span>
<span class="nc" id="L3594">                ownerAccountID = accountMgrApi.getAccountID(FEDERATOR_ACCOUNT_USERNAME);</span>
<span class="nc" id="L3595">            }</span>
		}

<span class="nc bnc" id="L3598" title="All 2 branches missed.">        if (regInfo.getDataSetID() != null) {</span>
            // User specified dataset ID
<span class="nc" id="L3600">            datasetIDforStore = regInfo.getDataSetID();</span>
        }

        // If object is not registered, we register it with new alias included.
<span class="nc" id="L3604">        final MetaDataInfo info = metaDataSrvApi.registerObject(objectIDofNewObject, metaClassID, datasetIDforStore,</span>
<span class="nc" id="L3605">                backendIDs, Configuration.Flags.READONLY_BY_DEFAULT.getBooleanValue(), alias, lang, ownerAccountID);</span>
<span class="nc" id="L3606">        objectIDofNewObject = info.getDataClayID();</span>
        //TODO: notify GCs about new aliases

       /** if (alias != null &amp;&amp; !alias.isEmpty()) {
            // notify alias reference since it is the first alias (with registration)
            // first makePeristent(alias)
            final Map&lt;ObjectID, Integer&gt; referenceCounting = new HashMap&lt;&gt;();
            referenceCounting.put(objectIDofNewObject, 1);
            notifyGarbageCollectors(referenceCounting);
        } **/

<span class="nc" id="L3617">		LOGGER.debug(&quot;&lt;== Finished registration of object with ID &quot; + objectIDofNewObject);</span>
<span class="nc" id="L3618">        return objectIDofNewObject;</span>
	}

    @Override
    public void unregisterObjects(final Set&lt;ObjectID&gt; objectsToUnregister) {
<span class="nc bnc" id="L3623" title="All 2 branches missed.">        for (final ObjectID objectID : objectsToUnregister) {</span>
<span class="nc" id="L3624">            LOGGER.debug(&quot;** Unregistering object: &quot; + objectID);</span>
<span class="nc" id="L3625">            metaDataSrvApi.unregisterObject(objectID);</span>
            // if object is external and marked as unregister = true
<span class="nc bnc" id="L3627" title="All 2 branches missed.">            if (metaDataSrvApi.externalObjectIsUnregistered(objectID)) {</span>
<span class="nc" id="L3628">                LOGGER.debug(&quot;** Unregistering External object: &quot; + objectID);</span>
<span class="nc" id="L3629">                metaDataSrvApi.unregisterExternalObject(objectID);</span>
            }
<span class="nc" id="L3631">        }</span>
<span class="nc" id="L3632">        this.metaDataSrvApi.vacuumDB();</span>
<span class="nc" id="L3633">    }</span>

    @Override
    public void registerObjectFromGC(final RegistrationInfo regInfo, final ExecutionEnvironmentID backendID,
                                     final DataServiceRuntime clientLib) {
<span class="nc bnc" id="L3638" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3639">            LOGGER.debug(&quot;Registering object from GC: &quot; + regInfo.getObjectID());</span>
        }

<span class="nc" id="L3642">        final HashSet&lt;ExecutionEnvironmentID&gt; backendIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3643">        backendIDs.add(backendID);</span>

<span class="nc" id="L3645">        final ObjectID objectIDofNewObject = regInfo.getObjectID();</span>
<span class="nc" id="L3646">        final MetaClassID metaClassID = regInfo.getClassID();</span>
<span class="nc" id="L3647">        final SessionID ownerSessionID = regInfo.getStoreSessionID();</span>
<span class="nc" id="L3648">        final SessionInfo sessionInfo = getSessionInfo(ownerSessionID);</span>
<span class="nc" id="L3649">        final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>
<span class="nc" id="L3650">        final DataContractID dataContractIDforStore = sessionInfo.getDataContractIDforStore();</span>
<span class="nc" id="L3651">        final SessionDataContract sessionDataContractOfStore = sessionDataInfo.get(dataContractIDforStore);</span>
<span class="nc" id="L3652">        DataSetID datasetIDforStore = sessionDataContractOfStore.getDataSetOfProvider();</span>
<span class="nc bnc" id="L3653" title="All 2 branches missed.">        if (regInfo.getDataSetID() != null) {</span>
            // User specified dataset ID
<span class="nc" id="L3655">            datasetIDforStore = regInfo.getDataSetID();</span>
        }
        try {
<span class="nc" id="L3658">            metaDataSrvApi.registerObject(objectIDofNewObject, metaClassID, datasetIDforStore, backendIDs,</span>
<span class="nc" id="L3659">                    Configuration.Flags.READONLY_BY_DEFAULT.getBooleanValue(), null, Langs.LANG_JAVA,</span>
<span class="nc" id="L3660">                    sessionInfo.getAccountID());</span>
<span class="nc" id="L3661">        } catch (final SessionNotExistException sessExpiredExc) {</span>
<span class="nc" id="L3662">            LOGGER.debug(&quot;The session does not exist&quot;, sessExpiredExc);</span>

            // ignore this session till design of what to do with objects persisted and
            // sessions closed before
            // actually registered: PULL hearth-bate from nodes, for instance.
<span class="nc" id="L3667">        }</span>
<span class="nc" id="L3668">    }</span>


    @Override
    public Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getAllExecutionEnvironmentsInfo(final Langs execEnvLang,
                                                                                             final boolean getExternal,
                                                                                             final boolean fromBackend) {
<span class="nc" id="L3675">        final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvs = this.logicMetadataMgr</span>
<span class="nc" id="L3676">                .getAllExecutionEnvironmentsInfo(execEnvLang);</span>

<span class="nc bnc" id="L3678" title="All 4 branches missed.">        if (!fromBackend &amp;&amp; exposedIPForClient != null) {</span>
            // All information send to client will use exposed IP configured
<span class="nc bnc" id="L3680" title="All 2 branches missed.">            for (final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; ee : execEnvs.entrySet()) {</span>
<span class="nc" id="L3681">                ee.getValue().setHostname(exposedIPForClient);</span>
<span class="nc" id="L3682">            }</span>
        }
<span class="nc bnc" id="L3684" title="All 2 branches missed.">        if (getExternal) {</span>
<span class="nc bnc" id="L3685" title="All 2 branches missed.">            for (DataClayInstanceID externalDataClayID : this.logicMetadataMgr.getAllExternalDataClays()) {</span>

                // Get external logicmodule
<span class="nc" id="L3688">                LogicModuleAPI externalLogicModule = null;</span>
                try {
<span class="nc" id="L3690">                    externalLogicModule = this.getExternalLogicModule(this.getExternalDataClayInfo(externalDataClayID));</span>
<span class="nc" id="L3691">                } catch (InterruptedException e) {</span>
<span class="nc" id="L3692">                    throw new RuntimeException(e);</span>
<span class="nc" id="L3693">                }</span>

                // Get external exec envs
<span class="nc" id="L3696">                Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; result = externalLogicModule.getAllExecutionEnvironmentsInfo(execEnvLang, false, false);</span>
<span class="nc" id="L3697">                execEnvs.putAll(result);</span>
<span class="nc" id="L3698">            }</span>
        }


<span class="nc bnc" id="L3702" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc bnc" id="L3703" title="All 2 branches missed.">            for (ExecutionEnvironment execEnv : execEnvs.values()) {</span>
<span class="nc" id="L3704">                LOGGER.debug(&quot;Found execution environment with ID {}: {}&quot;, execEnv.getDataClayID(), execEnv);</span>
<span class="nc" id="L3705">            }</span>
        }

<span class="nc" id="L3708">        return execEnvs;</span>
    }


    /**
     * Get all storage locations information
     * @return Storage location infos
     */
    private Map&lt;StorageLocationID, StorageLocation&gt; getAllStorageLocationsInfo() {
<span class="nc" id="L3717">        final Map&lt;StorageLocationID, StorageLocation&gt; stLocs = logicMetadataMgr.getAllStorageLocationsInfo();</span>
<span class="nc" id="L3718">        return stLocs;</span>
    }

    @Override
    public StorageLocation getStorageLocationInfo(final StorageLocationID backendID,
                                                      final boolean fromBackend) {
<span class="nc" id="L3724">        StorageLocation stLoc = logicMetadataMgr.getStorageLocationInfo(backendID);</span>
<span class="nc bnc" id="L3725" title="All 4 branches missed.">        if (!fromBackend &amp;&amp; exposedIPForClient != null) {</span>
            // All information send to client will use exposed IP configured
<span class="nc" id="L3727">            stLoc.setHostname(exposedIPForClient);</span>
        }
<span class="nc" id="L3729">        return stLoc;</span>

    }

    @Override
    public ExecutionEnvironment getExecutionEnvironmentInfo(final ExecutionEnvironmentID backendID,
                                                            final boolean fromBackend) {
<span class="nc" id="L3736">        ExecutionEnvironment execEnv = logicMetadataMgr.getExecutionEnvironmentInfo(backendID);</span>
<span class="nc bnc" id="L3737" title="All 4 branches missed.">        if (!fromBackend &amp;&amp; exposedIPForClient != null) {</span>
            // All information send to client will use exposed IP configured
<span class="nc" id="L3739">            execEnv.setHostname(exposedIPForClient);</span>
        }
<span class="nc" id="L3741">        LOGGER.debug(&quot;Found execution environment with ID {}: {}&quot;, backendID, execEnv);</span>
<span class="nc" id="L3742">        return execEnv;</span>

    }

    @Override
    public Tuple&lt;String, String&gt; getObjectInfo(final SessionID sessionID, final ObjectID objectID) {

        // FIXME: Looks like this method is not used anymore! (July 2018 jmarti)

        // Get session info if needed
<span class="nc" id="L3752">        SessionInfo sessionInfo = null;</span>
<span class="nc bnc" id="L3753" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3754">            sessionInfo = getSessionInfo(sessionID);</span>
        }

        // Get object info
<span class="nc" id="L3758">        final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L3759" title="All 2 branches missed.">        if (metadataInfo == null) {</span>
<span class="nc" id="L3760">            throw new DbObjectNotExistException(objectID);</span>
        }

        // Check dataset if needed
<span class="nc bnc" id="L3764" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3765">            checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
        }

<span class="nc" id="L3768">        return classMgrApi.getClassNameAndNamespace(metadataInfo.getMetaclassID());</span>

    }

    @Override
    public Triple&lt;ObjectID, MetaClassID, ExecutionEnvironmentID&gt; getObjectFromAlias(final SessionID sessionID,
                                                                                    final String alias) {
        try {

<span class="nc bnc" id="L3777" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3778">				LOGGER.debug(&quot;==&gt; Starting get object from alias for alias &quot; + alias);</span>
			}

            // Get session if needed
<span class="nc" id="L3782">            SessionInfo sessionInfo = null;</span>
<span class="nc bnc" id="L3783" title="All 2 branches missed.">            if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3784">                sessionInfo = getSessionInfo(sessionID);</span>
            }

<span class="nc bnc" id="L3787" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3788">                LOGGER.debug(&quot;Get object info from alias &quot; + alias);</span>
            }
<span class="nc" id="L3790">            final Tuple&lt;ObjectID, MetaDataInfo&gt; infoOfObject = metaDataSrvApi.getObjectInfoFromAlias(alias);</span>
<span class="nc" id="L3791">            final MetaDataInfo metadataInfo = infoOfObject.getSecond();</span>

            // Check dataset
<span class="nc bnc" id="L3794" title="All 2 branches missed.">            if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc bnc" id="L3795" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3796">                    LOGGER.debug(&quot;Check dataset is among datacontract for object with alias &quot; + alias);</span>
                }
<span class="nc" id="L3798">                checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
            }

<span class="nc" id="L3801">            final ObjectID result = infoOfObject.getFirst();</span>
<span class="nc" id="L3802">            final MetaClassID mclassID = metadataInfo.getMetaclassID();</span>
<span class="nc" id="L3803">            final ExecutionEnvironmentID execID = metadataInfo.getLocations().iterator().next();</span>
<span class="nc bnc" id="L3804" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3805">                LOGGER.debug(&quot;Returning object with id {} and alias {}&quot;, result, alias);</span>
            }
<span class="nc" id="L3807">            return new Triple&lt;&gt;(result, mclassID, execID);</span>
<span class="nc" id="L3808">        } catch (final Exception ex) {</span>
<span class="nc" id="L3809">            LOGGER.debug(&quot;getObjectFromAlias error&quot;, ex);</span>
<span class="nc" id="L3810">            throw ex;</span>
        }
    }

    @Override
    public ObjectID deleteAlias(final SessionID sessionID, final String alias) {
        try {
<span class="nc bnc" id="L3817" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3818">                LOGGER.debug(&quot;Starting delete alias &quot; + alias);</span>
            }

<span class="nc" id="L3821">            final Tuple&lt;ObjectID, MetaDataInfo&gt; infoOfObject = metaDataSrvApi.getObjectInfoFromAlias(alias);</span>
<span class="nc" id="L3822">            final MetaDataInfo metadataInfo = infoOfObject.getSecond();</span>

            // Check session if needed
<span class="nc bnc" id="L3825" title="All 2 branches missed.">            if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3826">                final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc bnc" id="L3827" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3828">                    LOGGER.debug(&quot;Check dataset is among datacontract for object with alias &quot; + alias);</span>
                }
<span class="nc" id="L3830">                checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
            }

            // Delete alias if can access object
<span class="nc" id="L3834">            final ObjectID objectID = metaDataSrvApi.deleteAlias(alias);</span>

            // Notify GC of each EE where a replica is located to add -1 reference
            // TODO: check how GC works with alias removal from DS
            /** final Map&lt;ObjectID, Integer&gt; referenceCounting = new HashMap&lt;&gt;();
            referenceCounting.put(objectID, -1);
            notifyGarbageCollectors(referenceCounting); **/

<span class="nc" id="L3842">            return objectID;</span>

<span class="nc" id="L3844">        } catch (final Exception ex) {</span>
<span class="nc" id="L3845">            LOGGER.debug(&quot;deleteAlias error&quot;, ex);</span>
<span class="nc" id="L3846">            throw new DataClayRuntimeException(ERRORCODE.UNKNOWN_EXCEPTION, &quot;deleteAlias failed&quot;, false);</span>
        }
    }


    @Override
    public Map&lt;ObjectID, MetaDataInfo&gt; getObjectsMetaDataInfoOfClassForNM(final MetaClassID classID) {
        // TODO We have to ensure that only Notification Manager can access this method
        // (3 Mar 2016 jmarti)
<span class="nc" id="L3855">        return metaDataSrvApi.getObjectsOfSpecificClass(classID);</span>
    }

    @Override
    public DataClayInstanceID getDataClayID() {
<span class="nc" id="L3860">        return publicIDs.dcID;</span>
    }

    /**
     * Get API to connect with external LogicModule
     *
     * @param dcInfo
     *            DataClayInstance of external DataClay
     * @return API to connect with external LogicModule
     * @throws InterruptedException
     *             if connection failed
     */
    private LogicModuleAPI getExternalLogicModule(final DataClayInstance dcInfo) throws InterruptedException {

<span class="nc" id="L3874">        LogicModuleAPI lmExternal = null;</span>
<span class="nc" id="L3875">        final List&lt;String&gt; hosts = dcInfo.getHosts();</span>
<span class="nc" id="L3876">        final List&lt;Integer&gt; ports = dcInfo.getPorts();</span>
<span class="nc" id="L3877">        final List&lt;String&gt; missedhosts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3878">        final List&lt;Integer&gt; missedports = new ArrayList&lt;&gt;();</span>

        try {
<span class="nc bnc" id="L3881" title="All 2 branches missed.">            for (int i = 0; i &lt; hosts.size(); i++) {</span>
                try {
<span class="nc" id="L3883">                    LOGGER.debug(&quot;Getting dataClay at &quot; + hosts.get(i) + &quot;:&quot; + ports.get(i) + &quot;&quot;);</span>
<span class="nc" id="L3884">                    lmExternal = grpcClient.getLogicModuleAPI(hosts.get(i), ports.get(i));</span>
<span class="nc" id="L3885">                    lmExternal.checkAlive();</span>
<span class="nc" id="L3886">                    break;</span>
<span class="nc" id="L3887">                } catch (final Exception e) {</span>
<span class="nc" id="L3888">                    LOGGER.debug(&quot;Could not connect to dataClay &quot; + hosts.get(i)</span>
<span class="nc" id="L3889">                            + &quot;:&quot; + ports.get(i) + &quot;. Trying another address.&quot;);</span>
<span class="nc" id="L3890">                    missedhosts.add(hosts.get(i));</span>
<span class="nc" id="L3891">                    missedports.add(ports.get(i));</span>

<span class="nc bnc" id="L3893" title="All 2 branches missed.">                    if (i + 1 == hosts.size()) {</span>
<span class="nc" id="L3894">                        throw e;</span>
                    }
                }
            }
        } finally {
            // remove missed addresses from metadata
<span class="nc bnc" id="L3900" title="All 2 branches missed.">            if (missedhosts.size() &gt; 0) {</span>
<span class="nc" id="L3901">                final int i = 0;</span>
<span class="nc bnc" id="L3902" title="All 2 branches missed.">                for (final String missedhost : missedhosts) {</span>
<span class="nc" id="L3903">                    final Integer missedport = missedports.get(i);</span>
<span class="nc" id="L3904">                    LOGGER.debug(&quot;Unregistering &quot; + hosts.get(i) + &quot;:&quot; + ports.get(i) + &quot; external dataClay&quot;);</span>
<span class="nc" id="L3905">                    logicMetadataMgr.unregisterExternalDataClayAddress(missedhost, missedport);</span>
<span class="nc" id="L3906">                }</span>
            }
        }
<span class="nc" id="L3909">        return lmExternal;</span>
    }

    @Override
    public DataClayInstanceID getExternalDataClayID(final String dcHost, final int dcPort) {
        try {
<span class="nc bnc" id="L3915" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3916">                LOGGER.debug(&quot;Getting external dataClay ID at {}:{}&quot;, dcHost, dcPort);</span>
            }
            // Get it from MDservice
<span class="nc" id="L3919">            return logicMetadataMgr.getExternalDataClayID(dcHost, dcPort);</span>
<span class="nc" id="L3920">        } catch (final Exception ex) {</span>
<span class="nc" id="L3921">            LOGGER.debug(&quot;External dataClay at {}:{} not found. Returning null.&quot;, dcHost, dcPort);</span>
<span class="nc" id="L3922">            return null;</span>
        }
    }

    @Override
    public DataClayInstance getExternalDataClayInfo(final DataClayInstanceID extDataClayID) {
        try {
<span class="nc" id="L3929">            final DataClayInstance dcInstance = logicMetadataMgr.getExternalDataClayInfo(extDataClayID);</span>
<span class="nc" id="L3930">            return dcInstance;</span>
<span class="nc" id="L3931">        } catch (final ExternalDataClayNotRegisteredException edn) {</span>
<span class="nc" id="L3932">            return null;</span>
        }
    }

    @Override
    public DataClayInstanceID registerExternalDataClay(final String thehostname, final int theport) {

<span class="nc bnc" id="L3939" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3940">            LOGGER.debug(&quot;Registering external dataClay at {}:{}&quot;, thehostname, theport);</span>

        }
<span class="nc" id="L3943">        return registerExternalDataClayAux(thehostname, theport);</span>
    }

    /**
     * Register external dataclay aux function
     * @param thehostname Hostname
     * @param theport Port
     * @return ID of the registered external dataclay
     */
    private DataClayInstanceID registerExternalDataClayAux(final String thehostname,
                                                           final int theport) {
        try {


<span class="nc" id="L3957">            final DataClayInstanceID id = getExternalDataClayID(thehostname, theport);</span>
<span class="nc bnc" id="L3958" title="All 2 branches missed.">            if (id != null) {</span>
<span class="nc bnc" id="L3959" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3960">                    LOGGER.debug(&quot;Already registered external dataClay at {}:{}&quot;, thehostname, theport);</span>
                }
<span class="nc" id="L3962">                return id; //Already registered</span>
            }

<span class="nc" id="L3965">            final LogicModuleAPI lmExternal = grpcClient.getLogicModuleAPI(thehostname, theport);</span>

<span class="nc" id="L3967">            String myHostname = this.hostname;</span>
<span class="nc bnc" id="L3968" title="All 2 branches missed.">            if (exposedIPForClient != null) {</span>
<span class="nc" id="L3969">                myHostname = exposedIPForClient;</span>
            }

<span class="nc" id="L3972">            final DataClayInstanceID dcID = lmExternal.notifyRegistrationOfExternalDataClay(this.getDataClayID(),</span>
                    myHostname, this.port);
<span class="nc" id="L3974">            final DataClayInstance dcInstance = new DataClayInstance(dcID, thehostname, theport);</span>
<span class="nc" id="L3975">            logicMetadataMgr.registerExternalDataclay(dcInstance);</span>
<span class="nc bnc" id="L3976" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3977">                LOGGER.debug(&quot;Registered external dataClay {}&quot;, dcInstance);</span>
            }
<span class="nc" id="L3979">            return dcID;</span>
<span class="nc" id="L3980">        } catch (final Exception ex) {</span>
<span class="nc bnc" id="L3981" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3982">                LOGGER.debug(&quot;Exception produced during registration of external dataClay&quot;, ex);</span>
            }
<span class="nc" id="L3984">            return null;</span>
        }
    }

    @Override
    public DataClayInstanceID registerExternalDataClayOverrideAuthority(final AccountID adminAccountID, final PasswordCredential adminCredential,
                                                                        final String thehostname, final int theport, final String authority) {

        // Validate admin account
<span class="nc" id="L3993">        this.accountMgrApi.validateAccount(adminAccountID, adminCredential, AccountRole.ADMIN_ROLE);</span>

        // NOTE: currently not implemented to beware of concurrent modifications of the SSL_AUTHORITY configuration field
<span class="nc" id="L3996">        Configuration.Flags.SSL_TARGET_AUTHORITY.setValue(authority);</span>

<span class="nc" id="L3998">        return this.registerExternalDataClayAux(thehostname, theport);</span>

    }

    @Override
    public DataClayInstanceID notifyRegistrationOfExternalDataClay(final DataClayInstanceID dataClayInstanceID,
                                                                   final String thehostname, final int theport) {
        try {
<span class="nc" id="L4006">            final DataClayInstance dcInstance = new DataClayInstance(dataClayInstanceID, thehostname, theport);</span>
<span class="nc" id="L4007">            logicMetadataMgr.registerExternalDataclay(dcInstance);</span>
<span class="nc bnc" id="L4008" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4009">                LOGGER.debug(&quot;Notified registration of external dataClay {}&quot;, dcInstance);</span>
            }
<span class="nc" id="L4011">            return this.getDataClayID();</span>
<span class="nc" id="L4012">        } catch (final Exception ex) {</span>
<span class="nc bnc" id="L4013" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4014">                LOGGER.debug(&quot;Exception produced during registration of external dataClay&quot;, ex);</span>
            }
<span class="nc" id="L4016">            return null;</span>
        }
    }

    @Override
    public Tuple&lt;Namespace, Set&lt;MetaClass&gt;&gt; getClassesInNamespace(final String namespaceName) {
<span class="nc" id="L4022">        NamespaceID namespaceID = this.namespaceMgrApi.getNamespaceID(namespaceName);</span>
<span class="nc" id="L4023">        final Map&lt;MetaClassID, MetaClass&gt; classesToFederate = this.classMgrApi.getInfoOfClassesInNamespace(namespaceID);</span>
<span class="nc" id="L4024">        final Namespace namespaceToFederate = namespaceMgrApi.getNamespaceInfo(namespaceID);</span>
<span class="nc" id="L4025">        Set&lt;MetaClass&gt; metaClassesToFederate = new HashSet&lt;MetaClass&gt;(classesToFederate.values());</span>
<span class="nc" id="L4026">        return new Tuple&lt;Namespace, Set&lt;MetaClass&gt;&gt;(namespaceToFederate, metaClassesToFederate);</span>

    }

    @Override
    public void importModelsFromExternalDataClay(final String extNamespaceName, final DataClayInstanceID extDataClayID) {

        // Get all information needed from external dataClay instance
<span class="nc" id="L4034">        LogicModuleAPI externalLogicModule = null;</span>
        try {
<span class="nc" id="L4036">            externalLogicModule = this.getExternalLogicModule(this.getExternalDataClayInfo(extDataClayID));</span>
<span class="nc" id="L4037">        } catch (InterruptedException e) {</span>
<span class="nc" id="L4038">            throw new RuntimeException(e);</span>
<span class="nc" id="L4039">        }</span>
<span class="nc" id="L4040">        Tuple&lt;Namespace, Set&lt;MetaClass&gt;&gt; toRegister = externalLogicModule.getClassesInNamespace(extNamespaceName);</span>
<span class="nc" id="L4041">        Namespace namespace = toRegister.getFirst();</span>
<span class="nc" id="L4042">        Set&lt;MetaClass&gt; classesToRegister = toRegister.getSecond();</span>

        // Register namespace
<span class="nc" id="L4045">        this.namespaceMgrApi.getDbHandler().store(namespace);</span>

        // Register metaClasses
<span class="nc" id="L4048">        ClassManagerDB classMgrDbHandler = this.classMgrApi.getDbHandler();</span>
<span class="nc" id="L4049">        Set&lt;String&gt; metaClassesToInstall = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4050">        Map&lt;NamespaceID, Namespace&gt; namespaceInfos = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4051">        namespaceInfos.put(namespace.getDataClayID(), namespace);</span>
<span class="nc bnc" id="L4052" title="All 2 branches missed.">        for (MetaClass metaClass : classesToRegister) {</span>
<span class="nc" id="L4053">            classMgrDbHandler.storeMetaClass(metaClass);</span>
<span class="nc" id="L4054">            metaClassesToInstall.add(metaClass.getName());</span>
<span class="nc" id="L4055">        }</span>
        // Outsource classes to dataservices
<span class="nc" id="L4057">        Langs language = namespace.getLanguage();</span>
<span class="nc bnc" id="L4058" title="All 2 branches missed.">        if (language == Langs.LANG_JAVA) {</span>
<span class="nc" id="L4059">            outsourceClassesDeploymentJava(classesToRegister, metaClassesToInstall, namespaceInfos,</span>
                    null, null);
<span class="nc bnc" id="L4061" title="All 2 branches missed.">        } else if (language == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L4062">            outsourceClassesDeploymentPython(classesToRegister, metaClassesToInstall, namespaceInfos,</span>
                    null, null);
        }
<span class="nc" id="L4065">    }</span>

    // ============== Data Service ==============//

    @Override
    public void setDataSetID(final SessionID sessionID, final ObjectID objectID, final DataSetID dataSetID) {
        // Check session exists if needed
<span class="nc bnc" id="L4072" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4073">            getSessionInfo(sessionID);</span>
        }
<span class="nc" id="L4075">        metaDataSrvApi.changeDataSetID(objectID, dataSetID);</span>
<span class="nc" id="L4076">    }</span>

    @Override
    public void setDataSetIDFromGarbageCollector(final ObjectID objectID, final DataSetID dataSetID) {
<span class="nc" id="L4080">        metaDataSrvApi.changeDataSetID(objectID, dataSetID);</span>
<span class="nc" id="L4081">    }</span>

    @Override
    public List&lt;ObjectID&gt; moveObject(final SessionID sessionID, final ObjectID objectID,
                                     final ExecutionEnvironmentID srcLocationID, final ExecutionEnvironmentID destLocationID,
                                     final boolean recursive) {

<span class="nc" id="L4088">        final List&lt;ObjectID&gt; allMovedObjects = new ArrayList&lt;&gt;();</span>
        try {
            // Get object info
<span class="nc" id="L4091">            final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4092" title="All 2 branches missed.">            if (metadataInfo == null) {</span>
<span class="nc" id="L4093">                throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
            }

            // Check session if needed
<span class="nc bnc" id="L4097" title="All 2 branches missed.">            if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4098">                final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L4099">                final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>

                // Check dataset
<span class="nc" id="L4102">                checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>
            }

            // Check object is present in srcBackend
<span class="nc" id="L4106">            final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locations = metaDataSrvApi</span>
<span class="nc" id="L4107">                    .getObjectBackends(objectID);</span>
<span class="nc bnc" id="L4108" title="All 2 branches missed.">            if (!locations.containsKey(srcLocationID)) {</span>
<span class="nc" id="L4109">                throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_IN_BACKEND);</span>
            }

            // Move replica object from source to dest
<span class="nc" id="L4113">            final ExecutionEnvironment srcLoc = locations.get(srcLocationID);</span>

<span class="nc" id="L4115">            final DataServiceAPI dataServiceApi = getExecutionEnvironmentAPI(srcLoc);</span>
<span class="nc" id="L4116">            final Set&lt;ObjectID&gt; movedObjs = dataServiceApi.moveObjects(sessionID, objectID, destLocationID, recursive);</span>
<span class="nc" id="L4117">            allMovedObjects.addAll(movedObjs);</span>

            // Register the movement
<span class="nc" id="L4120">            final Map&lt;ObjectID, MetaDataInfo&gt; newMetaDatas = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4121" title="All 2 branches missed.">            for (final ObjectID movedObjID : movedObjs) {</span>
                try {
<span class="nc" id="L4123">                    metaDataSrvApi.migrateObjectToBackend(movedObjID, srcLocationID, destLocationID);</span>
<span class="nc" id="L4124">                    final MetaDataInfo mdInfo = metaDataSrvApi.getObjectMetaData(objectID);</span>
<span class="nc" id="L4125">                    newMetaDatas.put(objectID, mdInfo);</span>
<span class="nc" id="L4126">                } catch (final Exception ex) {</span>
<span class="nc" id="L4127">                    LOGGER.debug(&quot;Error in moveObject, ignoring&quot;, ex);</span>
<span class="nc" id="L4128">                    continue;</span>
<span class="nc" id="L4129">                }</span>
<span class="nc" id="L4130">            }</span>

            // Update all md Caches in ALL nodes
            /*
             * for (Tuple&lt;DataServiceAPI, StorageLocation&gt; ds : getDsAPIs().values()) {
             * ds.getFirst().newMetaData(newMetaDatas); }
             */
<span class="nc" id="L4137">        } catch (final Exception ex) {</span>
<span class="nc" id="L4138">            LOGGER.debug(&quot;moveObject error&quot;, ex);</span>
<span class="nc" id="L4139">            throw ex;</span>
<span class="nc" id="L4140">        }</span>

<span class="nc" id="L4142">        return allMovedObjects;</span>
    }

    @Override
    public void setObjectReadOnly(final SessionID sessionID, final ObjectID objectID) {
        // Check session if needed
<span class="nc bnc" id="L4148" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4149">            final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L4150">            final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>

            // Get object info
<span class="nc" id="L4153">            final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4154" title="All 2 branches missed.">            if (metadataInfo == null) {</span>
<span class="nc" id="L4155">                throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
            }

            // Check dataset
<span class="nc" id="L4159">            checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>
        }

        // Perform op
<span class="nc" id="L4163">        metaDataSrvApi.setObjectReadOnly(objectID);</span>
<span class="nc" id="L4164">    }</span>

    @Override
    public void setObjectReadWrite(final SessionID sessionID, final ObjectID objectID) {
        // Check session if needed
<span class="nc bnc" id="L4169" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4170">            final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L4171">            final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>

            // Get object info
<span class="nc" id="L4174">            final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4175" title="All 2 branches missed.">            if (metadataInfo == null) {</span>
<span class="nc" id="L4176">                throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
            }

            // Check dataset
<span class="nc" id="L4180">            checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>
        }

        // Perform op
<span class="nc" id="L4184">        metaDataSrvApi.setObjectReadWrite(objectID);</span>

<span class="nc" id="L4186">    }</span>

    @Override
    public MetaDataInfo getMetadataByOID(final SessionID sessionID, final ObjectID objectID) {
        try {
            // Check session
<span class="nc" id="L4192">            SessionInfo sessionInfo = null;</span>
<span class="nc bnc" id="L4193" title="All 2 branches missed.">            if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4194">                sessionInfo = getSessionInfo(sessionID);</span>
            }

            // Get object info
<span class="nc" id="L4198">            final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4199" title="All 2 branches missed.">            if (metadataInfo == null) {</span>
                // In this case, return null instead of Exception for performance purposes
<span class="nc bnc" id="L4201" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4202">                    LOGGER.debug(&quot;[==GetMetadataByOID==] Object not found. Sending null.&quot;);</span>
                }
<span class="nc" id="L4204">                return null;</span>
            }
<span class="nc bnc" id="L4206" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4207">                LOGGER.debug(&quot;[==GetMetadataByOID==] Object found. Sending &quot; + objectID + &quot; metadata with locations &quot;</span>
<span class="nc" id="L4208">                        + metadataInfo.getLocations());</span>
            }

            // Check dataset
<span class="nc bnc" id="L4212" title="All 2 branches missed.">            if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4213">                checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
            }
<span class="nc" id="L4215">            return metadataInfo;</span>

<span class="nc" id="L4217">        } catch (final Exception ex) {</span>
<span class="nc" id="L4218">            LOGGER.debug(&quot;getMetadataByOID error&quot;, ex);</span>
<span class="nc" id="L4219">            throw ex;</span>
        }

    }

    @Override
    public MetaDataInfo getMetadataByOIDForDS(final ObjectID objectID) {
        try {
            // Get object info
<span class="nc" id="L4228">            final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc" id="L4229">            return metadataInfo;</span>

<span class="nc" id="L4231">        } catch (final Exception ex) {</span>
<span class="nc" id="L4232">            LOGGER.debug(&quot;getMetadataByOIDForDS error&quot;, ex);</span>
<span class="nc" id="L4233">            throw ex;</span>
        }

    }

    @Override
    public SerializedParametersOrReturn executeMethodOnTarget(final SessionID sessionID, final ObjectID objectID,
                                                              final String operationSignature, final SerializedParametersOrReturn params,
                                                              final ExecutionEnvironmentID backendID) {
        // Get object metadata
<span class="nc" id="L4243">        final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4244" title="All 2 branches missed.">        if (metadataInfo == null) {</span>
<span class="nc" id="L4245">            return null;</span>
        }

        // Get model info
<span class="nc" id="L4249">        final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L4250">        final Map&lt;ContractID, SessionContract&gt; sessionModelInfo = sessionInfo.getSessionContracts();</span>

        // Check datasets in session
<span class="nc bnc" id="L4253" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4254">            final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>
<span class="nc" id="L4255">            checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>
        }

        // Get method id from the class of object
<span class="nc" id="L4259">        final MetaClassID classID = metadataInfo.getMetaclassID();</span>
<span class="nc" id="L4260">        final OperationID opID = classMgrApi.getOperationID(classID, operationSignature);</span>

        // Find an implementation that matches with the operation signature for the
        // current session
<span class="nc" id="L4264">        ImplementationID remoteImplementationID = null;</span>
<span class="nc bnc" id="L4265" title="All 2 branches missed.">        for (final SessionContract sc : sessionModelInfo.values()) {</span>
<span class="nc bnc" id="L4266" title="All 2 branches missed.">            for (final SessionInterface si : sc.getSessionInterfaces().values()) {</span>
<span class="nc bnc" id="L4267" title="All 2 branches missed.">                for (final SessionOperation so : si.getSessionOperations().values()) {</span>
<span class="nc bnc" id="L4268" title="All 2 branches missed.">                    if (so.getOperationID().equals(opID)) {</span>
<span class="nc" id="L4269">                        remoteImplementationID = so.getSessionRemoteImplementation().getImplementationID();</span>
                    }
<span class="nc" id="L4271">                }</span>
<span class="nc" id="L4272">            }</span>
<span class="nc" id="L4273">        }</span>

<span class="nc bnc" id="L4275" title="All 2 branches missed.">        if (remoteImplementationID != null) {</span>
<span class="nc" id="L4276">            return executeMethodOnTargetInternal(sessionID, remoteImplementationID, objectID, metadataInfo, params,</span>
                    backendID);
        } else {
<span class="nc" id="L4279">            throw new DataClayRuntimeException(ERRORCODE.IMPLEMENTATION_NOT_EXIST);</span>
        }
    }

    /**
     * Internal function for execute implementation.
     *
     * @param origSession
     *            ID of the original session corresponding to initial application
     *            launcher
     * @param remoteImplementationID
     *            ID of the implementation executed
     * @param objectID
     *            ID of the object
     * @param metadataInfo
     *            Info of the object
     * @param params
     *            Parameters to the method
     * @param targetBackend
     *            Backend where the task must be executed
     * @return Object resulting of the execution of the implementation (all of them
     *         sepparately) @
     */
    private SerializedParametersOrReturn executeMethodOnTargetInternal(final SessionID origSession,
                                                                       final ImplementationID remoteImplementationID, final ObjectID objectID, final MetaDataInfo metadataInfo,
                                                                       final SerializedParametersOrReturn params, final ExecutionEnvironmentID targetBackend) {

<span class="nc" id="L4306">        final Set&lt;ExecutionEnvironmentID&gt; backendss = metadataInfo.getLocations();</span>
<span class="nc bnc" id="L4307" title="All 2 branches missed.">        if (!backendss.contains(targetBackend)) {</span>
            // TODO Should we create a temporal replica of the object for the execution? (17
            // Apr 2015 jmarti)
<span class="nc" id="L4310">            throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_IN_BACKEND,</span>
                    &quot;Object is not in the backend where the method has to be executed&quot;, false);
        }
<span class="nc" id="L4313">        ExecutionEnvironment backend = this.getExecutionEnvironmentInfo(targetBackend, true);</span>

        // Get the language for the current session
<span class="nc" id="L4316">        final Langs sessionLang = getSessionInfo(origSession).getLanguage();</span>

        // Execute the method
        // Limit retries depending on the current set of replicas of the object
<span class="nc" id="L4320">        SerializedParametersOrReturn resultObj = null;</span>
<span class="nc" id="L4321">        final DataServiceAPI dataSrvApi = getExecutionEnvironmentAPI(backend);</span>
<span class="nc" id="L4322">        resultObj = dataSrvApi.executeImplementation(objectID, remoteImplementationID, params, origSession);</span>

<span class="nc" id="L4324">        return resultObj;</span>

    }

    @Override
    public SerializedParametersOrReturn executeImplementation(final SessionID sessionID, final OperationID operationID,
                                                              final Triple&lt;ImplementationID, ContractID, InterfaceID&gt; remoteImplementation, final ObjectID objectID,
                                                              final SerializedParametersOrReturn params) {

        // ----------------- SESSION CHECKS ------------- //
        final MetaDataInfo metadataInfo;
        final SessionInfo sessionInfo;
<span class="nc bnc" id="L4336" title="All 2 branches missed.">        if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4337">            final Tuple&lt;SessionInfo, MetaDataInfo&gt; checkedInfo = executionClientChecksAndGetInfo(sessionID, objectID,</span>
                    remoteImplementation, operationID);
<span class="nc" id="L4339">            sessionInfo = checkedInfo.getFirst();</span>
<span class="nc" id="L4340">            metadataInfo = checkedInfo.getSecond();</span>
<span class="nc" id="L4341">        } else {</span>
<span class="nc" id="L4342">            sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L4343">            metadataInfo = getObjectMetadata(objectID);</span>
        }
<span class="nc bnc" id="L4345" title="All 2 branches missed.">        if (metadataInfo == null) {</span>
<span class="nc" id="L4346">            return null;</span>
        }

        // ------------------ EXECUTE ------------------ //

        // Get the language for the current session
<span class="nc" id="L4352">        final Langs sessionLang = sessionInfo.getLanguage();</span>

        // TODO: How should this be executed? in all backends or not? (jmarti 6 Apr
        // 2018)
<span class="nc" id="L4356">        final ImplementationID remoteImplementationID = remoteImplementation.getFirst();</span>
<span class="nc" id="L4357">        final SerializedParametersOrReturn result = executeImplementationInternal(sessionID, remoteImplementationID,</span>
                objectID, metadataInfo, params, sessionLang, false);

<span class="nc" id="L4360">        return result;</span>
    }

    /**
     * Common method to perform basic checks when processing an execution request
     * from a client stub.
     *
     * @param sessionID
     *            ID of the session
     * @param objectID
     *            ID of the object
     * @param remoteImplementation
     *            implementation to be executed
     * @param operationID
     *            ID of the operation to be executed
     * @return Info of the session and metadata
     * @throws RemoteException
     *             if any error occurs
     */
    private Tuple&lt;SessionInfo, MetaDataInfo&gt; executionClientChecksAndGetInfo(final SessionID sessionID,
                                                                             final ObjectID objectID, final Triple&lt;ImplementationID, ContractID, InterfaceID&gt; remoteImplementation,
                                                                             final OperationID operationID) {
<span class="nc" id="L4382">        final ImplementationID remoteImplementationID = remoteImplementation.getFirst();</span>
<span class="nc" id="L4383">        final ContractID contractID = remoteImplementation.getSecond();</span>
<span class="nc" id="L4384">        final InterfaceID interfaceID = remoteImplementation.getThird();</span>

        // TODO: Check if this method is still required (or methods calling this) (July
        // 2018 jmarti)

        // ---------------- SESSION CHECKS ------------------ //

        // Check session
<span class="nc" id="L4392">        final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L4393">        final Map&lt;ContractID, SessionContract&gt; sessionModelInfo = sessionInfo.getSessionContracts();</span>
<span class="nc" id="L4394">        final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>

        // Check dataset
<span class="nc" id="L4397">        final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4398" title="All 2 branches missed.">        if (metadataInfo == null) {</span>
<span class="nc" id="L4399">            throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
        }
<span class="nc" id="L4401">        checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>

        // Check interface and contract of implementation with the session
<span class="nc" id="L4404">        final SessionContract sessionContract = sessionModelInfo.get(contractID);</span>
<span class="nc bnc" id="L4405" title="All 4 branches missed.">        if (sessionContract == null || sessionContract.getSessionInterfaces() == null</span>
<span class="nc bnc" id="L4406" title="All 2 branches missed.">                || sessionContract.getSessionInterfaces().isEmpty()) {</span>
<span class="nc" id="L4407">            throw new DataClayRuntimeException(ERRORCODE.SESSION_DOES_NOT_MATCH_REQ);</span>
        }
<span class="nc" id="L4409">        final SessionInterface sessionInterface = sessionContract.getSessionInterfaces().get(interfaceID);</span>
<span class="nc bnc" id="L4410" title="All 2 branches missed.">        if (sessionInterface == null) {</span>
<span class="nc" id="L4411">            throw new DataClayRuntimeException(ERRORCODE.SESSION_DOES_NOT_MATCH_REQ);</span>
        }

        // Check interface can access the operation
<span class="nc" id="L4415">        final Map&lt;OperationID, SessionOperation&gt; sessionOperations = sessionInterface.getSessionOperations();</span>
<span class="nc" id="L4416">        final SessionOperation sessionOperation = sessionOperations.get(operationID);</span>
<span class="nc bnc" id="L4417" title="All 2 branches missed.">        if (sessionOperation == null) {</span>
<span class="nc" id="L4418">            throw new DataClayRuntimeException(ERRORCODE.OPERATION_NOT_IN_INTERFACE);</span>
        }
<span class="nc" id="L4420">        final SessionImplementation sessionImplementation = sessionOperation.getSessionRemoteImplementation();</span>
<span class="nc bnc" id="L4421" title="All 2 branches missed.">        if (!sessionImplementation.getImplementationID().equals(remoteImplementationID)) {</span>
<span class="nc" id="L4422">            throw new DataClayRuntimeException(ERRORCODE.INCOMPATIBLE_IMPLEMENTATION);</span>
        }
<span class="nc" id="L4424">        return new Tuple&lt;&gt;(sessionInfo, metadataInfo);</span>
    }

    /**
     * Internal function for execute implementation.
     *
     * @param origSession
     *            ID of the original session corresponding to initial application
     *            launcher
     * @param remoteImplementationID
     *            ID of the implementation executed
     * @param objectID
     *            ID of the object
     * @param metadataInfo
     *            Info of the object
     * @param params
     *            Parameters to the method
     * @param sessionLang
     *            Session language
     * @param allBackends Execute in all backends (for replication purposes)
     * @return Object resulting of the execution of the implementation (all of them,
     *         sepparately) @
     */
    private SerializedParametersOrReturn executeImplementationInternal(final SessionID origSession,
                                                                       final ImplementationID remoteImplementationID, final ObjectID objectID, final MetaDataInfo metadataInfo,
                                                                       final SerializedParametersOrReturn params, final Langs sessionLang,
                                                                       final boolean allBackends) {

        // Randomly select a backend to execute
        // TODO Define a better backend selection policy (10 Jul 2013 jmarti)
<span class="nc" id="L4454">        final Random rand = new Random();</span>
<span class="nc" id="L4455">        final Set&lt;ExecutionEnvironmentID&gt; locations = metadataInfo.getLocations();</span>
        final Set&lt;ExecutionEnvironmentID&gt; backends;
<span class="nc bnc" id="L4457" title="All 2 branches missed.">        if (allBackends) {</span>
<span class="nc" id="L4458">            backends = locations;</span>
        } else {
<span class="nc" id="L4460">            final int index = rand.nextInt(locations.size());</span>
<span class="nc" id="L4461">            final ExecutionEnvironmentID backendID = locations</span>
<span class="nc" id="L4462">                    .toArray(new ExecutionEnvironmentID[locations.size()])[index];</span>
<span class="nc" id="L4463">            backends = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4464">            backends.add(backendID);</span>
        }

<span class="nc" id="L4467">        SerializedParametersOrReturn resultObj = null;</span>
<span class="nc bnc" id="L4468" title="All 2 branches missed.">        for (ExecutionEnvironmentID backendID : backends) {</span>
            // Execute the method
            // Limit retries depending on the current set of replicas of the object
<span class="nc" id="L4471">            final int maxRetries = Math.max(Configuration.Flags.MAX_EXECUTION_RETRIES.getShortValue(), locations.size());</span>
<span class="nc bnc" id="L4472" title="All 2 branches missed.">            for (short i = 1; i &lt;= maxRetries; i++) {</span>
                try {
<span class="nc" id="L4474">                    final ExecutionEnvironment backend = this.getExecutionEnvironmentInfo(backendID, true);</span>
<span class="nc" id="L4475">                    final DataServiceAPI dataSrvApi = getExecutionEnvironmentAPI(backend);</span>
<span class="nc bnc" id="L4476" title="All 2 branches missed.">                    if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4477">                        final Set&lt;ImplementationID&gt; implementationIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4478">                        implementationIDs.add(remoteImplementationID);</span>
<span class="nc bnc" id="L4479" title="All 2 branches missed.">                        for (final Implementation impl : this.classMgrApi.getInfoOfImplementations(implementationIDs)</span>
<span class="nc" id="L4480">                                .values()) {</span>
<span class="nc" id="L4481">                            LOGGER.debug(&quot;Calling executeImplementation for object {} to  backend {}, method {}&quot;,</span>
<span class="nc" id="L4482">                                    objectID, backend, impl.getOpNameAndDescriptor());</span>
<span class="nc" id="L4483">                        }</span>
                    }

<span class="nc" id="L4486">                    resultObj = dataSrvApi.executeImplementation(objectID, remoteImplementationID, params, origSession);</span>
<span class="nc" id="L4487">                    break;</span>
<span class="nc" id="L4488">                } catch (final DataClayException nbEx) {</span>
<span class="nc bnc" id="L4489" title="All 4 branches missed.">                    if (!allBackends &amp;&amp; i &lt; maxRetries) {</span>
<span class="nc" id="L4490">                        final int index = rand.nextInt(locations.size());</span>
<span class="nc" id="L4491">                        backendID = locations.toArray(new ExecutionEnvironmentID[locations.size()])[index];</span>
<span class="nc" id="L4492">                        LOGGER.debug(&quot;Retrying execution on object {} onto backend {}&quot;, objectID, backendID);</span>
<span class="nc" id="L4493">                    } else {</span>
<span class="nc" id="L4494">                        LOGGER.debug(&quot;Aborting executeImplementation procedure&quot;, nbEx);</span>
<span class="nc" id="L4495">                        throw nbEx;</span>
                    }
                }
            }
<span class="nc" id="L4499">        }</span>
<span class="nc" id="L4500">        return resultObj;</span>
    }

    /**
     * Method that executes an action in a certain object. This method is called
     * from notification manager. Note that executions from this method have NO
     * session.
     *
     * @param objectID
     *            ID of the object
     * @param sessionID
     *            ID of the session of who triggered action
     * @param params
     *            the serialized parameters for the operation
     * @param opID
     *            id of the operation to be executed
     */
    public void executeNotificationAction(final ObjectID objectID, final SessionID sessionID,
                                          final SerializedParametersOrReturn params, final OperationID opID) {

        // TODO: Maybe we should check session here before waiting Data Service to do so
        // (July 2018 jmarti)

        // Get object metadata
<span class="nc" id="L4524">        final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>

        // Get implementation information, to serialize parameteres
<span class="nc" id="L4527">        final Operation op = this.classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L4528">        final Map&lt;String, Type&gt; paramTypes = op.getParams();</span>
<span class="nc" id="L4529">        final String[] paramsSignatures = new String[paramTypes.size()];</span>
<span class="nc" id="L4530">        final MetaClassID[] paramsClassIDs = new MetaClassID[paramTypes.size()];</span>
<span class="nc" id="L4531">        int idx = 0;</span>
<span class="nc bnc" id="L4532" title="All 2 branches missed.">        for (final Type paramType : paramTypes.values()) {</span>
<span class="nc" id="L4533">            paramsSignatures[idx] = paramType.getSignatureOrDescriptor();</span>
<span class="nc bnc" id="L4534" title="All 2 branches missed.">            if (paramType instanceof UserType) {</span>
<span class="nc" id="L4535">                final UserType uType = (UserType) paramType;</span>
<span class="nc" id="L4536">                paramsClassIDs[idx] = uType.getClassID();</span>
            }
<span class="nc" id="L4538">            idx++;</span>
<span class="nc" id="L4539">        }</span>

        // GET ANY IMPLEMENTATION
<span class="nc" id="L4542">        final ImplementationID implementationID = op.getImplementations().get(0).getDataClayID();</span>

        // ------------------ EXECUTE ------------------ //
<span class="nc" id="L4545">        executeImplementationInternal(sessionID, implementationID, objectID, metadataInfo, params, Langs.LANG_JAVA,</span>
                false);

<span class="nc" id="L4548">    }</span>

    /**
     * Method that executes a filterMethod in a certain object without parameters.
     * This method is called from notification manager. Note that executions from
     * this method have NO session.
     *
     * @param objectID
     *            ID of the object
     * @param sessionID
     *            ID of the session of who triggered action
     * @param params
     *            the serialized parameters for the operation
     * @param opID
     *            id of the operation to be executed
     * @return a boolean value with the result of the execution of the
     *         implementation (all of them, separately)
     */
    public boolean executeFilterMethod(final ObjectID objectID, final SessionID sessionID,
                                       final SerializedParametersOrReturn params, final OperationID opID) {
<span class="nc" id="L4568">        boolean filterMethodResult = true;</span>

        // TODO: Maybe we should check session info here instead of waiting to reach
        // Data Service backend checks (July 2018 jmarti)

<span class="nc" id="L4573">        final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
        // Get implementation information, to serialize parameteres
<span class="nc" id="L4575">        final Operation op = this.classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L4576">        final Map&lt;String, Type&gt; paramTypes = op.getParams();</span>
<span class="nc" id="L4577">        final String[] paramsSignatures = new String[paramTypes.size()];</span>
<span class="nc" id="L4578">        final MetaClassID[] paramsClassIDs = new MetaClassID[paramTypes.size()];</span>
<span class="nc" id="L4579">        int idx = 0;</span>
<span class="nc bnc" id="L4580" title="All 2 branches missed.">        for (final Type paramType : paramTypes.values()) {</span>
<span class="nc" id="L4581">            paramsSignatures[idx] = paramType.getSignatureOrDescriptor();</span>
<span class="nc bnc" id="L4582" title="All 2 branches missed.">            if (paramType instanceof UserType) {</span>
<span class="nc" id="L4583">                final UserType uType = (UserType) paramType;</span>
<span class="nc" id="L4584">                paramsClassIDs[idx] = uType.getClassID();</span>
            }
<span class="nc" id="L4586">            idx++;</span>
<span class="nc" id="L4587">        }</span>

        // GET ANY IMPLEMENTATION
<span class="nc" id="L4590">        final ImplementationID implementationID = op.getImplementations().get(0).getDataClayID();</span>

        // ------------------ EXECUTE ------------------ //
<span class="nc" id="L4593">        final SerializedParametersOrReturn result = executeImplementationInternal(sessionID, implementationID, objectID,</span>
                metadataInfo, params, Langs.LANG_JAVA, false);
<span class="nc" id="L4595">        filterMethodResult = DataClayDeserializationLib.deserializeReturnFilterMethod(result);</span>
<span class="nc" id="L4596">        return filterMethodResult;</span>
    }

    @Override
    public boolean isPrefetchingEnabled() {
<span class="nc" id="L4601">        return Configuration.Flags.PREFETCHING_ENABLED.getBooleanValue();</span>
    }

    @Override
    public boolean objectExistsInDataClay(final ObjectID objectID) {
<span class="nc" id="L4606">        LOGGER.debug(&quot;Checking if object {} exists&quot;, objectID);</span>
<span class="nc bnc" id="L4607" title="All 2 branches missed.">        for (final Tuple&lt;DataServiceAPI, StorageLocation&gt; elem : this.getStorageLocations().values()) {</span>
<span class="nc bnc" id="L4608" title="All 2 branches missed.">            if (elem.getFirst().existsInDB(objectID)) {</span>
<span class="nc" id="L4609">                LOGGER.debug(&quot;Found object {} in storage location {}&quot;, objectID, elem.getSecond().toString());</span>
<span class="nc" id="L4610">                return true;</span>
            }
<span class="nc" id="L4612">        }</span>
<span class="nc" id="L4613">        return false;</span>

    }

    @Override
    public int getNumObjects() {
<span class="nc" id="L4619">        LOGGER.debug(&quot;Getting number of objects in dataClay&quot;);</span>
<span class="nc" id="L4620">        int numObjs = 0;</span>
<span class="nc bnc" id="L4621" title="All 2 branches missed.">        for (final Tuple&lt;DataServiceAPI, StorageLocation&gt; elem : this.getStorageLocations().values()) {</span>
<span class="nc" id="L4622">            numObjs += elem.getFirst().getNumObjects();</span>
<span class="nc" id="L4623">        }</span>
<span class="nc" id="L4624">        LOGGER.debug(&quot;Found {} objects in dataClay&quot;, numObjs);</span>
<span class="nc" id="L4625">        return numObjs;</span>

    }

    /**
     * Get owner of the object
     *
     * @param objectID
     *            ID of the object
     * @return Owner of the object
     */
    public AccountID getOwner(final ObjectID objectID) {
<span class="nc" id="L4637">        final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc" id="L4638">        return metadataInfo.getOwnerID();</span>
    }

    /**
     * Initialize session of owner's object.
     *
     * @param ownerID
     *            ID of the owner.
     * @return Session ID
     */
    public SessionID initializeSessionAsOwnerOfObject(final AccountID ownerID) {
<span class="nc" id="L4649">        final Set&lt;DataSetID&gt; dataSets = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4650">        DataSetID dataSetForStore = null;</span>

        // Contracts in which account is applicant
<span class="nc" id="L4653">        final Map&lt;ContractID, Contract&gt; contracts = contractMgrApi.getContractIDsOfApplicant(ownerID);</span>
<span class="nc" id="L4654">        final Set&lt;ContractID&gt; contractIDs = new HashSet&lt;&gt;(contracts.keySet());</span>

        // Contracts in which account is owner
<span class="nc" id="L4657">        final Map&lt;ContractID, Contract&gt; contractsAsProvider = contractMgrApi.getContractIDsOfProvider(ownerID);</span>
<span class="nc" id="L4658">        contractIDs.addAll(contractsAsProvider.keySet());</span>

        // DataSets in which Account is applicant
<span class="nc" id="L4661">        final Map&lt;DataContractID, DataContract&gt; datacontracts = this.datacontractMgrApi</span>
<span class="nc" id="L4662">                .getDataContractIDsOfApplicant(ownerID);</span>
<span class="nc bnc" id="L4663" title="All 2 branches missed.">        for (final DataContract dc : datacontracts.values()) {</span>
<span class="nc" id="L4664">            dataSets.add(dc.getProviderDataSetID());</span>
<span class="nc bnc" id="L4665" title="All 2 branches missed.">            if (dataSetForStore == null) {</span>
<span class="nc" id="L4666">                dataSetForStore = dc.getProviderDataSetID();</span>
            }
<span class="nc" id="L4668">        }</span>

        // DataSets of the account
<span class="nc" id="L4671">        final List&lt;DataSet&gt; allDataSetsOfowner = dataSetMgrApi.getAllDataSetsOfAccount(ownerID);</span>
<span class="nc bnc" id="L4672" title="All 2 branches missed.">        for (final DataSet ds : allDataSetsOfowner) {</span>
<span class="nc" id="L4673">            dataSets.add(ds.getDataClayID());</span>
<span class="nc bnc" id="L4674" title="All 2 branches missed.">            if (dataSetForStore == null) {</span>
<span class="nc" id="L4675">                dataSetForStore = ds.getDataClayID();</span>
            }

<span class="nc" id="L4678">        }</span>
<span class="nc" id="L4679">        final SessionInfo sessInfo = newSessionInternal(ownerID, contractIDs, dataSets, dataSetForStore,</span>
                Langs.LANG_JAVA);
<span class="nc" id="L4681">        return sessInfo.getSessionID();</span>
    }

    /**
     * Preface for the getStubs|getBabelStubs. Validate the account and get all
     * interfaces.
     *
     * @param applicantAccountID
     *            The applicant Account
     * @param applicantCredential
     *            The applicant Credential
     * @param contractsIDs
     *            The list of ContractIDs for the stubs to be retrieved.
     * @return A map containing all the required data to proceed to stub generation.
     * @throws RemoteException
     *             if a RemoteException occurs from AccountManager or
     *             SessionManager.
     */
    private Map&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; getStubsInternalPreface(
            final AccountID applicantAccountID, final PasswordCredential applicantCredential,
            final List&lt;ContractID&gt; contractsIDs) {
        // Validate applicant account
<span class="nc bnc" id="L4703" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(applicantAccountID, applicantCredential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L4704">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }

        // Get info of contracts
<span class="nc" id="L4708">        final LinkedHashMap&lt;ContractID, Contract&gt; contractsInfo = contractMgrApi</span>
<span class="nc" id="L4709">                .getInfoOfSomeActiveContractsForAccount(contractsIDs, applicantAccountID);</span>

        // Get info of interfaces
<span class="nc" id="L4712">        final HashSet&lt;InterfaceID&gt; allInterfacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L4713" title="All 2 branches missed.">        for (final Contract contractInfo : contractsInfo.values()) {</span>
<span class="nc" id="L4714">            allInterfacesIDs.addAll(contractInfo.getInterfacesInContract().keySet());</span>
<span class="nc" id="L4715">        }</span>
<span class="nc" id="L4716">        final Map&lt;InterfaceID, Interface&gt; interfacesInfo = interfaceMgrApi.getInterfacesInfo(allInterfacesIDs);</span>

        // Update Interface with names of class, properties and signatures of operations
        /*
         * for (Interface ifaceInfo : interfacesInfo.values()) { MetaClass classInfo =
         * classMgrApi.getClassInfo(ifaceInfo.getMetaClassID());
         * ifaceInfo.setClassName(classInfo.getName());
         *
         * SortedSet&lt;Property&gt; props = classInfo.getProperties(); Map&lt;PropertyID,
         * String&gt; propsOfClass = new HashMap&lt;PropertyID, String&gt;(); for (Property prop
         * : props) { propsOfClass.put(prop.getID(), prop.getName()); }
         * HashMap&lt;PropertyID, String&gt; propsOfIface = new HashMap&lt;PropertyID, String&gt;();
         * for (PropertyID propID : ifaceInfo.getPropertiesIDs()) {
         * propsOfIface.put(propID, propsOfClass.get(propID)); }
         * ifaceInfo.setPropsNames(propsOfIface);
         *
         *
         * Map&lt;OperationID, String&gt; opsOfClass = new HashMap&lt;OperationID, String&gt;(); for
         * (Operation op : classInfo.getOperations()) { opsOfClass.put(op.getID(),
         * op.getName()); } HashMap&lt;OperationID, String&gt; opsOfIface = new
         * HashMap&lt;OperationID, String&gt;(); for (OperationID opID :
         * ifaceInfo.getOperationsIDs()) { opsOfIface.put(opID, opsOfClass.get(opID)); }
         * ifaceInfo.setOpsSignatures(opsOfIface); }
         */

        // Build structures for each metaclass to be &quot;stubbed&quot;
<span class="nc" id="L4742">        final Map&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; ifacesAndContractsOfClasses = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4743" title="All 2 branches missed.">        for (final Entry&lt;ContractID, Contract&gt; curContract : contractsInfo.entrySet()) {</span>
<span class="nc" id="L4744">            final ContractID contractID = curContract.getKey();</span>
<span class="nc" id="L4745">            final Contract contractInfo = curContract.getValue();</span>

<span class="nc bnc" id="L4747" title="All 2 branches missed.">            for (final InterfaceID interfaceID : contractInfo.getInterfacesInContract().keySet()) {</span>
<span class="nc" id="L4748">                final Interface interfaceInfo = interfacesInfo.get(interfaceID);</span>
<span class="nc" id="L4749">                final MetaClassID metaClassID = interfaceInfo.getMetaClassID();</span>

                // Track info of interfaces and contracts per class
<span class="nc bnc" id="L4752" title="All 2 branches missed.">                if (!ifacesAndContractsOfClasses.containsKey(metaClassID)) {</span>
<span class="nc" id="L4753">                    ifacesAndContractsOfClasses.put(metaClassID,</span>
                            new LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;());
                }
<span class="nc" id="L4756">                ifacesAndContractsOfClasses.get(metaClassID).put(contractID, new Tuple&lt;&gt;(contractInfo, interfaceInfo));</span>
<span class="nc" id="L4757">            }</span>
<span class="nc" id="L4758">        }</span>

<span class="nc" id="L4760">        return ifacesAndContractsOfClasses;</span>
    }

    @Override
    public Map&lt;String, byte[]&gt; getStubs(final AccountID applicantAccountID,
                                        final PasswordCredential applicantCredential, final Langs language, final List&lt;ContractID&gt; contractsIDs) {
<span class="nc" id="L4766">        final Map&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; ifacesAndContractsOfClasses = getStubsInternalPreface(</span>
                applicantAccountID, applicantCredential, contractsIDs);

        // Generate stub infos
<span class="nc" id="L4770">        final Map&lt;MetaClassID, StubInfo&gt; stubInfos = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4771">        final Map&lt;String, byte[]&gt; stubsBytesArrays = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4772" title="All 2 branches missed.">        for (final Entry&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; ifacesAndContractsOfClass : ifacesAndContractsOfClasses</span>
<span class="nc" id="L4773">                .entrySet()) {</span>
<span class="nc" id="L4774">            final MetaClassID metaClassID = ifacesAndContractsOfClass.getKey();</span>
            // Generate the stub info for the current class
<span class="nc" id="L4776">            final StubInfo stubInfo = getStubInfoForMetaClass(applicantAccountID, metaClassID,</span>
<span class="nc" id="L4777">                    ifacesAndContractsOfClass.getValue());</span>

<span class="nc" id="L4779">            stubInfos.put(metaClassID, stubInfo);</span>
<span class="nc" id="L4780">        }</span>

        // Generate stubs
<span class="nc" id="L4783">        final Map&lt;MetaClassID, Triple&lt;String, byte[], byte[]&gt;&gt; stubAndIncludes = classMgrApi.generateStubs(language,</span>
                stubInfos);

<span class="nc bnc" id="L4786" title="All 2 branches missed.">        for (final Entry&lt;MetaClassID, Triple&lt;String, byte[], byte[]&gt;&gt; curStub : stubAndIncludes.entrySet()) {</span>

<span class="nc" id="L4788">            final MetaClassID metaClassID = curStub.getKey();</span>
<span class="nc" id="L4789">            final Triple&lt;String, byte[], byte[]&gt; triple = curStub.getValue();</span>

<span class="nc" id="L4791">            final String className = triple.getFirst();</span>
<span class="nc" id="L4792">            final byte[] stubByteArray = triple.getSecond();</span>
<span class="nc" id="L4793">            final byte[] aspect = triple.getThird();</span>
<span class="nc" id="L4794">            stubsBytesArrays.put(className, stubByteArray);</span>

            // Add aspectj
<span class="nc bnc" id="L4797" title="All 2 branches missed.">            if (aspect != null) {</span>
<span class="nc" id="L4798">                stubsBytesArrays.put(className + &quot;Aspect&quot;, aspect);</span>
            }
            // Add Yaml
            // Generate the Babel stub for the current class, and put it in the returning
            // dictionary
<span class="nc" id="L4803">            final String myBabelStub = generateBabelStub(applicantAccountID, metaClassID,</span>
<span class="nc" id="L4804">                    ifacesAndContractsOfClasses.get(metaClassID));</span>
<span class="nc bnc" id="L4805" title="All 2 branches missed.">            if (myBabelStub != null) {</span>
<span class="nc" id="L4806">                final byte[] yamldoc = myBabelStub.getBytes();</span>
<span class="nc" id="L4807">                stubsBytesArrays.put(className + &quot;Yaml&quot;, yamldoc);</span>
            }
<span class="nc" id="L4809">        }</span>

<span class="nc" id="L4811">        return stubsBytesArrays;</span>

    }

    @Override
    public byte[] getBabelStubs(final AccountID applicantAccountID, final PasswordCredential applicantCredential,
                                final List&lt;ContractID&gt; contractsIDs) {
<span class="nc" id="L4818">        final Map&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; ifacesAndContractsOfClasses = getStubsInternalPreface(</span>
                applicantAccountID, applicantCredential, contractsIDs);

        // Generate &quot;Babel&quot; stubs
<span class="nc" id="L4822">        final Map&lt;String, Object&gt; stubsBytesArrays = new HashMap&lt;&gt;();</span>

        for (final Entry&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; //
<span class="nc bnc" id="L4825" title="All 2 branches missed.">                ifacesAndContractsOfClass : ifacesAndContractsOfClasses.entrySet()) {</span>
<span class="nc" id="L4826">            final MetaClassID metaClassID = ifacesAndContractsOfClass.getKey();</span>

            // Get the classname
<span class="nc" id="L4829">            final String className = classMgrApi.getClassname(metaClassID);</span>
            // Generate the Babel stub for the current class, and put it in the returning
            // dictionary
<span class="nc" id="L4832">            stubsBytesArrays.put(className,</span>
<span class="nc" id="L4833">                    generateBabelStub(applicantAccountID, metaClassID, ifacesAndContractsOfClass.getValue()));</span>
<span class="nc" id="L4834">        }</span>

<span class="nc" id="L4836">        final Yaml yaml = CommonYAML.getYamlObject();</span>
<span class="nc" id="L4837">        return yaml.dump(stubsBytesArrays).getBytes();</span>

    }

    @Override
    public String getClassNameForDS(final MetaClassID classID) {
<span class="nc" id="L4843">        return classMgrApi.getClassname(classID);</span>
    }

    @Override
    public Tuple&lt;String, String&gt; getClassNameAndNamespaceForDS(final MetaClassID classID) {
        try {
<span class="nc" id="L4849">            return classMgrApi.getClassNameAndNamespace(classID);</span>
<span class="nc" id="L4850">        } catch (Exception e) {</span>
<span class="nc" id="L4851">            throw e;</span>
        }
    }

    @Override
    public void registerEventListenerImplementation(final AccountID accountID, final PasswordCredential credential,
                                                    final ECA newEventListener) {
        // Check account
        // TODO: validate account, who is allowed to register it?

        // Advises notification manager
<span class="nc bnc" id="L4862" title="All 2 branches missed.">        if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L4863">            notificationMgrApi.registerEventListenerImpl(newEventListener);</span>
        } else {
<span class="nc" id="L4865">            throw new DataClayException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;Notification manager is not active&quot;, false);</span>
        }

<span class="nc" id="L4868">    }</span>

    @Override
    public void adviseEvent(final EventMessage newEvent) {
<span class="nc bnc" id="L4872" title="All 2 branches missed.">        if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L4873">            notificationMgrApi.adviseEvent(newEvent);</span>
        } else {
<span class="nc" id="L4875">            throw new DataClayException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;Notification manager is not active&quot;, false);</span>
        }
<span class="nc" id="L4877">    }</span>

    /**
     * @return the metaDataSrvApi
     */
    public MetaDataService getMetaDataSrvApi() {
<span class="nc" id="L4883">        return metaDataSrvApi;</span>
    }

    /***** Register Listener *****/

    // ============== PRIVATE METHODS FOR NAMESPACES ==============//

    /**
     * Checks that the specified account is the responsible of the given namespace
     *
     * @param accountID
     *            the account to be checked
     * @param credential
     *            the account credentials
     * @param namespaceID
     *            the id of the namespace
     * @return Success if the account is valid and it is the responsible of the
     *         namespace
     */
    private Namespace checkNamespaceResponsible(final AccountID accountID, final PasswordCredential credential,
                                                final NamespaceID namespaceID) {
        // Validate account
<span class="nc bnc" id="L4905" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L4906">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }
        // Check namespace responsible
<span class="nc" id="L4909">        return namespaceMgrApi.checkNamespaceResponsibleAndGetInfo(namespaceID, accountID);</span>

    }

    // ============== PRIVATE METHODS FOR DATASETS ==============//

    /**
     * Shared method that checks the responsible of a dataset
     *
     * @param accountID
     *            ID of the account to be checked
     * @param credential
     *            credential of the account
     * @param datasetID
     *            ID of the dataset to be checked
     */
    private void checkDataSetResponsible(final AccountID accountID, final PasswordCredential credential,
                                         final DataSetID datasetID) {
        // Validate account
<span class="nc bnc" id="L4928" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L4929">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }
        // Check namespace responsible
<span class="nc bnc" id="L4932" title="All 2 branches missed.">        if (!dataSetMgrApi.checkDataSetResponsible(datasetID, accountID)) {</span>
<span class="nc" id="L4933">            throw new DataClayRuntimeException(ERRORCODE.BAD_DATASET_RESPONSIBLE);</span>
        }

<span class="nc" id="L4936">    }</span>

    // ============== PRIVATE METHODS FOR CLASS MANAGEMENT AND IMPORTS
    // ==============//

    /**
     * Get metaclassID either because it is created in the namespace or imported in
     * it
     *
     * @param namespaceID
     *            ID of the namespace where the class should be present
     * @param className
     *            the name of the classes
     * @return ID of the metaclass
     */
    private MetaClassID getMetaClassID(final NamespaceID namespaceID, final String className) {
<span class="nc" id="L4952">        MetaClassID result = null;</span>
        // Check the class is not in use and get the classID (checks the class belongs
        // to the namespace)
<span class="nc" id="L4955">        result = classMgrApi.getMetaClassID(namespaceID, className);</span>
<span class="nc bnc" id="L4956" title="All 2 branches missed.">        if (result == null) {</span>
            // if class manager cannot obtain the class id in namespaceID check imports
<span class="nc" id="L4958">            final Set&lt;ImportedInterface&gt; importedInterfacess = namespaceMgrApi.getImportedInterfaces(namespaceID,</span>
                    className);
<span class="nc bnc" id="L4960" title="All 2 branches missed.">            if (importedInterfacess.isEmpty()) {</span>
<span class="nc" id="L4961">                throw new DataClayRuntimeException(ERRORCODE.BAD_IMPORTS);</span>
            } else {
<span class="nc" id="L4963">                result = importedInterfacess.iterator().next().getClassOfImportID();</span>
            }
        }

<span class="nc" id="L4967">        return result;</span>
    }

    // ============== PRIVATE METHODS FOR CONTRACT MANAGEMENT ==============//

    /**
     * Method that validates the provided contract in the context of the given
     * namespace
     *
     * @param contract
     *            the contract to validate
     * @return The info of the interfaces of the contract checked.
     */
    private Map&lt;InterfaceID, Interface&gt; checkContract(final Contract contract) {
<span class="nc" id="L4981">        Map&lt;InterfaceID, Interface&gt; infoOfInterfacesInContract = null;</span>
        // Get info of the interfaces for the contract
<span class="nc" id="L4983">        infoOfInterfacesInContract = interfaceMgrApi.getInterfacesOfNamespaceInfo(contract.getNamespaceID(),</span>
<span class="nc" id="L4984">                new HashSet&lt;&gt;(contract.getInterfacesInContract().keySet()));</span>

        // Checks for every interface
<span class="nc" id="L4987">        final Map&lt;InterfaceID, MetaClassID&gt; metaClassesOfInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4988" title="All 2 branches missed.">        for (final Entry&lt;InterfaceID, Interface&gt; curEntry : infoOfInterfacesInContract.entrySet()) {</span>
<span class="nc" id="L4989">            final InterfaceID interfaceID = curEntry.getKey();</span>
<span class="nc" id="L4990">            final Interface curInterface = curEntry.getValue();</span>

            // Check there is no previous interface associated with same
            // metaclass
<span class="nc bnc" id="L4994" title="All 2 branches missed.">            if (metaClassesOfInterfaces.containsValue(curInterface.getMetaClassID())) {</span>
<span class="nc" id="L4995">                throw new DataClayRuntimeException(ERRORCODE.SOME_INTERFACES_WITH_SAME_METACLASS);</span>
            } else {
<span class="nc" id="L4997">                metaClassesOfInterfaces.put(interfaceID, curInterface.getMetaClassID());</span>
            }

            // For some strange reason, doing this new was required in order to avoid a
            // misbehaviour
            // Check YAML-related MixedTest.UpToInterfaceTest
            // abarcelo 2014-10-28
<span class="nc" id="L5004">            final Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInNewContract = new LinkedHashMap&lt;&gt;(</span>
<span class="nc" id="L5005">                    contract.getInterfacesInContract());</span>
            // Update with a &quot;&quot;&quot;more valid&quot;&quot;&quot; Map --??? It Works (TM)
<span class="nc" id="L5007">            contract.setInterfacesInContract(interfacesInNewContract);</span>

            // Check the implementations for the operations in the current
            // interface are right
<span class="nc" id="L5011">            final InterfaceInContract curIfaceInContract = interfacesInNewContract.get(interfaceID);</span>
<span class="nc" id="L5012">            final Map&lt;OperationID, OpImplementations&gt; allOpsImplementations = curIfaceInContract</span>
<span class="nc" id="L5013">                    .getAccessibleImplementations();</span>
<span class="nc bnc" id="L5014" title="All 2 branches missed.">            if (!allOpsImplementations.keySet().containsAll(curInterface.getOperationsIDs())) {</span>
<span class="nc" id="L5015">                throw new DataClayRuntimeException(ERRORCODE.SOME_OPERATION_WITH_NO_ACCESSIBLE_IMPL);</span>
            }
<span class="nc bnc" id="L5017" title="All 2 branches missed.">            for (final Entry&lt;OperationID, OpImplementations&gt; curOpImpls : allOpsImplementations.entrySet()) {</span>
<span class="nc" id="L5018">                final OperationID operationID = curOpImpls.getKey();</span>
<span class="nc bnc" id="L5019" title="All 2 branches missed.">                if (!curInterface.getOperationsIDs().contains(operationID)) {</span>
<span class="nc" id="L5020">                    throw new DataClayRuntimeException(ERRORCODE.OPERATION_NOT_IN_INTERFACE);</span>
                }

<span class="nc" id="L5023">                final OpImplementations curImpls = curOpImpls.getValue();</span>

<span class="nc" id="L5025">                final List&lt;ImplementationID&gt; implementationsOfOp = classMgrApi</span>
<span class="nc" id="L5026">                        .getImplementationsOfOperation(operationID);</span>

<span class="nc bnc" id="L5028" title="All 2 branches missed.">                if (!implementationsOfOp.contains(curImpls.getLocalImplementationID())) {</span>
<span class="nc" id="L5029">                    throw new DataClayRuntimeException(ERRORCODE.IMPLEMENTATION_NOT_EXIST,</span>
<span class="nc" id="L5030">                            &quot; Implementation with ID &quot; + curImpls.getLocalImplementationID() + &quot; does not exist&quot;,</span>
                            false);
<span class="nc bnc" id="L5032" title="All 2 branches missed.">                } else if (!implementationsOfOp.contains(curImpls.getRemoteImplementationID())) {</span>
<span class="nc" id="L5033">                    throw new DataClayRuntimeException(ERRORCODE.IMPLEMENTATION_NOT_EXIST,</span>
<span class="nc" id="L5034">                            &quot; Implementation with ID &quot; + curImpls.getRemoteImplementationID() + &quot; does not exist&quot;,</span>
                            false);
                }
<span class="nc" id="L5037">            }</span>
<span class="nc" id="L5038">        }</span>

<span class="nc" id="L5040">        return infoOfInterfacesInContract;</span>

    }

    /**
     * This method updates the given interfaces of a contract by analyzing their
     * requirements (includes) and returns a merged set of interfaces for such a
     * contract.
     *
     * @param accountID
     *            ID of the account of the contract provider
     * @param credential
     *            Credential of the account
     * @param namespaceID
     *            ID of the namespace the contract provider
     * @param currentInterfacesInContract
     *            the current interfaces for the contract
     * @param infoOfInterfacesInContract
     *            the info of the current for the contract
     * @return Info of the resulting interfaces in contract.
     * @throws RemoteException
     *             if RemoteException occurs in ClassManager
     */
    private Map&lt;InterfaceID, InterfaceInContract&gt; updateInterfacesForTheContract(final AccountID accountID,
                                                                                 final PasswordCredential credential, final NamespaceID namespaceID,
                                                                                 final Map&lt;InterfaceID, InterfaceInContract&gt; currentInterfacesInContract,
                                                                                 final Map&lt;InterfaceID, Interface&gt; infoOfInterfacesInContract) {

        // Init result with current interfaces in contract
<span class="nc" id="L5069">        final Map&lt;InterfaceID, InterfaceInContract&gt; objResult = new HashMap&lt;&gt;();</span>
<span class="nc" id="L5070">        objResult.putAll(currentInterfacesInContract);</span>

        // Keep the metaclasses of the interfaces in contract
        final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; //
<span class="nc" id="L5074">                metaClassesOfInterfacesInContract = new HashMap&lt;&gt;();</span>

        // Start with the current interfaces in contract
<span class="nc" id="L5077">        Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInContractToBeAnalyzed = //</span>
                new HashMap&lt;&gt;(currentInterfacesInContract);

<span class="nc bnc" id="L5080" title="All 2 branches missed.">        while (!interfacesInContractToBeAnalyzed.isEmpty()) {</span>
            // Analyze includes required for the interfaces in contract and
            // separate
            // considering if they are related with classes created in the
            // namespace or not (imports)
<span class="nc" id="L5085">            final Set&lt;MetaClass&gt; importedIncludesInfo = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5086">            final Set&lt;MetaClass&gt; nonImportedIncludesInfo = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L5088" title="All 2 branches missed.">            for (final Entry&lt;InterfaceID, InterfaceInContract&gt; curEntry : interfacesInContractToBeAnalyzed.entrySet()) {</span>
<span class="nc" id="L5089">                final InterfaceID curInterfaceID = curEntry.getKey();</span>
<span class="nc" id="L5090">                final InterfaceInContract curInterfaceInContract = curEntry.getValue();</span>

                // Info of the current interface in contract
<span class="nc" id="L5093">                final Interface curInterface = infoOfInterfacesInContract.get(curInterfaceID);</span>
<span class="nc" id="L5094">                final MetaClassID metaClassID = curInterface.getMetaClassID();</span>
<span class="nc" id="L5095">                final Set&lt;PropertyID&gt; propertyIDs = curInterface.getPropertiesIDs();</span>
<span class="nc" id="L5096">                final Set&lt;OperationID&gt; operationIDs = curInterface.getOperationsIDs();</span>

                // Accessible implementations for current interface
<span class="nc" id="L5099">                final Map&lt;OperationID, OpImplementations&gt; accessibleImpls = curInterfaceInContract</span>
<span class="nc" id="L5100">                        .getAccessibleImplementations();</span>

<span class="nc" id="L5102">                final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; operationsAndImpls = //</span>
                        new HashMap&lt;&gt;();
<span class="nc bnc" id="L5104" title="All 2 branches missed.">                for (final OperationID curOpID : operationIDs) {</span>
<span class="nc" id="L5105">                    final OpImplementations accessibleImplsForCurrentOp = accessibleImpls.get(curOpID);</span>
<span class="nc" id="L5106">                    final HashSet&lt;ImplementationID&gt; implsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5107">                    implsIDs.add(accessibleImplsForCurrentOp.getLocalImplementationID());</span>
<span class="nc" id="L5108">                    implsIDs.add(accessibleImplsForCurrentOp.getRemoteImplementationID());</span>
<span class="nc" id="L5109">                    operationsAndImpls.put(curOpID, implsIDs);</span>
<span class="nc" id="L5110">                }</span>

                // Get parent class ID
<span class="nc" id="L5113">                final MetaClass curClassInfo = classMgrApi.getClassInfo(metaClassID);</span>
<span class="nc" id="L5114">                MetaClassID parentClassID = null;</span>
<span class="nc bnc" id="L5115" title="All 2 branches missed.">                if (curClassInfo.getParentType() != null) {</span>
<span class="nc" id="L5116">                    parentClassID = curClassInfo.getParentType().getClassID();</span>
                }

                // =&gt; CLASS MANAGER
                // Get all the needed &quot;includes&quot; for the current interface
                // in contract
<span class="nc" id="L5122">                final Tuple&lt;Set&lt;MetaClass&gt;, Set&lt;MetaClass&gt;&gt; curResult = classMgrApi</span>
<span class="nc" id="L5123">                        .getClassIncludesOfOperationsPropsAndImpls(operationsAndImpls, propertyIDs, namespaceID,</span>
                                parentClassID);

                // We have them separated considering if they are includes
                // present in namespace from imported classes
                // or they are classes created in itup
<span class="nc" id="L5129">                importedIncludesInfo.addAll(curResult.getFirst());</span>
<span class="nc" id="L5130">                nonImportedIncludesInfo.addAll(curResult.getSecond());</span>

                // Index interfaces in contract by metaclass and also with
                // the parent class info
<span class="nc" id="L5134">                metaClassesOfInterfacesInContract.put(metaClassID,</span>
                        new Triple&lt;&gt;(curInterface, curInterfaceInContract, parentClassID));
<span class="nc" id="L5136">            }</span>

            // Init interfacesInContract to be analyzed in next iteration
<span class="nc" id="L5139">            interfacesInContractToBeAnalyzed = new HashMap&lt;&gt;();</span>

            // Set of includes required that refer to classes already
            // created in namespace
<span class="nc" id="L5143">            final Map&lt;MetaClassID, MetaClass&gt; setOfclassesRequiredCreatedInNamespace = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5144" title="All 2 branches missed.">            for (final MetaClass mclassInfo : nonImportedIncludesInfo) {</span>
<span class="nc bnc" id="L5145" title="All 2 branches missed.">                if (!metaClassesOfInterfacesInContract.containsKey(mclassInfo.getDataClayID())) {</span>
<span class="nc" id="L5146">                    setOfclassesRequiredCreatedInNamespace.put(mclassInfo.getDataClayID(), mclassInfo);</span>
                }
<span class="nc" id="L5148">            }</span>
<span class="nc bnc" id="L5149" title="All 2 branches missed.">            if (!setOfclassesRequiredCreatedInNamespace.isEmpty()) {</span>

                final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; //
<span class="nc" id="L5152">                        interfacesForClasses = registerReqInterfacesForClasses(accountID, credential, namespaceID,</span>
                        setOfclassesRequiredCreatedInNamespace);

<span class="nc bnc" id="L5155" title="All 2 branches missed.">                for (final MetaClassID mclassID : interfacesForClasses.keySet()) {</span>
<span class="nc" id="L5156">                    final Triple&lt;Interface, InterfaceInContract, MetaClassID&gt; curInterface = interfacesForClasses</span>
<span class="nc" id="L5157">                            .get(mclassID);</span>
<span class="nc" id="L5158">                    interfacesInContractToBeAnalyzed.put(curInterface.getFirst().getDataClayID(),</span>
<span class="nc" id="L5159">                            curInterface.getSecond());</span>
<span class="nc" id="L5160">                    infoOfInterfacesInContract.put(curInterface.getFirst().getDataClayID(), curInterface.getFirst());</span>
<span class="nc" id="L5161">                }</span>
            }

            // Set of includes required that are present in namespace due to
            // imported classes
<span class="nc" id="L5166">            final Map&lt;MetaClassID, String&gt; setOfIncludesRequiredNotInNamespace = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5167" title="All 2 branches missed.">            for (final MetaClass mclassInfo : importedIncludesInfo) {</span>
<span class="nc bnc" id="L5168" title="All 2 branches missed.">                if (!metaClassesOfInterfacesInContract.containsKey(mclassInfo.getDataClayID())) {</span>
<span class="nc" id="L5169">                    setOfIncludesRequiredNotInNamespace.put(mclassInfo.getDataClayID(), mclassInfo.getName());</span>
                }
<span class="nc" id="L5171">            }</span>
<span class="nc bnc" id="L5172" title="All 2 branches missed.">            if (!setOfIncludesRequiredNotInNamespace.isEmpty()) {</span>

                final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; //
<span class="nc" id="L5175">                        ifacesForImportedIncludes = registerReqMergedInterfacesFromImports(accountID, credential, namespaceID,</span>
                        metaClassesOfInterfacesInContract, setOfIncludesRequiredNotInNamespace);

<span class="nc bnc" id="L5178" title="All 2 branches missed.">                for (final MetaClassID mclassID : ifacesForImportedIncludes.keySet()) {</span>
<span class="nc" id="L5179">                    final Triple&lt;Interface, InterfaceInContract, MetaClassID&gt; curInterface = ifacesForImportedIncludes</span>
<span class="nc" id="L5180">                            .get(mclassID);</span>
<span class="nc" id="L5181">                    interfacesInContractToBeAnalyzed.put(curInterface.getFirst().getDataClayID(),</span>
<span class="nc" id="L5182">                            curInterface.getSecond());</span>
<span class="nc" id="L5183">                    infoOfInterfacesInContract.put(curInterface.getFirst().getDataClayID(), curInterface.getFirst());</span>
<span class="nc" id="L5184">                }</span>
            }
<span class="nc" id="L5186">        }</span>

        // Update Interfaces In Contract depending on their inheritance
        // relationship
<span class="nc bnc" id="L5190" title="All 2 branches missed.">        for (final MetaClassID mclassID : metaClassesOfInterfacesInContract.keySet()) {</span>
<span class="nc" id="L5191">            final Triple&lt;Interface, InterfaceInContract, MetaClassID&gt; curInterfaceInContract = metaClassesOfInterfacesInContract</span>
<span class="nc" id="L5192">                    .get(mclassID);</span>
<span class="nc" id="L5193">            objResult.put(curInterfaceInContract.getFirst().getDataClayID(), curInterfaceInContract.getSecond());</span>
<span class="nc" id="L5194">        }</span>

<span class="nc" id="L5196">        return objResult;</span>
    }

    /**
     * This method autogenerates the interfaces for a contract related with a
     * specific set of classes created on a specific namespace
     *
     * @param accountID
     *            Account performing the action
     * @param credential
     *            Credential of the account
     * @param namespaceID
     *            the id of the namespace
     * @param setOfClassesRequiredCreatedInNamespace
     *            the set of classes and its related info
     * @return The interfaces for a contract
     * @throws RemoteException
     *             if a RemoteException occurs in InterfaceManager or ClassManager
     */
    private Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; registerReqInterfacesForClasses(
            final AccountID accountID, final PasswordCredential credential, final NamespaceID namespaceID,
            final Map&lt;MetaClassID, MetaClass&gt; setOfClassesRequiredCreatedInNamespace) {

<span class="nc" id="L5219">        final String namespace = namespaceMgrApi.getNamespaceInfo(namespaceID).getName();</span>
<span class="nc" id="L5220">        final String accountName = accountMgrApi.getAccount(accountID).getUsername();</span>
        // Init result
<span class="nc" id="L5222">        final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; newInterfacesInContract = //</span>
                new HashMap&lt;&gt;();

<span class="nc bnc" id="L5225" title="All 2 branches missed.">        for (final Entry&lt;MetaClassID, MetaClass&gt; curEntry : setOfClassesRequiredCreatedInNamespace.entrySet()) {</span>
<span class="nc" id="L5226">            final MetaClassID mclassID = curEntry.getKey();</span>
<span class="nc" id="L5227">            final MetaClass currentMclassInfo = curEntry.getValue();</span>

<span class="nc" id="L5229">            final Set&lt;String&gt; operationsSignatures = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5230">            final Set&lt;OpImplementations&gt; opImpls = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5231">            final Map&lt;OperationID, OpImplementations&gt; actualOpImpls = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5232" title="All 2 branches missed.">            for (final Operation op : currentMclassInfo.getOperations()) {</span>
<span class="nc" id="L5233">                operationsSignatures.add(op.getNameAndDescriptor());</span>
<span class="nc" id="L5234">                final OpImplementations opImplem = new OpImplementations(op.getNameAndDescriptor(), 0, 0);</span>
<span class="nc" id="L5235">                opImpls.add(opImplem);</span>
<span class="nc" id="L5236">                final ImplementationID implID = op.getImplementations().get(0).getDataClayID();</span>
<span class="nc" id="L5237">                opImplem.setLocalImplementationID(implID);</span>
<span class="nc" id="L5238">                opImplem.setRemoteImplementationID(implID);</span>
<span class="nc" id="L5239">                actualOpImpls.put(op.getDataClayID(), opImplem);</span>
<span class="nc" id="L5240">            }</span>

<span class="nc" id="L5242">            final Set&lt;String&gt; propNames = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L5243" title="All 2 branches missed.">            for (final Property prop : currentMclassInfo.getProperties()) {</span>
<span class="nc" id="L5244">                propNames.add(prop.getName());</span>
<span class="nc" id="L5245">            }</span>

            // Register the new Interface for the class
<span class="nc" id="L5248">            final Interface newInterface = new Interface(accountName, namespace, namespace, currentMclassInfo.getName(),</span>
                    propNames, operationsSignatures);

<span class="nc" id="L5251">            this.newInterface(accountID, credential, newInterface);</span>

<span class="nc" id="L5253">            MetaClassID parentID = null;</span>
<span class="nc bnc" id="L5254" title="All 2 branches missed.">            if (currentMclassInfo.getParentType() != null) {</span>
<span class="nc" id="L5255">                parentID = currentMclassInfo.getParentType().getClassID();</span>
            }

            // Update the interfaces in contract
<span class="nc" id="L5259">            final InterfaceInContract interfaceInContract = new InterfaceInContract(newInterface, opImpls);</span>
<span class="nc" id="L5260">            interfaceInContract.setAccessibleImplementations(actualOpImpls);</span>
<span class="nc" id="L5261">            newInterfacesInContract.put(mclassID, new Triple&lt;&gt;(newInterface, interfaceInContract, parentID));</span>
<span class="nc" id="L5262">        }</span>

<span class="nc" id="L5264">        return newInterfacesInContract;</span>
    }

    /**
     * @breief Registers the required merged interfaces from the given imports being
     *         used for the interfaces In Contract
     * @param accountID
     *            the account that creates the contract
     * @param credential
     *            Account credentials
     * @param namespaceID
     *            the id for the contract
     * @param metaClassesOfInterfacesInContract
     *            interfaces in contract indexed by class
     * @param setOfIncludesRequiredNotCreatedInNamespaceButImported
     *            the set of classes needed to satisfy the interfaces in contract
     * @return Returns the info of the registered interfaces in contract register
     * @throws RemoteException
     *             if an exception occurs in NamespaceManager, ContractManager or
     *             InterfaceManager
     *
     */
    private Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; registerReqMergedInterfacesFromImports(
            final AccountID accountID, final PasswordCredential credential, final NamespaceID namespaceID,
            final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; metaClassesOfInterfacesInContract,
            final Map&lt;MetaClassID, String&gt; setOfIncludesRequiredNotCreatedInNamespaceButImported) {

        // Init result
<span class="nc" id="L5292">        final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; newInterfacesInContract = //</span>
                new HashMap&lt;&gt;();

        // Init the already done interfaces in contract
<span class="nc" id="L5296">        final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; alreadyDoneInterfacesInContract = //</span>
                new HashMap&lt;&gt;(metaClassesOfInterfacesInContract);

        // =&gt; NAMESPACE MANAGER
        // Get imports and check that contain all the requirements
<span class="nc" id="L5301">        final Map&lt;MetaClassID, Set&lt;ImportedInterface&gt;&gt; importsInfo = namespaceMgrApi</span>
<span class="nc" id="L5302">                .getImportedInterfacesForMetaclasses(namespaceID,</span>
<span class="nc" id="L5303">                        new HashSet&lt;&gt;(setOfIncludesRequiredNotCreatedInNamespaceButImported.keySet()));</span>
<span class="nc bnc" id="L5304" title="All 2 branches missed.">        for (final Entry&lt;MetaClassID, String&gt; curInclude : setOfIncludesRequiredNotCreatedInNamespaceButImported</span>
<span class="nc" id="L5305">                .entrySet()) {</span>
<span class="nc" id="L5306">            final MetaClassID classID = curInclude.getKey();</span>
<span class="nc" id="L5307">            final String className = curInclude.getValue();</span>
<span class="nc bnc" id="L5308" title="All 4 branches missed.">            if (!importsInfo.containsKey(classID) || importsInfo.get(classID).isEmpty()) {</span>
<span class="nc" id="L5309">                throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_IMPORTED,</span>
                        &quot;Class &quot; + className + &quot; not imported in namespace &quot; + namespaceID, false);
            }
<span class="nc" id="L5312">        }</span>

        // =&gt; CONTRACT MANAGER
        // Get info of the interfaces in contract used for the imports
<span class="nc" id="L5316">        final Map&lt;ContractID, HashSet&lt;InterfaceID&gt;&gt; interfacesInContractOfImports = new HashMap&lt;&gt;();</span>
<span class="nc" id="L5317">        final Set&lt;InterfaceID&gt; interfacesIDsOfImports = new HashSet&lt;&gt;();</span>

        // For each class...
<span class="nc bnc" id="L5320" title="All 2 branches missed.">        for (final Set&lt;ImportedInterface&gt; importsInfoOfClass : importsInfo.values()) {</span>
            // For each import for the class...
<span class="nc bnc" id="L5322" title="All 2 branches missed.">            for (final ImportedInterface importInfoOfClass : importsInfoOfClass) {</span>
<span class="nc" id="L5323">                final ContractID curContractID = importInfoOfClass.getContractID();</span>
<span class="nc" id="L5324">                final InterfaceID curInterfaceID = importInfoOfClass.getInterfaceID();</span>
<span class="nc bnc" id="L5325" title="All 2 branches missed.">                if (!interfacesInContractOfImports.containsKey(curContractID)) {</span>
<span class="nc" id="L5326">                    final HashSet&lt;InterfaceID&gt; interfacesInCurContractOfImports = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5327">                    interfacesInContractOfImports.put(curContractID, interfacesInCurContractOfImports);</span>
                }
<span class="nc" id="L5329">                interfacesInContractOfImports.get(curContractID).add(curInterfaceID);</span>
<span class="nc" id="L5330">                interfacesIDsOfImports.add(curInterfaceID);</span>
<span class="nc" id="L5331">            }</span>
<span class="nc" id="L5332">        }</span>
<span class="nc" id="L5333">        final Map&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; ifacesInContractOfImportedIncludes = //</span>
<span class="nc" id="L5334">                contractMgrApi.getInfoOfMultipleInterfacesPerActiveContractsForAccount(accountID,</span>
                        interfacesInContractOfImports);

        // =&gt; INTERFACE MANAGER
        // Get info of the interfaces used for the imports
<span class="nc" id="L5339">        final Map&lt;InterfaceID, Interface&gt; interfacesOfImportedIncludesInfo = interfaceMgrApi</span>
<span class="nc" id="L5340">                .getInterfacesInfo(interfacesIDsOfImports);</span>

        // Index includes by class
<span class="nc" id="L5343">        final Map&lt;MetaClassID, Map&lt;InterfaceID, InterfaceInContract&gt;&gt; infoOfInterfacesInContractOfImportedIncludesPerClass = //</span>
                new HashMap&lt;&gt;();

<span class="nc bnc" id="L5346" title="All 2 branches missed.">        for (final Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt; curInterfacesInContract : ifacesInContractOfImportedIncludes</span>
<span class="nc" id="L5347">                .values()) {</span>

<span class="nc bnc" id="L5349" title="All 2 branches missed.">            for (final Entry&lt;InterfaceID, InterfaceInContract&gt; curEntry : curInterfacesInContract.getFirst()</span>
<span class="nc" id="L5350">                    .entrySet()) {</span>
<span class="nc" id="L5351">                final InterfaceID interfaceID = curEntry.getKey();</span>
<span class="nc" id="L5352">                final InterfaceInContract curInterfaceInContract = curEntry.getValue();</span>

<span class="nc" id="L5354">                final MetaClassID mclassID = interfacesOfImportedIncludesInfo.get(interfaceID).getMetaClassID();</span>
<span class="nc bnc" id="L5355" title="All 2 branches missed.">                if (!metaClassesOfInterfacesInContract.containsKey(mclassID)) {</span>
<span class="nc bnc" id="L5356" title="All 2 branches missed.">                    if (!infoOfInterfacesInContractOfImportedIncludesPerClass.containsKey(mclassID)) {</span>
<span class="nc" id="L5357">                        final Map&lt;InterfaceID, InterfaceInContract&gt; aux = new HashMap&lt;&gt;();</span>
<span class="nc" id="L5358">                        infoOfInterfacesInContractOfImportedIncludesPerClass.put(mclassID, aux);</span>
                    }
<span class="nc" id="L5360">                    infoOfInterfacesInContractOfImportedIncludesPerClass.get(mclassID).put(interfaceID,</span>
                            curInterfaceInContract);
                }
<span class="nc" id="L5363">            }</span>
<span class="nc" id="L5364">        }</span>

        // Build and register Interfaces and the necesssary info for the
        // contract
<span class="nc bnc" id="L5368" title="All 2 branches missed.">        for (final MetaClassID mclassID : infoOfInterfacesInContractOfImportedIncludesPerClass.keySet()) {</span>
<span class="nc bnc" id="L5369" title="All 2 branches missed.">            if (!alreadyDoneInterfacesInContract.containsKey(mclassID)) {</span>
<span class="nc" id="L5370">                final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; registeredClasses = //</span>
<span class="nc" id="L5371">                        buildRegisterInterfacesInContract(accountID, credential, namespaceID, mclassID,</span>
                                alreadyDoneInterfacesInContract, interfacesOfImportedIncludesInfo,
                                infoOfInterfacesInContractOfImportedIncludesPerClass);
<span class="nc" id="L5374">                alreadyDoneInterfacesInContract.putAll(registeredClasses);</span>
<span class="nc" id="L5375">                newInterfacesInContract.putAll(registeredClasses);</span>
            }
<span class="nc" id="L5377">        }</span>
<span class="nc" id="L5378">        return newInterfacesInContract;</span>
    }

    /**
     * Registers an interface for the given class by merging the contents of all the
     * interfaces corresponding to the imports
     *
     * @param accountID
     *            Account performing the action
     * @param credential
     *            Credential of the account
     * @param namespaceID
     *            the ID of the namespace where merged interface is created
     * @param currentClassToRegister
     *            the ID of the class of the merged interface
     * @param alreadyDoneInterfacesInContract
     *            the classes that have been already registered with the same
     *            process (for recursive purposes)
     * @param interfacesOfImportedIncludesInfo
     *            the info of the interfaces of imported includes in the namespace
     * @param ifacesInContractOfImportedIncludesPerClass
     *            the info of the interfaces in contract that were used to import
     *            the includes in the namespace (indexed by class)
     * @return the auto-generated interfaces in contract for the class to be
     *         registered (and its parents if needed)
     * @throws RemoteException
     *             if a RemoteException occurs in InterfaceManager or ClassManager
     */
    private Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; buildRegisterInterfacesInContract(
            final AccountID accountID, final PasswordCredential credential, final NamespaceID namespaceID,
            final MetaClassID currentClassToRegister,
            final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; alreadyDoneInterfacesInContract,
            final Map&lt;InterfaceID, Interface&gt; interfacesOfImportedIncludesInfo,
            final Map&lt;MetaClassID, Map&lt;InterfaceID, InterfaceInContract&gt;&gt; ifacesInContractOfImportedIncludesPerClass) {

        // Init result
<span class="nc" id="L5414">        final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; currentResult = //</span>
                new HashMap&lt;&gt;();

        // Init stuff to be merged
<span class="nc" id="L5418">        final Set&lt;String&gt; operationSignatures = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5419">        final Set&lt;String&gt; propertiesNames = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5420">        MetaClassID parentClassID = null;</span>

        // Merge info of all the interfaces in contract used to import the
        // current class in the namespace
<span class="nc" id="L5424">        final Map&lt;InterfaceID, InterfaceInContract&gt; ifacesInContractOfImportedIncludesForClassToBeRegistered = //</span>
<span class="nc" id="L5425">                ifacesInContractOfImportedIncludesPerClass.get(currentClassToRegister);</span>

<span class="nc bnc" id="L5427" title="All 2 branches missed.">        for (final InterfaceID ifaceID : ifacesInContractOfImportedIncludesForClassToBeRegistered.keySet()) {</span>
<span class="nc" id="L5428">            final Interface curInterfaceOfImportedInclude = interfacesOfImportedIncludesInfo.get(ifaceID);</span>

            // Get parent class ID
<span class="nc" id="L5431">            final MetaClassID curClassID = curInterfaceOfImportedInclude.getMetaClassID();</span>
<span class="nc" id="L5432">            final MetaClass curClassInfo = classMgrApi.getClassInfo(curClassID);</span>

<span class="nc" id="L5434">            parentClassID = null;</span>
<span class="nc bnc" id="L5435" title="All 2 branches missed.">            if (curClassInfo.getParentType() != null) {</span>
<span class="nc" id="L5436">                parentClassID = curClassInfo.getParentType().getClassID();</span>
            }

            // If it is a child class, register parent first if it needs to be
            // registered (RECURSIVELY)
<span class="nc bnc" id="L5441" title="All 4 branches missed.">            if (parentClassID != null &amp;&amp; ifacesInContractOfImportedIncludesPerClass.containsKey(parentClassID)</span>
<span class="nc bnc" id="L5442" title="All 2 branches missed.">                    &amp;&amp; !currentResult.containsKey(parentClassID)</span>
<span class="nc bnc" id="L5443" title="All 2 branches missed.">                    &amp;&amp; !alreadyDoneInterfacesInContract.containsKey(parentClassID)) {</span>
<span class="nc" id="L5444">                final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; partialResult = //</span>
<span class="nc" id="L5445">                        buildRegisterInterfacesInContract(accountID, credential, namespaceID, parentClassID,</span>
                                alreadyDoneInterfacesInContract, interfacesOfImportedIncludesInfo,
                                ifacesInContractOfImportedIncludesPerClass);
<span class="nc" id="L5448">                currentResult.putAll(partialResult);</span>
            }

            // Merge operations and properties for the interface
<span class="nc" id="L5452">            operationSignatures.addAll(curInterfaceOfImportedInclude.getOperationsSignatureInIface());</span>
<span class="nc" id="L5453">            propertiesNames.addAll(curInterfaceOfImportedInclude.getPropertiesInIface());</span>
<span class="nc" id="L5454">        }</span>

        // Merge operations and properties that are enrichments of the class in
        // the namespace
<span class="nc" id="L5458">        final Tuple&lt;Set&lt;PropertyID&gt;, Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt;&gt; enrichmentsOfClassInNamespace = classMgrApi</span>
<span class="nc" id="L5459">                .getEnrichmentsInNamespaceOfClass(currentClassToRegister, namespaceID);</span>
<span class="nc bnc" id="L5460" title="All 2 branches missed.">        for (final PropertyID propID : enrichmentsOfClassInNamespace.getFirst()) {</span>
<span class="nc" id="L5461">            final Property prop = classMgrApi.getPropertyInfo(propID);</span>
<span class="nc" id="L5462">            propertiesNames.add(prop.getName());</span>
<span class="nc" id="L5463">        }</span>
<span class="nc bnc" id="L5464" title="All 2 branches missed.">        for (final OperationID opID : enrichmentsOfClassInNamespace.getSecond().keySet()) {</span>
<span class="nc" id="L5465">            final Operation op = classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L5466">            operationSignatures.add(op.getNameAndDescriptor());</span>
<span class="nc" id="L5467">        }</span>

        // Select the implementations for the operations of the merged interface
<span class="nc" id="L5470">        final Map&lt;OperationID, OpImplementations&gt; opImpls = selectImplementationsForMergedInterface(</span>
<span class="nc" id="L5471">                enrichmentsOfClassInNamespace.getSecond(), ifacesInContractOfImportedIncludesForClassToBeRegistered);</span>

        // Register the merged interface for the current include to be
        // registered
        // as the merge of imported interfaces present in namespace for the
        // corresponding class
<span class="nc" id="L5477">        final String namespaceOfAccount = namespaceMgrApi.getNamespaceInfo(namespaceID).getName();</span>
<span class="nc" id="L5478">        final MetaClass classInfo = classMgrApi.getClassInfo(currentClassToRegister);</span>
<span class="nc" id="L5479">        final String accountName = accountMgrApi.getAccount(accountID).getUsername();</span>
        final InterfaceInContract interfaceInContract;
<span class="nc" id="L5481">        final Interface newInterface = new Interface(accountName, namespaceOfAccount, classInfo.getNamespace(),</span>
<span class="nc" id="L5482">                classInfo.getName(), propertiesNames, operationSignatures);</span>

<span class="nc" id="L5484">        this.newInterface(accountID, credential, newInterface);</span>

<span class="nc" id="L5486">        final Set&lt;OpImplementations&gt; finalOps = new HashSet&lt;&gt;(opImpls.values());</span>
<span class="nc" id="L5487">        interfaceInContract = new InterfaceInContract(newInterface, finalOps);</span>
<span class="nc" id="L5488">        interfaceInContract.setAccessibleImplementations(opImpls);</span>
<span class="nc" id="L5489">        currentResult.put(currentClassToRegister, new Triple&lt;&gt;(newInterface, interfaceInContract, parentClassID));</span>

<span class="nc" id="L5491">        return currentResult;</span>
    }

    /**
     * Select the implementations for operations from those ified in the given
     * interfaces in contract (currently it selects the first OpImplementations that
     * finds for every Operation it parses from the given interfaces in contracts)
     *
     * @param enrichedOperations
     *            the operations created as enrichments of the imported includes
     * @param infoOfInterfacesInContractOfImportedIncludesForClassToBeRegistered
     *            the information of the interfaces in contract related with the
     *            includes of the class accessible via imports
     * @return The selection of accessible implementations for each operation
     */
    private Map&lt;OperationID, OpImplementations&gt; selectImplementationsForMergedInterface(
            final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; enrichedOperations,
            final Map&lt;InterfaceID, InterfaceInContract&gt; infoOfInterfacesInContractOfImportedIncludesForClassToBeRegistered) {

<span class="nc" id="L5510">        final Map&lt;OperationID, OpImplementations&gt; result = new HashMap&lt;&gt;();</span>

        // TODO Default behaviour is selecting the first available
        // implementation as for local and remote
        // we should discuss this (jmarti 3 Sep 2013)

        // Init opImpls of the operations created as enrichments of the imported
        // includes
<span class="nc bnc" id="L5518" title="All 2 branches missed.">        for (final Entry&lt;OperationID, Set&lt;ImplementationID&gt;&gt; entry : enrichedOperations.entrySet()) {</span>
<span class="nc" id="L5519">            final OperationID curEnrichmentID = entry.getKey();</span>
<span class="nc" id="L5520">            final Operation op = classMgrApi.getOperationInfo(curEnrichmentID);</span>
<span class="nc" id="L5521">            final OpImplementations newOpImpls = new OpImplementations(op.getNameAndDescriptor(), 0, 0);</span>
<span class="nc" id="L5522">            final ImplementationID implID = op.getImplementations().get(0).getDataClayID();</span>
<span class="nc" id="L5523">            newOpImpls.setLocalImplementationID(implID);</span>
<span class="nc" id="L5524">            newOpImpls.setRemoteImplementationID(implID);</span>
<span class="nc" id="L5525">            result.put(op.getDataClayID(), newOpImpls);</span>
<span class="nc" id="L5526">        }</span>

        // Init opImpls of the operations already present from the imported
        // includes
<span class="nc bnc" id="L5530" title="All 2 branches missed.">        for (final InterfaceInContract curInterfaceInContract : infoOfInterfacesInContractOfImportedIncludesForClassToBeRegistered</span>
<span class="nc" id="L5531">                .values()) {</span>
<span class="nc" id="L5532">            final Map&lt;OperationID, OpImplementations&gt; curOpImpls = curInterfaceInContract</span>
<span class="nc" id="L5533">                    .getAccessibleImplementations();</span>
<span class="nc bnc" id="L5534" title="All 2 branches missed.">            for (final Entry&lt;OperationID, OpImplementations&gt; curEntry : curOpImpls.entrySet()) {</span>
<span class="nc" id="L5535">                result.put(curEntry.getKey(), curEntry.getValue());</span>
<span class="nc" id="L5536">            }</span>
<span class="nc" id="L5537">        }</span>

<span class="nc" id="L5539">        return result;</span>
    }

    // ============== PRIVATE METHODS FOR STUBS AND DATA MANAGEMENT ==============//

    /**
     * Return the object locations of an object
     *
     * @param objectID
     *            ID of the obejct
     * @return object locations of given object id
     * @throws RuntimeException
     *             if an exception occurs
     */
    private MetaDataInfo getObjectMetadata(final ObjectID objectID) {
        // Get object locations (replicas)
<span class="nc" id="L5555">        final MetaDataInfo metadataInfo = metaDataSrvApi.getObjectMetaData(objectID);</span>
<span class="nc" id="L5556">        return metadataInfo;</span>
    }

    /**
     * Checks provided session and returns its info
     *
     * @param sessionID
     *            ID of the session
     * @return The information of the session
     * @throws RemoteException
     *             if a RemoteException occurs from SessionManager
     */
    private SessionInfo getSessionInfo(final SessionID sessionID) {
        // Get session info
<span class="nc" id="L5570">        final SessionInfo result = sessionMgrApi.getSessionInfo(sessionID);</span>
<span class="nc" id="L5571">        return result;</span>
    }

    /**
     * Method that validates the dataset for store among the datacontracts and
     * calculates the more restrictive end date given all the data contracts.
     *
     * @param dataContractsInfo
     *            Info of the data contracts to be taken into account.
     * @param datasetsInfo
     *            Info of the datasets to be taken into account.
     * @param dataSetForStore
     *            Dataset defined for storing objects.
     * @return Success if the dataset ified for storing objects is among data
     *         contracts.
     */
    private Tuple&lt;DataContractID, Calendar&gt; validateDataSetForStore(
            final Map&lt;DataContractID, DataContract&gt; dataContractsInfo, final Map&lt;String, DataSet&gt; datasetsInfo,
            final DataSetID dataSetForStore) {
<span class="nc" id="L5590">        DataContractID dataContractIDforStore = null;</span>
<span class="nc" id="L5591">        Calendar endDate = null;</span>
<span class="nc bnc" id="L5592" title="All 2 branches missed.">        for (final Entry&lt;DataContractID, DataContract&gt; curDataContractEntry : dataContractsInfo.entrySet()) {</span>
<span class="nc" id="L5593">            final DataContractID curDataContractID = curDataContractEntry.getKey();</span>
<span class="nc" id="L5594">            final DataContract curDataContract = curDataContractEntry.getValue();</span>
<span class="nc" id="L5595">            final DataSetID curDataSetProvider = curDataContract.getProviderDataSetID();</span>
<span class="nc bnc" id="L5596" title="All 2 branches missed.">            if (curDataSetProvider.equals(dataSetForStore)) {</span>
<span class="nc" id="L5597">                dataContractIDforStore = curDataContractID;</span>
            }
<span class="nc" id="L5599">            final Calendar curEndDate = curDataContract.getEndDate();</span>
<span class="nc bnc" id="L5600" title="All 4 branches missed.">            if (endDate == null || curEndDate.before(endDate)) {</span>
<span class="nc" id="L5601">                endDate = curEndDate;</span>
            }
<span class="nc" id="L5603">        }</span>
<span class="nc bnc" id="L5604" title="All 2 branches missed.">        if (dataContractIDforStore == null) {</span>
<span class="nc" id="L5605">            throw new DataClayRuntimeException(ERRORCODE.DATASET_FOR_STORE_NOT_AMONG_DATACONTRACTS);</span>
        }
<span class="nc bnc" id="L5607" title="All 2 branches missed.">        if (endDate.before(Calendar.getInstance())) {</span>
<span class="nc" id="L5608">            throw new DataClayRuntimeException(ERRORCODE.APPLIABLE_END_DATE_FOR_SESSION_IS_BEFORE_CURRENT_DATE);</span>
        }
<span class="nc" id="L5610">        return new Tuple&lt;&gt;(dataContractIDforStore, endDate);</span>
    }

    /**
     * Method that checks whether a dataset is accessible from the given data
     * contracts
     *
     * @param datasetID
     *            ID of the dataset to be checked
     * @param dataContractsInfo
     *            info of the available data contracts
     */
    private void checkDataSetAmongDataContracts(final DataSetID datasetID,
                                                final Map&lt;DataContractID, SessionDataContract&gt; dataContractsInfo) {
<span class="nc" id="L5624">        boolean dataSetFound = false;</span>
<span class="nc bnc" id="L5625" title="All 2 branches missed.">        for (final SessionDataContract dataContract : dataContractsInfo.values()) {</span>
<span class="nc" id="L5626">            dataSetFound = dataContract.getDataSetOfProvider().equals(datasetID);</span>
<span class="nc bnc" id="L5627" title="All 2 branches missed.">            if (dataSetFound) {</span>
<span class="nc" id="L5628">                break;</span>
            }
<span class="nc" id="L5630">        }</span>
<span class="nc bnc" id="L5631" title="All 2 branches missed.">        if (!dataSetFound) {</span>
<span class="nc" id="L5632">            throw new DataClayRuntimeException(ERRORCODE.DATASET_NOT_AMONG_DATACONTRACTS);</span>
        }
<span class="nc" id="L5634">    }</span>

    /**
     * Retrieve the StubInfo from info of Interfaces and Contracts.
     *
     * @param applicantAccountID
     *            The applicantAccountID for the resulting StubInfo.
     * @param metaClassID
     *            The ID for the MetaClass. All provided Interfaces should be
     *            consistent with it.
     * @param infoOfInterfacesAndContractsOfClass
     *            Information for Interfaces and Contracts.
     * @return The StubInfo for the specified class.
     * @throws RemoteException
     *             thrown by ClassManager
     */
    private StubInfo getStubInfoForMetaClass(final AccountID applicantAccountID, final MetaClassID metaClassID,
                                             final LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt; infoOfInterfacesAndContractsOfClass) {
<span class="nc bnc" id="L5652" title="All 2 branches missed.">        if (applicantAccountID == null) {</span>
<span class="nc" id="L5653">            throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                    &quot;Applicant account ID is null (private function)&quot;, false);
<span class="nc bnc" id="L5655" title="All 2 branches missed.">        } else if (infoOfInterfacesAndContractsOfClass == null) {</span>
<span class="nc" id="L5656">            throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                    &quot;Info of interfaces and contracts of class is null (private function)&quot;, false);
<span class="nc bnc" id="L5658" title="All 2 branches missed.">        } else if (infoOfInterfacesAndContractsOfClass.isEmpty()) {</span>
<span class="nc" id="L5659">            throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
                    &quot;Info of interfaces and contracts of class is empty (private function)&quot;, false);
        }

        // Merge of operations and properties
<span class="nc" id="L5664">        final Map&lt;String, ImplementationStubInfo&gt; implsInInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc" id="L5665">        final Map&lt;String, ImplementationStubInfo&gt; implsInInterfacesByID = new HashMap&lt;&gt;();</span>

<span class="nc" id="L5667">        final Map&lt;String, PropertyStubInfo&gt; propertiesInInterfaces = new HashMap&lt;&gt;();</span>

<span class="nc" id="L5669">        final List&lt;String&gt; propertyListForStub = new LinkedList&lt;&gt;();</span>

<span class="nc" id="L5671">        final MetaClass classInfo = classMgrApi.getClassInfo(metaClassID);</span>

<span class="nc bnc" id="L5673" title="All 2 branches missed.">        for (final Entry&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt; curInfo : infoOfInterfacesAndContractsOfClass</span>
<span class="nc" id="L5674">                .entrySet()) {</span>
<span class="nc" id="L5675">            final ContractID contractID = curInfo.getKey();</span>
<span class="nc" id="L5676">            final Contract contractInfo = curInfo.getValue().getFirst();</span>
<span class="nc" id="L5677">            final Interface interfaceInfo = curInfo.getValue().getSecond();</span>
<span class="nc" id="L5678">            final InterfaceID interfaceID = interfaceInfo.getDataClayID();</span>

<span class="nc bnc" id="L5680" title="All 2 branches missed.">            if (!metaClassID.equals(interfaceInfo.getMetaClassID())) {</span>
<span class="nc" id="L5681">                throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE,</span>
                        &quot;All interfaces should be defined for the same MetaClass&quot;, false);
            }

            // Build the info for the properties of the stub
<span class="nc" id="L5686">            final SortedSet&lt;Property&gt; propertiesInStub = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L5687" title="All 2 branches missed.">            for (final PropertyID propertyID : interfaceInfo.getPropertiesIDs()) {</span>
<span class="nc" id="L5688">                final Property prop = classMgrApi.getPropertyInfo(propertyID);</span>
<span class="nc" id="L5689">                propertiesInStub.add(prop);</span>

<span class="nc bnc" id="L5691" title="All 2 branches missed.">                if (!propertiesInInterfaces.containsKey(propertyID.toString())) {</span>
<span class="nc" id="L5692">                    final PropertyStubInfo psi = new PropertyStubInfo(propertyID, prop.getName(), prop.getType(),</span>
<span class="nc" id="L5693">                            prop.getGetterOperationID(), prop.getSetterOperationID(), prop.getNamespace(),</span>
<span class="nc" id="L5694">                            prop.getNamespaceID(), prop.getBeforeUpdate(), prop.getAfterUpdate(), prop.getInMaster());</span>
<span class="nc" id="L5695">                    propertiesInInterfaces.put(prop.getName(), psi);</span>
                }
<span class="nc" id="L5697">            }</span>
            // Now add all the names of properties, sorted
<span class="nc bnc" id="L5699" title="All 2 branches missed.">            for (final Property prop : propertiesInStub) {</span>
<span class="nc" id="L5700">                propertyListForStub.add(prop.getName());</span>
<span class="nc" id="L5701">            }</span>

            // Build the info for the operations of the stub
<span class="nc bnc" id="L5704" title="All 2 branches missed.">            for (final OperationID operationID : interfaceInfo.getOperationsIDs()) {</span>
                // TODO: We could think about a better mechanism to select which is the remote
                // implementation
                // for the operations of the stub, now we are getting LAST one (6 Feb 2014
                // dgasull)
<span class="nc" id="L5709">                final Map&lt;OperationID, OpImplementations&gt; opsImpls = contractInfo.getInterfacesInContract()</span>
<span class="nc" id="L5710">                        .get(interfaceID).getAccessibleImplementations();</span>
<span class="nc" id="L5711">                final OpImplementations opImpls = opsImpls.get(operationID);</span>
<span class="nc" id="L5712">                final Operation op = classMgrApi.getOperationInfo(operationID);</span>

                // Get info of remote implementation to get responsible
<span class="nc" id="L5715">                final HashSet&lt;ImplementationID&gt; implsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5716">                implsIDs.add(opImpls.getRemoteImplementationID());</span>
<span class="nc" id="L5717">                final Implementation implInfo = classMgrApi.getInfoOfImplementations(implsIDs)</span>
<span class="nc" id="L5718">                        .get(opImpls.getRemoteImplementationID());</span>

<span class="nc" id="L5720">                final ImplementationStubInfo implStubInfo = new ImplementationStubInfo(implInfo.getNamespace(),</span>
<span class="nc" id="L5721">                        implInfo.getClassName(), op.getNameAndDescriptor(), op.getParams(), op.getParamsOrder(),</span>
<span class="nc" id="L5722">                        op.getReturnType(), op.getDataClayID(), opImpls.getLocalImplementationID(),</span>
<span class="nc" id="L5723">                        opImpls.getRemoteImplementationID(), contractID, interfaceID, applicantAccountID,</span>
<span class="nc" id="L5724">                        implInfo.getNamespaceID(), implInfo.getPosition());</span>
<span class="nc" id="L5725">                implsInInterfaces.put(implInfo.getOpNameAndDescriptor(), implStubInfo);</span>
<span class="nc" id="L5726">                implsInInterfacesByID.put(implStubInfo.getLocalImplID().toString(), implStubInfo);</span>
<span class="nc" id="L5727">                implsInInterfacesByID.put(implStubInfo.getRemoteImplID().toString(), implStubInfo);</span>
<span class="nc" id="L5728">            }</span>
<span class="nc" id="L5729">        }</span>

        /*
         * // WARNING abarcelo -- Removed the language check because this function
         * should be agnostic // Before, the namespacesIDs were being tracked --and here
         * they were checked.
         *
         * // Get namespaces info Map&lt;NamespaceID, Namespace&gt; namespacesInfo =
         * namespaceMgrApi.getNamespacesInfo(namespacesIDs);
         * checkNamespacesLanguage(namespacesInfo); // TODO maybe the language check
         * should be done on getStubs (for non-Babel scenarios)?
         */

<span class="nc" id="L5742">        String nameOfParentClass = null;</span>
<span class="nc bnc" id="L5743" title="All 2 branches missed.">        if (classInfo.getParentType() != null) {</span>
<span class="nc" id="L5744">            nameOfParentClass = classInfo.getParentType().getTypeName();</span>
        }

<span class="nc" id="L5747">        return new StubInfo(classInfo.getNamespace(), classInfo.getName(), nameOfParentClass, applicantAccountID,</span>
<span class="nc" id="L5748">                classInfo.getDataClayID(), classInfo.getNamespaceID(), implsInInterfacesByID, implsInInterfaces,</span>
                propertiesInInterfaces, propertyListForStub,
<span class="nc" id="L5750">                new HashSet&lt;&gt;(infoOfInterfacesAndContractsOfClass.keySet()));</span>
    }

    /**
     * Retrieve the StubInfo with all implementations and information.
     *
     * @param metaClassID
     *            The ID for the MetaClass. All provided Interfaces should be
     *            consistent with it.
     * @return The StubInfo for the specified class.
     * @throws RemoteException
     *             thrown by ClassManager
     */
    private StubInfo getStubInfoForExecutionClass(final MetaClassID metaClassID) {

        // Merge of operations and properties
<span class="nc" id="L5766">        final Map&lt;String, ImplementationStubInfo&gt; implsInInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc" id="L5767">        final Map&lt;String, ImplementationStubInfo&gt; implsInInterfacesByID = new HashMap&lt;&gt;();</span>

<span class="nc" id="L5769">        final Map&lt;String, PropertyStubInfo&gt; propertiesInInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc" id="L5770">        final List&lt;String&gt; propertyListForStub = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L5771">        final MetaClass classInfo = classMgrApi.getClassInfo(metaClassID);</span>

        // Build the info for the properties of the stub
<span class="nc" id="L5774">        final SortedSet&lt;Property&gt; propertiesInStub = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L5775" title="All 2 branches missed.">        for (final Property prop : classInfo.getProperties()) {</span>
<span class="nc" id="L5776">            final PropertyID propertyID = prop.getDataClayID();</span>
<span class="nc" id="L5777">            propertiesInStub.add(prop);</span>
<span class="nc bnc" id="L5778" title="All 2 branches missed.">            if (!propertiesInInterfaces.containsKey(propertyID.toString())) {</span>
<span class="nc" id="L5779">                propertiesInInterfaces.put(prop.getName(),</span>
<span class="nc" id="L5780">                        new PropertyStubInfo(propertyID, prop.getName(), prop.getType(), prop.getGetterOperationID(),</span>
<span class="nc" id="L5781">                                prop.getSetterOperationID(), prop.getNamespace(), prop.getNamespaceID(),</span>
<span class="nc" id="L5782">                                prop.getBeforeUpdate(), prop.getAfterUpdate(), prop.getInMaster()));</span>
            }
<span class="nc" id="L5784">        }</span>
        // Now add all the names of properties, sorted
<span class="nc bnc" id="L5786" title="All 2 branches missed.">        for (final Property prop : propertiesInStub) {</span>
<span class="nc" id="L5787">            propertyListForStub.add(prop.getName());</span>
<span class="nc" id="L5788">        }</span>

        // Build the info for the operations of the stub
<span class="nc bnc" id="L5791" title="All 2 branches missed.">        for (final Operation op : classInfo.getOperations()) {</span>
<span class="nc bnc" id="L5792" title="All 2 branches missed.">            for (final Implementation impl : op.getImplementations()) {</span>
                // Get info of remote implementation to get responsible
<span class="nc" id="L5794">                final ImplementationStubInfo implStubInfo = new ImplementationStubInfo(impl.getNamespace(),</span>
<span class="nc" id="L5795">                        impl.getClassName(), op.getNameAndDescriptor(), op.getParams(), op.getParamsOrder(),</span>
<span class="nc" id="L5796">                        op.getReturnType(), op.getDataClayID(), impl.getDataClayID(), impl.getDataClayID(), null, null,</span>
<span class="nc" id="L5797">                        null, impl.getNamespaceID(), impl.getPosition());</span>

                // Prepare opNameAndSignature : opName + $$ + numImpl + signature
<span class="nc" id="L5800">                final String opNameAndSignatureExec = op.getName() + &quot;$$&quot; + impl.getPosition() + op.getDescriptor();</span>
<span class="nc" id="L5801">                implsInInterfaces.put(opNameAndSignatureExec, implStubInfo);</span>
<span class="nc" id="L5802">                implsInInterfacesByID.put(implStubInfo.getLocalImplID().toString(), implStubInfo);</span>
<span class="nc" id="L5803">                implsInInterfacesByID.put(implStubInfo.getRemoteImplID().toString(), implStubInfo);</span>
<span class="nc" id="L5804">            }</span>
<span class="nc" id="L5805">        }</span>

<span class="nc" id="L5807">        String nameOfParentClass = null;</span>
<span class="nc bnc" id="L5808" title="All 2 branches missed.">        if (classInfo.getParentType() != null) {</span>
            // Execution class must include namespace
<span class="nc" id="L5810">            nameOfParentClass = classInfo.getNamespace() + &quot;.&quot; + classInfo.getParentType().getTypeName();</span>
        }
<span class="nc" id="L5812">        return new StubInfo(classInfo.getNamespace(), classInfo.getName(), nameOfParentClass, null,</span>
<span class="nc" id="L5813">                classInfo.getDataClayID(), classInfo.getNamespaceID(), implsInInterfacesByID, implsInInterfaces,</span>
                propertiesInInterfaces, propertyListForStub, null);
    }

    /**
     * Method that generates the &quot;Babel&quot; stub (language independent YAML-based)
     * corresponding to the interfaces in contracts provided.
     *
     * @param applicantAccountID
     *            the applicant for the stub
     * @param metaClassID
     *            The ID for the MetaClass. All provided Interfaces should be
     *            consistent with it.
     * @param infoOfInterfacesAndContractsOfClass
     *            info of the contracts related with the class of the stub to be
     *            generated
     * @return The yaml representation of the babel stub. FAIL otherwise.
     */
    private String generateBabelStub(final AccountID applicantAccountID, final MetaClassID metaClassID,
                                     final LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt; infoOfInterfacesAndContractsOfClass) {
<span class="nc" id="L5833">        final StubInfo stubInfo = getStubInfoForMetaClass(applicantAccountID, metaClassID,</span>
                infoOfInterfacesAndContractsOfClass);
<span class="nc" id="L5835">        final Yaml yaml = CommonYAML.getYamlObject();</span>
<span class="nc" id="L5836">        final String babelStubStructure = yaml.dump(stubInfo);</span>
<span class="nc" id="L5837">        return babelStubStructure;</span>

    }

    @Override
    public void activateTracing(final int currentAvailableTaskID) {
<span class="nc" id="L5843">        LOGGER.info(&quot;Extrae activating trace with task ID {}&quot;, currentAvailableTaskID);</span>

<span class="nc" id="L5845">        synchronized (DataClayExtrae.class) { //All workers could try to do it</span>
<span class="nc bnc" id="L5846" title="All 2 branches missed.">            if (DataClayExtrae.extraeTracingIsEnabled()) {</span>
<span class="nc" id="L5847">                LOGGER.info(&quot;Extrae already enabled&quot;);</span>
<span class="nc" id="L5848">                return;</span>
            }
            try {
<span class="nc" id="L5851">                int nextTaskID = 1;</span>
<span class="nc bnc" id="L5852" title="All 2 branches missed.">                if (currentAvailableTaskID != 0) {</span>
                    // A task ID available = 0 means that the client was activated only for dataclay without compss
                    // therefore LogicModule task id is 1
<span class="nc" id="L5855">                    nextTaskID = currentAvailableTaskID;</span>
                }

<span class="nc" id="L5858">                LOGGER.info(&quot;Initializing extrae with next available task id {}&quot;, nextTaskID);</span>
<span class="nc" id="L5859">                DataClayExtrae.setCurrentAvailableTaskID(nextTaskID);</span>
<span class="nc" id="L5860">                DataClayExtrae.initializeExtrae(true);</span>

                // DataServices Paraver traces
<span class="nc bnc" id="L5863" title="All 2 branches missed.">                for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_JAVA)</span>
<span class="nc" id="L5864">                        .values()) {</span>
<span class="nc" id="L5865">                    LOGGER.info(&quot;Activating Extrae in node {}&quot;, curApi.getSecond());</span>
<span class="nc" id="L5866">                    curApi.getFirst().activateTracing(DataClayExtrae.getAndIncrementCurrentAvailableTaskID());</span>
<span class="nc" id="L5867">                }</span>
<span class="nc bnc" id="L5868" title="All 2 branches missed.">                for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_PYTHON)</span>
<span class="nc" id="L5869">                        .values()) {</span>
<span class="nc" id="L5870">                    LOGGER.info(&quot;Activating Extrae in node {}&quot;, curApi.getSecond());</span>
<span class="nc" id="L5871">                    curApi.getFirst().activateTracing(DataClayExtrae.getAndIncrementCurrentAvailableTaskID());</span>

<span class="nc" id="L5873">                }</span>
<span class="nc" id="L5874">            } catch (final Exception ex) {</span>
<span class="nc" id="L5875">                LOGGER.debug(&quot;activateTracing error&quot;, ex);</span>
<span class="nc" id="L5876">                throw ex;</span>
<span class="nc" id="L5877">            }</span>
<span class="nc" id="L5878">        }</span>
<span class="nc" id="L5879">    }</span>

    @Override
    public void deactivateTracing() {
<span class="nc bnc" id="L5883" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L5884">            LOGGER.debug(&quot;** DEACTIVATING EXTRAE TRACING **&quot;);</span>
        }
        // DataServices Paraver traces
<span class="nc" id="L5887">        synchronized (DataClayExtrae.class) { //All workers could try to do it</span>
<span class="nc bnc" id="L5888" title="All 2 branches missed.">            if (DataClayExtrae.extraeTracingIsEnabled()) { //sanity check</span>
<span class="nc" id="L5889">                LOGGER.debug(&quot;Starting deactivation of traces&quot;);</span>
<span class="nc bnc" id="L5890" title="All 2 branches missed.">                for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_JAVA)</span>
<span class="nc" id="L5891">                        .values()) {</span>
<span class="nc" id="L5892">                    LOGGER.debug(&quot;Calling deactivate tracing to DS: &quot; + curApi.getSecond());</span>
<span class="nc" id="L5893">                    curApi.getFirst().deactivateTracing();</span>
<span class="nc" id="L5894">                }</span>
<span class="nc bnc" id="L5895" title="All 2 branches missed.">                for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_PYTHON)</span>
<span class="nc" id="L5896">                        .values()) {</span>
<span class="nc" id="L5897">                    LOGGER.debug(&quot;Calling deactivate tracing to EE: &quot; + curApi.getSecond());</span>
<span class="nc" id="L5898">                    curApi.getFirst().deactivateTracing();</span>
<span class="nc" id="L5899">                }</span>
<span class="nc" id="L5900">                DataClayExtrae.finishTracing(true);</span>
            }
<span class="nc" id="L5902">        }</span>
<span class="nc" id="L5903">    }</span>

    @Override
    public void cleanMetaDataCaches() {
<span class="nc" id="L5907">        this.metaDataSrvApi.cleanCaches();</span>
<span class="nc" id="L5908">    }</span>

    @Override
    public Map&lt;String, byte[]&gt; getTraces() {
<span class="nc" id="L5912">        LOGGER.info(&quot;Getting Extrae traces&quot;);</span>
<span class="nc" id="L5913">        synchronized (DataClayExtrae.class) { //All workers could try to do it</span>
<span class="nc" id="L5914">            final Map&lt;String, byte[]&gt; allTraces = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5915" title="All 2 branches missed.">            if (DataClayExtrae.isGeneratedTraces()) {</span>
                // Call DSs
<span class="nc bnc" id="L5917" title="All 2 branches missed.">                for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_JAVA)</span>
<span class="nc" id="L5918">                        .values()) {</span>
<span class="nc" id="L5919">                    LOGGER.debug(&quot;Calling get traces to DS: &quot; + curApi.getSecond());</span>
<span class="nc" id="L5920">                    allTraces.putAll(curApi.getFirst().getTraces());</span>
<span class="nc" id="L5921">                }</span>
<span class="nc bnc" id="L5922" title="All 2 branches missed.">                for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_PYTHON)</span>
<span class="nc" id="L5923">                        .values()) {</span>
<span class="nc" id="L5924">                    LOGGER.debug(&quot;Calling get traces to DS: &quot; + curApi.getSecond());</span>
<span class="nc" id="L5925">                    allTraces.putAll(curApi.getFirst().getTraces());</span>
<span class="nc" id="L5926">                }</span>
<span class="nc" id="L5927">                allTraces.putAll(DataClayExtrae.getTraces());</span>
            }
<span class="nc" id="L5929">            return allTraces;</span>
        }

    }

    /**
     * Wait for all asynchronous request to finish.
     */
    public void waitAndProcessAllAsyncRequests() {
<span class="nc" id="L5938">        grpcClient.waitAndProcessAllAsyncRequests();</span>
<span class="nc" id="L5939">    }</span>

    @Override
    public void closeManagerDb() {

<span class="nc" id="L5944">        this.accountMgrApi.getDbHandler().close();</span>
<span class="nc" id="L5945">        this.classMgrApi.getDbHandler().close();</span>
<span class="nc" id="L5946">        this.contractMgrApi.getDbHandler().close();</span>
<span class="nc" id="L5947">        this.datacontractMgrApi.getDbHandler().close();</span>
<span class="nc" id="L5948">        this.dataSetMgrApi.getDbHandler().close();</span>
<span class="nc" id="L5949">        this.namespaceMgrApi.getDbHandler().close();</span>
<span class="nc" id="L5950">        this.interfaceMgrApi.getDbHandler().close();</span>
<span class="nc bnc" id="L5951" title="All 2 branches missed.">        if (this.notificationMgrApi != null) {</span>
<span class="nc" id="L5952">            this.notificationMgrApi.getNotificationDB().close();</span>
        }
<span class="nc" id="L5954">        this.sessionMgrApi.getDbHandler().close();</span>

<span class="nc" id="L5956">    }</span>

    /**
     * Finish cache threads.
     *
     * @if some exception occurs
     */
    public void finishCacheThreads() {
<span class="nc" id="L5964">        LOGGER.debug(&quot;Finishing client connections...&quot;);</span>
<span class="nc" id="L5965">        grpcClient.finishClientConnections();</span>
<span class="nc" id="L5966">        this.sessionMgrApi.finishCacheThreads();</span>
<span class="nc" id="L5967">        storageLocations.clear();</span>
<span class="nc" id="L5968">        execEnvironments.clear();</span>
<span class="nc" id="L5969">    }</span>

    @Override
    public void closeDb() {
<span class="nc bnc" id="L5973" title="All 2 branches missed.">        if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L5974">            this.notificationMgrApi.closeManager();</span>
        }
<span class="nc" id="L5976">        this.metaDataSrvApi.closeDbHandler();</span>
<span class="nc" id="L5977">    }</span>

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public AccountManagerDB getAccountManagerDB() {
<span class="nc" id="L5985">        return this.accountMgrApi.getDbHandler();</span>
    }

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public ClassManagerDB getClassManagerDB() {
<span class="nc" id="L5994">        return this.classMgrApi.getDbHandler();</span>
    }

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public ContractManagerDB getContractManagerDB() {
<span class="nc" id="L6003">        return this.contractMgrApi.getDbHandler();</span>
    }

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public DataContractManagerDB getDataContractManagerDB() {
<span class="nc" id="L6012">        return this.datacontractMgrApi.getDbHandler();</span>
    }

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public DataSetManagerDB getDataSetManagerDB() {
<span class="nc" id="L6021">        return this.dataSetMgrApi.getDbHandler();</span>
    }

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public NamespaceManagerDB getNamespaceManagerDB() {
<span class="nc" id="L6030">        return this.namespaceMgrApi.getDbHandler();</span>
    }

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public InterfaceManagerDB getInterfaceManagerDB() {
<span class="nc" id="L6039">        return this.interfaceMgrApi.getDbHandler();</span>
    }

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public NotificationManagerDB getNotificationManagerDB() {
<span class="nc" id="L6048">        return this.notificationMgrApi.getNotificationDB();</span>
    }

    /**
     * Get manager db. For testing purposes.
     *
     * @return Manager db.
     */
    public SessionManagerDB getSessionManagerDB() {
<span class="nc" id="L6057">        return this.sessionMgrApi.getDbHandler();</span>
    }

    /**
     * Get logic db. For testing purposes.
     *
     * @return metadataservice db.
     */
    public MetaDataServiceDB getMetaDataServiceDb() {
<span class="nc" id="L6066">        return this.metaDataSrvApi.getDbHandler();</span>
    }

    /**
     * Get Class manager (for testing purposes)
     *
     * @return ClassManager of this logicModule
     */
    public ClassManager getClassManager() {
<span class="nc" id="L6075">        return this.classMgrApi;</span>
    }

    @Override
    public ContractID getContractIDOfDataClayProvider(final AccountID accountID, final PasswordCredential credential) {
        // Validate account
<span class="nc bnc" id="L6081" title="All 2 branches missed.">        if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L6082">            throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
        }
<span class="nc bnc" id="L6084" title="All 2 branches missed.">        if (publicIDs.dcPublicContractID == null) {</span>
<span class="nc" id="L6085">            throw new DataClayRuntimeException(ERRORCODE.CONTRACT_NOT_EXIST, &quot;No dataClay public contract&quot;, false);</span>
        }
<span class="nc" id="L6087">        return publicIDs.dcPublicContractID;</span>
    }

    /**
     * @return the shuttingDown
     */
    public boolean isShuttingDown() {
<span class="nc" id="L6094">        return shuttingDown;</span>
    }

    /**
     * @param theshuttingDown
     *            the shuttingDown to set
     */
    public void setShuttingDown(final boolean theshuttingDown) {
<span class="nc" id="L6102">        this.shuttingDown = theshuttingDown;</span>
<span class="nc" id="L6103">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>