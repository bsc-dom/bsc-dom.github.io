<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogicModule.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.logic</a> &gt; <span class="el_source">LogicModule.java</span></div><h1>LogicModule.java</h1><pre class="source lang-java linenums">
/**
 * @file LogicModule.java
 *
 * @date Sep 17, 2012
 */
package es.bsc.dataclay.logic;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.rmi.RemoteException;
import java.text.ParseException;
import java.util.*;
import java.util.Map.Entry;

import es.bsc.dataclay.exceptions.metadataservice.*;
import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.yaml.snakeyaml.Yaml;

import es.bsc.dataclay.commonruntime.DataServiceRuntime;
import es.bsc.dataclay.communication.grpc.clients.CommonGrpcClient;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.dataservice.api.DataServiceAPI;
import es.bsc.dataclay.dbhandler.DBHandler;
import es.bsc.dataclay.dbhandler.DBHandlerConf;
import es.bsc.dataclay.dbhandler.sql.SQLHandler;
import es.bsc.dataclay.exceptions.DataClayException;
import es.bsc.dataclay.exceptions.DataClayRuntimeException;
import es.bsc.dataclay.exceptions.ErrorDefs.ERRORCODE;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectAlreadyExistException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.accountmgr.AccountAlreadyExistException;
import es.bsc.dataclay.exceptions.logicmodule.accountmgr.AccountNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.datacontractmgr.AccountAlreadyHasADataContractWithProvider;
import es.bsc.dataclay.exceptions.logicmodule.datasetmgr.DataSetExistsException;
import es.bsc.dataclay.exceptions.logicmodule.namespacemgr.AccountNotResponsibleOfNamespace;
import es.bsc.dataclay.exceptions.logicmodule.namespacemgr.NamespaceDoesNotExistException;
import es.bsc.dataclay.exceptions.logicmodule.namespacemgr.NamespaceExistsException;
import es.bsc.dataclay.exceptions.logicmodule.sessionmgr.SessionNotExistException;
import es.bsc.dataclay.extrae.DataClayExtrae;
import es.bsc.dataclay.logic.accountmgr.AccountManager;
import es.bsc.dataclay.logic.accountmgr.AccountManagerDB;
import es.bsc.dataclay.logic.api.LogicModuleAPI;
import es.bsc.dataclay.logic.classmgr.ClassManager;
import es.bsc.dataclay.logic.classmgr.ClassManagerDB;
import es.bsc.dataclay.logic.contractmgr.ContractManager;
import es.bsc.dataclay.logic.contractmgr.ContractManagerDB;
import es.bsc.dataclay.logic.datacontractmgr.DataContractManager;
import es.bsc.dataclay.logic.datacontractmgr.DataContractManagerDB;
import es.bsc.dataclay.logic.datasetmgr.DataSetManager;
import es.bsc.dataclay.logic.datasetmgr.DataSetManagerDB;
import es.bsc.dataclay.logic.interfacemgr.InterfaceManager;
import es.bsc.dataclay.logic.interfacemgr.InterfaceManagerDB;
import es.bsc.dataclay.logic.logicmetadata.LogicMetadataDB;
import es.bsc.dataclay.logic.logicmetadata.LogicMetadataIDs;
import es.bsc.dataclay.logic.namespacemgr.NamespaceManager;
import es.bsc.dataclay.logic.namespacemgr.NamespaceManagerDB;
import es.bsc.dataclay.logic.notificationmgr.NotificationManager;
import es.bsc.dataclay.logic.notificationmgr.NotificationManagerDB;
import es.bsc.dataclay.logic.sessionmgr.SessionManager;
import es.bsc.dataclay.logic.sessionmgr.SessionManagerDB;
import es.bsc.dataclay.metadataservice.MetaDataService;
import es.bsc.dataclay.metadataservice.MetaDataServiceDB;
import es.bsc.dataclay.serialization.lib.DataClayDeserializationLib;
import es.bsc.dataclay.serialization.lib.ObjectWithDataParamOrReturn;
import es.bsc.dataclay.serialization.lib.SerializedParametersOrReturn;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.DataClayObjectMetaData;
import es.bsc.dataclay.util.FileAndAspectsUtils;
import es.bsc.dataclay.util.configs.CfgAdminEnvLoader;
import es.bsc.dataclay.util.events.listeners.ECA;
import es.bsc.dataclay.util.events.message.EventMessage;
import es.bsc.dataclay.util.events.type.EventType;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.ContractID;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.DataContractID;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.InterfaceID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.NamespaceID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.OperationID;
import es.bsc.dataclay.util.ids.PropertyID;
import es.bsc.dataclay.util.ids.SessionID;
import es.bsc.dataclay.util.ids.StorageLocationID;
import es.bsc.dataclay.util.info.VersionInfo;
import es.bsc.dataclay.util.management.accountmgr.Account;
import es.bsc.dataclay.util.management.accountmgr.AccountRole;
import es.bsc.dataclay.util.management.accountmgr.PasswordCredential;
import es.bsc.dataclay.util.management.classmgr.AccessedImplementation;
import es.bsc.dataclay.util.management.classmgr.AccessedProperty;
import es.bsc.dataclay.util.management.classmgr.Implementation;
import es.bsc.dataclay.util.management.classmgr.MetaClass;
import es.bsc.dataclay.util.management.classmgr.Operation;
import es.bsc.dataclay.util.management.classmgr.PrefetchingInformation;
import es.bsc.dataclay.util.management.classmgr.Property;
import es.bsc.dataclay.util.management.classmgr.Type;
import es.bsc.dataclay.util.management.classmgr.UserType;
import es.bsc.dataclay.util.management.contractmgr.Contract;
import es.bsc.dataclay.util.management.contractmgr.InterfaceInContract;
import es.bsc.dataclay.util.management.contractmgr.OpImplementations;
import es.bsc.dataclay.util.management.datacontractmgr.DataContract;
import es.bsc.dataclay.util.management.datasetmgr.DataSet;
import es.bsc.dataclay.util.management.interfacemgr.Interface;
import es.bsc.dataclay.util.management.metadataservice.DataClayInstance;
import es.bsc.dataclay.util.management.metadataservice.ExecutionEnvironment;
import es.bsc.dataclay.util.management.metadataservice.MetaDataInfo;
import es.bsc.dataclay.util.management.metadataservice.RegistrationInfo;
import es.bsc.dataclay.util.management.metadataservice.StorageLocation;
import es.bsc.dataclay.util.management.namespacemgr.ImportedInterface;
import es.bsc.dataclay.util.management.namespacemgr.Namespace;
import es.bsc.dataclay.util.management.sessionmgr.SessionContract;
import es.bsc.dataclay.util.management.sessionmgr.SessionDataContract;
import es.bsc.dataclay.util.management.sessionmgr.SessionImplementation;
import es.bsc.dataclay.util.management.sessionmgr.SessionInfo;
import es.bsc.dataclay.util.management.sessionmgr.SessionInterface;
import es.bsc.dataclay.util.management.sessionmgr.SessionOperation;
import es.bsc.dataclay.util.management.sessionmgr.SessionProperty;
import es.bsc.dataclay.util.management.stubs.ImplementationStubInfo;
import es.bsc.dataclay.util.management.stubs.PropertyStubInfo;
import es.bsc.dataclay.util.management.stubs.StubClassLoader;
import es.bsc.dataclay.util.management.stubs.StubInfo;
import es.bsc.dataclay.util.reflection.Reflector;
import es.bsc.dataclay.util.structs.Triple;
import es.bsc.dataclay.util.structs.Tuple;
import es.bsc.dataclay.util.tools.java.JavaSpecGenerator;
import es.bsc.dataclay.util.yaml.CommonYAML;

/**
 * This class represents the entry point to the system.
 * @param &lt;T&gt; Could be LogicModule using Postgres or SQLite
 */
public abstract class LogicModule&lt;T extends DBHandlerConf&gt; implements LogicModuleAPI {

	/** Logger. */
<span class="nc" id="L142">	protected static final Logger LOGGER = LogManager.getLogger(&quot;LogicModule&quot;);</span>

	/** Indicates if debug is enabled. */
<span class="nc" id="L145">	protected static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

	/** LogicModule hostname. */
	protected String hostname;
	/** LogicModule port. */
	protected int port;

	/** Grpc client. */
	public final CommonGrpcClient grpcClient;

	/** DataService APIs, with associated StorageLocation. */
<span class="nc" id="L156">	private final Map&lt;StorageLocationID, Tuple&lt;DataServiceAPI, StorageLocation&gt;&gt; storageLocations = new HashMap&lt;&gt;();</span>

	/**
	 * DataService APIs, associated to ExecutionEnvironment (language dependent).
	 */
<span class="nc" id="L161">	private final Map&lt;Langs, Map&lt;ExecutionEnvironmentID, Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt;&gt;&gt; execEnvironments = new HashMap&lt;&gt;();</span>

	/** Active Backends splitted in execution environments per storage Locations. */
<span class="nc" id="L164">	private final Map&lt;StorageLocationID, Set&lt;ExecutionEnvironmentID&gt;&gt; activeBackends = new HashMap&lt;&gt;();</span>
	
	/** Name of public namespace DataClay (for DataClay classes). */
	public static final String DC_PUBLIC_NAMESPACE = &quot;DataClayNamespace&quot;;
	/** Name of DataClay registrator (for DataClay classes). */
	public static final String DC_REGISTRATOR = &quot;DataClayRegistrator&quot;;
	/** Suffix for default dataset. */
	public static final String DEFAULT_DS_SUFFIX = &quot;_ds&quot;;
	/** Suffix for default java namespace. */
	public static final String DEFAULT_JAVA_NS_SUFFIX = &quot;_java_ns&quot;;
	/** Suffix for default python namespace. */
	public static final String DEFAULT_PYTHON_NS_SUFFIX = &quot;_python_ns&quot;;

	/** Account Manager. */
	private final AccountManager accountMgrApi;
	/** Contract Manager. */
	private final ContractManager contractMgrApi;
	/** Interface Manager. */
	private final InterfaceManager interfaceMgrApi;
	/** Class Manager. */
	private final ClassManager classMgrApi;
	/** Namespace Manager. */
	private final NamespaceManager namespaceMgrApi;
	/** Session Manager. */
	private final SessionManager sessionMgrApi;
	/** MetaDataService. */
	private final MetaDataService metaDataSrvApi;
	/** DataSet Manager. */
	private final DataSetManager dataSetMgrApi;
	/** DataContract Manager. */
	private final DataContractManager datacontractMgrApi;
	/** NotificationManager. */
	private NotificationManager notificationMgrApi;
	/** LogicModule IDs DB. */
	private final LogicMetadataDB logicMetaDataDB;
	/**
	 * LM public IDs (admin, contract, datasets...) This field contains all IDs that
	 * must be the same even if we restart LM or for backups.
	 */
<span class="nc" id="L203">	public LogicMetadataIDs publicIDs = new LogicMetadataIDs();</span>

	/** Credentials of DataClay registrator (for DataClay classes). */
<span class="nc" id="L206">	public PasswordCredential dcCredentials = new PasswordCredential(DC_REGISTRATOR);</span>

	/** IPs to be send to clients when information of a registered EE/SL is required. Can be null.*/
	private final String exposedIPForClient; 

	/** Account to register federation stuff. */
	private static final String FEDERATOR_ACCOUNT_USERNAME = &quot;Federator&quot;;
	/** Name of dataset for external objects. */
	private static final String EXTERNAL_OBJECTS_DATASET_NAME = &quot;ExternalObjects&quot;;
	/** Namespace of classes for federable Java class model. */
	private static final String JAVA_NAMESPACE_FOR_FEDERABLE_CLASSES = &quot;JavaFederableNamespace&quot;;
	/** Namespace of classes for federable Python class model. */
	private static final String PY_NAMESPACE_FOR_FEDERABLE_CLASSES = &quot;PythonFederableNamespace&quot;;

	/** Session ID for activity coming from external dataclays. */
	private static SessionID federationSessionID;

	/** Indicates if it is being shut down. */
<span class="nc" id="L224">	private boolean shuttingDown = false;</span>

	/** LogicModule read conf. */
	protected final T dbConf;

	/** Logic Module database handler. */
	protected final SQLHandler&lt;T&gt; logicModuleHandler;

	/** Name of the LM */
	protected String name;

	/**
	 * LogicModule constructor
	 * 
	 * @param lmName
	 *            LM name
	 * @param thehostname
	 *            Logic module host name
	 * @param theport
	 *            Logic Module port.
	 * @param theexposedIPForClient
	 * 			IPs to be send to clients when information of a registered EE/SL is required. Can be null.
	 * @throws InterruptedException
	 *             If GRPC client cannot be initialized for some reason
	 */
	public LogicModule(final String lmName, final String thehostname, final int theport, 
<span class="nc" id="L250">			final String theexposedIPForClient) throws InterruptedException {</span>

		// ==== Initialization note === //
		// Here we set all variables read from configuration files (parameters) and
		// we check if LM has already an admin, a public dataset, a public contract...
		// by asking
		// to LogicMetadataDB.sh
		// If LogicMetadataDB has information about this logic module then
		// it means that we do not need to create admin, install dataclay collections
		// and others.
		// Otherwise, if there is no information about current LogicModule in the
		// database, we create
		// all needed ids (including DataClayInstanceID) and others.
<span class="nc" id="L263">		this.name = lmName;</span>

<span class="nc" id="L265">		dbConf = initDBConf();</span>
<span class="nc" id="L266">		logicModuleHandler = initDBHandler();</span>
		// TODO generalize when dbhandler will not be sql-based
<span class="nc" id="L268">		final BasicDataSource dataSource = ((SQLHandler&lt;?&gt;) logicModuleHandler).getDataSource();</span>

<span class="nc" id="L270">		hostname = thehostname;</span>
<span class="nc" id="L271">		port = theport;</span>
<span class="nc" id="L272">		this.exposedIPForClient = theexposedIPForClient;</span>
<span class="nc" id="L273">		grpcClient = new CommonGrpcClient(lmName);</span>
<span class="nc" id="L274">		accountMgrApi = new AccountManager(dataSource);</span>
<span class="nc" id="L275">		sessionMgrApi = new SessionManager(dataSource);</span>
<span class="nc" id="L276">		namespaceMgrApi = new NamespaceManager(dataSource);</span>
<span class="nc" id="L277">		dataSetMgrApi = new DataSetManager(dataSource);</span>
<span class="nc" id="L278">		classMgrApi = new ClassManager(dataSource);</span>
<span class="nc" id="L279">		interfaceMgrApi = new InterfaceManager(dataSource);</span>
<span class="nc" id="L280">		contractMgrApi = new ContractManager(dataSource);</span>
<span class="nc" id="L281">		datacontractMgrApi = new DataContractManager(dataSource);</span>
<span class="nc" id="L282">		metaDataSrvApi = new MetaDataService(dataSource);</span>
		// Tricky initialization for the *ByLang table of tables
<span class="nc bnc" id="L284" title="All 2 branches missed.">		for (final Langs lang : Langs.values()) {</span>
<span class="nc" id="L285">			execEnvironments.put(lang, new HashMap&lt;ExecutionEnvironmentID, Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt;&gt;());</span>
		}

<span class="nc bnc" id="L288" title="All 2 branches missed.">		if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L289">			notificationMgrApi = new NotificationManager(this, dataSource);</span>
		}

<span class="nc" id="L292">		logicMetaDataDB = new LogicMetadataDB(dataSource);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">		if (!logicMetaDataDB.existsMetaData()) {</span>
<span class="nc" id="L294">			this.prepareLogicModuleFirstTime(lmName, thehostname, theport);</span>
		} else {
			// update registered nodes!
<span class="nc" id="L297">			this.publicIDs = this.logicMetaDataDB.getLogicMetadata();</span>
<span class="nc" id="L298">			this.updateAPIsFromDB();</span>
		}
<span class="nc" id="L300">		LOGGER.info(&quot;Initialized Logic Module for dataClay with id {}&quot;, publicIDs.dcID);</span>
<span class="nc" id="L301">		LOGGER.info(&quot;Initialized Logic Module with hostname {} and port {}&quot;, hostname, port);</span>

<span class="nc" id="L303">	}</span>

	/**
	 * Prepare Lm for the first time (not for restart or others)
	 * 
	 * @param lmName
	 *            LM name
	 * @param thehostname
	 *            Logic module host name
	 * @param theport
	 *            Logic Module port.
	 * @throws InterruptedException
	 *             If GRPC client cannot be initialized for some reason
	 */
	private void prepareLogicModuleFirstTime(final String lmName, final String thehostname, final int theport) {

		// TODO: review uneeded code for checking if admin, datasets and others are
		// already created since
		// this function is called when LogicModule is restarted or using an existing
		// DB.

<span class="nc" id="L324">		publicIDs.dcID = new DataClayInstanceID();</span>
<span class="nc" id="L325">		final Account adminAccount = CfgAdminEnvLoader.parseAdminUser();</span>
<span class="nc" id="L326">		LOGGER.info(&quot;Creating admin user with name &quot; + adminAccount.getUsername() + &quot; and password &quot;</span>
<span class="nc" id="L327">				+ adminAccount.getCredential().toString());</span>
		try {
<span class="nc" id="L329">			publicIDs.dcAdminID = accountMgrApi.getAccountID(adminAccount.getUsername());</span>
<span class="nc" id="L330">			LOGGER.info(&quot;Account admin already exists&quot;);</span>
<span class="nc" id="L331">		} catch (final AccountNotExistException e) {</span>
			// Create Admin account
<span class="nc" id="L333">			publicIDs.dcAdminID = new AccountID();</span>
<span class="nc" id="L334">			adminAccount.setDataClayID(publicIDs.dcAdminID);</span>
<span class="nc" id="L335">			final AccountManagerDB accountDbHandler = accountMgrApi.getDbHandler();</span>
			try {
<span class="nc" id="L337">				accountDbHandler.store(adminAccount);</span>
<span class="nc" id="L338">			} catch (final DbObjectAlreadyExistException err) {</span>
				// ignore
<span class="nc" id="L340">			}</span>
<span class="nc" id="L341">		}</span>
		// Register dataSet for external objects (federated with us)
<span class="nc" id="L343">		final PasswordCredential fedCredential = new PasswordCredential(FEDERATOR_ACCOUNT_USERNAME);</span>
<span class="nc" id="L344">		final Account federator = new Account(FEDERATOR_ACCOUNT_USERNAME, AccountRole.NORMAL_ROLE,</span>
				fedCredential);
		try {
<span class="nc" id="L347">			federator.setDataClayID(newAccount(publicIDs.dcAdminID, adminAccount.getCredential(), federator));</span>
<span class="nc" id="L348">		} catch (final AccountAlreadyExistException | NamespaceExistsException ne) {</span>
			// namespace might exist in case of mf2c starting db
<span class="nc" id="L350">			federator.setDataClayID(accountMgrApi.getAccountID(FEDERATOR_ACCOUNT_USERNAME));</span>
<span class="nc" id="L351">			LOGGER.info(&quot;Account Federator already exists&quot;);</span>
<span class="nc" id="L352">		}</span>

<span class="nc" id="L354">		final DataSet dataset = new DataSet(EXTERNAL_OBJECTS_DATASET_NAME, federator.getDataClayID(), true);</span>
<span class="nc" id="L355">		DataContract dContract = null;</span>
		try {
<span class="nc" id="L357">			dataset.setDataClayID(newDataSet(federator.getDataClayID(), federator.getCredential(), dataset));</span>

<span class="nc" id="L359">			final Calendar beginDate = Calendar.getInstance();</span>
<span class="nc" id="L360">			beginDate.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L361">			final Calendar endDate = Calendar.getInstance();</span>
<span class="nc" id="L362">			endDate.add(Calendar.YEAR, 100);</span>
<span class="nc" id="L363">			dContract = new DataContract(dataset.getDataClayID(), federator.getDataClayID(),</span>
					new HashSet&lt;&gt;(), beginDate, endDate, false);
<span class="nc" id="L365">			dContract.setPublicAvailable(true);</span>

<span class="nc" id="L367">			newDataContract(federator.getDataClayID(), federator.getCredential(), dContract);</span>

<span class="nc" id="L369">		} catch (final DataSetExistsException de) {</span>
			// Ignore it, for testing purposes
<span class="nc" id="L371">			dataset.setDataClayID(dataSetMgrApi.getDataSetID(EXTERNAL_OBJECTS_DATASET_NAME));</span>
<span class="nc" id="L372">			LOGGER.info(&quot;Dataset for external objects already exists&quot;);</span>
<span class="nc" id="L373">		}</span>

		// Register namespaces for the model of federated objects
<span class="nc" id="L376">		final Namespace jNamespace = new Namespace(JAVA_NAMESPACE_FOR_FEDERABLE_CLASSES, federator.getUsername(),</span>
				Langs.LANG_JAVA);
<span class="nc" id="L378">		final Namespace pyNamespace = new Namespace(PY_NAMESPACE_FOR_FEDERABLE_CLASSES, federator.getUsername(),</span>
				Langs.LANG_PYTHON);
		try {
<span class="nc" id="L381">			newNamespace(federator.getDataClayID(), federator.getCredential(), jNamespace);</span>
<span class="nc" id="L382">			newNamespace(federator.getDataClayID(), federator.getCredential(), pyNamespace);</span>
<span class="nc" id="L383">		} catch (final NamespaceExistsException ne) {</span>
			// Ignore it
<span class="nc" id="L385">			LOGGER.info(&quot;Namespace for federated objects already exists&quot;);</span>
<span class="nc" id="L386">		}</span>

<span class="nc bnc" id="L388" title="All 2 branches missed.">		if (Configuration.Flags.REGISTER_DATACLAY_CLASSES.getBooleanValue()) {</span>
<span class="nc" id="L389">			registerDataClayPreinstalledClasses(adminAccount);</span>
		}

		// Store LogicModule information once prepared
<span class="nc" id="L393">		this.logicMetaDataDB.store(publicIDs);</span>

<span class="nc" id="L395">		final Set&lt;DataSetID&gt; dataSetIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L396">		dataSetIDs.add(dataset.getDataClayID());</span>
<span class="nc" id="L397">		final Set&lt;ContractID&gt; contracts = new HashSet&lt;&gt;();</span>
<span class="nc" id="L398">		federationSessionID = this.newSession(federator.getDataClayID(), fedCredential,</span>
<span class="nc" id="L399">				contracts, dataSetIDs, dataset.getDataClayID(), Langs.LANG_JAVA).getSessionID();</span>

<span class="nc" id="L401">	}</span>

	/**
	 * Initialize database configuration.
	 * @return Database configuration
	 */
	protected abstract T initDBConf();

	/**
	 * Initializes DB handler. 
	 * @return DB handler.
	 */
	protected abstract SQLHandler&lt;T&gt; initDBHandler();

	/**
	 * Method that registers a set of preinstalled dataClay class model, including a
	 * dataClay normal account responsible of it, plus a public namespace for the
	 * classes.
	 * 
	 * @param adminAccount Admin account
	 */
	private void registerDataClayPreinstalledClasses(final Account adminAccount) {
		try {
			// Create the account for dataClay classes
			try {
<span class="nc" id="L426">				publicIDs.dcRegistratorID = accountMgrApi.getAccountID(DC_REGISTRATOR);</span>
<span class="nc" id="L427">			} catch (final AccountNotExistException e) {</span>
<span class="nc" id="L428">				final Account dcRegistrator = new Account(DC_REGISTRATOR, AccountRole.NORMAL_ROLE, dcCredentials);</span>
<span class="nc" id="L429">				publicIDs.dcRegistratorID = newAccount(publicIDs.dcAdminID, adminAccount.getCredential(),</span>
						dcRegistrator);
<span class="nc" id="L431">			}</span>

			// Public Namespace ID
			try {
<span class="nc" id="L435">				publicIDs.dcPublicNamespaceID = namespaceMgrApi.getNamespaceID(DC_PUBLIC_NAMESPACE);</span>
<span class="nc" id="L436">			} catch (final NamespaceDoesNotExistException e) {</span>
				// Create new namespace ID
<span class="nc" id="L438">				final Namespace publicDataClayNamespace = new Namespace(DC_PUBLIC_NAMESPACE, DC_REGISTRATOR,</span>
						Langs.LANG_JAVA);
<span class="nc" id="L440">				publicIDs.dcPublicNamespaceID = newNamespace(publicIDs.dcRegistratorID, dcCredentials,</span>
						publicDataClayNamespace);
<span class="nc" id="L442">			}</span>

			// Generate MetaClassSpec for DataClay Classes
			// COMPILE
<span class="nc" id="L446">			LOGGER.info(&quot;[LOGICMODULE] Installing classes located at : &quot;</span>
<span class="nc" id="L447">					+ Configuration.Flags.DATACLAY_INSTALLED_CLASSES_SRC_PATH.getStringValue());</span>
<span class="nc" id="L448">			final File f = new File(Configuration.Flags.DATACLAY_INSTALLED_CLASSES_SRC_PATH.getStringValue());</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">			if (f.exists()) {</span>
				// WARNING: do not remove this until a new script design is done. In case we
				// change Collections, this
				// is going to compile them again and make sure we use last collections. TODO:
				// better design.
<span class="nc" id="L454">				FileAndAspectsUtils.compileClasses(</span>
<span class="nc" id="L455">						Configuration.Flags.DATACLAY_INSTALLED_CLASSES_SRC_PATH.getStringValue(),</span>
<span class="nc" id="L456">						Configuration.Flags.DATACLAY_INSTALLED_CLASSES_BIN_PATH.getStringValue(),</span>
<span class="nc" id="L457">						new String[] { Configuration.Flags.INCLUDE_THIS_PROJECT.getStringValue() },</span>
						&quot;test&quot;);
<span class="nc" id="L459">				Map&lt;String, MetaClass&gt; newClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L460">				final Map&lt;MetaClassID, MetaClass&gt; installedClasses = classMgrApi</span>
<span class="nc" id="L461">						.getInfoOfClassesInNamespace(publicIDs.dcPublicNamespaceID);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">				if (installedClasses.isEmpty()) {</span>
					// Init class loader
<span class="nc" id="L464">					final String regClassPath = Configuration.Flags.DATACLAY_INSTALLED_CLASSES_BIN_PATH</span>
<span class="nc" id="L465">							.getStringValue();</span>
<span class="nc" id="L466">					final Set&lt;String&gt; classNames = new HashSet&lt;&gt;();</span>
<span class="nc" id="L467">					final Set&lt;String&gt; exclusions = new HashSet&lt;&gt;();</span>

<span class="nc" id="L469">					final Path inputPath = Paths.get(regClassPath).normalize();</span>
<span class="nc" id="L470">					final Path fullSrcPath = inputPath.toAbsolutePath();</span>
<span class="nc" id="L471">					final String fullPath = fullSrcPath.toString().replace(File.separatorChar + &quot;.&quot; + File.separatorChar,</span>
							File.separator);
<span class="nc" id="L473">					exclusions.add(&quot;test&quot;);</span>
<span class="nc" id="L474">					StubClassLoader.getClasses(fullPath, new File(fullPath), classNames, &quot;.class&quot;, exclusions);</span>
<span class="nc" id="L475">					LOGGER.info(&quot;[LOGICMODULE] Installing classes : &quot; + classNames);</span>
<span class="nc" id="L476">					final JavaSpecGenerator jvspec = new JavaSpecGenerator(</span>
<span class="nc" id="L477">							Configuration.Flags.DATACLAY_INSTALLED_CLASSES_BIN_PATH.getStringValue());</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">					for (final String className : classNames) {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">						if (newClasses.containsKey(className)) {</span>
<span class="nc" id="L480">							continue; // Avoid registering same class twice.</span>
						}
<span class="nc" id="L482">						final Map&lt;String, MetaClass&gt; classes = jvspec.generateMetaClassSpecForRegisterClass(DC_PUBLIC_NAMESPACE,</span>
								className);
<span class="nc bnc" id="L484" title="All 2 branches missed.">						if (classes.isEmpty()) {</span>
<span class="nc" id="L485">							LOGGER.info(&quot;Could not create Class spec of {}.&quot;, className);</span>
						}
<span class="nc" id="L487">						newClasses.putAll(classes);</span>
<span class="nc" id="L488">					}</span>
					// Install them
					try {
<span class="nc" id="L491">						newClasses = this.newClass(publicIDs.dcRegistratorID, dcCredentials, Langs.LANG_JAVA,</span>
								newClasses);
<span class="nc" id="L493">					} catch (final Exception ex) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L495">							LOGGER.debug(&quot;registerDataClayPreinstalledClasses error in newClass invocation&quot;, ex);</span>
						}
<span class="nc" id="L497">					}</span>
				}

				// Public Contract ID
<span class="nc" id="L501">				final Map&lt;ContractID, Contract&gt; contracts = this.getContractIDsOfProvider(publicIDs.dcRegistratorID,</span>
						dcCredentials, publicIDs.dcPublicNamespaceID);
<span class="nc bnc" id="L503" title="All 2 branches missed.">				if (contracts.isEmpty()) {</span>
					// CONTRACT

					// Create interfaces of the contract
<span class="nc" id="L507">					final List&lt;InterfaceInContract&gt; theInterfacesInContract = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">					for (final MetaClass metaClassInfo : newClasses.values()) {</span>

						// OPERATIONS
						// We assume that local and remote Impl are the same (first one) (23 Oct 2013
						// jmarti)
<span class="nc" id="L513">						final Set&lt;OpImplementations&gt; opImpls = new HashSet&lt;&gt;();</span>
<span class="nc" id="L514">						final Set&lt;String&gt; accOpsSignatures = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">						for (final Operation opInfo : metaClassInfo.getOperations()) {</span>
<span class="nc" id="L516">							opImpls.add(new OpImplementations(opInfo.getNameAndDescriptor(), 0, 0));</span>
<span class="nc" id="L517">							accOpsSignatures.add(opInfo.getNameAndDescriptor());</span>
<span class="nc" id="L518">						}</span>

						// PROPERTIES
<span class="nc" id="L521">						final Set&lt;String&gt; props = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">						for (final Property prop : metaClassInfo.getProperties()) {</span>
<span class="nc" id="L523">							props.add(prop.getName());</span>
<span class="nc" id="L524">						}</span>

						// Register an interface for the contract
<span class="nc" id="L527">						final Interface iface = new Interface(DC_REGISTRATOR, DC_PUBLIC_NAMESPACE, DC_PUBLIC_NAMESPACE,</span>
<span class="nc" id="L528">								metaClassInfo.getName(), props, accOpsSignatures);</span>

<span class="nc" id="L530">						this.newInterface(publicIDs.dcRegistratorID, dcCredentials, iface);</span>
<span class="nc" id="L531">						final InterfaceInContract ifaceInContract = new InterfaceInContract(iface, opImpls);</span>

<span class="nc" id="L533">						theInterfacesInContract.add(ifaceInContract);</span>
<span class="nc" id="L534">					}</span>

					// Prepare the dates of begin and end of a contract
<span class="nc" id="L537">					final Calendar beginDateOfContract = Calendar.getInstance();</span>
<span class="nc" id="L538">					beginDateOfContract.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L539">					final Calendar endDateOfContract = Calendar.getInstance();</span>
					// TODO: This contract should last forever (jmarti 1 Jul 2016)
<span class="nc" id="L541">					endDateOfContract.add(Calendar.YEAR, 100);</span>

<span class="nc" id="L543">					final Contract contract = new Contract(DC_PUBLIC_NAMESPACE, DC_REGISTRATOR, theInterfacesInContract,</span>
							beginDateOfContract, endDateOfContract);
<span class="nc" id="L545">					publicIDs.dcPublicContractID = this.newContract(publicIDs.dcRegistratorID, dcCredentials, contract);</span>
<span class="nc" id="L546">				} else {</span>
<span class="nc" id="L547">					publicIDs.dcPublicContractID = contracts.entrySet().iterator().next().getKey();</span>
				}
			}
<span class="nc" id="L550">		} catch (final Exception ex) {</span>
<span class="nc" id="L551">			LOGGER.debug(&quot;registerDataClayPreinstalledClasses error&quot;, ex);</span>
<span class="nc" id="L552">		}</span>
<span class="nc" id="L553">	}</span>

	/**
	 * Get remote DataService API
	 * 
	 * @param backend
	 *            Backend specification
	 * @return API of remote DS
	 * @throws Exception
	 *             If DS not started
	 */
	public DataServiceAPI getExecutionEnvironmentAPI(final ExecutionEnvironment backend) {
<span class="nc" id="L565">		final ExecutionEnvironmentID execID = backend.getDataClayID();</span>
<span class="nc" id="L566">		final Langs lang = backend.getLang();</span>
<span class="nc" id="L567">		final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; dsAPI = execEnvironments.get(lang).get(execID);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">		if (dsAPI == null) {</span>
<span class="nc" id="L569">			LOGGER.warn(&quot;No DataServiceAPI. Current execution environments: {}&quot;, execEnvironments);</span>
<span class="nc" id="L570">			throw new DataClayRuntimeException(ERRORCODE.DATASERVICE_BACKEND_NOT_RESPONDS,</span>
<span class="nc" id="L571">					&quot;DataService with ID &quot; + execID + &quot; is not initialized for language &quot; + lang.toString(), false);</span>
		}
<span class="nc" id="L573">		return dsAPI.getFirst();</span>
	}

	/**
	 * Get DataService APIs for backend with support for a given language.
	 * 
	 * @param lang
	 *            The language required.
	 * @return DataServiceAPIs, the ones compatible with the language
	 */
	protected Map&lt;ExecutionEnvironmentID, Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt;&gt; getExecutionEnvironments(final Langs lang) {
<span class="nc bnc" id="L584" title="All 2 branches missed.">		if (DEBUG_ENABLED) { </span>
<span class="nc" id="L585">			LOGGER.debug(&quot;[==GetExecutionEnvironments==] Execution environments in language &quot; + lang + &quot; : &quot; + execEnvironments.get(lang).keySet());</span>
		}
<span class="nc" id="L587">		return execEnvironments.get(lang);</span>
	}

	/**
	 * Update APIs for all registered environments/storage locations
	 */
	protected void updateAPIsFromDB() {
<span class="nc bnc" id="L594" title="All 2 branches missed.">		for (final ExecutionEnvironment execEnv : metaDataSrvApi.getAllExecutionEnvironmentsInfo(null).values()) {</span>
			try {
<span class="nc" id="L596">				initRemoteTCPExecutionEnvironment(execEnv.getDataClayID(), </span>
<span class="nc" id="L597">						execEnv.getName(), execEnv.getHostname(), execEnv.getPort(), execEnv.getLang());</span>
<span class="nc" id="L598">			} catch (final InterruptedException e) {</span>
<span class="nc" id="L599">				e.printStackTrace();</span>
<span class="nc" id="L600">			}</span>
<span class="nc" id="L601">		}</span>

<span class="nc bnc" id="L603" title="All 2 branches missed.">		for (final StorageLocation stLoc : metaDataSrvApi.getAllStorageLocationsInfo().values()) {</span>
			try {
<span class="nc" id="L605">				initRemoteTCPStorageLocation(stLoc.getDataClayID(), </span>
<span class="nc" id="L606">						stLoc.getName(), stLoc.getHostname(), stLoc.getStorageTCPPort());</span>
<span class="nc" id="L607">			} catch (final InterruptedException e) {</span>
<span class="nc" id="L608">				e.printStackTrace();</span>
<span class="nc" id="L609">			}</span>
<span class="nc" id="L610">		}</span>

<span class="nc" id="L612">	}</span>

	/**
	 * Resume traces in services
	 * 
	 * @param dsName
	 *            Name of the data service to be cleaned
	 * @throws RemoteException
	 *             if exception occurs
	 */
	public void cleanCachesOfDataService(final String dsName) {
<span class="nc" id="L623">		storageLocations.get(dsName).getFirst().cleanCaches();</span>
<span class="nc" id="L624">	}</span>

	// ========== Initialization by DataServices ==========//

	/**
	 * This method adds an StorageLocation to the list of DS/extras.
	 * @param id ID of backend to use in case of registration
	 * @param dsName
	 *            Name of the DataService
	 * @param dsHostname
	 *            Hostname of the DataService
	 * @param dsTCPPort
	 *            The TCP port
	 * @return The StorageLocation for the DataService.
	 * @throws InterruptedException
	 *             if some remote initialization was interrupted
	 */
	private StorageLocation initRemoteTCPStorageLocation(final StorageLocationID id, 
			final String dsName, final String dsHostname,
			final int dsTCPPort) throws InterruptedException {
		// Test connection
<span class="nc" id="L645">		final DataServiceAPI dsApi = grpcClient.getDataServiceAPI(dsHostname, dsTCPPort);</span>
<span class="nc" id="L646">		final StorageLocation dsSL = new StorageLocation(dsHostname, dsName, dsTCPPort);</span>
<span class="nc" id="L647">		dsSL.setDataClayID(id); </span>
<span class="nc" id="L648">		storageLocations.put(id, new Tuple&lt;&gt;(dsApi, dsSL));</span>
<span class="nc" id="L649">		return dsSL;</span>
	}

	/**
	 * This method adds an ExecutionEnvironment to the list of DS/extras.
	 * @param execID Execution Environment ID
	 * @param dsName
	 *            Name of the DataService
	 * @param dsHostname
	 *            Hostname of the DataService
	 * @param dsTCPPort
	 *            The TCP port
	 * @param dsLang
	 *            The Language for the ExecutionEnvironment in this DataService
	 * @return The StorageLocation for the DataService. (Itself for Java, the Java
	 *         one for Python).
	 * @throws InterruptedException
	 *             if some remote initialization was interrupted
	 */
	private ExecutionEnvironment initRemoteTCPExecutionEnvironment(final ExecutionEnvironmentID execID, 
			final String dsName, final String dsHostname,
			final int dsTCPPort, final Langs dsLang) throws InterruptedException {
<span class="nc" id="L671">		final DataServiceAPI dsApi = grpcClient.getDataServiceAPI(dsHostname, dsTCPPort);</span>
<span class="nc" id="L672">		final ExecutionEnvironment dsEE = new ExecutionEnvironment(dsHostname, dsName, dsTCPPort, dsLang);</span>
<span class="nc" id="L673">		dsEE.setDataClayID(execID); </span>
<span class="nc" id="L674">		execEnvironments.get(dsLang).put(execID, new Tuple&lt;&gt;(dsApi, dsEE));</span>
<span class="nc" id="L675">		return dsEE;</span>
	}

	@Override
	public void checkAlive() {
<span class="nc" id="L680">		return;</span>
	}

	@Override
	public void publishAddress(final String thehostname, final int theport) { 
<span class="nc" id="L685">		this.hostname = thehostname;</span>
<span class="nc" id="L686">		this.port = theport;</span>
<span class="nc" id="L687">		LOGGER.info(&quot;Published address {}:{}&quot;, thehostname, theport);</span>
<span class="nc" id="L688">	}</span>

	@Override
	public void autoregisterSL(final StorageLocationID id, final String dsName, 
			final String dsHostname, final Integer dsPort) { 

		// ===================== TRY CONNECTION ======================= //
		final StorageLocation storageLoc;
		try {
<span class="nc" id="L697">			storageLoc = initRemoteTCPStorageLocation(id, dsName, dsHostname, dsPort);</span>
<span class="nc" id="L698">		} catch (final Exception ex) {</span>
<span class="nc" id="L699">			LOGGER.debug(&quot;autoregisterDataService error while creating DataService&quot;, ex);</span>
<span class="nc" id="L700">			throw new DataClayRuntimeException(ERRORCODE.DATASERVICE_INIT_ERROR,</span>
					&quot;Could not connect to DataService in the LogicModule&quot;, true);
<span class="nc" id="L702">		}</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">		if (storageLoc == null) {</span>
<span class="nc" id="L704">			throw new DataClayRuntimeException(ERRORCODE.DATASERVICE_INIT_ERROR,</span>
					&quot;The StorageLocation for this DataService is not satisfactory registered&quot;, true);
		}
		// ========== REGISTER ========== //
		try {
<span class="nc" id="L709">			metaDataSrvApi.registerStorageLocation(storageLoc);</span>
<span class="nc" id="L710">			LOGGER.info(&quot;[LOGICMODULE] Registered StorageLocation named &quot; + storageLoc + &quot; as &quot; + id.getId());</span>
<span class="nc" id="L711">		} catch (final StorageLocationAlreadyExistsException e) {</span>
<span class="nc" id="L712">			metaDataSrvApi.updateStorageLocation(id, dsHostname, dsPort);</span>
<span class="nc" id="L713">			LOGGER.info(&quot;[LOGICMODULE] Found already registered StorageLocation &quot; + storageLoc + &quot; as &quot;</span>
<span class="nc" id="L714">					+ id.getId());</span>
<span class="nc" id="L715">		}</span>

		// Activate storage location (execution environments cannot be activated before SL is ready)
<span class="nc" id="L718">		this.activeBackends.put(id, new HashSet&lt;ExecutionEnvironmentID&gt;());</span>
		
<span class="nc" id="L720">	}</span>
	
	@Override
	public StorageLocationID getStorageLocationID(final String slName) {
<span class="nc" id="L724">		final StorageLocationID slID = metaDataSrvApi.getStorageLocationID(slName);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">		if (!this.activeBackends.containsKey(slID)) {</span>
			// Still not active
<span class="nc" id="L727">			throw new StorageLocationNotExistException(slName);</span>
		}
<span class="nc" id="L729">		return slID;</span>
	}

	@Override
	public StorageLocationID autoregisterEE(final ExecutionEnvironmentID id, final String eeName, 
			final String eeHostname, final Integer eePort, final Langs language) {
		
<span class="nc" id="L736">		final StorageLocationID slID = getStorageLocationID(eeName);</span>

		// ===================== TRY CONNECTION ======================= //
		// Obtain or Register the Execution Environment
		final ExecutionEnvironment executionEnv;
		try {
<span class="nc" id="L742">			LOGGER.debug(&quot;autoregisterDataService initializing with hostname &quot; + eeHostname + &quot; and port &quot; + eePort);</span>
<span class="nc" id="L743">			executionEnv = initRemoteTCPExecutionEnvironment(id, eeName, eeHostname, eePort, language);</span>
<span class="nc" id="L744">		} catch (final Exception ex) {</span>
<span class="nc" id="L745">			LOGGER.debug(&quot;autoregisterDataService interrupted while initializing remote ExecutionEnvironment&quot;, ex);</span>
<span class="nc" id="L746">			throw new DataClayRuntimeException(ERRORCODE.DATASERVICE_INIT_ERROR,</span>
					&quot;Could not create the DataService ExecutionEnvironment in the LogicModule&quot;, true);
<span class="nc" id="L748">		}</span>
		// ========== REGISTER ========== //
<span class="nc" id="L750">		boolean newRegistration = false;</span>
		try {
<span class="nc" id="L752">			metaDataSrvApi.registerExecutionEnvironment(executionEnv);</span>
<span class="nc" id="L753">			LOGGER.info(&quot;[LOGICMODULE] Registered ExecutionEnvironment &quot; + executionEnv + &quot; for language `&quot;</span>
<span class="nc" id="L754">					+ language + &quot;` as &quot; + id.getId() + &quot; associated to storage location &quot; + slID);</span>
<span class="nc" id="L755">			newRegistration = true;</span>
<span class="nc" id="L756">		} catch (final ExecutionEnvironmentAlreadyExistsException e) {</span>
<span class="nc" id="L757">			metaDataSrvApi.updateExecutionEnvironment(id, eeHostname, eePort);</span>
<span class="nc" id="L758">			LOGGER.info(&quot;[LOGICMODULE] Found already registered EE. Updated to &quot; + executionEnv + &quot; as &quot;</span>
<span class="nc" id="L759">					+ id.getId());</span>
<span class="nc" id="L760">		}</span>

		// Activate storage location (execution environments cannot be activated before SL is ready)
<span class="nc" id="L763">		this.activeBackends.get(slID).add(id);</span>
		
		// ========== DEPLOY INSTALLED CLASSES ========== //
<span class="nc bnc" id="L766" title="All 4 branches missed.">		if (newRegistration &amp;&amp; Configuration.Flags.REGISTER_DATACLAY_CLASSES.getBooleanValue()) {</span>
<span class="nc" id="L767">			LOGGER.info(&quot;[LOGICMODULE] Going to deploy dataClay classes&quot;);</span>
			// Deploy DataClay classes
			// Generate MetaClassSpec for DataClay Classes
			try {
<span class="nc" id="L771">				final Map&lt;MetaClassID, MetaClass&gt; installedClasses = classMgrApi</span>
<span class="nc" id="L772">						.getInfoOfClassesInNamespace(publicIDs.dcPublicNamespaceID);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">				if (!installedClasses.isEmpty()) {</span>
<span class="nc" id="L774">					final Set&lt;MetaClass&gt; allMetaClasses = new HashSet&lt;&gt;(installedClasses.values());</span>
<span class="nc" id="L775">					final Set&lt;String&gt; classesToDeploy = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">					for (final MetaClass curClass : allMetaClasses) {</span>
<span class="nc" id="L777">						classesToDeploy.add(curClass.getName());</span>
<span class="nc" id="L778">					}</span>
<span class="nc" id="L779">					final Set&lt;NamespaceID&gt; namespacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L780">					namespacesIDs.add(publicIDs.dcPublicNamespaceID);</span>
<span class="nc" id="L781">					final Map&lt;NamespaceID, Namespace&gt; namespaceInfos = namespaceMgrApi.getNamespacesInfo(namespacesIDs);</span>
<span class="nc" id="L782">					final Langs eeLang = executionEnv.getLang();</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">					if (eeLang.equals(Langs.LANG_JAVA)) {</span>
<span class="nc" id="L784">						outsourceClassesDeploymentJava(allMetaClasses, classesToDeploy, namespaceInfos, null, executionEnv.getDataClayID());</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">					} else if (eeLang.equals(Langs.LANG_PYTHON)) {</span>
<span class="nc" id="L786">						outsourceClassesDeploymentPython(allMetaClasses, classesToDeploy, namespaceInfos, null,</span>
<span class="nc" id="L787">								executionEnv.getDataClayID());</span>
					}
				}
<span class="nc" id="L790">			} catch (final Exception ex) {</span>
<span class="nc" id="L791">				LOGGER.debug(&quot;autoregisterDataService error during dataClay classes registration&quot;, ex);</span>
<span class="nc" id="L792">			}</span>
		}

<span class="nc" id="L795">		return slID;</span>
	}

	@Override
	public void unregisterStorageLocation(final StorageLocationID stLocID) {
<span class="nc" id="L800">		metaDataSrvApi.unregisterStorageLocation(stLocID);</span>
		//TODO: remove from any cache in LM
<span class="nc" id="L802">	}</span>

	@Override
	public void unregisterExecutionEnvironment(final ExecutionEnvironmentID execEnvID) {
<span class="nc" id="L806">		metaDataSrvApi.unregisterExecutionEnvironment(execEnvID);</span>
		//TODO: remove from any cache in LM
<span class="nc" id="L808">	}</span>

	@Override
	public void notifyExecutionEnvironmentShutdown(final ExecutionEnvironmentID execEnvID) {
		// TODO: check if metadata service should be the one with information about active EEs and SLs
<span class="nc" id="L813">		LOGGER.info(&quot;Notified shutdown of execution environment &quot; + execEnvID);</span>
<span class="nc" id="L814">		ExecutionEnvironment eeInfo = metaDataSrvApi.getExecutionEnvironmentInfo(execEnvID);</span>
<span class="nc" id="L815">		StorageLocationID slID = this.getStorageLocationID(eeInfo.getName());</span>
<span class="nc" id="L816">		this.activeBackends.get(slID).remove(execEnvID);</span>
<span class="nc" id="L817">	}</span>

	@Override
	public void notifyStorageLocationShutdown(final StorageLocationID stLocID) {
<span class="nc" id="L821">		LOGGER.info(&quot;Notified shutdown of storage location &quot; + stLocID);</span>
<span class="nc" id="L822">		this.activeBackends.remove(stLocID);</span>
<span class="nc" id="L823">	}</span>

	@Override
	public boolean existsActiveEnvironmentsForSL(final StorageLocationID stLocID) {
<span class="nc" id="L827">		int numEEs = this.activeBackends.get(stLocID).size();</span>
<span class="nc" id="L828">		LOGGER.info(&quot;Found &quot; + numEEs + &quot; active execution environments for SL &quot; + stLocID);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">		return numEEs != 0;</span>
	}

	/**
	 * Wait for all registered Storage locations and Execution environments to shut down. 
	 */
	public void waitForAllNodesShutdown() {
		while (true) {
<span class="nc" id="L837">			int numBackends = this.activeBackends.size();</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">			if (numBackends == 0) {</span>
<span class="nc" id="L839">				break;</span>
			}
			try {
<span class="nc" id="L842">				LOGGER.info(&quot;Waiting for backends to shutdown. Active backends: &quot; + numBackends);</span>
<span class="nc" id="L843">				Thread.sleep(Configuration.Flags.SLEEP_WAIT_SHUTDOWN.getLongValue());</span>
<span class="nc" id="L844">			} catch (final InterruptedException ie) {</span>
<span class="nc" id="L845">				LOGGER.warn(&quot;Checking interrupted. Shutting down LM without waiting for backends.&quot;);</span>
<span class="nc" id="L846">				break;</span>
<span class="nc" id="L847">			}</span>
<span class="nc" id="L848">		}</span>
<span class="nc" id="L849">	}</span>

	// ========== Generic batch operations ==========//

	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public byte[] performSetOfNewAccounts(final AccountID adminID, final PasswordCredential adminCredential,
			final byte[] yamlFile) {
<span class="nc" id="L857">		final Yaml yaml = CommonYAML.getYamlObject();</span>

		/*
		 * The structure that we will return on the YAML response
		 */
<span class="nc" id="L862">		final Map&lt;String, UUID&gt; returnIDs = new HashMap&lt;&gt;();</span>
		// Maps with account-uuid pairs

		// The YAML should be a list of accounts
		final List&lt;Object&gt; newAccounts;
		try {
<span class="nc" id="L868">			newAccounts = (List&lt;Object&gt;) yaml.load(new String(yamlFile));</span>
<span class="nc" id="L869">		} catch (final Exception e) {</span>
<span class="nc" id="L870">			LOGGER.warn(&quot;Received exception during deserialization&quot;, e);</span>
<span class="nc" id="L871">			LOGGER.debug(&quot;YAML document:\n{}&quot;, new String(yamlFile));</span>
<span class="nc" id="L872">			throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;Error when loading YAML file&quot;, true);</span>
<span class="nc" id="L873">		}</span>

<span class="nc bnc" id="L875" title="All 2 branches missed.">		for (final Object objAccount : newAccounts) {</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">			if (!(objAccount instanceof Account)) {</span>
<span class="nc" id="L877">				throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;This call only accepts Accounts&quot;,</span>
						true);
			}
<span class="nc" id="L880">			final Account acc = (Account) objAccount;</span>

<span class="nc" id="L882">			final AccountID accountID = newAccount(adminID, adminCredential, (Account) objAccount);</span>
<span class="nc" id="L883">			returnIDs.put(acc.getUsername(), accountID.getId());</span>
<span class="nc" id="L884">		}</span>
<span class="nc" id="L885">		return yaml.dump(returnIDs).getBytes();</span>
	}

	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public byte[] performSetOfOperations(final AccountID performerID, final PasswordCredential performerCredential,
			final byte[] yamlFile) {
<span class="nc" id="L892">		final Yaml yaml = CommonYAML.getYamlObject();</span>

		/*
		 * The structure that we will return on the YAML response
		 */
<span class="nc" id="L897">		final Map&lt;String, Object&gt; returnIDs = new HashMap&lt;&gt;();</span>

		// Initialize the potentially empty list //
		// Namespaces
<span class="nc" id="L901">		final Map&lt;String, UUID&gt; namespaceIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L902">		returnIDs.put(&quot;namespaces&quot;, namespaceIDs);</span>
		// DataSets
<span class="nc" id="L904">		final Map&lt;String, UUID&gt; datasetIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L905">		returnIDs.put(&quot;datasets&quot;, datasetIDs);</span>
		// Contracts
<span class="nc" id="L907">		final Map&lt;String, UUID&gt; contractIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L908">		returnIDs.put(&quot;contracts&quot;, contractIDs);</span>
		// DataContracts
<span class="nc" id="L910">		final Map&lt;String, UUID&gt; datacontractIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L911">		returnIDs.put(&quot;datacontracts&quot;, datacontractIDs);</span>
		// Interfaces
<span class="nc" id="L913">		final Map&lt;String, UUID&gt; interfaceIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L914">		returnIDs.put(&quot;interfaces&quot;, interfaceIDs);</span>
		// MetaClasses
<span class="nc" id="L916">		final Map&lt;String, UUID&gt; metaclassIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L917">		returnIDs.put(&quot;metaclasses&quot;, metaclassIDs);</span>

		// The YAML should be a dictionary, indexed by name
		final Map&lt;String, Object&gt; operations;
		try {
<span class="nc" id="L922">			operations = (Map&lt;String, Object&gt;) yaml.load(new String(yamlFile));</span>
<span class="nc" id="L923">		} catch (final Exception e) {</span>
<span class="nc" id="L924">			LOGGER.warn(&quot;Received exception during deserialization&quot;, e);</span>
<span class="nc" id="L925">			LOGGER.debug(&quot;YAML document:\n{}&quot;, new String(yamlFile));</span>
<span class="nc" id="L926">			throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;Error when loading YAML file&quot;, true);</span>
<span class="nc" id="L927">		}</span>

		// Note: This works well because snakeyaml implements the Map as a LinkedHashMap
		// and there is no anarchy on ordering. The registering must obey user-provided
		// order.
<span class="nc bnc" id="L932" title="All 2 branches missed.">		for (final Entry&lt;String, Object&gt; elem : operations.entrySet()) {</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">			if (elem.getValue() instanceof Namespace) {</span>
<span class="nc" id="L934">				final Namespace dom = (Namespace) elem.getValue();</span>
<span class="nc" id="L935">				dom.setName(elem.getKey());</span>

<span class="nc" id="L937">				final NamespaceID namespaceID = newNamespace(performerID, performerCredential, dom);</span>
<span class="nc" id="L938">				namespaceIDs.put(elem.getKey(), namespaceID.getId());</span>

<span class="nc bnc" id="L940" title="All 2 branches missed.">			} else if (elem.getValue() instanceof DataSet) {</span>
<span class="nc" id="L941">				LOGGER.info(&quot;[LM] Dataset &quot; + elem.getKey() + &quot; request to be created.&quot;);</span>
<span class="nc" id="L942">				final DataSet dset = (DataSet) elem.getValue();</span>
<span class="nc" id="L943">				dset.setName(elem.getKey());</span>

<span class="nc" id="L945">				final DataSetID datasetID = newDataSet(performerID, performerCredential, dset);</span>
<span class="nc" id="L946">				datasetIDs.put(elem.getKey(), datasetID.getId());</span>

<span class="nc bnc" id="L948" title="All 2 branches missed.">			} else if (elem.getValue() instanceof Contract) {</span>
<span class="nc" id="L949">				final Contract contr = (Contract) elem.getValue();</span>

<span class="nc" id="L951">				final ContractID contractID = newContract(performerID, performerCredential, contr);</span>
<span class="nc" id="L952">				contractIDs.put(elem.getKey(), contractID.getId());</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">			} else if (elem.getValue() instanceof DataContract) {</span>
<span class="nc" id="L954">				final DataContract dcontr = (DataContract) elem.getValue();</span>

<span class="nc" id="L956">				final DataContractID datacontractID = newDataContract(performerID, performerCredential, dcontr);</span>
<span class="nc" id="L957">				datacontractIDs.put(elem.getKey(), datacontractID.getId());</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">			} else if (elem.getValue() instanceof Interface) {</span>
<span class="nc" id="L959">				final Interface iface = (Interface) elem.getValue();</span>

<span class="nc" id="L961">				final InterfaceID interfaceID = newInterface(performerID, performerCredential, iface);</span>
<span class="nc" id="L962">				interfaceIDs.put(elem.getKey(), interfaceID.getId());</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">			} else if (elem.getValue() instanceof MetaClass) {</span>
<span class="nc" id="L964">				final MetaClass mclass = (MetaClass) elem.getValue();</span>
<span class="nc" id="L965">				mclass.setName(elem.getKey());</span>

				// newClass expects a Map
<span class="nc" id="L968">				final Map&lt;String, MetaClass&gt; singleElement = new HashMap&lt;&gt;();</span>
<span class="nc" id="L969">				singleElement.put(elem.getKey(), mclass);</span>

				// TODO: (LASTTODO) fix this to add language!
<span class="nc" id="L972">				final Map&lt;String, MetaClass&gt; metaclassResponse = newClass(performerID, performerCredential,</span>
						Langs.LANG_NONE, singleElement);

				// We are only interested in the provided element
<span class="nc bnc" id="L976" title="All 2 branches missed.">				if (metaclassResponse.containsKey(elem.getKey())) {</span>
<span class="nc" id="L977">					metaclassIDs.put(elem.getKey(), metaclassResponse.get(elem.getKey()).getDataClayID().getId());</span>
				}
<span class="nc" id="L979">			} else {</span>
<span class="nc" id="L980">				throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION,</span>
						&quot;Malformed YAML --not a valid dataClay set of operations&quot;, true);
			}
<span class="nc" id="L983">		}</span>

<span class="nc" id="L985">		LOGGER.debug(</span>
				&quot;Ready to return the following sets of IDs (count):\n&quot; + &quot;    - Namespaces:    #{}\n&quot;
						+ &quot;    - Datasets:      #{}\n&quot; + &quot;    - Contracts:     #{}\n&quot; + &quot;    - DataContracts: #{}\n&quot;
						+ &quot;    - Interfaces:    #{}\n&quot; + &quot;    - MetaClasses:   #{}&quot;,
<span class="nc" id="L989">						() -&gt; namespaceIDs.size(), () -&gt; datasetIDs.size(), () -&gt; contractIDs.size(),</span>
<span class="nc" id="L990">						() -&gt; datacontractIDs.size(), () -&gt; interfaceIDs.size(), () -&gt; metaclassIDs.size());</span>

<span class="nc" id="L992">		return yaml.dump(returnIDs).getBytes();</span>
	}

	// ============== Account Manager ==============//

	@Override
	public AccountID newAccountNoAdmin(final Account newAccount) {

		// Create the new account (admin account validated during the newAccount op)
<span class="nc" id="L1001">		final Account adminAccount = accountMgrApi.getAccount(publicIDs.dcAdminID);</span>
<span class="nc" id="L1002">		final AccountID accountID = accountMgrApi.newAccount(publicIDs.dcAdminID, adminAccount.getCredential(),</span>
				newAccount);

		// Create a default dataset for the account
<span class="nc" id="L1006">		final DataSet ds = new DataSet(newAccount.getUsername() + DEFAULT_DS_SUFFIX, accountID, false);</span>
<span class="nc" id="L1007">		newDataSet(accountID, newAccount.getCredential(), ds);</span>
<span class="nc" id="L1008">		final Calendar begin = Calendar.getInstance();</span>
<span class="nc" id="L1009">		begin.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L1010">		final Calendar end = Calendar.getInstance();</span>
<span class="nc" id="L1011">		end.add(Calendar.YEAR, 100);</span>
<span class="nc" id="L1012">		final DataContract dc = new DataContract(ds.getDataClayID(), newAccount.getDataClayID(), new HashSet&lt;&gt;(), </span>
				begin, end, false);
<span class="nc" id="L1014">		newDataContract(accountID, newAccount.getCredential(), dc);</span>

		// Create default namespaces for the account
<span class="nc" id="L1017">		final Namespace ns1 = new Namespace(newAccount.getUsername() + DEFAULT_JAVA_NS_SUFFIX, newAccount.getUsername(),</span>
				Langs.LANG_JAVA);
		try {
<span class="nc" id="L1020">			newNamespace(accountID, newAccount.getCredential(), ns1);</span>
<span class="nc" id="L1021">		} catch (final NamespaceExistsException e) {</span>
			// FIXME: if the namespace exists, it means database was exported from another
			// dataClay
			// in a federation model. Note that namespace Mgr and Class Mgr are databases
			// than can be 'exported'
			// to allow federation.
			// in this case, we could find a namespace with same user name if two dataClays
			// have
			// accounts with same name (Bob) and we export from one to another (we export
			// BobNamespace)
			// we will try to create BobNamespace in both cases but BobNamespace could be
			// already
			// exported.
			// this will not be necessary once we register models and namespaces with
			// predefined IDs.
<span class="nc" id="L1036">			LOGGER.debug(&quot;Java namespace already exists (can be expected in Federation): &quot;, e);</span>
<span class="nc" id="L1037">		}</span>
<span class="nc" id="L1038">		final Namespace ns2 = new Namespace(newAccount.getUsername() + DEFAULT_PYTHON_NS_SUFFIX,</span>
<span class="nc" id="L1039">				newAccount.getUsername(), Langs.LANG_PYTHON);</span>
		try {
<span class="nc" id="L1041">			newNamespace(accountID, newAccount.getCredential(), ns2);</span>
<span class="nc" id="L1042">		} catch (final NamespaceExistsException e) {</span>
			// check comments in previous exception for Java
<span class="nc" id="L1044">			LOGGER.debug(&quot;Python Namespace already exists (can be expected in Federation): &quot;, e);</span>
<span class="nc" id="L1045">		}</span>
<span class="nc" id="L1046">		return accountID;</span>
	}

	@Override
	public AccountID newAccount(final AccountID adminAccountID, final PasswordCredential adminCredential,
			final Account newAccount) {

		// Create the new account (admin account validated during the newAccount op)
<span class="nc" id="L1054">		final AccountID accountID = accountMgrApi.newAccount(adminAccountID, adminCredential, newAccount);</span>

		// Create a default dataset for the account
<span class="nc" id="L1057">		final DataSet ds = new DataSet(newAccount.getUsername() + DEFAULT_DS_SUFFIX, accountID, false);</span>
<span class="nc" id="L1058">		newDataSet(accountID, newAccount.getCredential(), ds);</span>
<span class="nc" id="L1059">		final Calendar begin = Calendar.getInstance();</span>
<span class="nc" id="L1060">		begin.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L1061">		final Calendar end = Calendar.getInstance();</span>
<span class="nc" id="L1062">		end.add(Calendar.YEAR, 100);</span>
<span class="nc" id="L1063">		final DataContract dc = new DataContract(ds.getDataClayID(), newAccount.getDataClayID(), new HashSet&lt;&gt;(), </span>
				begin, end, false);
<span class="nc" id="L1065">		newDataContract(accountID, newAccount.getCredential(), dc);</span>

		// Create default namespaces for the account
<span class="nc" id="L1068">		final Namespace ns1 = new Namespace(newAccount.getUsername() + DEFAULT_JAVA_NS_SUFFIX, newAccount.getUsername(),</span>
				Langs.LANG_JAVA);
<span class="nc" id="L1070">		newNamespace(accountID, newAccount.getCredential(), ns1);</span>
<span class="nc" id="L1071">		final Namespace ns2 = new Namespace(newAccount.getUsername() + DEFAULT_PYTHON_NS_SUFFIX,</span>
<span class="nc" id="L1072">				newAccount.getUsername(), Langs.LANG_PYTHON);</span>
<span class="nc" id="L1073">		newNamespace(accountID, newAccount.getCredential(), ns2);</span>
<span class="nc" id="L1074">		return accountID;</span>
	}

	@Override
	public AccountID getAccountID(final String accountName) {
<span class="nc" id="L1079">		return accountMgrApi.getAccountID(accountName);</span>
	}

	@Override
	public HashSet&lt;AccountID&gt; getAccountList(final AccountID adminAccountID, final PasswordCredential adminCredential) {
<span class="nc" id="L1084">		HashSet&lt;AccountID&gt; accountsIDs = null;</span>
		// Get the list of users
<span class="nc" id="L1086">		accountsIDs = accountMgrApi.getAccountList(adminAccountID, adminCredential);</span>
<span class="nc" id="L1087">		return accountsIDs;</span>
	}

	// ============== Session Manager ==============//

	@Override
	public SessionInfo newSession(final AccountID accountID, final PasswordCredential credential,
			final Set&lt;ContractID&gt; contracts, final Set&lt;DataSetID&gt; dataSetIDs, final DataSetID dataSetForStore,
			final Langs newsessionLang) {

<span class="nc" id="L1097">		final boolean valid = accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE);</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">		if (!valid) {</span>
<span class="nc" id="L1099">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L1102">		return newSessionInternal(accountID, contracts, dataSetIDs, dataSetForStore, newsessionLang);</span>

	}

	/**
	 * New session internal function.
	 * 
	 * @param accountID
	 *            ID of account of the session
	 * @param contracts
	 *            Contracts of the session
	 * @param dataSets
	 *            names of datasets of the session
	 * @param dataSetForStore
	 *            Name of dataset for store
	 * @param newsessionLang
	 *            Session language
	 * @return Information of new session.
	 */
	private SessionInfo newSessionInternal(final AccountID accountID, final Set&lt;ContractID&gt; contracts,
			final Set&lt;DataSetID&gt; dataSets, final DataSetID dataSetForStore, final Langs newsessionLang) {

		// Get datasets info
<span class="nc" id="L1125">		final Map&lt;String, DataSet&gt; datasetsInfo = dataSetMgrApi.getDataSetsInfo(dataSets);</span>

		// Obtain Set of DataSetID
<span class="nc" id="L1128">		final Set&lt;DataSetID&gt; datasetsIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">		for (final DataSet datasetInfo : datasetsInfo.values()) {</span>
<span class="nc" id="L1130">			final DataSetID dsID = datasetInfo.getDataClayID();</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">			if (datasetsIDs.contains(dsID)) {</span>
<span class="nc" id="L1132">				continue;</span>
			}
<span class="nc" id="L1134">			datasetsIDs.add(dsID);</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">			if (datasetInfo.getIsPublic()) {</span>
<span class="nc" id="L1136">				final DataContractID datacontractID = datacontractMgrApi.getPublicDataContractIDOfProvider(dsID);</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">				if (datacontractID == null) {</span>
<span class="nc" id="L1138">					throw new DataClayRuntimeException(ERRORCODE.DATACONTRACT_NOT_PUBLIC,</span>
<span class="nc" id="L1139">							&quot; Dataset &quot; + datasetInfo.getName() + &quot; has no public conract.&quot;, false);</span>
				}
				try {
<span class="nc" id="L1142">					datacontractMgrApi.registerToPublicDataContract(accountID, datacontractID);</span>
<span class="nc" id="L1143">				} catch (final AccountAlreadyHasADataContractWithProvider ex) {</span>
					// Ignore
<span class="nc" id="L1145">				}</span>
			}
<span class="nc" id="L1147">		}</span>

		// Validate data contracts and get info
<span class="nc" id="L1150">		final Map&lt;DataContractID, DataContract&gt; dataContractsInfo = datacontractMgrApi</span>
<span class="nc" id="L1151">				.getInfoOfSomeActiveDataContractsForAccountWithProviders(accountID, datasetsIDs);</span>

		// Validate dataSetForStore is among data contracts and calculate endDate from
		// them
<span class="nc" id="L1155">		final Tuple&lt;DataContractID, Calendar&gt; checkedDataSetAmongDataContracts = validateDataSetForStore(</span>
				dataContractsInfo, datasetsInfo, dataSetForStore);
<span class="nc" id="L1157">		final DataContractID dataContractIDforStore = checkedDataSetAmongDataContracts.getFirst();</span>
<span class="nc" id="L1158">		Calendar endDate = checkedDataSetAmongDataContracts.getSecond();</span>

		// Validate model contracts and get info
<span class="nc" id="L1161">		final Map&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; infoOfInterfacesInContracts = contractMgrApi</span>
<span class="nc" id="L1162">				.getInfoOfMultipleContractsPerActiveContractsForAccount(accountID, contracts);</span>

		// Index implementations and calculate endDate for the session
<span class="nc" id="L1165">		final HashSet&lt;InterfaceID&gt; interfacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1166">		final HashSet&lt;ImplementationID&gt; implementationsIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">		for (final Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt; interfacesInContract : infoOfInterfacesInContracts</span>
<span class="nc" id="L1168">				.values()) {</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">			for (final Entry&lt;InterfaceID, InterfaceInContract&gt; curEntry : interfacesInContract.getFirst().entrySet()) {</span>
<span class="nc" id="L1170">				final InterfaceID interfaceID = curEntry.getKey();</span>
<span class="nc" id="L1171">				final InterfaceInContract interfaceInContract = curEntry.getValue();</span>
<span class="nc" id="L1172">				interfacesIDs.add(interfaceID);</span>

				// Implementations
<span class="nc bnc" id="L1175" title="All 2 branches missed.">				for (final Entry&lt;OperationID, OpImplementations&gt; curOpImpls : interfaceInContract</span>
<span class="nc" id="L1176">						.getAccessibleImplementations().entrySet()) {</span>
<span class="nc" id="L1177">					implementationsIDs.add(curOpImpls.getValue().getRemoteImplementationID());</span>
<span class="nc" id="L1178">					implementationsIDs.add(curOpImpls.getValue().getLocalImplementationID());</span>
<span class="nc" id="L1179">				}</span>
<span class="nc" id="L1180">			}</span>

			// End date
<span class="nc bnc" id="L1183" title="All 4 branches missed.">			if (endDate == null || interfacesInContract.getSecond().before(endDate)) {</span>
<span class="nc" id="L1184">				endDate = interfacesInContract.getSecond();</span>
			}
<span class="nc" id="L1186">		}</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">		if (endDate.before(Calendar.getInstance())) {</span>
<span class="nc" id="L1188">			throw new DataClayRuntimeException(ERRORCODE.APPLIABLE_END_DATE_FOR_SESSION_IS_BEFORE_CURRENT_DATE);</span>
		}

		// Get info of interfaces
<span class="nc" id="L1192">		final Map&lt;InterfaceID, Interface&gt; infoOfInterfaces = interfaceMgrApi.getInterfacesInfo(interfacesIDs);</span>

		// Get info of classes of interfaces
<span class="nc" id="L1195">		final Map&lt;MetaClassID, MetaClass&gt; classesInfo = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1196">		final Map&lt;MetaClassID, Set&lt;Interface&gt;&gt; interfacesPerClass = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">		for (final Interface curInterface : infoOfInterfaces.values()) {</span>
<span class="nc" id="L1198">			final MetaClassID curClassID = curInterface.getMetaClassID();</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">			if (!classesInfo.containsKey(curClassID)) {</span>
<span class="nc" id="L1200">				final MetaClass classInfo = classMgrApi.getClassInfo(curClassID);</span>
<span class="nc" id="L1201">				classesInfo.put(curClassID, classInfo);</span>
			}
<span class="nc" id="L1203">			Set&lt;Interface&gt; ifacesOfClass = interfacesPerClass.get(curClassID);</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">			if (ifacesOfClass == null) {</span>
<span class="nc" id="L1205">				ifacesOfClass = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1206">				interfacesPerClass.put(curClassID, ifacesOfClass);</span>
			}
<span class="nc" id="L1208">			ifacesOfClass.add(curInterface);</span>
<span class="nc" id="L1209">		}</span>

		// CROSS-NAMESPACE STUFF
		// Get info of the implementations
<span class="nc" id="L1213">		final Map&lt;ImplementationID, Implementation&gt; infoOfImplementations = classMgrApi</span>
<span class="nc" id="L1214">				.getInfoOfImplementations(implementationsIDs);</span>

		// Get the info of namespaces of implementations
<span class="nc" id="L1217">		final Map&lt;ImplementationID, NamespaceID&gt; namespaceIDsOfImplementations = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">		for (final Entry&lt;ImplementationID, Implementation&gt; curImplementation : infoOfImplementations.entrySet()) {</span>
<span class="nc" id="L1219">			final ImplementationID curImplementationID = curImplementation.getKey();</span>
<span class="nc" id="L1220">			final NamespaceID curNamespaceID = curImplementation.getValue().getNamespaceID();</span>
<span class="nc" id="L1221">			namespaceIDsOfImplementations.put(curImplementationID, curNamespaceID);</span>
<span class="nc" id="L1222">		}</span>
<span class="nc" id="L1223">		final Set&lt;NamespaceID&gt; namespaceIDs = new HashSet&lt;&gt;(namespaceIDsOfImplementations.values());</span>
<span class="nc" id="L1224">		final Map&lt;NamespaceID, Namespace&gt; namespacesInfo = namespaceMgrApi.getNamespacesInfo(namespaceIDs);</span>

<span class="nc bnc" id="L1226" title="All 2 branches missed.">		if (dataSets.size() == 0) {</span>
<span class="nc" id="L1227">			throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION, &quot;Received information for #&quot;</span>
<span class="nc" id="L1228">					+ namespacesInfo.size() + &quot; namespace(s) and #&quot; + dataSets.size() + &quot; dataset(s)&quot;, true);</span>
		}

		// Build model contract session stuff and bitsets for every class
<span class="nc" id="L1232">		final Map&lt;ContractID, SessionContract&gt; sessionContracts = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1233">		final Map&lt;MetaClassID, BitSet&gt; bitsetsPerClass = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1235" title="All 2 branches missed.">		for (final Entry&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; curEntry : infoOfInterfacesInContracts</span>
<span class="nc" id="L1236">				.entrySet()) {</span>

<span class="nc" id="L1238">			final ContractID curContractID = curEntry.getKey();</span>
<span class="nc" id="L1239">			final Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt; curNamespaceAndInterfacesInContract = curEntry</span>
<span class="nc" id="L1240">					.getValue();</span>
<span class="nc" id="L1241">			final Map&lt;InterfaceID, InterfaceInContract&gt; curInterfacesInContract = curNamespaceAndInterfacesInContract</span>
<span class="nc" id="L1242">					.getFirst();</span>

			// Build session interfaces for every contract
<span class="nc" id="L1245">			final Map&lt;InterfaceID, SessionInterface&gt; sessionInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">			for (final Entry&lt;InterfaceID, InterfaceInContract&gt; curInterfaceInContractEntry : curInterfacesInContract</span>
<span class="nc" id="L1247">					.entrySet()) {</span>

<span class="nc" id="L1249">				final InterfaceID curInterfaceID = curInterfaceInContractEntry.getKey();</span>
<span class="nc" id="L1250">				final InterfaceInContract curInterfaceInContract = curInterfaceInContractEntry.getValue();</span>
<span class="nc" id="L1251">				final Interface curInterface = infoOfInterfaces.get(curInterfaceID);</span>

				// Add BitSet if it is the first time we explore the class of the interface
<span class="nc bnc" id="L1254" title="All 2 branches missed.">				if (!bitsetsPerClass.containsKey(curInterface.getMetaClassID())) {</span>
<span class="nc" id="L1255">					bitsetsPerClass.put(curInterface.getMetaClassID(), new BitSet());</span>
				}
<span class="nc" id="L1257">				final BitSet curBitSet = bitsetsPerClass.get(curInterface.getMetaClassID());</span>

				// Build session properties for every interface and update bitset of class
<span class="nc" id="L1260">				final Map&lt;PropertyID, SessionProperty&gt; sessionProperties = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1261">				final MetaClass classInfo = classesInfo.get(curInterface.getMetaClassID());</span>
<span class="nc" id="L1262">				final List&lt;Property&gt; propertiesInfo = classInfo.getProperties();</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">				for (final Property curProp : propertiesInfo) {</span>
<span class="nc" id="L1264">					final PropertyID propertyID = curProp.getDataClayID();</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">					if (curInterface.getPropertiesIDs().contains(propertyID)) {</span>
<span class="nc" id="L1266">						final SessionProperty sessionProperty = new SessionProperty(propertyID);</span>
<span class="nc" id="L1267">						sessionProperties.put(propertyID, sessionProperty);</span>
					}
<span class="nc" id="L1269">				}</span>

<span class="nc" id="L1271">				setIfacesBitMap(curInterface, classesInfo, curBitSet, interfacesPerClass, 0);</span>

				// Build session operations for every interface
<span class="nc" id="L1274">				final Map&lt;OperationID, SessionOperation&gt; sessionOperations = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">				for (final OperationID operationID : curInterface.getOperationsIDs()) {</span>
<span class="nc" id="L1276">					final OpImplementations opImpls = curInterfaceInContract.getAccessibleImplementations()</span>
<span class="nc" id="L1277">							.get(operationID);</span>
<span class="nc" id="L1278">					final ImplementationID localImplID = opImpls.getLocalImplementationID();</span>
<span class="nc" id="L1279">					final NamespaceID namespaceIDofLocalImplID = infoOfImplementations.get(localImplID)</span>
<span class="nc" id="L1280">							.getNamespaceID();</span>

<span class="nc" id="L1282">					final ImplementationID remoteImplID = opImpls.getRemoteImplementationID();</span>
<span class="nc" id="L1283">					final NamespaceID namespaceIDofRemoteImplID = infoOfImplementations.get(remoteImplID)</span>
<span class="nc" id="L1284">							.getNamespaceID();</span>

<span class="nc" id="L1286">					final SessionImplementation localImpl = new SessionImplementation(localImplID,</span>
							namespaceIDofLocalImplID,
<span class="nc" id="L1288">							namespacesInfo.get(namespaceIDofLocalImplID).getProviderAccountID());</span>
<span class="nc" id="L1289">					final SessionImplementation remoteImpl = new SessionImplementation(remoteImplID,</span>
							namespaceIDofRemoteImplID,
<span class="nc" id="L1291">							namespacesInfo.get(namespaceIDofRemoteImplID).getProviderAccountID());</span>
<span class="nc" id="L1292">					final SessionOperation sessionOperation = new SessionOperation(operationID, localImpl, remoteImpl);</span>

<span class="nc" id="L1294">					sessionOperations.put(operationID, sessionOperation);</span>

<span class="nc" id="L1296">					implementationsIDs.add(localImplID);</span>
<span class="nc" id="L1297">					implementationsIDs.add(remoteImplID);</span>
<span class="nc" id="L1298">				}</span>

				// Build the current sessionInterface
<span class="nc" id="L1301">				final SessionInterface sessionInterface = new SessionInterface(curInterfaceID,</span>
<span class="nc" id="L1302">						curInterface.getMetaClassID());</span>

<span class="nc" id="L1304">				sessionInterface.setSessionProperties(sessionProperties);</span>
<span class="nc" id="L1305">				sessionInterface.setSessionOperations(sessionOperations);</span>

				// Add sessionInterface to session interfaces
<span class="nc" id="L1308">				sessionInterfaces.put(curInterfaceID, sessionInterface);</span>
<span class="nc" id="L1309">			}</span>

			// Build the current session contract
<span class="nc" id="L1312">			final SessionContract sessionContract = new SessionContract(curContractID);</span>
<span class="nc" id="L1313">			sessionContract.setSessionInterfaces(sessionInterfaces);</span>

			// Add sessionContract to session contracts
<span class="nc" id="L1316">			sessionContracts.put(curContractID, sessionContract);</span>
<span class="nc" id="L1317">		}</span>

		// Build data contract session stuff
<span class="nc" id="L1320">		final Map&lt;DataContractID, SessionDataContract&gt; sessionDataContracts = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">		for (final Entry&lt;DataContractID, DataContract&gt; curDataContract : dataContractsInfo.entrySet()) {</span>
<span class="nc" id="L1322">			final DataContractID dataContractID = curDataContract.getKey();</span>
<span class="nc" id="L1323">			final DataContract dataContract = curDataContract.getValue();</span>
<span class="nc" id="L1324">			final DataSetID dataSetIDofProvider = dataContract.getProviderDataSetID();</span>
<span class="nc" id="L1325">			final SessionDataContract sessionDataContract = new SessionDataContract(dataContractID,</span>
					dataSetIDofProvider);
<span class="nc" id="L1327">			sessionDataContracts.put(dataContractID, sessionDataContract);</span>
<span class="nc" id="L1328">		}</span>

		// Finally register the new session
		// Generate bitmaps for interfaces of stubs
<span class="nc" id="L1332">		final Map&lt;MetaClassID, byte[]&gt; bitmapsPerClass = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">		for (final Entry&lt;MetaClassID, BitSet&gt; curEntry : bitsetsPerClass.entrySet()) {</span>
<span class="nc" id="L1334">			bitmapsPerClass.put(curEntry.getKey(), curEntry.getValue().toByteArray());</span>
<span class="nc" id="L1335">		}</span>
<span class="nc" id="L1336">		final SessionInfo result = sessionMgrApi.newSession(accountID, sessionContracts, sessionDataContracts,</span>
				dataContractIDforStore, endDate, newsessionLang, bitmapsPerClass);
<span class="nc" id="L1338">		return result;</span>
	}

	@Override
	public void closeSession(final SessionID sessionID) {
<span class="nc" id="L1343">		sessionMgrApi.closeSession(sessionID);</span>

		// Broadcast closing of session
<span class="nc bnc" id="L1346" title="All 2 branches missed.">		for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_JAVA).values()) {</span>
<span class="nc" id="L1347">			elem.getFirst().closeSessionInDS(sessionID);</span>
<span class="nc" id="L1348">		}</span>
<span class="nc bnc" id="L1349" title="All 2 branches missed.">		for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_PYTHON).values()) {</span>
<span class="nc" id="L1350">			elem.getFirst().closeSessionInDS(sessionID);</span>
<span class="nc" id="L1351">		}</span>
<span class="nc" id="L1352">	}</span>

	/**
	 * Set iface bitmap for session.
	 * 
	 * @param curInterface
	 *            Current interface
	 * @param classesInfo
	 *            Information of classes
	 * @param curBitSet
	 *            Current bitset being set
	 * @param ifacesPerClass
	 *            Interfaces per class
	 * @param initialPosition
	 *            Initial position (used for embbeded)
	 */
	private void setIfacesBitMap(final Interface curInterface, final Map&lt;MetaClassID, MetaClass&gt; classesInfo,
			final BitSet curBitSet, final Map&lt;MetaClassID, Set&lt;Interface&gt;&gt; ifacesPerClass, final int initialPosition) {

<span class="nc" id="L1371">		int curPosition = initialPosition;</span>
<span class="nc" id="L1372">		final MetaClass classInfo = classesInfo.get(curInterface.getMetaClassID());</span>
<span class="nc" id="L1373">		final List&lt;Property&gt; propertiesInfo = classInfo.getProperties();</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">		for (final Property curProp : propertiesInfo) {</span>
<span class="nc" id="L1375">			final PropertyID propertyID = curProp.getDataClayID();</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">			if (curInterface.getPropertiesIDs().contains(propertyID)) {</span>
				// Update bitset for calculating the final bitmap afterwards

				// Also, in case of embeded this is setting the boolean indicating if it is null
<span class="nc" id="L1380">				curBitSet.set(curPosition);</span>

				// === EMBEDDED FIELDS === //
				/*
				 * if (curProp.getType().getClassID() != null) { MetaClass clazz =
				 * classesInfo.get(curProp.getType().getClassID()); if (clazz.isImmutable()) {
				 * // Get interface of the embedded class Set&lt;Interface&gt; newIfaces =
				 * ifacesPerClass.get(clazz.getID()); for (Interface iface : newIfaces) {
				 * setIfacesBitMap(iface, classesInfo, curBitSet, ifacesPerClass,
				 * curProp.getPosition() + 1); } curPosition = curPosition +
				 * clazz.getProperties().size(); } }
				 */
			}

<span class="nc" id="L1394">			curPosition++;</span>
<span class="nc" id="L1395">		}</span>
<span class="nc" id="L1396">	}</span>

	@Override
	public Tuple&lt;Tuple&lt;DataSetID, Set&lt;DataSetID&gt;&gt;, Calendar&gt; getInfoOfSessionForDS(final SessionID sessionID) {
		// TODO We have to ensure that only a DataService is able to access this method
		// (30 May 2014 jmarti)
<span class="nc" id="L1402">		final HashSet&lt;DataSetID&gt; visibleDataSets = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1403">		final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L1404">		DataSetID dataSetForStore = null;</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">		for (final SessionDataContract sessionDataContract : sessionInfo.getSessionDataContracts().values()) {</span>
<span class="nc" id="L1406">			visibleDataSets.add(sessionDataContract.getDataSetOfProvider());</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">			if (sessionDataContract.getDataContractID().equals(sessionInfo.getDataContractIDforStore())) {</span>
<span class="nc" id="L1408">				dataSetForStore = sessionDataContract.getDataSetOfProvider();</span>
			}
<span class="nc" id="L1410">		}</span>
<span class="nc" id="L1411">		return new Tuple&lt;&gt;(new Tuple&lt;DataSetID, Set&lt;DataSetID&gt;&gt;(dataSetForStore, visibleDataSets),</span>
<span class="nc" id="L1412">				sessionInfo.getEndDate());</span>
	}

	// ============== Namespace Manager ==============//

	@Override
	public NamespaceID newNamespace(final AccountID accountID, final PasswordCredential credential,
			final Namespace newNamespace) {
		// Validate account
<span class="nc bnc" id="L1421" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L1422">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

		// =========== CHECK AND SET IDS =========== //
<span class="nc" id="L1426">		final String providerAccountName = newNamespace.getProviderAccountName();</span>
<span class="nc bnc" id="L1427" title="All 4 branches missed.">		if (providerAccountName == null || providerAccountName.isEmpty()) {</span>
<span class="nc" id="L1428">			throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
					&quot;Namespace wrong specification: Provider account name cannot be null nor empty&quot;, false);
		}
<span class="nc" id="L1431">		final AccountID provAccountID = accountMgrApi.getAccountID(providerAccountName);</span>
<span class="nc" id="L1432">		newNamespace.setProviderAccountID(provAccountID);</span>

<span class="nc" id="L1434">		final String namespaceName = newNamespace.getName();</span>
<span class="nc bnc" id="L1435" title="All 4 branches missed.">		if (namespaceName == null || namespaceName.isEmpty()) {</span>
<span class="nc" id="L1436">			throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
					&quot;Namespace wrong specification: name cannot be null&quot;, false);
		}
		// =========== =========== //

		// Generate ID
<span class="nc" id="L1442">		newNamespace.setDataClayID(new NamespaceID());</span>
		// Set correctly the responsible account
<span class="nc" id="L1444">		newNamespace.setProviderAccountID(accountID);</span>

		// Create the new namespace
<span class="nc" id="L1447">		NamespaceID newNamespaceID = namespaceMgrApi.newNamespace(newNamespace);</span>
<span class="nc" id="L1448">		LOGGER.info(&quot;[LOGICMODULE] Created new namespace called &quot; + namespaceName);</span>

<span class="nc" id="L1450">		return newNamespaceID;</span>


	}

	@Override
	public Set&lt;String&gt; getNamespaces(final AccountID accountID, final PasswordCredential credential) {

		// Validate account
<span class="nc bnc" id="L1459" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L1460">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L1463">		return namespaceMgrApi.getNamespacesNames();</span>
	}

	@Override
	public void removeNamespace(final AccountID accountID, final PasswordCredential credential,
			final String namespaceName) {
		// Get the namespaceID of the namespace
<span class="nc" id="L1470">		final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespaceName);</span>

		// Validate account (ADMIN || NAMESPACE RESPONSIBLE)
		try {
<span class="nc" id="L1474">			accountMgrApi.validateAccount(accountID, credential, AccountRole.ADMIN_ROLE);</span>
<span class="nc" id="L1475">		} catch (final Exception ex) {</span>
<span class="nc" id="L1476">			checkNamespaceResponsible(accountID, credential, namespaceID);</span>
<span class="nc" id="L1477">		}</span>

		// Check the namespace can be removed
		// Check namespace is not related with any contract
<span class="nc bnc" id="L1481" title="All 2 branches missed.">		if (!contractMgrApi.checkNamespaceHasNoContracts(namespaceID)) {</span>
<span class="nc" id="L1482">			throw new DataClayRuntimeException(ERRORCODE.NAMESPACE_WITH_CONTRACTS);</span>
		}
		// Check namespace has nothing
<span class="nc bnc" id="L1485" title="All 2 branches missed.">		if (!classMgrApi.checkNamespaceHasNothing(namespaceID)) {</span>
<span class="nc" id="L1486">			throw new DataClayRuntimeException(ERRORCODE.NAMESPACE_WITH_CLASSES);</span>
		}

		// Remove namespace
<span class="nc" id="L1490">		namespaceMgrApi.removeNamespace(namespaceID);</span>

<span class="nc" id="L1492">	}</span>

	@Override
	public NamespaceID getNamespaceID(final AccountID accountID, final PasswordCredential credential,
			final String namespaceName) {
		// Validate account
<span class="nc bnc" id="L1498" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1499">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}
<span class="nc" id="L1501">		return namespaceMgrApi.getNamespaceID(namespaceName);</span>

	}

	@Override
	public Langs getNamespaceLang(final AccountID accountID, final PasswordCredential credential,
			final String namespaceName) {
		// Validate account
<span class="nc bnc" id="L1509" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1510">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}
<span class="nc" id="L1512">		return namespaceMgrApi.getNamespaceLang(namespaceName);</span>
	}

	@Override
	public void importInterface(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final ContractID contractID, final InterfaceID interfaceID) {
		// Check namespace responsible
<span class="nc" id="L1519">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

		// Check interface in contract of import and get contract info
<span class="nc" id="L1522">		final Map&lt;ContractID, InterfaceID&gt; aux = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1523">		aux.put(contractID, interfaceID);</span>
<span class="nc" id="L1524">		final Contract contractInfo = contractMgrApi</span>
<span class="nc" id="L1525">				.checkInterfacesInActiveContractsForAccountAndReturnContractsInfo(accountID, aux).get(contractID);</span>
<span class="nc" id="L1526">		final Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInContract = contractInfo.getInterfacesInContract();</span>

		// Check compatibility between namespaces (language)
<span class="nc" id="L1529">		final HashSet&lt;NamespaceID&gt; namespacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1530">		namespacesIDs.add(namespaceID);</span>
<span class="nc" id="L1531">		namespacesIDs.add(contractInfo.getNamespaceID());</span>

		// Init interfaces to be imported with the explicitly specified one
<span class="nc" id="L1534">		final HashSet&lt;InterfaceID&gt; interfacesIDsToBeImported = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1535">		interfacesIDsToBeImported.add(interfaceID);</span>

<span class="nc bnc" id="L1537" title="All 2 branches missed.">		while (!interfacesIDsToBeImported.isEmpty()) {</span>
<span class="nc" id="L1538">			final Set&lt;InterfaceID&gt; nextInterfacesIDsToBeImported = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1539">			final Map&lt;InterfaceID, ImportedInterface&gt; currentImportss = new HashMap&lt;&gt;();</span>

			// Get info of current interfaces to be imported
<span class="nc" id="L1542">			final Map&lt;InterfaceID, Interface&gt; interfacesInfo = interfaceMgrApi</span>
<span class="nc" id="L1543">					.getInterfacesInfo(interfacesIDsToBeImported);</span>

<span class="nc bnc" id="L1545" title="All 2 branches missed.">			for (final InterfaceID curInterfaceID : interfacesIDsToBeImported) {</span>
<span class="nc" id="L1546">				final Interface interfaceInfo = interfacesInfo.get(curInterfaceID);</span>
<span class="nc" id="L1547">				final InterfaceInContract interfaceInContract = interfacesInContract.get(curInterfaceID);</span>
<span class="nc" id="L1548">				final MetaClassID classIDofInterface = interfaceInfo.getMetaClassID();</span>

				// Check interface actually comes from another namespace
<span class="nc bnc" id="L1551" title="All 2 branches missed.">				if (interfaceInfo.getNamespaceID().equals(namespaceID)) {</span>
<span class="nc" id="L1552">					throw new DataClayRuntimeException(ERRORCODE.IMPORTED_INTERFACE_WAS_CREATED_IN_TARGET_NAMESPACE);</span>
				}

				// Get info of class of interface and its includes filtering by real needs of
				// interface in contract (properties, operations, implementations)
<span class="nc" id="L1557">				final Set&lt;PropertyID&gt; propertiesIDsOfInterface = interfaceInfo.getPropertiesIDs();</span>
<span class="nc" id="L1558">				final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; opsIDsandImplsIDsOfInterfaceInContract = //</span>
						new HashMap&lt;&gt;();
<span class="nc bnc" id="L1560" title="All 2 branches missed.">				for (final Entry&lt;OperationID, OpImplementations&gt; curEntry : interfaceInContract</span>
<span class="nc" id="L1561">						.getAccessibleImplementations().entrySet()) {</span>
<span class="nc" id="L1562">					final HashSet&lt;ImplementationID&gt; implsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1563">					implsIDs.add(curEntry.getValue().getLocalImplementationID());</span>
<span class="nc" id="L1564">					implsIDs.add(curEntry.getValue().getRemoteImplementationID());</span>
<span class="nc" id="L1565">					opsIDsandImplsIDsOfInterfaceInContract.put(curEntry.getKey(), implsIDs);</span>
<span class="nc" id="L1566">				}</span>
<span class="nc" id="L1567">				final Triple&lt;String, NamespaceID, Set&lt;MetaClassID&gt;&gt; classInfoAndIncludesOfDifferentNamespace = classMgrApi</span>
<span class="nc" id="L1568">						.getIncludesInDifferentNamespaces(classIDofInterface, propertiesIDsOfInterface,</span>
								opsIDsandImplsIDsOfInterfaceInContract, namespaceID);
<span class="nc" id="L1570">				final String className = classInfoAndIncludesOfDifferentNamespace.getFirst();</span>
<span class="nc" id="L1571">				final NamespaceID namespaceIDofClass = classInfoAndIncludesOfDifferentNamespace.getSecond();</span>
<span class="nc" id="L1572">				final Set&lt;MetaClassID&gt; includesIDs = classInfoAndIncludesOfDifferentNamespace.getThird();</span>

				// Check namespace of class is different than target namespace for the import
<span class="nc bnc" id="L1575" title="All 2 branches missed.">				if (namespaceID.equals(namespaceIDofClass)) {</span>
<span class="nc" id="L1576">					throw new DataClayRuntimeException(</span>
							ERRORCODE.CLASS_OF_IMPORTED_INTERFACE_WAS_CREATED_IN_TARGET_NAMESPACE);
				}

				// Check there is no class created in target namespace with the same name as
				// imported class
<span class="nc bnc" id="L1582" title="All 2 branches missed.">				if (classMgrApi.getMetaClassID(namespaceID, className) != null) {</span>
<span class="nc" id="L1583">					throw new DataClayRuntimeException(ERRORCODE.CLASS_WITH_SAME_NAME_IN_NAMESPACE);</span>
				}

				// Filter subset of interfaces of the contract that are needed given the
				// includes
				// for the current one to be imported
<span class="nc" id="L1589">				nextInterfacesIDsToBeImported.addAll(interfaceMgrApi.getSubsetInterfacesOfClasses(</span>
<span class="nc" id="L1590">						new HashSet&lt;&gt;(contractInfo.getInterfacesInContract().keySet()), includesIDs));</span>

				// Filter current interfaceID to be imported
<span class="nc" id="L1593">				nextInterfacesIDsToBeImported.removeAll(interfacesIDsToBeImported);</span>

				// Filter those that were already imported in the namespace
<span class="nc" id="L1596">				final Set&lt;ImportedInterface&gt; interfacesImported = namespaceMgrApi</span>
<span class="nc" id="L1597">						.getImportedInterfaces(namespaceIDofClass, className);</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">				for (final ImportedInterface importedInterface : interfacesImported) {</span>
<span class="nc" id="L1599">					nextInterfacesIDsToBeImported.remove(importedInterface.getInterfaceID());</span>
<span class="nc" id="L1600">				}</span>

<span class="nc" id="L1602">				final ImportedInterface currentInterface = new ImportedInterface(className, curInterfaceID, contractID,</span>
						classIDofInterface, namespaceIDofClass);
<span class="nc" id="L1604">				currentImportss.put(curInterfaceID, currentInterface);</span>
<span class="nc" id="L1605">			}</span>

<span class="nc" id="L1607">			final HashSet&lt;ImportedInterface&gt; importss = new HashSet&lt;&gt;(currentImportss.values());</span>

			// Deploy imported class
<span class="nc" id="L1610">			final HashSet&lt;NamespaceID&gt; domIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1611">			domIDs.add(namespaceID);</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">			for (final ImportedInterface impInterface : importss) {</span>
<span class="nc" id="L1613">				final NamespaceID domID = impInterface.getNamespaceIDofClass();</span>
<span class="nc" id="L1614">				domIDs.add(domID);</span>
<span class="nc" id="L1615">			}</span>

			// Register current imports
<span class="nc" id="L1618">			namespaceMgrApi.importInterfaces(namespaceID, new HashSet&lt;&gt;(currentImportss.values()));</span>

			// Update interfacesIDsToBeImported
<span class="nc" id="L1621">			interfacesIDsToBeImported.addAll(nextInterfacesIDsToBeImported);</span>
<span class="nc" id="L1622">			interfacesIDsToBeImported.removeAll(currentImportss.keySet());</span>
<span class="nc" id="L1623">		}</span>

<span class="nc" id="L1625">	}</span>

	@Override
	public void importContract(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final ContractID contractID) {
		// Check namespace responsible
<span class="nc" id="L1631">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

		// Check compatibility between namespaces (language)
<span class="nc" id="L1634">		final LinkedList&lt;ContractID&gt; contractsIDs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1635">		contractsIDs.add(contractID);</span>
<span class="nc" id="L1636">		final Contract contractInfo = contractMgrApi.getInfoOfSomeActiveContractsForAccount(contractsIDs, accountID)</span>
<span class="nc" id="L1637">				.get(contractID);</span>
<span class="nc" id="L1638">		final Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInContract = contractInfo.getInterfacesInContract();</span>

		// Check compatibility between namespaces
<span class="nc" id="L1641">		final HashSet&lt;NamespaceID&gt; namespacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1642">		namespacesIDs.add(namespaceID);</span>
<span class="nc" id="L1643">		namespacesIDs.add(contractInfo.getNamespaceID());</span>

		// Get info of interfaces
<span class="nc" id="L1646">		final Map&lt;InterfaceID, Interface&gt; interfacesInfo = interfaceMgrApi</span>
<span class="nc" id="L1647">				.getInterfacesInfo(new HashSet&lt;&gt;(contractInfo.getInterfacesInContract().keySet()));</span>

		// Check no interface was created on target namespace
<span class="nc" id="L1650">		final HashSet&lt;ImportedInterface&gt; importss = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">		for (final Entry&lt;InterfaceID, Interface&gt; curInterface : interfacesInfo.entrySet()) {</span>
<span class="nc" id="L1652">			final InterfaceID interfaceID = curInterface.getKey();</span>
<span class="nc" id="L1653">			final Interface interfaceInfo = curInterface.getValue();</span>
<span class="nc" id="L1654">			final InterfaceInContract interfaceInContract = interfacesInContract.get(interfaceID);</span>
<span class="nc" id="L1655">			final MetaClassID classIDofInterface = interfaceInfo.getMetaClassID();</span>

			// Check interface was not created in same namespace as target one
<span class="nc bnc" id="L1658" title="All 2 branches missed.">			if (interfaceInfo.getNamespaceID().equals(namespaceID)) {</span>
<span class="nc" id="L1659">				throw new DataClayRuntimeException(ERRORCODE.IMPORTED_INTERFACE_WAS_CREATED_IN_TARGET_NAMESPACE);</span>
			}

			// Get info of class of interface and its includes filtering by
			// real needs of
			// interface in contract (properties, operations,
			// implementations)
<span class="nc" id="L1666">			final Set&lt;PropertyID&gt; propertiesIDsOfInterface = interfaceInfo.getPropertiesIDs();</span>
<span class="nc" id="L1667">			final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; opsIDsandImplsIDsOfInterfaceInContract = //</span>
					new HashMap&lt;&gt;();
<span class="nc bnc" id="L1669" title="All 2 branches missed.">			for (final Entry&lt;OperationID, OpImplementations&gt; curEntry : interfaceInContract</span>
<span class="nc" id="L1670">					.getAccessibleImplementations().entrySet()) {</span>
<span class="nc" id="L1671">				final HashSet&lt;ImplementationID&gt; implsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1672">				implsIDs.add(curEntry.getValue().getLocalImplementationID());</span>
<span class="nc" id="L1673">				implsIDs.add(curEntry.getValue().getRemoteImplementationID());</span>
<span class="nc" id="L1674">				opsIDsandImplsIDsOfInterfaceInContract.put(curEntry.getKey(), implsIDs);</span>
<span class="nc" id="L1675">			}</span>
<span class="nc" id="L1676">			final Triple&lt;String, NamespaceID, Set&lt;MetaClassID&gt;&gt; classInfoAndIncludesOfDifferentNamespace = classMgrApi</span>
<span class="nc" id="L1677">					.getIncludesInDifferentNamespaces(classIDofInterface, propertiesIDsOfInterface,</span>
							opsIDsandImplsIDsOfInterfaceInContract, namespaceID);
<span class="nc" id="L1679">			final String className = classInfoAndIncludesOfDifferentNamespace.getFirst();</span>
<span class="nc" id="L1680">			final NamespaceID namespaceIDofClass = classInfoAndIncludesOfDifferentNamespace.getSecond();</span>
			// BEWARE: If contract is correct, we do not have to check
			// includes are in contract in this point
			// HashSet&lt;MetaClassID&gt; includesIDs =
			// classInfoAndIncludesOfDifferentNamespace.getThird();

<span class="nc bnc" id="L1686" title="All 2 branches missed.">			if (namespaceIDofClass.equals(namespaceID)) {</span>
<span class="nc" id="L1687">				throw new DataClayRuntimeException(</span>
						ERRORCODE.CLASS_OF_IMPORTED_INTERFACE_WAS_CREATED_IN_TARGET_NAMESPACE);
			} else {
<span class="nc" id="L1690">				final ImportedInterface importInterface = new ImportedInterface(className, interfaceID, contractID,</span>
<span class="nc" id="L1691">						interfaceInfo.getMetaClassID(), namespaceIDofClass);</span>
<span class="nc" id="L1692">				importss.add(importInterface);</span>
			}
<span class="nc" id="L1694">		}</span>

		// Deploy imported class
<span class="nc" id="L1697">		final HashSet&lt;NamespaceID&gt; domIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1698">		domIDs.add(namespaceID);</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">		for (final ImportedInterface impInterface : importss) {</span>
<span class="nc" id="L1700">			final NamespaceID domID = impInterface.getNamespaceIDofClass();</span>
<span class="nc" id="L1701">			domIDs.add(domID);</span>
<span class="nc" id="L1702">		}</span>

<span class="nc" id="L1704">		namespaceMgrApi.importInterfaces(namespaceID, importss);</span>

<span class="nc" id="L1706">	}</span>

	// ============== DataSet Manager ==============//

	@Override
	public DataSetID newDataSet(final AccountID accountID, final PasswordCredential credential,
			final DataSet newDataSet) {

		// Validate account
<span class="nc bnc" id="L1715" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L1716">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

		// ================================================ //
<span class="nc bnc" id="L1720" title="All 2 branches missed.">		if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L1721">			this.notificationMgrApi.removeSessionInCache(accountID);</span>
		}

<span class="nc" id="L1724">		final String dataSetName = newDataSet.getName();</span>
<span class="nc bnc" id="L1725" title="All 4 branches missed.">		if (dataSetName == null || dataSetName.isEmpty()) {</span>
<span class="nc" id="L1726">			throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
					&quot;DataSet wrong specification: DataSet name cannot be null&quot;, false);
		}
		// =========== =========== //

		// Create ID
<span class="nc bnc" id="L1732" title="All 2 branches missed.">		if (newDataSet.getDataClayID() == null) {</span>
<span class="nc" id="L1733">			newDataSet.setDataClayID(new DataSetID());</span>
		}
		// Set the responsible account correctly
<span class="nc" id="L1736">		newDataSet.setProviderAccountID(accountID);</span>

		// Create the new dataset
<span class="nc" id="L1739">		final DataSetID dsID = dataSetMgrApi.newDataSet(newDataSet);</span>

<span class="nc" id="L1741">		LOGGER.info(&quot;[LOGICMODULE] Created new dataset called &quot; + newDataSet.getName() + &quot; with ID &quot; + dsID);</span>

<span class="nc" id="L1743">		return dsID;</span>
	}

	@Override
	public void removeDataSet(final AccountID accountID, final PasswordCredential credential,
			final String datasetName) {
		// Get the namespaceID of the namespace
<span class="nc" id="L1750">		final DataSetID datasetID = dataSetMgrApi.getDataSetID(datasetName);</span>

		// Validate account (ADMIN || NAMESPACE RESPONSIBLE)
		try {
<span class="nc" id="L1754">			accountMgrApi.validateAccount(accountID, credential, AccountRole.ADMIN_ROLE);</span>
<span class="nc" id="L1755">		} catch (final Exception ex) {</span>
<span class="nc" id="L1756">			checkDataSetResponsible(accountID, credential, datasetID);</span>
<span class="nc" id="L1757">		}</span>

		// Check the dataset can be removed
		// Check dataset is not related with any contract
<span class="nc bnc" id="L1761" title="All 2 branches missed.">		if (!datacontractMgrApi.checkDataSetHasNoDataContracts(datasetID)) {</span>
<span class="nc" id="L1762">			throw new DataClayRuntimeException(ERRORCODE.DATASET_WITH_DATACONTRACTS);</span>
		}
		// Check dataset has nothing
<span class="nc bnc" id="L1765" title="All 2 branches missed.">		if (!metaDataSrvApi.checkDatasetIsEmpty(datasetID)) {</span>
<span class="nc" id="L1766">			throw new DataClayRuntimeException(ERRORCODE.DATASET_NOT_EMPTY);</span>
		}

		// Remove dataset
<span class="nc" id="L1770">		dataSetMgrApi.removeDataSet(datasetID);</span>

<span class="nc" id="L1772">	}</span>

	@Override
	public DataSetID getDataSetID(final AccountID accountID, final PasswordCredential credential,
			final String datasetName) {
		// Validate account
<span class="nc bnc" id="L1778" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1779">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

		// Get the datasetID of the namespace
<span class="nc" id="L1783">		return dataSetMgrApi.getDataSetID(datasetName);</span>
	}

	@Override
	public boolean checkDataSetIsPublic(final DataSetID datasetID) {
<span class="nc" id="L1788">		return dataSetMgrApi.checkDataSetIsPublic(datasetID);</span>
	}

	@Override
	public Set&lt;String&gt; getPublicDataSets(final AccountID accountID, final PasswordCredential credential) {
		// Validate account
<span class="nc bnc" id="L1794" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1795">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}
<span class="nc" id="L1797">		final Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">		for (final DataSet ds : dataSetMgrApi.getPublicDataSets()) {</span>
<span class="nc" id="L1799">			result.add(ds.getName());</span>
<span class="nc" id="L1800">		}</span>
<span class="nc" id="L1801">		return result;</span>
	}

	@Override
	public Set&lt;String&gt; getAccountDataSets(final AccountID accountID, final PasswordCredential credential) {
		// Validate account
<span class="nc bnc" id="L1807" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L1808">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}
<span class="nc" id="L1810">		final Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">		for (final DataSet ds : dataSetMgrApi.getAllDataSetsOfAccount(accountID)) {</span>
<span class="nc" id="L1812">			result.add(ds.getName());</span>
<span class="nc" id="L1813">		}</span>
<span class="nc" id="L1814">		return result;</span>
	}

	@Override
	public DataSetID getObjectDataSetID(final SessionID sessionID, final ObjectID oid) {
		// Check session if needed
<span class="nc" id="L1820">		SessionInfo sessionInfo = null;</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L1822">			sessionInfo = getSessionInfo(sessionID);</span>
		}

<span class="nc" id="L1825">		final MetaDataInfo metadataInfo = getObjectMetadata(oid);</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">		if (metadataInfo == null) {</span>
<span class="nc" id="L1827">			throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
		}

		// Check dataset if needed
<span class="nc bnc" id="L1831" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L1832">			checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
		}

<span class="nc" id="L1835">		return metadataInfo.getDatasetID();</span>
	}

	// ============== Class Manager ==============//

	@Override
	public Map&lt;String, MetaClass&gt; newClass(final AccountID accountID, final PasswordCredential credential,
			final Langs language, final Map&lt;String, MetaClass&gt; newClasses) {
<span class="nc" id="L1843">		return registerAndUpdateDependencies(accountID, credential, language, newClasses, null, null);</span>
	}

	@Override
	public MetaClassID newClassID(final AccountID accountID, final PasswordCredential credential,
			final String className, final Langs language, final Map&lt;String, MetaClass&gt; newClasses) {
<span class="nc" id="L1849">		final MetaClass result = registerAndUpdateDependencies(accountID, credential, language, newClasses, null, null)</span>
<span class="nc" id="L1850">				.get(className);</span>

<span class="nc bnc" id="L1852" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L1853">			return null;</span>
		} else {
<span class="nc" id="L1855">			return result.getDataClayID();</span>
		}
	}

	/**
	 * Manage the class deployment (to all DataServices) of Java classes.
	 *
	 * @param allMetaClasses
	 *            all the MetaClasses related to this deployment.
	 * @param classesToDeploy
	 *            the name for all the classes which should be deployed (this should
	 *            be a subset of the previous set).
	 * @param namespaceInfos
	 *            all the namespace information of the namespaces of the classes
	 *            (although the deployment should be only on a specific one).
	 * @param enrichmentNamespaceID
	 *            NamespaceID for the enrichment when applicable.
	 * @param specificLocationOnly
	 *            Indicates only to deploy to a specific location
	 * @throws RemoteException
	 *             from the ClassManager calls, when things go wrong.
	 */
	private void outsourceClassesDeploymentJava(final Set&lt;MetaClass&gt; allMetaClasses, final Set&lt;String&gt; classesToDeploy,
			final Map&lt;NamespaceID, Namespace&gt; namespaceInfos, final NamespaceID enrichmentNamespaceID,
			final ExecutionEnvironmentID specificLocationOnly) {

<span class="nc" id="L1881">		final Map&lt;Tuple&lt;String, MetaClassID&gt;, byte[]&gt; bytecodes = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1882">		final Map&lt;String, byte[]&gt; aspects = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1883">		final Map&lt;String, byte[]&gt; yamls = new HashMap&lt;&gt;();</span>

<span class="nc" id="L1885">		Namespace namespaceInfo = null;</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">		if (enrichmentNamespaceID != null) {</span>
<span class="nc" id="L1887">			namespaceInfo = namespaceInfos.get(enrichmentNamespaceID);</span>

		}
<span class="nc bnc" id="L1890" title="All 2 branches missed.">		for (final MetaClass curMetaClass : allMetaClasses) {</span>
<span class="nc" id="L1891">			final String className = curMetaClass.getName();</span>
<span class="nc" id="L1892">			final MetaClassID classID = curMetaClass.getDataClayID();</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">			if (classesToDeploy.contains(curMetaClass.getName())) {</span>

<span class="nc bnc" id="L1895" title="All 2 branches missed.">				if (namespaceInfo == null) {</span>
					// WARNING!!!! Precondition: all classes belongs to the same namespace
<span class="nc" id="L1897">					namespaceInfo = namespaceInfos.get(curMetaClass.getNamespaceID());</span>
				}
				/*
				 * Get the execution class for Java
				 */
<span class="nc" id="L1902">				final Tuple&lt;byte[], byte[]&gt; classAndAspectsToDeploy = classMgrApi</span>
<span class="nc" id="L1903">						.generateJavaExecutionClass(curMetaClass);</span>
<span class="nc" id="L1904">				bytecodes.put(new Tuple&lt;&gt;(className, classID), classAndAspectsToDeploy.getFirst());</span>
<span class="nc" id="L1905">				aspects.put(className, classAndAspectsToDeploy.getSecond());</span>
				// Yamls
<span class="nc" id="L1907">				final StubInfo execStubInfo = this.getStubInfoForExecutionClass(curMetaClass.getDataClayID());</span>
<span class="nc" id="L1908">				final Yaml yaml = CommonYAML.getYamlObject();</span>
<span class="nc" id="L1909">				final String yamlStr = yaml.dump(execStubInfo);</span>
<span class="nc" id="L1910">				yamls.put(className, yamlStr.getBytes());</span>
			}
<span class="nc" id="L1912">		}</span>

		// First deploy the class at the adequate Execution Environments
<span class="nc bnc" id="L1915" title="All 2 branches missed.">		if (specificLocationOnly == null) {</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">			for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_JAVA).values()) {</span>
<span class="nc" id="L1917">				elem.getFirst().deployClasses(namespaceInfo.getName(), bytecodes, aspects, yamls);</span>
<span class="nc" id="L1918">			}</span>
		} else {
<span class="nc" id="L1920">			final ExecutionEnvironment eeInfo = metaDataSrvApi.getExecutionEnvironmentInfo(specificLocationOnly);</span>
<span class="nc" id="L1921">			final DataServiceAPI elem = getExecutionEnvironments(Langs.LANG_JAVA).get(eeInfo.getDataClayID()).getFirst();</span>
<span class="nc" id="L1922">			elem.deployClasses(namespaceInfo.getName(), bytecodes, aspects, yamls);</span>
		}
<span class="nc" id="L1924">	}</span>

	/**
	 * Manage the class deployment (to all DataServices) of Java classes.
	 *
	 * @param allMetaClasses
	 *            all the MetaClasses related to this deployment.
	 * @param classesToDeploy
	 *            the name for all the classes which should be deployed (this should
	 *            be a subset of the previous set).
	 * @param namespaceInfos
	 *            all the namespace information of the namespaces of the classes
	 *            (although the deployment should be only on a specific one).
	 * @param enrichmentNamespaceID
	 *            NamespaceID for the enrichment when applicable.
	 * @param specificEnvironmentOnly
	 *            specific environment if required (optional)
	 *
	 * @throws RemoteException
	 *             from the ClassManager calls, when things go wrong.
	 */
	private void outsourceClassesDeploymentPython(final Set&lt;MetaClass&gt; allMetaClasses,
			final Set&lt;String&gt; classesToDeploy, final Map&lt;NamespaceID, Namespace&gt; namespaceInfos,
			final NamespaceID enrichmentNamespaceID, final ExecutionEnvironmentID specificEnvironmentOnly) {

<span class="nc" id="L1949">		final Map&lt;String, MetaClass&gt; deploymentPack = new HashMap&lt;&gt;();</span>

<span class="nc" id="L1951">		Namespace namespaceInfo = null;</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">		if (enrichmentNamespaceID != null) {</span>
<span class="nc" id="L1953">			namespaceInfo = namespaceInfos.get(enrichmentNamespaceID);</span>
		}

<span class="nc bnc" id="L1956" title="All 2 branches missed.">		for (final MetaClass curMetaClass : allMetaClasses) {</span>
<span class="nc" id="L1957">			final String className = curMetaClass.getName();</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">			if (classesToDeploy.contains(curMetaClass.getName())) {</span>

<span class="nc bnc" id="L1960" title="All 2 branches missed.">				if (namespaceInfo == null) {</span>
					// WARNING!!!! Precondition: all classes belongs to the same namespace
<span class="nc" id="L1962">					namespaceInfo = namespaceInfos.get(curMetaClass.getNamespaceID());</span>
				}

<span class="nc" id="L1965">				deploymentPack.put(className, curMetaClass);</span>
			}
<span class="nc" id="L1967">		}</span>
<span class="nc bnc" id="L1968" title="All 2 branches missed.">		if (specificEnvironmentOnly == null) {</span>
			// First deploy the classes at the adequate Execution Environments
<span class="nc bnc" id="L1970" title="All 2 branches missed.">			for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_PYTHON).values()) {</span>
<span class="nc" id="L1971">				LOGGER.debug(&quot;Seding classes to {}&quot;, elem.getFirst());</span>
<span class="nc" id="L1972">				elem.getFirst().deployMetaClasses(namespaceInfo.getName(), deploymentPack);</span>
<span class="nc" id="L1973">			}</span>
		} else {
<span class="nc" id="L1975">			final ExecutionEnvironment eeInfo = metaDataSrvApi.getExecutionEnvironmentInfo(specificEnvironmentOnly);</span>
<span class="nc" id="L1976">			final DataServiceAPI elem = getExecutionEnvironments(Langs.LANG_PYTHON).get(eeInfo.getDataClayID()).getFirst();</span>
<span class="nc" id="L1977">			elem.deployMetaClasses(namespaceInfo.getName(), deploymentPack);</span>
		}
<span class="nc" id="L1979">	}</span>

	/**
	 * This internal operation recursively registers all the required dependencies
	 * of a metaClass to be usable.
	 * 
	 * @param accountID
	 *            ID of the account of the user that calls the operation
	 * @param credentials
	 *            Credentials of the account provided
	 * @param language
	 *            Language of the classes provided
	 * @param metaClasses
	 *            ifications of classes to create
	 * @param enrichmentNamespaceID
	 *            ID of the Namespace of the enrichment (can be NULL)
	 * @param enrichedClassName
	 *            if we are executing the method from en enrichment process, the
	 *            name of the enriched class
	 *
	 * @return the id or information of the new metaclass if the operation succeeds.
	 *         null otherwise.
	 * @throws RemoteException
	 *             if some exception occurs
	 */
	public Map&lt;String, MetaClass&gt; registerAndUpdateDependencies(final AccountID accountID,
			final PasswordCredential credentials, final Langs language, final Map&lt;String, MetaClass&gt; metaClasses,
			final NamespaceID enrichmentNamespaceID, final String enrichedClassName) {

		// IDs structures
<span class="nc" id="L2009">		final Map&lt;String, MetaClassID&gt; classIDsSet = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2010">		final Map&lt;String, PropertyID&gt; propIDsSet = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2011">		final Map&lt;String, ImplementationID&gt; implIDsSet = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2012">		final Map&lt;String, MetaClass&gt; infoOfRegisteredClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2013">		final Set&lt;String&gt; createdClasses = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2014">		final Map&lt;NamespaceID, Namespace&gt; namespaceInfos = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L2016" title="All 2 branches missed.">		for (final MetaClass curMetaClass : metaClasses.values()) {</span>

<span class="nc" id="L2018">			final String namespace = curMetaClass.getNamespace();</span>
<span class="nc" id="L2019">			final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L2020">			final Namespace namespaceInfo = namespaceMgrApi.getNamespaceInfo(namespaceID);</span>
			// TODO: Check namespace responsible or imports
<span class="nc" id="L2022">			namespaceInfos.put(namespaceID, namespaceInfo);</span>
<span class="nc" id="L2023">		}</span>

<span class="nc bnc" id="L2025" title="All 2 branches missed.">		if (enrichmentNamespaceID != null) {</span>
<span class="nc" id="L2026">			final Namespace namespaceInfo = checkNamespaceResponsible(accountID, credentials, enrichmentNamespaceID);</span>
<span class="nc" id="L2027">			namespaceInfos.put(enrichmentNamespaceID, namespaceInfo);</span>
		}

		// ===================================================== //
		// ====== CHECK CLASSES THAT EXISTS AND SET IDS ======== //
		// ===================================================== //

<span class="nc" id="L2034">		final Set&lt;MetaClass&gt; metaClassesToInstall = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">		for (final MetaClass curMetaClass : metaClasses.values()) {</span>
<span class="nc" id="L2036">			final String namespace = curMetaClass.getNamespace();</span>
<span class="nc" id="L2037">			final String signature = Reflector.getSignatureFromTypeName(curMetaClass.getName());</span>
<span class="nc" id="L2038">			final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L2039">			MetaClassID classID = null;</span>

<span class="nc" id="L2041">			final UserType uType = new UserType(namespace, curMetaClass.getName(), signature, signature, null);</span>
<span class="nc" id="L2042">			final boolean typeExists = checkTypeIsRegistered(accountID, credentials, uType);</span>

<span class="nc bnc" id="L2044" title="All 4 branches missed.">			if (enrichedClassName != null &amp;&amp; curMetaClass.getName().equals(enrichedClassName)) {</span>
				// =================== ENRICHMENT SET IDS ====================== //

				// GET IDS OF THE CLASS (in case it is accessed)
<span class="nc" id="L2048">				classID = classMgrApi.getMetaClassID(namespaceID, enrichedClassName);</span>
<span class="nc" id="L2049">				getIDsOfAlreadyRegisteredClass(accountID, credentials, namespaceID, curMetaClass, classIDsSet,</span>
						propIDsSet, implIDsSet, classID);

				// Set IDs
				// GENERATE IDS FOR PROPERTIES AND IMPLEMENTATIONS OF THE CLASS TO REGISTER
<span class="nc" id="L2054">				generateIDsToRegister(curMetaClass, propIDsSet, implIDsSet, namespaceInfos, classID, namespaceID,</span>
						accountID);
<span class="nc" id="L2056">				metaClassesToInstall.add(curMetaClass);</span>

<span class="nc bnc" id="L2058" title="All 2 branches missed.">			} else if (!typeExists) {</span>

				// =================== NEW CLASS ====================== //

				// Set ClassID
<span class="nc" id="L2063">				classID = new MetaClassID();</span>
<span class="nc" id="L2064">				curMetaClass.setDataClayID(classID);</span>
<span class="nc" id="L2065">				classIDsSet.put(curMetaClass.getNamespace() + &quot;$&quot; + curMetaClass.getName(), classID);</span>
				// GENERATE IDS FOR PROPERTIES AND IMPLEMENTATIONS OF THE CLASS TO REGISTER
<span class="nc" id="L2067">				generateIDsToRegister(curMetaClass, propIDsSet, implIDsSet, namespaceInfos, classID, namespaceID,</span>
						accountID);
<span class="nc" id="L2069">				metaClassesToInstall.add(curMetaClass);</span>

			} else {
				// =================== ALREADY EXISTANT CLASS GET IDS ====================== //

				// GET IDS OF THE CLASS (in case it is accessed)
<span class="nc" id="L2075">				classID = classMgrApi.getMetaClassID(namespaceID, curMetaClass.getName());</span>
<span class="nc" id="L2076">				getIDsOfAlreadyRegisteredClass(accountID, credentials, namespaceID, curMetaClass, classIDsSet,</span>
						propIDsSet, implIDsSet, classID);
			}
<span class="nc" id="L2079">		}</span>

<span class="nc bnc" id="L2081" title="All 2 branches missed.">		for (final MetaClass curMetaClass : metaClassesToInstall) {</span>
			// Set ClassID of all associated metaclass
			// Also set PropertyIDs and ImplementationIDs for accessed props and impls
<span class="nc" id="L2084">			setIDs(accountID, credentials, curMetaClass, classIDsSet, propIDsSet, implIDsSet, language);</span>
<span class="nc" id="L2085">		}</span>

<span class="nc bnc" id="L2087" title="All 2 branches missed.">		for (final MetaClass curMetaClass : metaClassesToInstall) {</span>
<span class="nc" id="L2088">			final NamespaceID namespaceID = curMetaClass.getNamespaceID();</span>
			// Update with classIDs dependencies
<span class="nc" id="L2090">			updateDependencies(curMetaClass, classIDsSet, propIDsSet, implIDsSet, language);</span>
<span class="nc bnc" id="L2091" title="All 4 branches missed.">			if (enrichedClassName == null</span>
<span class="nc bnc" id="L2092" title="All 2 branches missed.">					|| (enrichedClassName != null &amp;&amp; !curMetaClass.getName().equals(enrichedClassName))) {</span>

				// Register class
<span class="nc" id="L2095">				final MetaClass curInfo = newClassInternal(accountID, credentials, namespaceID, curMetaClass,</span>
<span class="nc" id="L2096">						namespaceInfos.get(namespaceID), language);</span>
<span class="nc" id="L2097">				infoOfRegisteredClasses.put(curInfo.getName(), curInfo);</span>
<span class="nc" id="L2098">				createdClasses.add(curInfo.getName());</span>
			}
<span class="nc" id="L2100">		}</span>

<span class="nc bnc" id="L2102" title="All 2 branches missed.">		if (createdClasses.size() &gt; 0) {</span>
			// There are classes to deploy
<span class="nc bnc" id="L2104" title="All 2 branches missed.">			if (language == Langs.LANG_JAVA) {</span>
<span class="nc" id="L2105">				outsourceClassesDeploymentJava(metaClassesToInstall, createdClasses, namespaceInfos,</span>
						enrichmentNamespaceID, null);

				// outsourceClassesDeploymentPython(metaClassesToInstall, createdClasses,
				// namespaceInfos, enrichmentNamespaceID,
				// null);

<span class="nc bnc" id="L2112" title="All 2 branches missed.">			} else if (language == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L2113">				outsourceClassesDeploymentPython(metaClassesToInstall, createdClasses, namespaceInfos,</span>
						enrichmentNamespaceID, null);
				// @TODO: real cross-language in both directions
				// outsourceClassesDeploymentJava(languagelessMetaClassesToInstall,
				// createdClasses, namespaceInfos, enrichmentNamespaceID, null);
			} // else {
			// WARNING
			// IGNORE it: used for outsource of classes without language
			// throw new DataClayRuntimeException(ERRORCODE.CLASS_UNSUPPORTED_LANGUAGE,
			// &quot;The provided class' language is not supported for registration&quot;);
			// }
		}

		// ===================================================== //
		// ====== SET ECAS IDS ======== //
		// ===================================================== //
<span class="nc bnc" id="L2129" title="All 2 branches missed.">		if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc bnc" id="L2130" title="All 2 branches missed.">			for (final MetaClass curMetaClass : metaClassesToInstall) {</span>
<span class="nc" id="L2131">				final List&lt;ECA&gt; ecas = curMetaClass.getEcas();</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">				if (ecas == null) {</span>
<span class="nc" id="L2133">					continue;</span>
				}
<span class="nc bnc" id="L2135" title="All 2 branches missed.">				for (final ECA eca : ecas) {</span>
<span class="nc" id="L2136">					final EventType evType = eca.getEventType();</span>

					// Initialize IDs
<span class="nc" id="L2139">					evType.init(accountID, credentials, curMetaClass.getNamespace(), this);</span>

					// Set operationIDs of filter and action
<span class="nc bnc" id="L2142" title="All 2 branches missed.">					if (eca.getFilterMethodSignature() != null) {</span>
<span class="nc" id="L2143">						final OperationID filterOpID = classMgrApi.getOperationID(curMetaClass.getDataClayID(),</span>
<span class="nc" id="L2144">								eca.getFilterMethodSignature());</span>
<span class="nc" id="L2145">						eca.setFilterMethod(filterOpID);</span>
					}

<span class="nc bnc" id="L2148" title="All 2 branches missed.">					if (eca.getActionSignature() == null) {</span>
<span class="nc" id="L2149">						throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
								&quot;ECA action signature cannot be null&quot;, false);
					}

<span class="nc" id="L2153">					final OperationID actionOpID = classMgrApi.getOperationID(curMetaClass.getDataClayID(),</span>
<span class="nc" id="L2154">							eca.getActionSignature());</span>
<span class="nc" id="L2155">					eca.setAction(actionOpID);</span>

					// Set target class: the same used in new class
<span class="nc" id="L2158">					eca.setTargetClass(curMetaClass.getDataClayID());</span>

					// Now Register ECA
<span class="nc" id="L2161">					this.registerEventListenerImplementation(accountID, credentials, eca);</span>

<span class="nc" id="L2163">				}</span>
<span class="nc" id="L2164">			}</span>
		}

		/******** RT: Store Prefetching Info ********/
<span class="nc" id="L2168">		return infoOfRegisteredClasses;</span>
	}

	/**
	 * Generate IDs of properties, implementations, namespaces to register
	 * 
	 * @param curMetaClass
	 *            MetaClass to process
	 * @param propIDsSet
	 *            Currently set PropertyIDs (for enrichments)
	 * @param implIDsSet
	 *            Currently set ImplementationIDs (for enrichments)
	 * @param namespaceInfos
	 *            Information of namespaces of the classes to install
	 * @param classID
	 *            ID of the class to set
	 * @param namespaceID
	 *            ID of the namespace to set
	 * @param accountID
	 *            ID of the account
	 */
	private void generateIDsToRegister(final MetaClass curMetaClass, final Map&lt;String, PropertyID&gt; propIDsSet,
			final Map&lt;String, ImplementationID&gt; implIDsSet, final Map&lt;NamespaceID, Namespace&gt; namespaceInfos,
			final MetaClassID classID, final NamespaceID namespaceID, final AccountID accountID) {
<span class="nc bnc" id="L2192" title="All 2 branches missed.">		for (final Property property : curMetaClass.getProperties()) {</span>

<span class="nc" id="L2194">			final String propNamespace = property.getNamespace();</span>
<span class="nc" id="L2195">			final NamespaceID propNamespaceID = namespaceMgrApi.getNamespaceID(propNamespace);</span>
<span class="nc" id="L2196">			property.setNamespaceID(propNamespaceID);</span>
<span class="nc" id="L2197">			property.setMetaClassID(classID);</span>
<span class="nc" id="L2198">			property.setDataClayID(new PropertyID());</span>

<span class="nc" id="L2200">			final String key = propNamespace + &quot;$&quot; + curMetaClass.getName() + &quot;$&quot; + property.getName();</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">			if (!propIDsSet.containsKey(key)) {</span>
				// For accessed props
<span class="nc" id="L2203">				propIDsSet.put(key, property.getDataClayID());</span>
			}

<span class="nc" id="L2206">		}</span>
<span class="nc bnc" id="L2207" title="All 2 branches missed.">		for (final Operation operation : curMetaClass.getOperations()) {</span>
			// Set IDs
<span class="nc" id="L2209">			operation.setDataClayID(new OperationID());</span>
<span class="nc" id="L2210">			final String opNamespace = operation.getNamespace();</span>
<span class="nc" id="L2211">			final NamespaceID opNamespaceID = namespaceMgrApi.getNamespaceID(opNamespace);</span>
<span class="nc" id="L2212">			operation.setNamespaceID(opNamespaceID);</span>

<span class="nc bnc" id="L2214" title="All 2 branches missed.">			for (final Implementation implementation : operation.getImplementations()) {</span>

<span class="nc" id="L2216">				final String implNamespace = implementation.getNamespace();</span>
<span class="nc" id="L2217">				final NamespaceID implNamespaceID = namespaceMgrApi.getNamespaceID(implNamespace);</span>
<span class="nc" id="L2218">				implementation.setNamespaceID(implNamespaceID);</span>
<span class="nc" id="L2219">				implementation.setDataClayID(new ImplementationID());</span>
<span class="nc" id="L2220">				implementation.setOperationID(operation.getDataClayID());</span>
<span class="nc" id="L2221">				implementation.setResponsibleAccountID(accountID);</span>
<span class="nc" id="L2222">				implementation.setMetaClassID(classID);</span>
<span class="nc" id="L2223">				final String key = implementation.getNamespace() + &quot;$&quot; + implementation.getClassName() + &quot;$&quot;</span>
<span class="nc" id="L2224">						+ implementation.getOpNameAndDescriptor() + &quot;$&quot; + implementation.getPosition();</span>
<span class="nc bnc" id="L2225" title="All 2 branches missed.">				if (!implIDsSet.containsKey(key)) {</span>
					// For accessed impls
<span class="nc" id="L2227">					implIDsSet.put(key, implementation.getDataClayID());</span>
				}

<span class="nc" id="L2230">			}</span>
<span class="nc" id="L2231">			operation.setMetaClassID(classID);</span>
<span class="nc" id="L2232">		}</span>
<span class="nc" id="L2233">		curMetaClass.setNamespaceID(namespaceID);</span>
<span class="nc" id="L2234">		curMetaClass.setNamespace(namespaceInfos.get(namespaceID).getName());</span>
<span class="nc" id="L2235">	}</span>

	/**
	 * Set the Class IDs of all included types to register recursively
	 * 
	 * @param accountID
	 *            ID of the account of the user that calls the operation
	 * @param credentials
	 *            Credentials of the account provided
	 * @param metaClass
	 *            Current class spec
	 * @param classIDsSet
	 *            IDs of the classes
	 * @param propsIDsSet
	 *            Map of PropertyIDs by className + PropertyName. Used to set
	 *            accessed properties.
	 * @param implsIDsSet
	 *            Map of ImplementationIDs by className + opName. Used to set
	 *            accessed implementations.
	 * @param language
	 *            Language of the classes to register
	 * @throws RemoteException
	 *             if some exception occurs
	 */
	private void setIDs(final AccountID accountID, final PasswordCredential credentials, final MetaClass metaClass,
			final Map&lt;String, MetaClassID&gt; classIDsSet, final Map&lt;String, PropertyID&gt; propsIDsSet,
			final Map&lt;String, ImplementationID&gt; implsIDsSet, final Langs language) {

		// =================================== //
		// ==== GET ALREADY INSTALLED IDS ==== //
		// =================================== //

		// ================ GET IDS FOR CLASSES ASSOCIATED TO ATTRIBUTES =============
		// //
<span class="nc bnc" id="L2269" title="All 2 branches missed.">		for (final Property property : metaClass.getProperties()) {</span>
<span class="nc" id="L2270">			checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet, propsIDsSet,</span>
<span class="nc" id="L2271">					implsIDsSet, property.getType(), language);</span>

			// ================ PROPERTY INCLUDES TYPES ============= //
<span class="nc bnc" id="L2274" title="All 2 branches missed.">			if (property.getType().getIncludes() != null) {</span>
<span class="nc bnc" id="L2275" title="All 2 branches missed.">				for (final Type subincludeType : property.getType().getIncludes()) {</span>
<span class="nc bnc" id="L2276" title="All 2 branches missed.">					if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2277">						checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
								propsIDsSet, implsIDsSet, subincludeType, language);
					}
<span class="nc" id="L2280">				}</span>
			}

<span class="nc" id="L2283">		}</span>
		// ================ GET IDS FOR CLASSES ASSOCIATED TO METHODS ============= //
<span class="nc bnc" id="L2285" title="All 2 branches missed.">		for (final Operation operation : metaClass.getOperations()) {</span>

			// ================ RETURN TYPE ============= //
<span class="nc" id="L2288">			final Type returnType = operation.getReturnType();</span>
<span class="nc bnc" id="L2289" title="All 2 branches missed.">			if (returnType instanceof UserType) {</span>
<span class="nc" id="L2290">				checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet, propsIDsSet,</span>
						implsIDsSet, returnType, language);
			}
<span class="nc bnc" id="L2293" title="All 2 branches missed.">			if (returnType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2294" title="All 2 branches missed.">				for (final Type subincludeType : returnType.getIncludes()) {</span>
<span class="nc bnc" id="L2295" title="All 2 branches missed.">					if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2296">						checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
								propsIDsSet, implsIDsSet, subincludeType, language);
					}
<span class="nc" id="L2299">				}</span>
			}

			// ================ PARAMETER TYPES ============= //
<span class="nc bnc" id="L2303" title="All 2 branches missed.">			for (final Type paramType : operation.getParams().values()) {</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">				if (paramType instanceof UserType) {</span>
<span class="nc" id="L2305">					checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet, propsIDsSet,</span>
							implsIDsSet, paramType, language);
				}
<span class="nc bnc" id="L2308" title="All 2 branches missed.">				if (paramType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">					for (final Type subincludeType : paramType.getIncludes()) {</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">						if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2311">							checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
									propsIDsSet, implsIDsSet, subincludeType, language);
						}
<span class="nc" id="L2314">					}</span>
				}
<span class="nc" id="L2316">			}</span>

<span class="nc bnc" id="L2318" title="All 2 branches missed.">			for (final Implementation impl : operation.getImplementations()) {</span>
				// ================ IMPLEMENTATION INCLUDES TYPES ============= //
<span class="nc bnc" id="L2320" title="All 2 branches missed.">				for (final Type includeType : impl.getIncludes()) {</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">					if (includeType instanceof UserType) {</span>
<span class="nc" id="L2322">						checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
								propsIDsSet, implsIDsSet, includeType, language);
					}
<span class="nc bnc" id="L2325" title="All 2 branches missed.">					if (includeType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2326" title="All 2 branches missed.">						for (final Type subincludeType : includeType.getIncludes()) {</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">							if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2328">								checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
										propsIDsSet, implsIDsSet, subincludeType, language);
							}
<span class="nc" id="L2331">						}</span>
					}
<span class="nc" id="L2333">				}</span>

				// TODO: (LASTTODO) check accessed properties types
<span class="nc bnc" id="L2336" title="All 2 branches missed.">				for (final AccessedProperty accProperty : impl.getAccessedProperties()) {</span>
<span class="nc" id="L2337">					final String typeName = accProperty.getClassName();</span>
<span class="nc" id="L2338">					final String signature = Reflector.getSignatureFromTypeName(typeName);</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">					final boolean isUserType = !Reflector.isJavaPrimitiveOrArraySignature(signature);</span>
<span class="nc bnc" id="L2340" title="All 2 branches missed.">					if (isUserType) {</span>
<span class="nc" id="L2341">						final Type accType = new UserType(accProperty.getNamespace(), typeName, signature, signature,</span>
								null);
<span class="nc" id="L2343">						checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
								propsIDsSet, implsIDsSet, accType, language);
					}
<span class="nc" id="L2346">				}</span>

<span class="nc bnc" id="L2348" title="All 2 branches missed.">				for (final AccessedImplementation accImpl : impl.getAccessedImplementations()) {</span>
<span class="nc" id="L2349">					final String typeName = accImpl.getClassName();</span>
<span class="nc" id="L2350">					final String signature = Reflector.getSignatureFromTypeName(typeName);</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">					final boolean isUserType = !Reflector.isJavaPrimitiveOrArraySignature(signature);</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">					if (isUserType) {</span>
<span class="nc" id="L2353">						final Type accType = new UserType(accImpl.getNamespace(), typeName, signature, signature, null);</span>
						// JavaConstantSignature sig = new JavaConstantSignature(signature);
						// JavaTypeInfo jTypeInfo = new JavaTypeInfo(sig);
						// accType.addLanguageDepInfo(jTypeInfo);
<span class="nc" id="L2357">						checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet,</span>
								propsIDsSet, implsIDsSet, accType, language);
					}
<span class="nc" id="L2360">				}</span>

				// ==== PREFETCHING INFO === //
<span class="nc bnc" id="L2363" title="All 4 branches missed.">				if (impl.getPrefetchingInfo() != null &amp;&amp; impl.getPrefetchingInfo().getInjectPrefetchingCall()) {</span>
<span class="nc" id="L2364">					final String typeName = impl.getClassName();</span>
<span class="nc" id="L2365">					final String signature = Reflector.getSignatureFromTypeName(typeName);</span>
<span class="nc" id="L2366">					final Type accType = new UserType(impl.getNamespace(), typeName, signature, signature, null);</span>

<span class="nc" id="L2368">					checkClassIsAlreadyRegisteredAndGetID(accountID, credentials, metaClass, classIDsSet, propsIDsSet,</span>
							implsIDsSet, accType, language);

				}

<span class="nc" id="L2373">			}</span>
<span class="nc" id="L2374">		}</span>

<span class="nc" id="L2376">	}</span>

	/**
	 * Recursively get the IDs of an already registered class (operationIDs,
	 * propertyIDs, ...)
	 * 
	 * @param accountID
	 *            ID of the account registering the class that imports this class
	 * @param credentials
	 *            Credentials fo the account
	 * @param namespaceID
	 *            ID of the namespace in which the class is being registered
	 * @param metaClass
	 *            s of the class to register
	 * @param classIDsSet
	 *            Structure of imported class ids
	 * @param propsIDsSet
	 *            IDs of properties
	 * @param implsIDsSet
	 *            IDs of implementations
	 * @param classID
	 *            ID of the already registered class
	 * @throws RemoteException
	 *             if some exception occurs
	 */
	private void getIDsOfAlreadyRegisteredClass(final AccountID accountID, final PasswordCredential credentials,
			final NamespaceID namespaceID, final MetaClass metaClass, final Map&lt;String, MetaClassID&gt; classIDsSet,
			final Map&lt;String, PropertyID&gt; propsIDsSet, final Map&lt;String, ImplementationID&gt; implsIDsSet,
			final MetaClassID classID) {
		// If already processed
<span class="nc bnc" id="L2406" title="All 2 branches missed.">		if (classIDsSet.containsValue(classID)) {</span>
<span class="nc" id="L2407">			return;</span>
		}
		// Get PropertyIDs and ImplementationIDs
<span class="nc" id="L2410">		final MetaClass classInfo = classMgrApi.getClassInfo(classID);</span>
<span class="nc" id="L2411">		final String className = classInfo.getName();</span>

		// Modify the ID
<span class="nc" id="L2414">		classIDsSet.put(classInfo.getNamespace() + &quot;$&quot; + className, classID);</span>

		// Get ImplementationIDs
<span class="nc bnc" id="L2417" title="All 2 branches missed.">		for (final Operation opInfo : classInfo.getOperations()) {</span>
<span class="nc bnc" id="L2418" title="All 2 branches missed.">			for (final Implementation implInfo : opInfo.getImplementations()) {</span>
<span class="nc" id="L2419">				implsIDsSet.put(</span>
<span class="nc" id="L2420">						implInfo.getNamespace() + &quot;$&quot; + implInfo.getClassName() + &quot;$&quot;</span>
<span class="nc" id="L2421">								+ implInfo.getOpNameAndDescriptor() + &quot;$&quot; + implInfo.getPosition(),</span>
<span class="nc" id="L2422">								implInfo.getDataClayID());</span>
<span class="nc" id="L2423">			}</span>
<span class="nc" id="L2424">		}</span>
		// Get PropertyIDs
<span class="nc bnc" id="L2426" title="All 2 branches missed.">		for (final Property propInfo : classInfo.getProperties()) {</span>
<span class="nc" id="L2427">			propsIDsSet.put(propInfo.getNamespace() + &quot;$&quot; + propInfo.getClassName() + &quot;$&quot; + propInfo.getName(),</span>
<span class="nc" id="L2428">					propInfo.getDataClayID());</span>

<span class="nc" id="L2430">			final MetaClassID propclassID = classMgrApi.getClassIDFromProperty(propInfo.getDataClayID());</span>
			// If classID is null it is not a user type property
<span class="nc bnc" id="L2432" title="All 2 branches missed.">			if (propclassID != null) {</span>
				// If not already checked
<span class="nc" id="L2434">				getIDsOfAlreadyRegisteredClass(accountID, credentials, namespaceID, metaClass, classIDsSet, propsIDsSet,</span>
						implsIDsSet, propclassID);

			}
<span class="nc" id="L2438">		}</span>
<span class="nc" id="L2439">	}</span>

	/**
	 * Check if specification provided is an already registered class and in case it
	 * is, get the IDs (operationIDs, propertyIDs, ...)
	 * 
	 * @param accountID
	 *            ID of the account registering the class that imports this class
	 * @param credentials
	 *            Credentials fo the account
	 * @param metaClass
	 *            s of the class to register
	 * @param classIDsSet
	 *            Structure of imported class ids
	 * @param propsIDsSet
	 *            IDs of properties
	 * @param implsIDsSet
	 *            IDs of implementations
	 * @param type
	 *            ification of the already registered class
	 * @param language
	 *            Language of the new classes
	 * @throws RemoteException
	 *             if some exception occurs
	 */
	private void checkClassIsAlreadyRegisteredAndGetID(final AccountID accountID, final PasswordCredential credentials,
			final MetaClass metaClass, final Map&lt;String, MetaClassID&gt; classIDsSet,
			final Map&lt;String, PropertyID&gt; propsIDsSet, final Map&lt;String, ImplementationID&gt; implsIDsSet, final Type type,
			final Langs language) {
		// If type specification already contains Class ID, do not check.
<span class="nc bnc" id="L2469" title="All 2 branches missed.">		if (type instanceof UserType) {</span>
<span class="nc" id="L2470">			final UserType uType = (UserType) type;</span>
<span class="nc bnc" id="L2471" title="All 2 branches missed.">			if (uType.getClassID() != null) {</span>
<span class="nc" id="L2472">				return;</span>
			}
<span class="nc" id="L2474">			final boolean typeExists = checkTypeIsRegistered(accountID, credentials, uType);</span>
			// CHECKSTYLE:ON
<span class="nc bnc" id="L2476" title="All 2 branches missed.">			if (typeExists) {</span>
				// GET IDS OF THE CLASS (in case it is accessed)
<span class="nc bnc" id="L2478" title="All 2 branches missed.">				if (type instanceof UserType) {</span>
<span class="nc" id="L2479">					final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(uType.getNamespace());</span>
<span class="nc" id="L2480">					MetaClassID classID = classMgrApi.getMetaClassID(namespaceID, uType.getTypeName());</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">					if (classID == null) {</span>
						// if class manager cannot obtain the class id in namespaceID check imports
<span class="nc" id="L2483">						final Set&lt;ImportedInterface&gt; importedInterfaces = namespaceMgrApi</span>
<span class="nc" id="L2484">								.getImportedInterfaces(namespaceID, uType.getTypeName());</span>
<span class="nc" id="L2485">						classID = importedInterfaces.iterator().next().getClassOfImportID();</span>
					}

<span class="nc" id="L2488">					getIDsOfAlreadyRegisteredClass(accountID, credentials, namespaceID, metaClass, classIDsSet,</span>
							propsIDsSet, implsIDsSet, classID);
<span class="nc" id="L2490">				}</span>
			} else {
<span class="nc" id="L2492">				LOGGER.trace(&quot;Class {} is not registered&quot;, type.getTypeName());</span>
<span class="nc" id="L2493">				return;</span>
			}
		}
<span class="nc" id="L2496">	}</span>

	/**
	 * Method that updates the dependencies of types with the corresponding classIDs
	 * 
	 * @param metaClass
	 *            the spec to be updated
	 * @param newClassIDs
	 *            the IDs to be used
	 * @param propsIDsSet
	 *            Map of PropertyIDs by className + PropertyName. Used to set
	 *            accessed properties.
	 * @param implsIDsSet
	 *            Map of ImplementationIDs by className + opName. Used to set
	 *            accessed implementations.
	 * @param language
	 *            Language of the class
	 */
	private void updateDependencies(final MetaClass metaClass, final Map&lt;String, MetaClassID&gt; newClassIDs,
			final Map&lt;String, PropertyID&gt; propsIDsSet, final Map&lt;String, ImplementationID&gt; implsIDsSet,
			final Langs language) {

		// Update properties
<span class="nc bnc" id="L2519" title="All 2 branches missed.">		for (final Property property : metaClass.getProperties()) {</span>
<span class="nc" id="L2520">			final Type propertyType = property.getType();</span>
<span class="nc bnc" id="L2521" title="All 2 branches missed.">			if (propertyType instanceof UserType) {</span>
<span class="nc" id="L2522">				final UserType uType = (UserType) propertyType;</span>
<span class="nc bnc" id="L2523" title="All 2 branches missed.">				if (uType.getClassID() == null) {</span>
<span class="nc" id="L2524">					final String typename = uType.getTypeName();</span>
<span class="nc" id="L2525">					final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2526" title="All 2 branches missed.">					if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2527">						LOGGER.error(&quot;Unable to find property type {}${} in class ids structure&quot;, typenamespace,</span>
								typename);
					}
<span class="nc" id="L2530">					uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
				}
			}

<span class="nc bnc" id="L2534" title="All 2 branches missed.">			if (propertyType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">				for (final Type includeType : propertyType.getIncludes()) {</span>
<span class="nc bnc" id="L2536" title="All 2 branches missed.">					if (includeType instanceof UserType) {</span>
<span class="nc" id="L2537">						final UserType uType = (UserType) includeType;</span>
<span class="nc bnc" id="L2538" title="All 2 branches missed.">						if (uType.getClassID() == null) {</span>
<span class="nc" id="L2539">							final String typename = uType.getTypeName();</span>
<span class="nc" id="L2540">							final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">							if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2542">								LOGGER.error(&quot;Unable to find property includes type {}${} in class ids structure&quot;,</span>
										typenamespace, typename);
							}
<span class="nc" id="L2545">							uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
						}
					}
<span class="nc" id="L2548">				}</span>
			}
<span class="nc" id="L2550">		}</span>

		// Update operations
<span class="nc bnc" id="L2553" title="All 2 branches missed.">		for (final Operation operation : metaClass.getOperations()) {</span>
<span class="nc" id="L2554">			final Type returnType = operation.getReturnType();</span>
<span class="nc bnc" id="L2555" title="All 2 branches missed.">			if (returnType instanceof UserType) {</span>
<span class="nc" id="L2556">				final UserType uType = (UserType) returnType;</span>

<span class="nc bnc" id="L2558" title="All 2 branches missed.">				if (uType.getClassID() == null) {</span>
<span class="nc" id="L2559">					final String typename = uType.getTypeName();</span>
<span class="nc" id="L2560">					final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2561" title="All 2 branches missed.">					if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2562">						LOGGER.error(&quot;Unable to find operation return type {}${} in class ids structure&quot;, typenamespace,</span>
								typename);
					}
<span class="nc" id="L2565">					uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
				}
			}
<span class="nc bnc" id="L2568" title="All 2 branches missed.">			if (returnType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2569" title="All 2 branches missed.">				for (final Type includeType : returnType.getIncludes()) {</span>
<span class="nc bnc" id="L2570" title="All 2 branches missed.">					if (includeType instanceof UserType) {</span>
<span class="nc" id="L2571">						final UserType uType = (UserType) includeType;</span>
<span class="nc bnc" id="L2572" title="All 2 branches missed.">						if (uType.getClassID() == null) {</span>
<span class="nc" id="L2573">							final String typename = uType.getTypeName();</span>
<span class="nc" id="L2574">							final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2575" title="All 2 branches missed.">							if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2576">								LOGGER.error(</span>
										&quot;Unable to found operation return include type {}${} in class ids structure&quot;,
										typenamespace, typename);
							}
<span class="nc" id="L2580">							uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
						}
					}
<span class="nc" id="L2583">				}</span>
			}

<span class="nc bnc" id="L2586" title="All 2 branches missed.">			for (final Type paramType : operation.getParams().values()) {</span>
<span class="nc bnc" id="L2587" title="All 2 branches missed.">				if (paramType instanceof UserType) {</span>
<span class="nc" id="L2588">					final UserType uType = (UserType) paramType;</span>
<span class="nc bnc" id="L2589" title="All 2 branches missed.">					if (uType.getClassID() == null) {</span>
<span class="nc" id="L2590">						final String typename = uType.getTypeName();</span>
<span class="nc" id="L2591">						final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2592" title="All 2 branches missed.">						if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2593">							LOGGER.error(&quot;Unable to found operation param type {}${} in class ids structure&quot;,</span>
									typenamespace, typename);
						}
<span class="nc" id="L2596">						uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
					}
				}
<span class="nc bnc" id="L2599" title="All 2 branches missed.">				if (paramType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2600" title="All 2 branches missed.">					for (final Type includeType : paramType.getIncludes()) {</span>
<span class="nc bnc" id="L2601" title="All 2 branches missed.">						if (includeType instanceof UserType) {</span>
<span class="nc" id="L2602">							final UserType uType = (UserType) includeType;</span>
<span class="nc bnc" id="L2603" title="All 2 branches missed.">							if (uType.getClassID() == null) {</span>
<span class="nc" id="L2604">								final String typename = uType.getTypeName();</span>
<span class="nc" id="L2605">								final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2606" title="All 2 branches missed.">								if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2607">									LOGGER.error(</span>
											&quot;Unable to found operation param include type {}${} in class ids structure&quot;,
											typenamespace, typename);
								}
<span class="nc" id="L2611">								uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
							}
						}
<span class="nc" id="L2614">					}</span>
				}
<span class="nc" id="L2616">			}</span>

			// Update implementations of current operation
<span class="nc bnc" id="L2619" title="All 2 branches missed.">			for (final Implementation impl : operation.getImplementations()) {</span>
<span class="nc bnc" id="L2620" title="All 2 branches missed.">				for (final Type includeType : impl.getIncludes()) {</span>
<span class="nc bnc" id="L2621" title="All 2 branches missed.">					if (includeType instanceof UserType) {</span>
<span class="nc" id="L2622">						final UserType uType = (UserType) includeType;</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">						if (uType.getClassID() == null) {</span>
<span class="nc" id="L2624">							final String typename = uType.getTypeName();</span>
<span class="nc" id="L2625">							final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2626" title="All 2 branches missed.">							if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2627">								LOGGER.error(&quot;Unable to found implementation include type {}${} in class ids structure&quot;,</span>
										typenamespace, typename);
							}
<span class="nc" id="L2630">							uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
						}
					}
<span class="nc bnc" id="L2633" title="All 2 branches missed.">					if (includeType.getIncludes() != null) {</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">						for (final Type subincludeType : includeType.getIncludes()) {</span>
<span class="nc bnc" id="L2635" title="All 2 branches missed.">							if (subincludeType instanceof UserType) {</span>
<span class="nc" id="L2636">								final UserType uType = (UserType) subincludeType;</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">								if (uType.getClassID() == null) {</span>
<span class="nc" id="L2638">									final String typename = uType.getTypeName();</span>
<span class="nc" id="L2639">									final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">									if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2641">										LOGGER.error(</span>
												&quot;Unable to found implementation subinclude type {}${} in class ids structure&quot;,
												typenamespace, typename);
									}
<span class="nc" id="L2645">									uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
								}
							}
<span class="nc" id="L2648">						}</span>
					}
<span class="nc" id="L2650">				}</span>

				// Update accessed properties
<span class="nc bnc" id="L2653" title="All 2 branches missed.">				for (final AccessedProperty accProperty : impl.getAccessedProperties()) {</span>
<span class="nc bnc" id="L2654" title="All 4 branches missed.">					if (accProperty.getPropertyID() == null &amp;&amp; accProperty.getPropertyID() == null) {</span>
<span class="nc" id="L2655">						final String propClassname = accProperty.getClassName();</span>
<span class="nc" id="L2656">						final String propNamespace = accProperty.getNamespace();</span>
<span class="nc" id="L2657">						final String propName = accProperty.getName();</span>

<span class="nc" id="L2659">						final PropertyID accPropertyID = propsIDsSet</span>
<span class="nc" id="L2660">								.get(propNamespace + &quot;$&quot; + propClassname + &quot;$&quot; + propName);</span>

<span class="nc bnc" id="L2662" title="All 2 branches missed.">						if (accPropertyID == null) {</span>
<span class="nc" id="L2663">							throw new DataClayRuntimeException(ERRORCODE.PROPERTY_NOT_EXIST,</span>
<span class="nc" id="L2664">									&quot;Property &quot; + accProperty.getName() + &quot; does not exist in registered class &quot;</span>
<span class="nc" id="L2665">											+ accProperty.getClassName() + &quot;. You might be registering a class that &quot;</span>
											+ &quot; imports another class which is already registered. &quot;,
											true);

						}
<span class="nc" id="L2670">						accProperty.setPropertyID(accPropertyID);</span>
					}
<span class="nc" id="L2672">				}</span>

				// Update accessed implementations
<span class="nc bnc" id="L2675" title="All 2 branches missed.">				for (final AccessedImplementation accImpl : impl.getAccessedImplementations()) {</span>
<span class="nc bnc" id="L2676" title="All 4 branches missed.">					if (accImpl.getImplementationID() == null &amp;&amp; accImpl.getImplementationID() == null) {</span>
<span class="nc" id="L2677">						final String implClassname = accImpl.getClassName();</span>
<span class="nc" id="L2678">						final String implNamespace = accImpl.getNamespace();</span>
<span class="nc" id="L2679">						final String implOpSignature = accImpl.getOpSignature();</span>
<span class="nc" id="L2680">						final int implementationPos = accImpl.getImplPosition();</span>
<span class="nc" id="L2681">						final ImplementationID accImplID = implsIDsSet.get(</span>
								implNamespace + &quot;$&quot; + implClassname + &quot;$&quot; + implOpSignature + &quot;$&quot; + implementationPos);
<span class="nc bnc" id="L2683" title="All 2 branches missed.">						if (accImplID == null) {</span>
<span class="nc" id="L2684">							throw new DataClayRuntimeException(ERRORCODE.OPERATION_NOT_EXIST,</span>
<span class="nc" id="L2685">									&quot;Operation &quot; + accImpl.getOpSignature() + &quot; does not exist in registered class &quot;</span>
<span class="nc" id="L2686">											+ accImpl.getClassName() + &quot;. You might be registering a class that &quot;</span>
											+ &quot; imports another class which is already registered. &quot;,
											true);
						}
<span class="nc" id="L2690">						accImpl.setImplementationID(accImplID);</span>
					}
<span class="nc" id="L2692">				}</span>

				// Update prefetching info
<span class="nc bnc" id="L2695" title="All 4 branches missed.">				if (impl.getPrefetchingInfo() != null &amp;&amp; impl.getPrefetchingInfo().getInjectPrefetchingCall()) {</span>
<span class="nc" id="L2696">					final PrefetchingInformation pfInfo = impl.getPrefetchingInfo();</span>
<span class="nc" id="L2697">					final String implClassname = pfInfo.getPrefetchingClassName();</span>
<span class="nc" id="L2698">					final String implNamespace = pfInfo.getPrefetchingNameSpace();</span>
<span class="nc" id="L2699">					final String implOpSignature = pfInfo.getPrefetchingMethodSignature();</span>
<span class="nc" id="L2700">					final int implementationPos = 0;</span>
<span class="nc" id="L2701">					final ImplementationID accImplID = implsIDsSet</span>
<span class="nc" id="L2702">							.get(implNamespace + &quot;$&quot; + implClassname + &quot;$&quot; + implOpSignature + &quot;$&quot; + implementationPos);</span>
<span class="nc bnc" id="L2703" title="All 2 branches missed.">					if (accImplID == null) {</span>
<span class="nc" id="L2704">						throw new DataClayRuntimeException(ERRORCODE.OPERATION_NOT_EXIST,</span>
<span class="nc" id="L2705">								&quot;Operation &quot; + pfInfo.getPrefetchingMethodSignature()</span>
<span class="nc" id="L2706">								+ &quot; does not exist in registered class &quot; + pfInfo.getPrefetchingClassName()</span>
								+ &quot;. You might be registering a class that &quot;
								+ &quot; imports another class which is already registered. &quot;,
								true);
					}
<span class="nc" id="L2711">					pfInfo.setPrefetchingImplementationID(accImplID);</span>
<span class="nc" id="L2712">					pfInfo.setPrefetchingClassID(newClassIDs.get(implNamespace + &quot;$&quot; + implClassname));</span>
				}

<span class="nc" id="L2715">			}</span>
<span class="nc" id="L2716">		}</span>

<span class="nc bnc" id="L2718" title="All 2 branches missed.">		if (metaClass.getJavaClassInfo() != null) { </span>
<span class="nc bnc" id="L2719" title="All 2 branches missed.">			for (final Type ifaceInclude : metaClass.getJavaClassInfo().getIncludes()) {  </span>
<span class="nc bnc" id="L2720" title="All 2 branches missed.">				if (ifaceInclude instanceof UserType) {</span>
<span class="nc" id="L2721">					final UserType uType = (UserType) ifaceInclude;</span>
<span class="nc bnc" id="L2722" title="All 2 branches missed.">					if (uType.getClassID() == null) {</span>
<span class="nc" id="L2723">						final String typename = uType.getTypeName();</span>
<span class="nc" id="L2724">						final String typenamespace = uType.getNamespace();</span>
<span class="nc bnc" id="L2725" title="All 2 branches missed.">						if (newClassIDs.get(typenamespace + &quot;$&quot; + typename) == null) {</span>
<span class="nc" id="L2726">							LOGGER.error(</span>
									&quot;Unable to found implementation subinclude type {}${} in class ids structure&quot;,
									typenamespace, typename);
						}
<span class="nc" id="L2730">						uType.setClassID(newClassIDs.get(typenamespace + &quot;$&quot; + typename));</span>
					}
				}
<span class="nc" id="L2733">			}</span>
		}
		
		
		// Update parent
<span class="nc" id="L2738">		final UserType parentType = metaClass.getParentType();</span>
<span class="nc bnc" id="L2739" title="All 2 branches missed.">		if (parentType != null) {</span>
			// We get the name without parsing since parent are not
			// signature
<span class="nc" id="L2742">			final MetaClassID m = newClassIDs.get(parentType.getNamespace() + &quot;$&quot; + parentType.getTypeName());</span>
<span class="nc" id="L2743">			parentType.setClassID(m);</span>
		}
<span class="nc" id="L2745">	}</span>

	/**
	 * Creates a new metaclass in the system with the provided specifications and
	 * associates it to the Namespace provided.
	 * 
	 * @param accountID
	 *            ID of the account of the user that calls the operation
	 * @param credential
	 *            Credential of the account provided
	 * @param namespaceID
	 *            id of the namespace in which to create the metaclass
	 * @param namespaceInfo
	 *            Information of namespace
	 * @param newClass
	 *            New class specifications
	 * @param language
	 *            Language of the new class
	 * @return info of the new MetaClass if it was successfully created.
	 */
	private MetaClass newClassInternal(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final MetaClass newClass, final Namespace namespaceInfo,
			final Langs language) {

		// Check language of namespace
<span class="nc bnc" id="L2770" title="All 2 branches missed.">		if (namespaceInfo.getLanguage() != language) {</span>
<span class="nc" id="L2771">			throw new DataClayRuntimeException(ERRORCODE.INCOMPATIBLE_LANGUAGE_FOR_CLASS_WITH_NAMESPACE);</span>
		}

		// Register class in class manager
<span class="nc" id="L2775">		final MetaClass newClassInfo = classMgrApi.newClass(accountID, namespaceID, namespaceInfo.getName(), newClass,</span>
				language);
<span class="nc" id="L2777">		return newClassInfo;</span>

	}

	@Override
	public void removeClass(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final String className) {
		// Check namespace responsible
<span class="nc" id="L2785">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

<span class="nc" id="L2787">		Set&lt;ImportedInterface&gt; importedInterfaces = null;</span>
		// Check the class is not in use and get the classID (checks the class belongs
		// to the namespace)
<span class="nc" id="L2790">		MetaClassID classID = classMgrApi.checkClassNotInIncludesAndGetID(className, namespaceID);</span>
<span class="nc bnc" id="L2791" title="All 2 branches missed.">		if (classID == null) {</span>
			// if class manager cannot obtain the class id in namespaceID look for imports
			// and check they are not used
<span class="nc" id="L2794">			importedInterfaces = namespaceMgrApi.checkImportsOfClassAreNotUsedAndGet(namespaceID, className);</span>
<span class="nc bnc" id="L2795" title="All 2 branches missed.">			if (importedInterfaces.isEmpty()) {</span>
<span class="nc" id="L2796">				throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_CREATED_IN_NAMESPACE_NOR_IMPORTED);</span>
			}
<span class="nc" id="L2798">			classID = importedInterfaces.iterator().next().getClassOfImportID();</span>
		}

		// Check there is no interface of the class related with a contract
<span class="nc" id="L2802">		final Set&lt;InterfaceID&gt; interfacesIDs = interfaceMgrApi.getInterfacesOfClass(namespaceID, classID);</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">		for (final InterfaceID interfaceID : interfacesIDs) {</span>
<span class="nc bnc" id="L2804" title="All 2 branches missed.">			if (!contractMgrApi.checkInterfaceHasNoContracts(interfaceID)) {</span>
<span class="nc" id="L2805">				throw new DataClayRuntimeException(ERRORCODE.INTERFACE_WITH_CONTRACTS);</span>
			}
<span class="nc" id="L2807">		}</span>

		// Remove the interfaces of the class
<span class="nc bnc" id="L2810" title="All 2 branches missed.">		for (final InterfaceID interfaceID : interfacesIDs) {</span>
<span class="nc" id="L2811">			interfaceMgrApi.removeInterface(namespaceID, interfaceID);</span>
<span class="nc" id="L2812">		}</span>

<span class="nc bnc" id="L2814" title="All 2 branches missed.">		if (importedInterfaces == null) {</span>
			// Remove the class
<span class="nc" id="L2816">			classMgrApi.removeClass(classID);</span>
		} else {
			// Remote imports
<span class="nc" id="L2819">			namespaceMgrApi.removeImportedInterfaces(namespaceID, importedInterfaces);</span>
		}

		// Unregister associations with the imports it used if any
<span class="nc" id="L2823">		final HashSet&lt;MetaClassID&gt; metaClassesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2824">		metaClassesIDs.add(classID);</span>
<span class="nc" id="L2825">		namespaceMgrApi.unregisterSubClassesFromUsingAnyImportedClassInNamespace(namespaceID, metaClassesIDs);</span>

<span class="nc" id="L2827">	}</span>

	@Override
	public void removeOperation(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final String className, final String operationSignature) {
		// Check namespace responsible
<span class="nc" id="L2833">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

		// Get metaClassID either because it is created in namespace or imported in it
<span class="nc" id="L2836">		final MetaClassID classID = getMetaClassID(namespaceID, className);</span>

		// Get the operationID (checks the operation belongs to the class)
<span class="nc" id="L2839">		final OperationID operationID = classMgrApi.getOperationID(classID, operationSignature);</span>

		// Check there is no implementation accessing the operation
<span class="nc bnc" id="L2842" title="All 2 branches missed.">		if (classMgrApi.existsImplementationAccessingOperation(operationID)) {</span>
<span class="nc" id="L2843">			throw new DataClayRuntimeException(ERRORCODE.SOME_IMPLEMENTATIONS_ACCESS_OPERATION);</span>
		}

		// Check there is no interface related with the operation
<span class="nc" id="L2847">		final Set&lt;InterfaceID&gt; interfacesIDs = interfaceMgrApi.getInterfacesAccessingOperation(namespaceID, classID,</span>
				operationID);
<span class="nc bnc" id="L2849" title="All 2 branches missed.">		if (!interfacesIDs.isEmpty()) {</span>
<span class="nc" id="L2850">			throw new DataClayRuntimeException(ERRORCODE.OPERATION_ALREADY_IN_INTERFACE);</span>
		}

		// Remove the operation
<span class="nc" id="L2854">		final Operation opInfo = classMgrApi.removeOperation(operationID);</span>

		// Unregister associations with the imports it used
		// TODO Do this in a single op (24 Jul 2013 jmarti)
<span class="nc" id="L2858">		final HashSet&lt;OperationID&gt; operationsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2859">		operationsIDs.add(operationID);</span>
<span class="nc" id="L2860">		namespaceMgrApi.unregisterOperationsFromUsingAnyImportedClassInNamespace(namespaceID, operationsIDs);</span>

<span class="nc" id="L2862">		final HashSet&lt;ImplementationID&gt; implIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2863" title="All 2 branches missed.">		for (final Implementation impl : opInfo.getImplementations()) {</span>
<span class="nc" id="L2864">			implIDs.add(impl.getDataClayID());</span>
<span class="nc" id="L2865">		}</span>
<span class="nc" id="L2866">		namespaceMgrApi.unregisterImplementationsFromUsingAnyImportedClassInNamespace(namespaceID, implIDs);</span>

<span class="nc" id="L2868">	}</span>

	@Override
	public void removeImplementation(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final ImplementationID implementationID) {
		// Check namespace responsible
<span class="nc" id="L2874">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

		// Check the method is not related with contracts
<span class="nc bnc" id="L2877" title="All 2 branches missed.">		if (!contractMgrApi.checkImplementationHasNoContracts(implementationID)) {</span>
<span class="nc" id="L2878">			throw new DataClayRuntimeException(ERRORCODE.IMPL_ACCESSIBLE_FROM_CONTRACTS);</span>
		}

		// Remove the method
<span class="nc" id="L2882">		classMgrApi.removeImplementation(implementationID);</span>

		// Unregister associations with the imports it used
<span class="nc" id="L2885">		final HashSet&lt;ImplementationID&gt; implementationsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2886">		implementationsIDs.add(implementationID);</span>
<span class="nc" id="L2887">		namespaceMgrApi.unregisterImplementationsFromUsingAnyImportedClassInNamespace(namespaceID, implementationsIDs);</span>

<span class="nc" id="L2889">	}</span>

	@Override
	public OperationID getOperationID(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final String className, final String operationSignature) {
		// Check namespace responsible
<span class="nc" id="L2895">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

		// Get metaClassID either because it is created in namespace or imported in it
<span class="nc" id="L2898">		final MetaClassID classID = getMetaClassID(namespaceID, className);</span>

		// Get the operationID (checks the operation belongs to the class)
<span class="nc" id="L2901">		return classMgrApi.getOperationID(classID, operationSignature);</span>

	}

	@Override
	public PropertyID getPropertyID(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final String className, final String propertyName) {
		// Check namespace responsible
<span class="nc" id="L2909">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

		// Get metaClassID either because it is created in namespace or imported in it
<span class="nc" id="L2912">		final MetaClassID classID = getMetaClassID(namespaceID, className);</span>

		// Get the propertyID (checks the property belongs to the class)
<span class="nc" id="L2915">		return classMgrApi.getPropertyID(classID, propertyName);</span>

	}

	@Override
	public MetaClassID getClassID(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final String className) {
		// Check namespace responsible
<span class="nc" id="L2923">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

		// Get the classID (checks the class belongs to the namespace)
<span class="nc" id="L2926">		final MetaClassID classID = classMgrApi.getMetaClassID(namespaceID, className);</span>
<span class="nc bnc" id="L2927" title="All 2 branches missed.">		if (classID == null) {</span>
<span class="nc" id="L2928">			throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_EXIST);</span>
		} else {
<span class="nc" id="L2930">			return classID;</span>
		}

	}

	@Override
	public MetaClass getClassInfo(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final String className) {
<span class="nc" id="L2938">		final MetaClassID classID = classMgrApi.getMetaClassID(namespaceID, className);</span>
<span class="nc bnc" id="L2939" title="All 2 branches missed.">		if (classID == null) {</span>
<span class="nc" id="L2940">			throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_EXIST,</span>
<span class="nc" id="L2941">					&quot;Class &quot; + className + &quot; (at namespace: {&quot; + namespaceID.toString() + &quot;})&quot;, false);</span>
		} else {
<span class="nc" id="L2943">			return classMgrApi.getClassInfo(classID);</span>
		}
	}

	@Override
	public Map&lt;MetaClassID, MetaClass&gt; getInfoOfClassesInNamespace(final AccountID accountID,
			final PasswordCredential credential, final NamespaceID namespaceID) {
		try {
			// Check namespace responsible
<span class="nc" id="L2952">			checkNamespaceResponsible(accountID, credential, namespaceID);</span>

<span class="nc" id="L2954">			return classMgrApi.getInfoOfClassesInNamespace(namespaceID);</span>
<span class="nc" id="L2955">		} catch (final Exception ex) {</span>
<span class="nc" id="L2956">			LOGGER.debug(&quot;getInfoOfClassesInNamespace error&quot;, ex);</span>
<span class="nc" id="L2957">			throw ex;</span>
		}

	}



	/**
	 * Method that check if type with signature provided exists and set Class ID if
	 * needed.
	 * 
	 * @param accountID
	 *            the account ID just in case it is an import and we need to check
	 *            if it is registered to any of the corresponding contracts
	 * @param credential
	 *            the credential of the account
	 * @param userType
	 *            Type to check
	 * @return TRUE if type is already registered in DataClay.
	 */
	private boolean checkTypeIsRegistered(final AccountID accountID, final PasswordCredential credential,
			final UserType userType) {

<span class="nc" id="L2980">		final String typeName = userType.getTypeName();</span>
<span class="nc" id="L2981">		final String namespace = userType.getNamespace();</span>
<span class="nc" id="L2982">		final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
		// Get the metaClassID (checks the class belongs to the namespace)
<span class="nc" id="L2984">		final MetaClassID metaClassID = classMgrApi.getMetaClassID(namespaceID, typeName);</span>
<span class="nc bnc" id="L2985" title="All 2 branches missed.">		if (metaClassID != null) {</span>
<span class="nc" id="L2986">			return true;</span>
		} else {
			// if class manager cannot obtain the class id in namespaceID check imports
<span class="nc" id="L2989">			final Set&lt;ImportedInterface&gt; importedInterfaces = namespaceMgrApi.getImportedInterfaces(namespaceID,</span>
					typeName);
<span class="nc bnc" id="L2991" title="All 2 branches missed.">			if (!importedInterfaces.isEmpty()) {</span>
<span class="nc" id="L2992">				return true;</span>
			}
		}
<span class="nc" id="L2995">		return false;</span>

	}

	// ============== Contract Manager ==============//

	// TODO ROLLBACK IF IT FAILS (2 Jul 2013 jmarti)
	@Override
	public ContractID newContract(final AccountID accountID, final PasswordCredential credential,
			final Contract newContract) {

		try {
			// =========== CHECK AND FILL WITH IDS =========== //
			// Set IDs of accounts and namespaces (check it is properly specified)
			// Namespace
<span class="nc" id="L3010">			final String namespace = newContract.getNamespace();</span>
<span class="nc bnc" id="L3011" title="All 4 branches missed.">			if (namespace == null || namespace.isEmpty()) {</span>
<span class="nc" id="L3012">				throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
						&quot;Contract specification: Namespace cannot null or empty&quot;, false);
			}
<span class="nc" id="L3015">			final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L3016">			newContract.setNamespaceID(namespaceID);</span>
<span class="nc" id="L3017">			newContract.setProviderAccountID(accountID);</span>

			// Provider account ID
<span class="nc bnc" id="L3020" title="All 2 branches missed.">			if (newContract.getProviderAccountID() == null) {</span>
<span class="nc" id="L3021">				throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
						&quot;Contract specification: Provider account id cannot be null or empty&quot;, false);
			}

			// Interfaces in contract
<span class="nc" id="L3026">			final Map&lt;InterfaceID, InterfaceInContract&gt; ifacesWithIDs = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3027">			final List&lt;InterfaceInContract&gt; ifacesInContract = newContract.getInterfacesInContractSpecs();</span>
<span class="nc bnc" id="L3028" title="All 2 branches missed.">			for (final InterfaceInContract ifaceInContract : ifacesInContract) {</span>
				// Get interface IDs

<span class="nc" id="L3031">				final Interface ifaceSpec = ifaceInContract.getIface();</span>

				/**** rtouma ****/
				// Set provider account name if null
<span class="nc bnc" id="L3035" title="All 4 branches missed.">				if (ifaceSpec.getProviderAccountName() == null || ifaceSpec.getProviderAccountName().isEmpty()) {</span>
<span class="nc" id="L3036">					final AccountID providerID = ifaceSpec.getProviderAccountID();</span>
<span class="nc bnc" id="L3037" title="All 2 branches missed.">					if (providerID == null) {</span>
<span class="nc" id="L3038">						throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
								&quot;Contract specification: Provider account ID cannot be null or empty&quot;, false);
					}
<span class="nc" id="L3041">					final String providerName = accountMgrApi.getAccount(providerID).getUsername();</span>
<span class="nc" id="L3042">					ifaceSpec.setProviderAccountName(providerName);</span>
				}
				/****************/

<span class="nc" id="L3046">				final InterfaceID ifaceID = interfaceMgrApi.getInterfaceID(ifaceSpec.getProviderAccountName(),</span>
<span class="nc" id="L3047">						ifaceSpec.getNamespace(), ifaceSpec.getClassName(), ifaceSpec.getPropertiesInIface(),</span>
<span class="nc" id="L3048">						ifaceSpec.getOperationsSignatureInIface());</span>
<span class="nc" id="L3049">				final Interface iface = interfaceMgrApi.getInterfaceInfo(ifaceID);</span>
<span class="nc" id="L3050">				ifaceInContract.setInterfaceID(iface.getDataClayID());</span>

				// Set actual iface
<span class="nc" id="L3053">				ifaceInContract.setIface(iface);</span>
<span class="nc" id="L3054">				final MetaClassID classID = iface.getMetaClassID();</span>

				// OpImplementations
<span class="nc" id="L3057">				final Map&lt;OperationID, OpImplementations&gt; opImpls = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3058">				final Set&lt;OpImplementations&gt; implSpecOps = ifaceInContract.getImplementationsSpecPerOperation();</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">				for (final OpImplementations opImpl : implSpecOps) {</span>
<span class="nc" id="L3060">					final String opSignature = opImpl.getOperationSignature();</span>
<span class="nc" id="L3061">					final int numLocalImpl = opImpl.getNumLocalImpl();</span>
<span class="nc" id="L3062">					final int numRemoteImpl = opImpl.getNumRemoteImpl();</span>

<span class="nc" id="L3064">					final OperationID opID = classMgrApi.getOperationID(classID, opSignature);</span>
<span class="nc" id="L3065">					final Operation operation = classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L3066">					int curImpl = 0;</span>
<span class="nc bnc" id="L3067" title="All 2 branches missed.">					for (final Implementation impl : operation.getImplementations()) {</span>
<span class="nc bnc" id="L3068" title="All 2 branches missed.">						if (curImpl == numLocalImpl) {</span>
<span class="nc" id="L3069">							opImpl.setLocalImplementationID(impl.getDataClayID());</span>
						}
<span class="nc bnc" id="L3071" title="All 2 branches missed.">						if (curImpl == numRemoteImpl) {</span>
<span class="nc" id="L3072">							opImpl.setRemoteImplementationID(impl.getDataClayID());</span>
						}
<span class="nc bnc" id="L3074" title="All 4 branches missed.">						if (opImpl.getLocalImplementationID() != null &amp;&amp; opImpl.getRemoteImplementationID() != null) {</span>
<span class="nc" id="L3075">							break;</span>
						}
<span class="nc" id="L3077">						curImpl++;</span>
<span class="nc" id="L3078">					}</span>
<span class="nc" id="L3079">					opImpls.put(opID, opImpl);</span>

<span class="nc" id="L3081">				}</span>
<span class="nc" id="L3082">				ifaceInContract.setAccessibleImplementations(opImpls);</span>
<span class="nc" id="L3083">				ifacesWithIDs.put(ifaceID, ifaceInContract);</span>
<span class="nc" id="L3084">			}</span>
<span class="nc" id="L3085">			newContract.setInterfacesInContract(ifacesWithIDs);</span>
			// =========== =========== =========== =========== //

			// Validate proprietary and check it is the responsible of the namespace
<span class="nc" id="L3089">			final Namespace namespaceInfo = checkNamespaceResponsible(accountID, credential,</span>
<span class="nc" id="L3090">					newContract.getNamespaceID());</span>

			// Update contract with the implementations of the default getters and setters
<span class="nc bnc" id="L3093" title="All 2 branches missed.">			if (namespaceInfo.getLanguage() == Langs.LANG_JAVA) { // Getters/setters do not apply to Python codes</span>
				// (jcosta
				// 17/jun/2014)
<span class="nc" id="L3096">				final Map&lt;InterfaceID, Interface&gt; infoOfInterfaces = interfaceMgrApi</span>
<span class="nc" id="L3097">						.getInterfacesInfo(new HashSet&lt;&gt;(newContract.getInterfacesInContract().keySet()));</span>
<span class="nc" id="L3098">				final Map&lt;MetaClassID, Set&lt;PropertyID&gt;&gt; propertiesInInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L3099" title="All 2 branches missed.">				for (final Interface ifaceInfo : infoOfInterfaces.values()) {</span>
<span class="nc" id="L3100">					final MetaClassID curClassID = ifaceInfo.getMetaClassID();</span>
<span class="nc" id="L3101">					final Set&lt;PropertyID&gt; curPropsIDs = ifaceInfo.getPropertiesIDs();</span>
<span class="nc" id="L3102">					propertiesInInterfaces.put(curClassID, curPropsIDs);</span>
<span class="nc" id="L3103">				}</span>
<span class="nc" id="L3104">				final Map&lt;PropertyID, Map&lt;OperationID, ImplementationID&gt;&gt; implsOfGettersSetters = classMgrApi</span>
<span class="nc" id="L3105">						.getImplementationsOfGettersAndSetters(propertiesInInterfaces);</span>
<span class="nc bnc" id="L3106" title="All 2 branches missed.">				for (final Entry&lt;InterfaceID, InterfaceInContract&gt; ifaceInContract : newContract</span>
<span class="nc" id="L3107">						.getInterfacesInContract().entrySet()) {</span>
<span class="nc" id="L3108">					final InterfaceID curIfaceID = ifaceInContract.getKey();</span>
<span class="nc" id="L3109">					final Interface ifaceInfo = infoOfInterfaces.get(curIfaceID);</span>
<span class="nc" id="L3110">					final InterfaceInContract curIfaceInContract = ifaceInContract.getValue();</span>
<span class="nc bnc" id="L3111" title="All 2 branches missed.">					for (final PropertyID propertyInInterface : ifaceInfo.getPropertiesIDs()) {</span>
<span class="nc" id="L3112">						final Map&lt;OperationID, ImplementationID&gt; implsOfGetterSetter = implsOfGettersSetters</span>
<span class="nc" id="L3113">								.get(propertyInInterface);</span>
<span class="nc bnc" id="L3114" title="All 2 branches missed.">						for (final Entry&lt;OperationID, ImplementationID&gt; curImplOfGetterSetter : implsOfGetterSetter</span>
<span class="nc" id="L3115">								.entrySet()) {</span>
<span class="nc" id="L3116">							final OperationID opID = curImplOfGetterSetter.getKey();</span>
<span class="nc" id="L3117">							final Operation op = classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L3118">							final OpImplementations opImplementationGetterSetter = new OpImplementations(</span>
<span class="nc" id="L3119">									op.getNameAndDescriptor(), 0, 0);</span>
<span class="nc" id="L3120">							final ImplementationID implID = op.getImplementations().get(0).getDataClayID();</span>
<span class="nc" id="L3121">							opImplementationGetterSetter.setLocalImplementationID(implID);</span>
<span class="nc" id="L3122">							opImplementationGetterSetter.setRemoteImplementationID(implID);</span>
<span class="nc" id="L3123">							curIfaceInContract.getAccessibleImplementations().put(curImplOfGetterSetter.getKey(),</span>
									opImplementationGetterSetter);
<span class="nc" id="L3125">						}</span>
<span class="nc" id="L3126">					}</span>
<span class="nc" id="L3127">				}</span>
			}

			// Check contract
<span class="nc" id="L3131">			final Map&lt;InterfaceID, Interface&gt; infoOfInterfacesInContract = checkContract(newContract);</span>

			// Generate interfaces that must be automatically added in the contract
<span class="nc" id="L3134">			final Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInContract = updateInterfacesForTheContract(accountID,</span>
<span class="nc" id="L3135">					credential, newContract.getNamespaceID(), newContract.getInterfacesInContract(),</span>
					infoOfInterfacesInContract);

<span class="nc" id="L3138">			newContract.setInterfacesInContract(interfacesInContract);</span>

			// Create the contract
<span class="nc" id="L3141">			ContractID newContractID = new ContractID();</span>
<span class="nc" id="L3142">			newContract.setDataClayID(newContractID);</span>

<span class="nc bnc" id="L3144" title="All 2 branches missed.">			if (!newContract.isPublicAvailable()) {</span>
<span class="nc" id="L3145">				newContractID = contractMgrApi.newPrivateContract(newContract);</span>
			} else {
<span class="nc" id="L3147">				newContractID = contractMgrApi.newPublicContract(newContract);</span>
			}

<span class="nc" id="L3150">			return newContractID;</span>

<span class="nc" id="L3152">		} catch (final ParseException e) {</span>
<span class="nc" id="L3153">			throw new DataClayRuntimeException(ERRORCODE.BAD_DATES);</span>
		}
	}

	@Override
	public void registerToPublicContract(final AccountID accountID, final PasswordCredential credential,
			final ContractID contractID) {
		// Validate proprietary account
<span class="nc bnc" id="L3161" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3162">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L3165">		contractMgrApi.registerToPublicContract(accountID, contractID);</span>
<span class="nc" id="L3166">	}</span>

	@Override
	public ContractID registerToPublicContractOfNamespace(final AccountID accountID,
			final PasswordCredential credential, final NamespaceID namespaceID) {
		// Validate proprietary account
<span class="nc bnc" id="L3172" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3173">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L3176">		final Map&lt;ContractID, Contract&gt; pubContracts = contractMgrApi.getPublicContractIDsOfProvider(namespaceID);</span>
<span class="nc bnc" id="L3177" title="All 2 branches missed.">		if (pubContracts.size() == 0) {</span>
<span class="nc" id="L3178">			throw new DataClayRuntimeException(ERRORCODE.CONTRACT_NOT_EXIST);</span>
		}
<span class="nc" id="L3180">		final ContractID pubContractID = pubContracts.keySet().iterator().next();</span>
<span class="nc" id="L3181">		contractMgrApi.registerToPublicContract(accountID, pubContractID);</span>
<span class="nc" id="L3182">		return pubContractID;</span>
	}

	@Override
	public Map&lt;ContractID, Contract&gt; getContractIDsOfProvider(final AccountID accountID,
			final PasswordCredential credential, final NamespaceID namespaceIDofProvider) {
		// Validate account and check it is the responsible of the namespace
<span class="nc" id="L3189">		checkNamespaceResponsible(accountID, credential, namespaceIDofProvider);</span>

<span class="nc" id="L3191">		return contractMgrApi.getContractIDsOfProvider(namespaceIDofProvider);</span>
	}

	@Override
	public Map&lt;ContractID, Contract&gt; getContractIDsOfApplicant(final AccountID applicantAccountID,
			final PasswordCredential credential) {
		// Validate account
<span class="nc bnc" id="L3198" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(applicantAccountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3199">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L3202">		return contractMgrApi.getContractIDsOfApplicant(applicantAccountID);</span>

	}

	@Override
	public Map&lt;ContractID, Contract&gt; getContractIDsOfApplicantWithProvider(final AccountID applicantAccountID,
			final PasswordCredential credential, final NamespaceID namespaceIDofProvider) {
		// Validate account
<span class="nc bnc" id="L3210" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(applicantAccountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3211">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L3214">		return contractMgrApi.getContractIDsOfApplicantWithProvider(applicantAccountID, namespaceIDofProvider);</span>
	}

	// ============== DataContract Manager ==============//

	// TODO ROLLBACK IF IT FAILS (2 Jul 2013 jmarti)
	@Override
	public DataContractID newDataContract(final AccountID accountID, final PasswordCredential credential,
			final DataContract newDataContract) {
		try {

			// ================================================ //
<span class="nc bnc" id="L3226" title="All 2 branches missed.">			if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L3227">				this.notificationMgrApi.removeSessionInCache(accountID);</span>
			}

<span class="nc" id="L3230">			final DataSetID datasetID = newDataContract.getProviderDataSetID();</span>

			// Validate proprietary and check it is the responsible of the namespace
<span class="nc" id="L3233">			checkDataSetResponsible(accountID, credential, datasetID);</span>

			// Check applicants exist (if any)
<span class="nc bnc" id="L3236" title="All 2 branches missed.">			if (newDataContract.isPublicAvailable()) {</span>
<span class="nc bnc" id="L3237" title="All 2 branches missed.">				for (final AccountID applicantAccountID : newDataContract.getApplicantsAccountsIDs()) {</span>
<span class="nc bnc" id="L3238" title="All 2 branches missed.">					if (applicantAccountID != null) {</span>
<span class="nc bnc" id="L3239" title="All 2 branches missed.">						if (!accountMgrApi.existsAccount(applicantAccountID)) {</span>
<span class="nc" id="L3240">							throw new DataClayRuntimeException(ERRORCODE.ACCOUNT_NOT_EXIST);</span>
						}
					}
<span class="nc" id="L3243">				}</span>
			}

			// Create the contract
<span class="nc" id="L3247">			DataContractID newDataContractID = new DataContractID();</span>
<span class="nc" id="L3248">			newDataContract.setDataClayID(newDataContractID);</span>
<span class="nc bnc" id="L3249" title="All 2 branches missed.">			if (newDataContract.isPublicAvailable()) {</span>
<span class="nc" id="L3250">				newDataContractID = datacontractMgrApi.newPublicDataContract(newDataContract);</span>
			} else {
<span class="nc" id="L3252">				newDataContractID = datacontractMgrApi.newPrivateDataContract(newDataContract);</span>
			}

<span class="nc" id="L3255">			LOGGER.info(&quot;[LOGICMODULE] Created new datacontract called&quot; + &quot; with ID &quot; + newDataContractID);</span>

<span class="nc" id="L3257">			return newDataContractID;</span>

<span class="nc" id="L3259">		} catch (final ParseException e) {</span>
<span class="nc" id="L3260">			throw new DataClayRuntimeException(ERRORCODE.BAD_DATES);</span>
		}
	}

	@Override
	public void registerToPublicDataContract(final AccountID accountID, final PasswordCredential credential,
			final DataContractID datacontractID) {
		// Validate proprietary account
<span class="nc bnc" id="L3268" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3269">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L3272">		datacontractMgrApi.registerToPublicDataContract(accountID, datacontractID);</span>

<span class="nc" id="L3274">	}</span>

	@Override
	public Map&lt;DataContractID, DataContract&gt; getDataContractIDsOfProvider(final AccountID accountID,
			final PasswordCredential credential, final DataSetID datasetIDofProvider) {
		// Validate account and check it is the responsible of the namespace
<span class="nc" id="L3280">		checkDataSetResponsible(accountID, credential, datasetIDofProvider);</span>

<span class="nc" id="L3282">		return datacontractMgrApi.getDataContractIDsOfProvider(datasetIDofProvider);</span>

	}

	@Override
	public Map&lt;DataContractID, DataContract&gt; getDataContractIDsOfApplicant(final AccountID applicantAccountID,
			final PasswordCredential credential) {
		// Validate account
<span class="nc bnc" id="L3290" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(applicantAccountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3291">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L3294">		return datacontractMgrApi.getDataContractIDsOfApplicant(applicantAccountID);</span>

	}

	@Override
	public DataContract getDataContractInfoOfApplicantWithProvider(final AccountID applicantAccountID,
			final PasswordCredential credential, final DataSetID datasetIDofProvider) {
		// Validate account
<span class="nc bnc" id="L3302" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(applicantAccountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3303">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

<span class="nc" id="L3306">		return datacontractMgrApi.getDataContractInfoOfApplicantWithProvider(applicantAccountID, datasetIDofProvider);</span>

	}

	// ============== Interface Manager ==============//

	@Override
	public InterfaceID newInterface(final AccountID accountID, final PasswordCredential credential,
			final Interface newInterface) {
		// =========== CHECK AND FILL WITH IDS =========== //

		// Account ID
<span class="nc bnc" id="L3318" title="All 2 branches missed.">		if (newInterface.getProviderAccountID() == null) {</span>
<span class="nc" id="L3319">			final String accountName = newInterface.getProviderAccountName();</span>
<span class="nc bnc" id="L3320" title="All 4 branches missed.">			if (accountName == null || accountName.isEmpty()) {</span>
<span class="nc" id="L3321">				throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty account name&quot;, false);</span>
			}
<span class="nc" id="L3323">			final AccountID accID = accountMgrApi.getAccountID(accountName);</span>
<span class="nc" id="L3324">			newInterface.setProviderAccountID(accID);</span>
		}

		/**** rtouma ****/
		// Account name
<span class="nc bnc" id="L3329" title="All 2 branches missed.">		if (newInterface.getProviderAccountName() == null) {</span>
<span class="nc" id="L3330">			final AccountID accID = newInterface.getProviderAccountID();</span>
<span class="nc bnc" id="L3331" title="All 2 branches missed.">			if (accID == null) {</span>
<span class="nc" id="L3332">				throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty account ID&quot;, false);</span>
			}
<span class="nc" id="L3334">			final String accName = accountMgrApi.getAccount(accID).getUsername();</span>
<span class="nc" id="L3335">			newInterface.setProviderAccountName(accName);</span>
		}
		/****************/

		// Namespace
<span class="nc" id="L3340">		final String namespace = newInterface.getNamespace();</span>
<span class="nc bnc" id="L3341" title="All 4 branches missed.">		if (namespace == null || namespace.isEmpty()) {</span>
<span class="nc" id="L3342">			throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty interface namespace&quot;, false);</span>
		}
<span class="nc" id="L3344">		final NamespaceID namespaceID = namespaceMgrApi.getNamespaceID(namespace);</span>
<span class="nc" id="L3345">		newInterface.setNamespaceID(namespaceID);</span>

		// Interface ID of class
<span class="nc" id="L3348">		final String classNamespace = newInterface.getClassNamespace();</span>
<span class="nc bnc" id="L3349" title="All 4 branches missed.">		if (classNamespace == null || classNamespace.isEmpty()) {</span>
<span class="nc" id="L3350">			throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty class namespace&quot;, false);</span>
		}
<span class="nc" id="L3352">		final NamespaceID classNamespaceID = namespaceMgrApi.getNamespaceID(classNamespace);</span>
<span class="nc" id="L3353">		newInterface.setClassNamespaceID(classNamespaceID);</span>

		// Class ID
<span class="nc" id="L3356">		final String className = newInterface.getClassName();</span>
<span class="nc bnc" id="L3357" title="All 4 branches missed.">		if (className == null || className.isEmpty()) {</span>
<span class="nc" id="L3358">			throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null or empty interface class&quot;, false);</span>
		}
<span class="nc" id="L3360">		MetaClassID metaClassID = classMgrApi.getMetaClassID(classNamespaceID, className);</span>
<span class="nc" id="L3361">		newInterface.setMetaClassID(metaClassID);</span>

		// Property IDs
<span class="nc" id="L3364">		final Set&lt;PropertyID&gt; propIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3365" title="All 2 branches missed.">		if (newInterface.getPropertiesInIface() == null) {</span>
<span class="nc" id="L3366">			throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null properties list&quot;, false);</span>
		}
<span class="nc bnc" id="L3368" title="All 2 branches missed.">		for (final String propName : newInterface.getPropertiesInIface()) {</span>
<span class="nc" id="L3369">			final PropertyID propID = classMgrApi.getPropertyID(metaClassID, propName);</span>
<span class="nc" id="L3370">			propIDs.add(propID);</span>
<span class="nc" id="L3371">		}</span>
<span class="nc" id="L3372">		newInterface.setPropertiesIDs(propIDs);</span>

		// Operation IDs
<span class="nc" id="L3375">		final Set&lt;OperationID&gt; opIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3376" title="All 2 branches missed.">		if (newInterface.getOperationsSignatureInIface() == null) {</span>
<span class="nc" id="L3377">			throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Null operations list&quot;, false);</span>
		}
<span class="nc bnc" id="L3379" title="All 2 branches missed.">		for (final String opSignature : newInterface.getOperationsSignatureInIface()) {</span>
<span class="nc" id="L3380">			final OperationID opID = classMgrApi.getOperationID(metaClassID, opSignature);</span>
<span class="nc" id="L3381">			opIDs.add(opID);</span>
<span class="nc" id="L3382">		}</span>
<span class="nc" id="L3383">		newInterface.setOperationsIDs(opIDs);</span>

		// =========== =========== //

		// Check interface exists
<span class="nc bnc" id="L3388" title="All 2 branches missed.">		if (interfaceMgrApi.existsInterface(newInterface.getProviderAccountName(), newInterface.getNamespace(),</span>
<span class="nc" id="L3389">				newInterface.getClassName(), newInterface.getPropertiesInIface(),</span>
<span class="nc" id="L3390">				newInterface.getOperationsSignatureInIface())) {</span>
<span class="nc" id="L3391">			throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE, &quot;Interface already exists&quot;, false);</span>
		}

		// Check namespace responsible =&gt; validates account
<span class="nc" id="L3395">		final HashSet&lt;InterfaceID&gt; interfacesOfImports = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3396">		Namespace namespaceInfo = null;</span>
		try {
<span class="nc" id="L3398">			namespaceInfo = checkNamespaceResponsible(accountID, credential, namespaceID);</span>
<span class="nc" id="L3399">		} catch (final AccountNotResponsibleOfNamespace e) {</span>
			// class ID does not exist in namespace, look for it in the imports
<span class="nc" id="L3401">			final Set&lt;ImportedInterface&gt; importedInterfaces = namespaceMgrApi.getImportedInterfaces(namespaceID,</span>
					className);
<span class="nc bnc" id="L3403" title="All 2 branches missed.">			if (importedInterfaces.isEmpty()) {</span>
<span class="nc" id="L3404">				throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_CREATED_IN_NAMESPACE_NOR_IMPORTED,</span>
						&quot;Class &quot; + className + &quot; not created in namespace {&quot; + namespaceID + &quot;}&quot;, false);
			}

			// Check imports
<span class="nc" id="L3409">			final Map&lt;ContractID, InterfaceID&gt; interfacesInContracts = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L3410" title="All 2 branches missed.">			for (final ImportedInterface importedInterface : importedInterfaces) {</span>
<span class="nc bnc" id="L3411" title="All 2 branches missed.">				if (metaClassID == null) { // first iteration</span>
<span class="nc" id="L3412">					metaClassID = importedInterface.getClassOfImportID();</span>
				}

<span class="nc" id="L3415">				final InterfaceID previousValue = interfacesInContracts.put(importedInterface.getContractID(),</span>
<span class="nc" id="L3416">						importedInterface.getInterfaceID());</span>
<span class="nc bnc" id="L3417" title="All 2 branches missed.">				if (previousValue != null) {</span>
					// WARNING: This should not happen ever (18 Jun 2013 jmarti)
<span class="nc" id="L3419">					throw new DataClayRuntimeException(ERRORCODE.CONTRACT_DUPLICATION);</span>
				}

<span class="nc" id="L3422">				interfacesOfImports.add(importedInterface.getInterfaceID());</span>
<span class="nc" id="L3423">			}</span>

			// Check interfaces in contracts
<span class="nc bnc" id="L3426" title="All 2 branches missed.">			if (!contractMgrApi.checkInterfacesInActiveContractsForAccount(accountID, interfacesInContracts)) {</span>
<span class="nc" id="L3427">				throw new DataClayRuntimeException(ERRORCODE.BAD_CONTRACT);</span>
			}

<span class="nc" id="L3430">		}</span>

<span class="nc" id="L3432">		final Set&lt;PropertyID&gt; propertiesIDs = newInterface.getPropertiesIDs();</span>
<span class="nc" id="L3433">		final Set&lt;OperationID&gt; operationsIDs = newInterface.getOperationsIDs();</span>
<span class="nc bnc" id="L3434" title="All 2 branches missed.">		if (namespaceInfo.getLanguage() == Langs.LANG_JAVA) { // Getters/setters do not apply to Python codes (jcosta</span>
			// 17/jun/2014)
			// Get operations IDs of default setters and getters
<span class="nc" id="L3437">			final Set&lt;OperationID&gt; gettersAndSetters = classMgrApi.getOperationsIDsOfGettersAndSetters(metaClassID,</span>
					propertiesIDs);
<span class="nc" id="L3439">			operationsIDs.addAll(gettersAndSetters);</span>
		}

<span class="nc" id="L3442">		final InterfaceID ifaceID = interfaceMgrApi.newInterface(newInterface);</span>
<span class="nc" id="L3443">		return ifaceID;</span>

	}

	@Override
	public Interface getInterfaceInfo(final AccountID accountID, final PasswordCredential credential,
			final InterfaceID interfaceID) {
		// Validate account
<span class="nc bnc" id="L3451" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L3452">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

		// Get contracts of account
<span class="nc" id="L3456">		final Map&lt;ContractID, Contract&gt; contractsOfAccount = contractMgrApi.getContractIDsOfApplicant(accountID);</span>

		// Check interface is present within the contracts of account
<span class="nc" id="L3459">		boolean found = false;</span>
<span class="nc bnc" id="L3460" title="All 2 branches missed.">		for (final Entry&lt;ContractID, Contract&gt; curContract : contractsOfAccount.entrySet()) {</span>
<span class="nc" id="L3461">			final Contract contractInfo = curContract.getValue();</span>
<span class="nc" id="L3462">			found = contractInfo.getInterfacesInContract().containsKey(interfaceID);</span>
<span class="nc bnc" id="L3463" title="All 2 branches missed.">			if (found) {</span>
<span class="nc" id="L3464">				break;</span>
			}
<span class="nc" id="L3466">		}</span>
<span class="nc bnc" id="L3467" title="All 2 branches missed.">		if (!found) {</span>
<span class="nc" id="L3468">			throw new DataClayRuntimeException(ERRORCODE.INTERFACE_NOT_ACCESSIBLE);</span>
		}

<span class="nc" id="L3471">		final HashSet&lt;InterfaceID&gt; interfacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3472">		interfacesIDs.add(interfaceID);</span>
<span class="nc" id="L3473">		final Interface ifaceInfo = interfaceMgrApi.getInterfacesInfo(interfacesIDs).values().iterator().next();</span>

<span class="nc" id="L3475">		return ifaceInfo;</span>

	}

	@Override
	public void removeInterface(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID, final InterfaceID interfaceID) {
		// Check namespace responsible
<span class="nc" id="L3483">		checkNamespaceResponsible(accountID, credential, namespaceID);</span>

		// Check there is no contract associated with the interface
<span class="nc bnc" id="L3486" title="All 2 branches missed.">		if (!contractMgrApi.checkInterfaceHasNoContracts(interfaceID)) {</span>
<span class="nc" id="L3487">			throw new DataClayRuntimeException(ERRORCODE.INTERFACE_WITH_CONTRACTS);</span>
		}

<span class="nc" id="L3490">		interfaceMgrApi.removeInterface(namespaceID, interfaceID);</span>

<span class="nc" id="L3492">	}</span>

	// ============== Metadata Service ==============//

	@Override
	public ObjectID registerObject(final RegistrationInfo regInfo, final ExecutionEnvironmentID backendID,
			final String alias, final Langs lang) {
<span class="nc bnc" id="L3499" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3500">			LOGGER.debug(&quot;Registering object explicit call: &quot; + regInfo + &quot; and alias &quot; + alias);</span>
		}
		// Register the object in the metadataservice
<span class="nc" id="L3503">		final HashSet&lt;ExecutionEnvironmentID&gt; backendIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3504">		backendIDs.add(backendID);</span>
<span class="nc" id="L3505">		ObjectID objectIDofNewObject = regInfo.getObjectID();</span>
<span class="nc" id="L3506">		final SessionID ownerSessionID = regInfo.getStoreSessionID();</span>
<span class="nc" id="L3507">		final MetaClassID metaClassID = regInfo.getClassID();</span>
<span class="nc" id="L3508">		DataSetID datasetIDforStore = null;</span>
<span class="nc" id="L3509">		AccountID ownerAccountID = null;</span>
<span class="nc bnc" id="L3510" title="All 2 branches missed.">		if (ownerSessionID == null) {</span>
			// objects created in federation or without session
			// TODO: create a general dataClay dataset and account
<span class="nc" id="L3513">			datasetIDforStore = dataSetMgrApi.getDataSetID(EXTERNAL_OBJECTS_DATASET_NAME);</span>
<span class="nc" id="L3514">			ownerAccountID = accountMgrApi.getAccountID(FEDERATOR_ACCOUNT_USERNAME);</span>
		} else {
<span class="nc" id="L3516">			final SessionInfo sessionInfo = getSessionInfo(ownerSessionID);</span>
<span class="nc" id="L3517">			final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>
<span class="nc" id="L3518">			final DataContractID dataContractIDforStore = sessionInfo.getDataContractIDforStore();</span>
<span class="nc" id="L3519">			final SessionDataContract sessionDataContractOfStore = sessionDataInfo.get(dataContractIDforStore);</span>
<span class="nc" id="L3520">			datasetIDforStore = sessionDataContractOfStore.getDataSetOfProvider();</span>
<span class="nc" id="L3521">			ownerAccountID = sessionInfo.getAccountID();</span>
		}

<span class="nc bnc" id="L3524" title="All 2 branches missed.">		if (regInfo.getDataSetID() != null) {</span>
			// User specified dataset ID
<span class="nc" id="L3526">			datasetIDforStore = regInfo.getDataSetID();</span>
		}

		// If object is not registered, we register it with new alias included.
<span class="nc" id="L3530">		final MetaDataInfo info = metaDataSrvApi.registerObject(objectIDofNewObject, metaClassID, datasetIDforStore,</span>
<span class="nc" id="L3531">				backendIDs, Configuration.Flags.READONLY_BY_DEFAULT.getBooleanValue(), alias, lang, ownerAccountID);</span>
<span class="nc" id="L3532">		objectIDofNewObject = info.getDataClayID();</span>
<span class="nc bnc" id="L3533" title="All 4 branches missed.">		if (alias != null &amp;&amp; !alias.isEmpty()) {</span>
			// notify alias reference since it is the first alias (with registration)
			// first makePeristent(alias)
<span class="nc" id="L3536">			final Map&lt;ObjectID, Integer&gt; referenceCounting = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3537">			referenceCounting.put(objectIDofNewObject, 1);</span>
<span class="nc" id="L3538">			notifyGarbageCollectors(referenceCounting);</span>
		}

<span class="nc" id="L3541">		return objectIDofNewObject;</span>
	}

	/**
	 * Notify garbage collectors to add delta in reference counting of the objects
	 * with ID provided
	 * 
	 * @param updateRefs
	 *            IDs of the objects to notify + delta to add to them. We require a
	 *            map in order to save calls and group notifications.
	 */
	private void notifyGarbageCollectors(final Map&lt;ObjectID, Integer&gt; updateRefs) {
<span class="nc bnc" id="L3553" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3554">			LOGGER.debug(&quot;Notifying garbage collectors reference counting: {}&quot;, updateRefs);</span>
		}

		// Group by locations
<span class="nc" id="L3558">		final Map&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; groupByLocation = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L3559" title="All 2 branches missed.">		for (final ObjectID objectID : updateRefs.keySet()) {</span>
<span class="nc" id="L3560">			final MetaDataInfo mdInfo = metaDataSrvApi.getObjectMetaData(objectID);</span>
<span class="nc bnc" id="L3561" title="All 2 branches missed.">			for (final ExecutionEnvironmentID execID : mdInfo.getLocations().keySet()) {</span>
<span class="nc" id="L3562">				Set&lt;ObjectID&gt; currGroup = groupByLocation.get(execID);</span>
<span class="nc bnc" id="L3563" title="All 2 branches missed.">				if (currGroup == null) {</span>
<span class="nc" id="L3564">					currGroup = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3565">					groupByLocation.put(execID, currGroup);</span>
				}
<span class="nc" id="L3567">				currGroup.add(objectID);</span>
<span class="nc" id="L3568">			}</span>
<span class="nc" id="L3569">		}</span>

		// Notify Storage Locations (GC) of the object
<span class="nc bnc" id="L3572" title="All 2 branches missed.">		for (final Entry&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; currentGroup : groupByLocation.entrySet()) {</span>
<span class="nc" id="L3573">			final ExecutionEnvironment execEnv = metaDataSrvApi.getExecutionEnvironmentInfo(currentGroup.getKey());</span>
<span class="nc" id="L3574">			final DataServiceAPI dsAPI = getExecutionEnvironmentAPI(execEnv);</span>

			// prepare map of reference countings to update (we are using same notification
			// system used between GCs)
<span class="nc" id="L3578">			final Map&lt;ObjectID, Integer&gt; updateCounterRefs = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L3579" title="All 2 branches missed.">			for (final ObjectID objectID : currentGroup.getValue()) {</span>
<span class="nc" id="L3580">				updateCounterRefs.put(objectID, updateRefs.get(objectID));</span>
<span class="nc" id="L3581">			}</span>
<span class="nc" id="L3582">			dsAPI.updateRefs(updateCounterRefs);</span>
<span class="nc" id="L3583">		}</span>
<span class="nc" id="L3584">	}</span>

	@Override
	public void unregisterObjects(final Set&lt;ObjectID&gt; objectsToUnregister) {
<span class="nc bnc" id="L3588" title="All 2 branches missed.">		for (final ObjectID objectID : objectsToUnregister) {</span>
<span class="nc" id="L3589">			LOGGER.debug(&quot;** Unregistering object: &quot; + objectID);</span>
<span class="nc" id="L3590">			metaDataSrvApi.unregisterObject(objectID);</span>
			// if object is external and marked as unregister = true
<span class="nc bnc" id="L3592" title="All 2 branches missed.">			if (metaDataSrvApi.externalObjectIsUnregistered(objectID)) { </span>
<span class="nc" id="L3593">				LOGGER.debug(&quot;** Unregistering External object: &quot; + objectID);</span>
<span class="nc" id="L3594">				metaDataSrvApi.unregisterExternalObject(objectID);</span>
			}
<span class="nc" id="L3596">		}</span>
<span class="nc" id="L3597">	}</span>

	@Override
	public void registerObjectFromGC(final RegistrationInfo regInfo, final ExecutionEnvironmentID backendID,
			final DataServiceRuntime clientLib) {
<span class="nc bnc" id="L3602" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3603">			LOGGER.debug(&quot;Registering object from GC: &quot; + regInfo.getObjectID());</span>
		}

<span class="nc" id="L3606">		final HashSet&lt;ExecutionEnvironmentID&gt; backendIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3607">		backendIDs.add(backendID);</span>

<span class="nc" id="L3609">		final ObjectID objectIDofNewObject = regInfo.getObjectID();</span>
<span class="nc" id="L3610">		final MetaClassID metaClassID = regInfo.getClassID();</span>
<span class="nc" id="L3611">		final SessionID ownerSessionID = regInfo.getStoreSessionID();</span>
<span class="nc" id="L3612">		final SessionInfo sessionInfo = getSessionInfo(ownerSessionID);</span>
<span class="nc" id="L3613">		final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>
<span class="nc" id="L3614">		final DataContractID dataContractIDforStore = sessionInfo.getDataContractIDforStore();</span>
<span class="nc" id="L3615">		final SessionDataContract sessionDataContractOfStore = sessionDataInfo.get(dataContractIDforStore);</span>
<span class="nc" id="L3616">		DataSetID datasetIDforStore = sessionDataContractOfStore.getDataSetOfProvider();</span>
<span class="nc bnc" id="L3617" title="All 2 branches missed.">		if (regInfo.getDataSetID() != null) {</span>
			// User specified dataset ID
<span class="nc" id="L3619">			datasetIDforStore = regInfo.getDataSetID();</span>
		}
		try {
<span class="nc" id="L3622">			metaDataSrvApi.registerObject(objectIDofNewObject, metaClassID, datasetIDforStore, backendIDs,</span>
<span class="nc" id="L3623">					Configuration.Flags.READONLY_BY_DEFAULT.getBooleanValue(), null, Langs.LANG_JAVA,</span>
<span class="nc" id="L3624">					sessionInfo.getAccountID());</span>
<span class="nc" id="L3625">		} catch (final SessionNotExistException sessExpiredExc) {</span>
<span class="nc" id="L3626">			LOGGER.debug(&quot;The session does not exist&quot;, sessExpiredExc);</span>

			// ignore this session till design of what to do with objects persisted and
			// sessions closed before
			// actually registered: PULL hearth-bate from nodes, for instance.
<span class="nc" id="L3631">		}</span>
<span class="nc" id="L3632">	}</span>


	@Override
	public Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getExecutionEnvironmentsInfo(final SessionID sessionID,
			final Langs execEnvLang, final boolean fromClient) {
		// Check session exists
<span class="nc bnc" id="L3639" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3640">			getSessionInfo(sessionID);</span>
		}
<span class="nc" id="L3642">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvs = metaDataSrvApi</span>
<span class="nc" id="L3643">				.getAllExecutionEnvironmentsInfo(execEnvLang);</span>
<span class="nc bnc" id="L3644" title="All 4 branches missed.">		if (fromClient &amp;&amp; exposedIPForClient != null) {</span>
			// All information send to client will use exposed IP configured
<span class="nc bnc" id="L3646" title="All 2 branches missed.">			for (final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; ee : execEnvs.entrySet()) { </span>
<span class="nc" id="L3647">				ee.getValue().setHostname(exposedIPForClient);</span>
<span class="nc" id="L3648">			}</span>
		}
<span class="nc bnc" id="L3650" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3651">			LOGGER.debug(&quot;Got execution environments: &quot; + execEnvs);</span>
		}
<span class="nc" id="L3653">		return execEnvs;</span>
	}

	@Override
	public Set&lt;String&gt; getExecutionEnvironmentsNames(final AccountID accountID, final PasswordCredential credential,
			final Langs execEnvLang) {
		// Validate account
<span class="nc bnc" id="L3660" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L3661">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}
<span class="nc" id="L3663">		final Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3664">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvs = metaDataSrvApi</span>
<span class="nc" id="L3665">				.getAllExecutionEnvironmentsInfo(execEnvLang);</span>
<span class="nc bnc" id="L3666" title="All 2 branches missed.">		if (execEnvs != null) {</span>
<span class="nc bnc" id="L3667" title="All 2 branches missed.">			for (final ExecutionEnvironment ee : execEnvs.values()) {</span>
<span class="nc" id="L3668">				result.add(ee.getName() + &quot;,&quot; + ee.getHostname() + &quot;:&quot; + ee.getPort());</span>
<span class="nc" id="L3669">			}</span>
		}
<span class="nc" id="L3671">		return result;</span>
	}

	// ============== Metadata Service ==============//

	@Override
	public StorageLocation getStorageLocationForDS(final StorageLocationID backendID) {
<span class="nc" id="L3678">		return metaDataSrvApi.getStorageLocationInfo(backendID);</span>
	}

	@Override
	public ExecutionEnvironment getExecutionEnvironmentForDS(final ExecutionEnvironmentID backendID) {
<span class="nc" id="L3683">		return metaDataSrvApi.getExecutionEnvironmentInfo(backendID);</span>
	}

	@Override
	public Tuple&lt;String, String&gt; getObjectInfo(final SessionID sessionID, final ObjectID objectID) {

		// FIXME: Looks like this method is not used anymore! (July 2018 jmarti)

		// Get session info if needed
<span class="nc" id="L3692">		SessionInfo sessionInfo = null;</span>
<span class="nc bnc" id="L3693" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3694">			sessionInfo = getSessionInfo(sessionID);</span>
		}

		// Get object info
<span class="nc" id="L3698">		final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L3699" title="All 2 branches missed.">		if (metadataInfo == null) {</span>
<span class="nc" id="L3700">			throw new DbObjectNotExistException(objectID);</span>
		}

		// Check dataset if needed
<span class="nc bnc" id="L3704" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3705">			checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
		}

<span class="nc" id="L3708">		return classMgrApi.getClassNameAndNamespace(metadataInfo.getMetaclassID());</span>

	}

	@Override
	public Triple&lt;ObjectID, MetaClassID, ExecutionEnvironmentID&gt; getObjectFromAlias(final SessionID sessionID,
			final String alias) {
		try {

<span class="nc bnc" id="L3717" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3718">				LOGGER.debug(&quot;Starting get object from alias for alias &quot; + alias);</span>
			}

			// Get session if needed
<span class="nc" id="L3722">			SessionInfo sessionInfo = null;</span>
<span class="nc bnc" id="L3723" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3724">				sessionInfo = getSessionInfo(sessionID);</span>
			}

<span class="nc bnc" id="L3727" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3728">				LOGGER.debug(&quot;Get object info from alias &quot; + alias);</span>
			}
<span class="nc" id="L3730">			final Tuple&lt;ObjectID, MetaDataInfo&gt; infoOfObject = metaDataSrvApi.getObjectInfoFromAlias(alias);</span>
<span class="nc" id="L3731">			final MetaDataInfo metadataInfo = infoOfObject.getSecond();</span>

			// Check dataset
<span class="nc bnc" id="L3734" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc bnc" id="L3735" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3736">					LOGGER.debug(&quot;Check dataset is among datacontract for object with alias &quot; + alias);</span>
				}
<span class="nc" id="L3738">				checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
			}

<span class="nc" id="L3741">			final ObjectID result = infoOfObject.getFirst();</span>
<span class="nc" id="L3742">			final MetaClassID mclassID = metadataInfo.getMetaclassID();</span>
<span class="nc" id="L3743">			final ExecutionEnvironmentID execID = metadataInfo.getLocations().values().iterator().next()</span>
<span class="nc" id="L3744">					.getDataClayID();</span>
<span class="nc bnc" id="L3745" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3746">				LOGGER.debug(&quot;Returning object with id {} and alias {}&quot;, result, alias);</span>
			}
<span class="nc" id="L3748">			return new Triple&lt;&gt;(result, mclassID, execID);</span>
<span class="nc" id="L3749">		} catch (final Exception ex) {</span>
<span class="nc" id="L3750">			LOGGER.debug(&quot;getObjectFromAlias error&quot;, ex);</span>
<span class="nc" id="L3751">			throw ex;</span>
		}
	}

	@Override
	public void deleteAlias(final SessionID sessionID, final String alias) {
		try {
<span class="nc bnc" id="L3758" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3759">				LOGGER.debug(&quot;Starting delete alias &quot; + alias);</span>
			}

<span class="nc" id="L3762">			final Tuple&lt;ObjectID, MetaDataInfo&gt; infoOfObject = metaDataSrvApi.getObjectInfoFromAlias(alias);</span>
<span class="nc" id="L3763">			final MetaDataInfo metadataInfo = infoOfObject.getSecond();</span>

			// Check session if needed
<span class="nc bnc" id="L3766" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L3767">				final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc bnc" id="L3768" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3769">					LOGGER.debug(&quot;Check dataset is among datacontract for object with alias &quot; + alias);</span>
				}
<span class="nc" id="L3771">				checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
			}

			// Delete alias if can access object
<span class="nc" id="L3775">			final ObjectID objectID = metaDataSrvApi.deleteAlias(alias);</span>

			// Notify GC of each EE where a replica is located to add -1 reference
<span class="nc" id="L3778">			final Map&lt;ObjectID, Integer&gt; referenceCounting = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3779">			referenceCounting.put(objectID, -1);</span>
<span class="nc" id="L3780">			notifyGarbageCollectors(referenceCounting);</span>

<span class="nc" id="L3782">		} catch (final Exception ex) {</span>
<span class="nc" id="L3783">			LOGGER.debug(&quot;deleteAlias error&quot;, ex);</span>
<span class="nc" id="L3784">			throw new DataClayRuntimeException(ERRORCODE.UNKNOWN_EXCEPTION, &quot;deleteAlias failed&quot;, false);</span>
<span class="nc" id="L3785">		}</span>
<span class="nc" id="L3786">	}</span>


	@Override
	public Map&lt;ObjectID, MetaDataInfo&gt; getObjectsMetaDataInfoOfClassForNM(final MetaClassID classID) {
		// TODO We have to ensure that only Notification Manager can access this method
		// (3 Mar 2016 jmarti)
<span class="nc" id="L3793">		return metaDataSrvApi.getObjectsOfSpecificClass(classID);</span>
	}

	@Override
	public DataClayInstanceID getDataClayID() {
<span class="nc" id="L3798">		return publicIDs.dcID;</span>
	}

	/**
	 * Get API to connect with external LogicModule
	 * 
	 * @param dcInfo
	 *            DataClayInstance of external DataClay
	 * @return API to connect with external LogicModule
	 * @throws InterruptedException
	 *             if connection failed
	 */
	private LogicModuleAPI getExternalLogicModule(final DataClayInstance dcInfo) throws InterruptedException {

<span class="nc" id="L3812">		LogicModuleAPI lmExternal = null;</span>
<span class="nc" id="L3813">		final String[] hosts = dcInfo.getHosts();</span>
<span class="nc" id="L3814">		final Integer[] ports = dcInfo.getPorts();</span>
<span class="nc" id="L3815">		final List&lt;String&gt; missedhosts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3816">		final List&lt;Integer&gt; missedports = new ArrayList&lt;&gt;();</span>

		try {
<span class="nc bnc" id="L3819" title="All 2 branches missed.">			for (int i = 0; i &lt; hosts.length; i++) {</span>
				try {
<span class="nc" id="L3821">					LOGGER.debug(&quot;Getting dataClay at &quot; + hosts[i] + &quot;:&quot; + ports[i] + &quot;&quot;);</span>
<span class="nc" id="L3822">					lmExternal = grpcClient.getLogicModuleAPI(hosts[i], ports[i]);</span>
<span class="nc" id="L3823">					lmExternal.checkAlive();</span>
<span class="nc" id="L3824">					break;</span>
<span class="nc" id="L3825">				} catch (final Exception e) {</span>
<span class="nc" id="L3826">					LOGGER.debug(&quot;Could not connect to dataClay &quot; + hosts[i] + &quot;:&quot; + ports[i] + &quot;. Trying another address.&quot;);</span>
<span class="nc" id="L3827">					missedhosts.add(hosts[i]);</span>
<span class="nc" id="L3828">					missedports.add(ports[i]);</span>

<span class="nc bnc" id="L3830" title="All 2 branches missed.">					if (i + 1 == hosts.length) {</span>
<span class="nc" id="L3831">						throw e;</span>
					}
				}
			}
		} finally { 
			// remove missed addresses from metadata 
<span class="nc bnc" id="L3837" title="All 2 branches missed.">			if (missedhosts.size() &gt; 0) {</span>
<span class="nc" id="L3838">				final int i = 0;</span>
<span class="nc bnc" id="L3839" title="All 2 branches missed.">				for (final String missedhost : missedhosts) { </span>
<span class="nc" id="L3840">					final Integer missedport = missedports.get(i);</span>
<span class="nc" id="L3841">					LOGGER.debug(&quot;Unregistering &quot; + hosts[i] + &quot;:&quot; + ports[i] + &quot; external dataClay&quot;);</span>
<span class="nc" id="L3842">					metaDataSrvApi.unregisterExternalDataClayAddress(missedhost, missedport);</span>
<span class="nc" id="L3843">				}</span>
			}
		}
<span class="nc" id="L3846">		return lmExternal;</span>
	}

	@Override
	public DataClayInstanceID getExternalDataClayID(final String dcHost, final int dcPort) {
		try {
<span class="nc bnc" id="L3852" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3853">				LOGGER.debug(&quot;Getting external dataClay ID at {}:{}&quot;, dcHost, dcPort);</span>
			}
			// Get it from MDservice
<span class="nc" id="L3856">			return metaDataSrvApi.getExternalDataClayID(dcHost, dcPort);</span>
<span class="nc" id="L3857">		} catch (final Exception ex) {</span>
<span class="nc" id="L3858">			LOGGER.debug(&quot;External dataClay at {}:{} not found. Returning null.&quot;, dcHost, dcPort);</span>
<span class="nc" id="L3859">			return null;</span>
		}
	}

	@Override
	public DataClayInstance getExternalDataClayInfo(final DataClayInstanceID extDataClayID) {
		try {
<span class="nc" id="L3866">			final DataClayInstance dcInstance = metaDataSrvApi.getExternalDataClayInfo(extDataClayID);</span>
<span class="nc" id="L3867">			return dcInstance;</span>
<span class="nc" id="L3868">		} catch (final ExternalDataClayNotRegisteredException edn) {</span>
<span class="nc" id="L3869">			return null;</span>
		}
	}

	@Override
	public DataClayInstanceID registerExternalDataClay(final String thehostname, final int theport) {

<span class="nc bnc" id="L3876" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3877">			LOGGER.debug(&quot;Registering external dataClay at {}:{}&quot;, thehostname, theport);</span>

		}
<span class="nc" id="L3880">		return registerExternalDataClayAux(thehostname, theport);</span>
	}

	/**
	 * Register external dataclay aux function
	 * @param thehostname Hostname
	 * @param theport Port
	 * @return ID of the registered external dataclay
	 */
	private DataClayInstanceID registerExternalDataClayAux(final String thehostname, final int theport) { 
		try { 


<span class="nc" id="L3893">			final DataClayInstanceID id = getExternalDataClayID(thehostname, theport);</span>
<span class="nc bnc" id="L3894" title="All 2 branches missed.">			if (id != null) { </span>
<span class="nc bnc" id="L3895" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3896">					LOGGER.debug(&quot;Already registered external dataClay at {}:{}&quot;, thehostname, theport);</span>
				}
<span class="nc" id="L3898">				return id; //Already registered</span>
			}

<span class="nc" id="L3901">			final LogicModuleAPI lmExternal = grpcClient.getLogicModuleAPI(thehostname, theport);</span>
<span class="nc" id="L3902">			final DataClayInstanceID dcID = lmExternal.notifyRegistrationOfExternalDataClay(this.getDataClayID(),</span>
					this.hostname, this.port);
<span class="nc" id="L3904">			final DataClayInstance dcInstance = new DataClayInstance(dcID, thehostname, theport);</span>
<span class="nc" id="L3905">			metaDataSrvApi.registerExternalDataclay(dcInstance);</span>
<span class="nc bnc" id="L3906" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3907">				LOGGER.debug(&quot;Registered external dataClay {}&quot;, dcInstance);</span>
			}
<span class="nc" id="L3909">			return dcID;</span>
<span class="nc" id="L3910">		} catch (final Exception ex) {</span>
<span class="nc bnc" id="L3911" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3912">				LOGGER.debug(&quot;Exception produced during registration of external dataClay&quot;, ex);</span>
			}
<span class="nc" id="L3914">			return null;</span>
		}
	}

	@Override
	public DataClayInstanceID registerExternalDataClayOverrideAuthority(final AccountID adminAccountID, final PasswordCredential adminCredential,
			final String thehostname, final int theport, final String authority) {
		
		// Validate admin account
<span class="nc" id="L3923">		this.accountMgrApi.validateAccount(adminAccountID, adminCredential, AccountRole.ADMIN_ROLE);</span>

		// NOTE: currently not implemented to beware of concurrent modifications of the SSL_AUTHORITY configuration field 
<span class="nc" id="L3926">		Configuration.Flags.SSL_TARGET_AUTHORITY.setValue(authority);</span>

<span class="nc" id="L3928">		return this.registerExternalDataClayAux(thehostname, theport);</span>

	}

	@Override
	public DataClayInstanceID notifyRegistrationOfExternalDataClay(final DataClayInstanceID dataClayInstanceID,
			final String thehostname, final int theport) {
		try {
<span class="nc" id="L3936">			final DataClayInstance dcInstance = new DataClayInstance(dataClayInstanceID, thehostname, theport);</span>
<span class="nc" id="L3937">			metaDataSrvApi.registerExternalDataclay(dcInstance);</span>
<span class="nc bnc" id="L3938" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3939">				LOGGER.debug(&quot;Notified registration of external dataClay {}&quot;, dcInstance);</span>
			}
<span class="nc" id="L3941">			return this.getDataClayID();</span>
<span class="nc" id="L3942">		} catch (final Exception ex) {</span>
<span class="nc bnc" id="L3943" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L3944">				LOGGER.debug(&quot;Exception produced during registration of external dataClay&quot;, ex);</span>
			}
<span class="nc" id="L3946">			return null;</span>
		}
	}

	@Override
	public Tuple&lt;Namespace, Set&lt;MetaClass&gt;&gt; getClassesInNamespace(final String namespaceName)  {
<span class="nc" id="L3952">		NamespaceID namespaceID = this.namespaceMgrApi.getNamespaceID(namespaceName);</span>
<span class="nc" id="L3953">		final Map&lt;MetaClassID, MetaClass&gt; classesToFederate = this.classMgrApi.getInfoOfClassesInNamespace(namespaceID);</span>
<span class="nc" id="L3954">		final Namespace namespaceToFederate = namespaceMgrApi.getNamespaceInfo(namespaceID);</span>
<span class="nc" id="L3955">		Set&lt;MetaClass&gt; metaClassesToFederate = new HashSet&lt;MetaClass&gt;(classesToFederate.values());</span>
<span class="nc" id="L3956">		return new Tuple&lt;Namespace, Set&lt;MetaClass&gt;&gt;(namespaceToFederate, metaClassesToFederate);</span>

	}

	@Override
	public void importModelsFromExternalDataClay(final String extNamespaceName, final DataClayInstanceID extDataClayID) {

		// Get all information needed from external dataClay instance
<span class="nc" id="L3964">		LogicModuleAPI externalLogicModule = null;</span>
		try {
<span class="nc" id="L3966">			externalLogicModule = this.getExternalLogicModule(this.getExternalDataClayInfo(extDataClayID));</span>
<span class="nc" id="L3967">		} catch (InterruptedException e) {</span>
<span class="nc" id="L3968">			throw new RuntimeException(e);</span>
<span class="nc" id="L3969">		}</span>
<span class="nc" id="L3970">		Tuple&lt;Namespace, Set&lt;MetaClass&gt;&gt; toRegister = externalLogicModule.getClassesInNamespace(extNamespaceName);</span>
<span class="nc" id="L3971">		Namespace namespace = toRegister.getFirst();</span>
<span class="nc" id="L3972">		Set&lt;MetaClass&gt; classesToRegister = toRegister.getSecond();</span>

		// Register namespace
<span class="nc" id="L3975">		this.namespaceMgrApi.getDbHandler().store(namespace);</span>

		// Register metaClasses
<span class="nc" id="L3978">		ClassManagerDB classMgrDbHandler = this.classMgrApi.getDbHandler();</span>
<span class="nc" id="L3979">		Set&lt;String&gt; metaClassesToInstall = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3980">		Map&lt;NamespaceID, Namespace&gt; namespaceInfos = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3981">		namespaceInfos.put(namespace.getDataClayID(), namespace);</span>
<span class="nc bnc" id="L3982" title="All 2 branches missed.">		for (MetaClass metaClass : classesToRegister) {</span>
<span class="nc" id="L3983">			classMgrDbHandler.storeMetaClass(metaClass);</span>
<span class="nc" id="L3984">			metaClassesToInstall.add(metaClass.getName());</span>
<span class="nc" id="L3985">		}</span>
		// Outsource classes to dataservices
<span class="nc" id="L3987">		Langs language = namespace.getLanguage();</span>
<span class="nc bnc" id="L3988" title="All 2 branches missed.">		if (language == Langs.LANG_JAVA) {</span>
<span class="nc" id="L3989">			outsourceClassesDeploymentJava(classesToRegister, metaClassesToInstall, namespaceInfos,</span>
					null, null);
<span class="nc bnc" id="L3991" title="All 2 branches missed.">		} else if (language == Langs.LANG_PYTHON) {</span>
<span class="nc" id="L3992">			outsourceClassesDeploymentPython(classesToRegister, metaClassesToInstall, namespaceInfos,</span>
					null, null);
		}
<span class="nc" id="L3995">	}</span>

	@Override
	public void federateObject(final SessionID sessionID, final ObjectID objectID,
			final DataClayInstanceID extDataClayID, final boolean recursive) {
<span class="nc" id="L4000">		final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4001">		objectIDs.add(objectID);</span>
<span class="nc" id="L4002">		federateObjectsInternal(sessionID, objectIDs, extDataClayID, recursive);</span>
<span class="nc" id="L4003">	}</span>

	/**
	 * Internal function that federates objects provided with external dataclay specified. 
	 * @param sessionID ID of session executing the action
	 * @param objectIDs IDs of objects to federate
	 * @param extDataClayID ID of dataclay to federate objects with
	 * @param recursive Indicates if sub-objects of objects with id provided should be also federated.
	 */
	private void federateObjectsInternal(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs, 
			final DataClayInstanceID extDataClayID, final boolean recursive) { 
		try {
<span class="nc" id="L4015">			final Map&lt;ObjectID, MetaDataInfo&gt; objectsInfo = new HashMap&lt;&gt;();</span>

			// Check access to external dataClay
<span class="nc" id="L4018">			final DataClayInstance dcInfo = getExternalDataClayInfo(extDataClayID);</span>
<span class="nc bnc" id="L4019" title="All 2 branches missed.">			if (dcInfo == null) {</span>
<span class="nc" id="L4020">				LOGGER.warn(&quot;dataClay instance {} is not registered&quot;, extDataClayID);</span>
<span class="nc" id="L4021">				throw new DataClayException(ERRORCODE.EXTERNAL_DATACLAY_NOT_REGISTERED,</span>
						&quot;dataClay instance: &quot; + extDataClayID + &quot;, is not registered&quot;, false);
			}

<span class="nc bnc" id="L4025" title="All 2 branches missed.">			for (final ObjectID objectID : objectIDs) {</span>

				// ======================== IF NOT THE OWNER, DELEGATE ========================= //

				// Check if object belongs to current dataClay
<span class="nc" id="L4030">				final DataClayInstanceID ownerDataClayID = getExternalSourceDataClayOfObject(objectID);</span>
<span class="nc bnc" id="L4031" title="All 2 branches missed.">				if (ownerDataClayID != null) {</span>
<span class="nc" id="L4032">					final DataClayInstance ownerDataClay = metaDataSrvApi.getExternalDataClayInfo(ownerDataClayID);</span>

					// this object belongs to another dataClay, delegate it
<span class="nc" id="L4035">					LOGGER.info(&quot;Calling owner dataClay {} to federate {}&quot;, extDataClayID, objectID);</span>

					// Get external dataClay
<span class="nc" id="L4038">					final LogicModuleAPI ownerLogicModule = getExternalLogicModule(ownerDataClay);</span>
					try {
<span class="nc" id="L4040">						ownerLogicModule.federateObject(null, objectID, extDataClayID, recursive);</span>
<span class="nc" id="L4041">					} catch (final DataClayException dce) {</span>
<span class="nc bnc" id="L4042" title="All 2 branches missed.">						if (dce.getErrorcode().equals(ERRORCODE.EXTERNAL_DATACLAY_NOT_REGISTERED)) {</span>
							// First notify registration of external dataClay
<span class="nc bnc" id="L4044" title="All 2 branches missed.">							if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4045">								LOGGER.debug(&quot;Owner dataClay does not know external dataClay {}, register it first&quot;,</span>
										dcInfo);
							}
<span class="nc bnc" id="L4048" title="All 2 branches missed.">							for (int i = 0; i &lt; dcInfo.getHosts().length; ++i) {</span>
<span class="nc" id="L4049">								ownerLogicModule.notifyRegistrationOfExternalDataClay(extDataClayID, dcInfo.getHosts()[i],</span>
<span class="nc" id="L4050">										dcInfo.getPorts()[i]);</span>
							}
<span class="nc bnc" id="L4052" title="All 2 branches missed.">							if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4053">								LOGGER.debug(&quot;Retrying federation of object {} to external dataClay {}&quot;, objectID,</span>
										extDataClayID);
							}
							// Retry federation
<span class="nc" id="L4057">							ownerLogicModule.federateObject(null, objectID, extDataClayID, recursive);</span>

						} else {
<span class="nc" id="L4060">							throw dce;</span>
						}

<span class="nc" id="L4063">					}</span>
<span class="nc" id="L4064">					continue; //skip this object</span>
				}

				// =================== I'M THE OWNER. CHECK IF ALREADY FEDERATED ===================== //

<span class="nc bnc" id="L4069" title="All 2 branches missed.">				if (metaDataSrvApi.checkIsFederatedWith(objectID, extDataClayID)) { </span>
<span class="nc bnc" id="L4070" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4071">						LOGGER.debug(&quot;Object &quot; + objectID + &quot; is already federated. Skipping.&quot;);</span>
					}
					continue;
				}


				// ==================================================================== //
<span class="nc" id="L4078">				LOGGER.info(&quot;Starting federate object {} with ext dataClay {}&quot;, objectID, extDataClayID);</span>

				// Get object metadata
<span class="nc" id="L4081">				MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4082" title="All 2 branches missed.">				if (metadataInfo == null) {</span>
<span class="nc bnc" id="L4083" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4084">						LOGGER.debug(&quot;Object {} not registered&quot;, objectID);</span>
					}
<span class="nc" id="L4086">					throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
				}

				// Check session
<span class="nc bnc" id="L4090" title="All 4 branches missed.">				if (Configuration.Flags.CHECK_SESSION.getBooleanValue() &amp;&amp; sessionID != null) {</span>
<span class="nc" id="L4091">					final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
					// Check dataset
<span class="nc bnc" id="L4093" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4094">						LOGGER.debug(&quot;Check dataset is among datacontract for object &quot; + objectID);</span>
					}
<span class="nc" id="L4096">					checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
				}



				// Get objects info
<span class="nc" id="L4102">				objectsInfo.put(objectID, metadataInfo);</span>
				// If recursive, get associated object IDs and their info
<span class="nc bnc" id="L4104" title="All 2 branches missed.">				if (recursive) {</span>
<span class="nc bnc" id="L4105" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4106">						LOGGER.debug(&quot;Getting referenced object ids from {}&quot;, objectID);</span>
					}
<span class="nc" id="L4108">					final DataServiceAPI dsAPI = getExecutionEnvironmentAPI(</span>
<span class="nc" id="L4109">							metadataInfo.getLocations().values().iterator().next());</span>
<span class="nc" id="L4110">					final Set&lt;ObjectID&gt; setIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4111">					setIDs.add(objectID);</span>

<span class="nc" id="L4113">					final Set&lt;ObjectID&gt; otherIDs = dsAPI.getReferencedObjectsIDs(sessionID, setIDs);</span>
<span class="nc" id="L4114">					otherIDs.remove(objectID);</span>
<span class="nc bnc" id="L4115" title="All 2 branches missed.">					for (final ObjectID oid : otherIDs) {</span>
<span class="nc" id="L4116">						metadataInfo = getObjectMetadata(oid);</span>
<span class="nc" id="L4117">						objectsInfo.put(oid, metadataInfo);</span>
<span class="nc" id="L4118">					}</span>
				}	
<span class="nc" id="L4120">			}</span>

<span class="nc bnc" id="L4122" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4123">				LOGGER.debug(&quot;Registering objects&quot;);</span>
			}
			// Register objects 
<span class="nc bnc" id="L4126" title="All 2 branches missed.">			for (final ObjectID objectID : objectsInfo.keySet()) { </span>
<span class="nc bnc" id="L4127" title="All 2 branches missed.">				if (!metaDataSrvApi.federateObjectWith(objectID, extDataClayID)) { </span>
<span class="nc bnc" id="L4128" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4129">						LOGGER.debug(&quot;ERROR: Object &quot; + objectID + &quot; federation registration failed.&quot;);</span>
					}
				}
<span class="nc" id="L4132">			}</span>
<span class="nc bnc" id="L4133" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4134">				LOGGER.debug(&quot;Notifying external dataClay&quot;);</span>
			}
			// ================= NOTIFY FEDERATION ===================== //
<span class="nc" id="L4137">			final LogicModuleAPI lmExternal = getExternalLogicModule(dcInfo);</span>
<span class="nc" id="L4138">			lmExternal.notifyFederatedObjects(publicIDs.dcID, this.hostname, this.port, objectsInfo, </span>
<span class="nc" id="L4139">					this.getFederatedObjectsInternal(extDataClayID, objectsInfo.keySet()));</span>

<span class="nc" id="L4141">		} catch (final DataClayException dex) {</span>
<span class="nc" id="L4142">			throw dex;</span>
<span class="nc" id="L4143">		} catch (final Exception ex) {</span>
<span class="nc" id="L4144">			LOGGER.warn(&quot;Exception while federating object&quot;, ex);</span>
<span class="nc" id="L4145">			throw new DataClayException(ERRORCODE.REQUEST_INTERRUPTED, ex.getMessage(), false);</span>
<span class="nc" id="L4146">		}</span>
<span class="nc" id="L4147">	}</span>

	@Override
	public void notifyFederatedObjects(final DataClayInstanceID srcDataClayID, final String srcDcHost,
			final int srcDcPort, final Map&lt;ObjectID, MetaDataInfo&gt; providedobjectsInfo, 
			final Map&lt;Langs, SerializedParametersOrReturn&gt; federatedObjects) {

		try {
<span class="nc bnc" id="L4155" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4156">				LOGGER.debug(&quot;[==Federation==] Notified federation of objects&quot;);</span>
			}

			// Register (if needed) the external dataClay federating objects with us
<span class="nc" id="L4160">			final DataClayInstance dcInfo = new DataClayInstance(srcDataClayID, srcDcHost, srcDcPort);</span>
<span class="nc" id="L4161">			metaDataSrvApi.registerExternalDataclay(dcInfo);</span>


			// Remove already existing objects 
<span class="nc" id="L4165">			final Set&lt;ObjectID&gt; gcObjectsToNotifyFedRef = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4166">			final Set&lt;ObjectID&gt; gcObjectsToNotifyAliasRef = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L4167" title="All 2 branches missed.">			for (final Entry&lt;Langs, SerializedParametersOrReturn&gt; curFederatedObjects : federatedObjects.entrySet()) { </span>

<span class="nc" id="L4169">				final Langs language = curFederatedObjects.getKey(); </span>
<span class="nc" id="L4170">				final SerializedParametersOrReturn objectsToSendToEE = curFederatedObjects.getValue();</span>
				// Store these objects in a backend
<span class="nc" id="L4172">				final DataSetID dsID = dataSetMgrApi.getDataSetID(EXTERNAL_OBJECTS_DATASET_NAME);</span>
<span class="nc bnc" id="L4173" title="All 2 branches missed.">				if (DEBUG_ENABLED) { </span>
<span class="nc" id="L4174">					LOGGER.debug(&quot;[==Federation==] Looking for random exec.environment of language &quot;, language);</span>
				}
<span class="nc" id="L4176">				final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; randomExecEnv =  this.getExecutionEnvironments(language).values().iterator().next();</span>
<span class="nc" id="L4177">				final ExecutionEnvironmentID execEnvID = randomExecEnv.getSecond().getDataClayID();</span>
<span class="nc" id="L4178">				final DataServiceAPI dsAPI = randomExecEnv.getFirst();</span>
<span class="nc" id="L4179">				final Set&lt;ExecutionEnvironmentID&gt; initBackends = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4180">				initBackends.add(execEnvID);</span>

<span class="nc" id="L4182">				final Set&lt;ObjectID&gt; oidsSend = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4183">				final Iterator&lt;Entry&lt;Integer, ObjectWithDataParamOrReturn&gt;&gt; it = objectsToSendToEE.getVolatileObjs().entrySet().iterator();</span>
<span class="nc bnc" id="L4184" title="All 2 branches missed.">				while (it.hasNext()) {</span>
<span class="nc" id="L4185">					final Entry&lt;Integer, ObjectWithDataParamOrReturn&gt; serializedVolatileEntry = it.next();</span>

					// === UPDATE HINTS === //
<span class="nc" id="L4188">					final Integer tag = serializedVolatileEntry.getKey();</span>
<span class="nc" id="L4189">					final ObjectWithDataParamOrReturn serializedVolatile = serializedVolatileEntry.getValue();</span>
<span class="nc" id="L4190">					final ObjectID oid = serializedVolatile.getObjectID();</span>
<span class="nc" id="L4191">					final DataClayObjectMetaData origMetaData = serializedVolatile.getMetaData();</span>
<span class="nc" id="L4192">					final Map&lt;Integer, ExecutionEnvironmentID&gt; hints = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4193">					hints.put(tag, execEnvID);</span>
<span class="nc" id="L4194">					origMetaData.setHints(hints);</span>
<span class="nc" id="L4195">					final MetaDataInfo metadataInfo = providedobjectsInfo.get(oid);</span>
<span class="nc" id="L4196">					final String alias = metadataInfo.getAlias();</span>
<span class="nc" id="L4197">					final MetaClassID classID = metadataInfo.getMetaclassID();</span>

					// === OBJECTS WITH ALIAS ALREADY PRESENT ARE IGNORED ==== //
<span class="nc" id="L4200">					boolean aliasExists = false;</span>
<span class="nc bnc" id="L4201" title="All 2 branches missed.">					if(alias != null) {</span>
						try {
<span class="nc bnc" id="L4203" title="All 2 branches missed.">							if (this.metaDataSrvApi.getObjectInfoFromAlias(alias) != null) {</span>
<span class="nc" id="L4204">								aliasExists = true;</span>
							}
<span class="nc" id="L4206">						} catch (final ObjectNotRegisteredException oe) {</span>
							// ignore
<span class="nc" id="L4208">						}</span>
					}

<span class="nc bnc" id="L4211" title="All 2 branches missed.">					if (aliasExists) { </span>
						// IMPORTANT NOTE: race-condition unfederation + federation we will find that alias is not 
						// registered but the object exists, so if the alias is registered it means that the object 
						// cannot actually be federated, it is not a race-condition. 
<span class="nc" id="L4215">						LOGGER.debug(&quot;[==Federation==] Ignoring federated object {} because alias {} already exists&quot;, oid, alias);</span>
<span class="nc" id="L4216">						it.remove();</span>
<span class="nc" id="L4217">						continue; //next</span>
					}

<span class="nc bnc" id="L4220" title="All 2 branches missed.">					if (metaDataSrvApi.externalObjectIsRegistered(oid)) { </span>
						// already registered properly. two federates called. ignoring. 
<span class="nc" id="L4222">						it.remove();</span>
<span class="nc" id="L4223">						continue;</span>
					}

					// === SANITY CHECKS ===
<span class="nc" id="L4227">					final Tuple&lt;String, String&gt; classNameAndNamespace = classMgrApi</span>
<span class="nc" id="L4228">							.getClassNameAndNamespace(classID);</span>
<span class="nc bnc" id="L4229" title="All 2 branches missed.">					if (classNameAndNamespace == null) {</span>
<span class="nc" id="L4230">						LOGGER.warn(&quot;[==Federation==] Found class {} is not registered during federation&quot;,</span>
								classID);
<span class="nc" id="L4232">						throw new DataClayException(ERRORCODE.CLASS_NOT_EXIST,</span>
								&quot;Class &quot; + classID + &quot; not registered&quot;, false);
					}
<span class="nc bnc" id="L4235" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4236">						LOGGER.debug(&quot;[==Federation==] Registering external object metadata for {} from source dataClay {}&quot;,</span>
								oid, srcDataClayID);
					}

					// object must be send
<span class="nc" id="L4241">					oidsSend.add(oid);</span>
<span class="nc" id="L4242">					gcObjectsToNotifyFedRef.add(oid);</span>
<span class="nc bnc" id="L4243" title="All 2 branches missed.">					if (alias != null) {</span>
<span class="nc" id="L4244">						gcObjectsToNotifyAliasRef.add(oid);</span>
					}
					// === REGISTER OBJECT AS EXTERNAL ===

<span class="nc bnc" id="L4248" title="All 2 branches missed.">					if (metaDataSrvApi.externalObjectIsUnregistered(oid)) { </span>
						// already exists but pending to unregister, set pending to false
<span class="nc" id="L4250">						metaDataSrvApi.markExternalObjectAsRegistered(oid);</span>
					} else { 
<span class="nc" id="L4252">						metaDataSrvApi.registerExternalObject(oid, srcDataClayID);</span>
					}

					// === REGISTER METADATA ===
<span class="nc bnc" id="L4256" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4257">						LOGGER.debug(&quot;[==Federation==] Registering federated object with alias: &quot; + alias + &quot; and class: &quot; + classID);</span>
					}
<span class="nc" id="L4259">					metaDataSrvApi.registerObject(oid, classID, dsID, initBackends, false, alias, language, new AccountID(srcDataClayID.getId()));</span>
<span class="nc" id="L4260">				}</span>

<span class="nc bnc" id="L4262" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4263">					LOGGER.debug(&quot;[==Federation==] Calling federate to EE, objects: &quot;, oidsSend);</span>
				}

				// === SEND OBJECT ===
<span class="nc" id="L4267">				dsAPI.federate(LogicModule.federationSessionID, objectsToSendToEE);</span>
<span class="nc" id="L4268">			}</span>

			// Notify alias and federation reference references
<span class="nc" id="L4271">			final Map&lt;ObjectID, Integer&gt; referenceCounting = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4272" title="All 2 branches missed.">			for (final ObjectID curoid : providedobjectsInfo.keySet()) {</span>
<span class="nc" id="L4273">				int counter = 0; </span>
<span class="nc bnc" id="L4274" title="All 2 branches missed.">				if (gcObjectsToNotifyAliasRef.contains(curoid)) {</span>
<span class="nc" id="L4275">					counter++;</span>
				}
<span class="nc bnc" id="L4277" title="All 2 branches missed.">				if (gcObjectsToNotifyFedRef.contains(curoid)) { </span>
<span class="nc" id="L4278">					counter++;</span>
				}
<span class="nc bnc" id="L4280" title="All 2 branches missed.">				if (counter &gt; 0) {</span>
<span class="nc" id="L4281">					referenceCounting.put(curoid, counter); // +1 reference in alias +1 federation ref.</span>
				} 
<span class="nc" id="L4283">			}</span>
			// ====================== NOTIFYING REFERENCE COUNTING ================= //
<span class="nc bnc" id="L4285" title="All 2 branches missed.">			if (!referenceCounting.isEmpty()) { </span>
<span class="nc" id="L4286">				this.notifyGarbageCollectors(referenceCounting);</span>
			}

<span class="nc" id="L4289">		} catch (final Exception exec) {</span>
<span class="nc" id="L4290">			LOGGER.debug(&quot;Exception while notifying federated object&quot;, exec);</span>
<span class="nc" id="L4291">			throw exec;</span>
<span class="nc" id="L4292">		}</span>
<span class="nc" id="L4293">	}</span>

	/**
	 * Get serialized data of objects to federate
	 * @param extDataClayID ID of dataclay
	 * @param objectsIDs IDs of objects to federate
	 * @return Serialized objects to federate, sepparated by language
	 */
	private Map&lt;Langs, SerializedParametersOrReturn&gt; getFederatedObjectsInternal(final DataClayInstanceID extDataClayID,
			final Set&lt;ObjectID&gt; objectsIDs) {
		try {
<span class="nc bnc" id="L4304" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4305">				LOGGER.debug(&quot;[==Federation==] Starting get federated objects of {}&quot;, objectsIDs);</span>
			}
<span class="nc" id="L4307">			final Map&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; objectsByLocation = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4308" title="All 2 branches missed.">			for (final ObjectID oid : objectsIDs) {</span>
<span class="nc" id="L4309">				final MetaDataInfo mdInfo = metaDataSrvApi.getObjectMetaData(oid);</span>
<span class="nc bnc" id="L4310" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4311">					LOGGER.debug(&quot;[==Federation==] Obtained metadainfo for object {}&quot;, oid);</span>
				}
<span class="nc" id="L4313">				final ExecutionEnvironment backend = mdInfo.getLocations().values().iterator().next();</span>
<span class="nc" id="L4314">				Set&lt;ObjectID&gt; oids = objectsByLocation.get(backend);</span>
<span class="nc bnc" id="L4315" title="All 2 branches missed.">				if (oids == null) {</span>
<span class="nc" id="L4316">					oids = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4317">					objectsByLocation.put(backend, oids);</span>
				}
<span class="nc" id="L4319">				oids.add(oid);</span>
<span class="nc" id="L4320">			}</span>
<span class="nc" id="L4321">			final Map&lt;Langs, SerializedParametersOrReturn&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4322">			final Map&lt;Langs, List&lt;ObjectWithDataParamOrReturn&gt;&gt; serializedObjectsPerLang = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4323" title="All 2 branches missed.">			for (final Entry&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; entry : objectsByLocation.entrySet()) {</span>
<span class="nc bnc" id="L4324" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4325">					LOGGER.debug(&quot;[==Federation==] Calling get in EE for objects {}&quot;, entry.getValue());</span>
				}
<span class="nc" id="L4327">				final ExecutionEnvironment execEnv = entry.getKey();</span>
<span class="nc" id="L4328">				final Langs execEnvLang = execEnv.getLang();</span>
<span class="nc" id="L4329">				final DataServiceAPI dsAPI = getExecutionEnvironmentAPI(execEnv);</span>

<span class="nc" id="L4331">				List&lt;ObjectWithDataParamOrReturn&gt; serObjs = serializedObjectsPerLang.get(execEnvLang);</span>
<span class="nc bnc" id="L4332" title="All 2 branches missed.">				if (serObjs == null) { </span>
<span class="nc" id="L4333">					serObjs = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L4334">					serializedObjectsPerLang.put(execEnvLang, serObjs);</span>
				}

<span class="nc" id="L4337">				final List&lt;ObjectWithDataParamOrReturn&gt; curSerObjs = dsAPI.getFederatedObjects(extDataClayID, entry.getValue());</span>
				// remove hints
<span class="nc bnc" id="L4339" title="All 2 branches missed.">				for (final ObjectWithDataParamOrReturn serializedVolatile : curSerObjs) { </span>
<span class="nc" id="L4340">					final DataClayObjectMetaData origMetaData = serializedVolatile.getMetaData();</span>
<span class="nc" id="L4341">					origMetaData.setHints(new HashMap&lt;Integer, ExecutionEnvironmentID&gt;());</span>
<span class="nc" id="L4342">				}</span>
<span class="nc" id="L4343">				serObjs.addAll(curSerObjs);</span>
<span class="nc" id="L4344">			}</span>

<span class="nc bnc" id="L4346" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4347">				LOGGER.debug(&quot;[==Federation==] Finished get federated objects&quot;);</span>
			}

<span class="nc bnc" id="L4350" title="All 2 branches missed.">			for (final Entry&lt;Langs, List&lt;ObjectWithDataParamOrReturn&gt;&gt; curSerObjs : serializedObjectsPerLang.entrySet()) { </span>
<span class="nc" id="L4351">				final Langs language = curSerObjs.getKey();</span>
<span class="nc" id="L4352">				final List&lt;ObjectWithDataParamOrReturn&gt; serObjs = curSerObjs.getValue();</span>
				// only one entry per language
<span class="nc" id="L4354">				result.put(language, new SerializedParametersOrReturn(serObjs));</span>
<span class="nc" id="L4355">			}</span>

<span class="nc" id="L4357">			return result; </span>

<span class="nc" id="L4359">		} catch (final Exception exec) {</span>
<span class="nc" id="L4360">			LOGGER.debug(&quot;Exception while getting federated object&quot;, exec);</span>
<span class="nc" id="L4361">			throw exec;</span>
		}
	}

	@Override
	public boolean checkObjectIsFederatedWithDataClayInstance(final ObjectID objectID,
			final DataClayInstanceID extDataClayID) {
<span class="nc bnc" id="L4368" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4369">			LOGGER.debug(&quot;[==Federation==] Checking if object {} is federated with dataClay {}&quot;, objectID,</span>
					extDataClayID);
		}
<span class="nc" id="L4372">		final boolean isFederated = metaDataSrvApi.checkIsFederatedWith(objectID, extDataClayID);</span>
<span class="nc bnc" id="L4373" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4374">			LOGGER.debug(&quot;[==Federation==] Object {} is federated with dataClay {}: {}&quot;, objectID, extDataClayID,</span>
<span class="nc" id="L4375">					isFederated);</span>
		}
<span class="nc" id="L4377">		return isFederated;</span>
	}

	@Override
	public void unfederateObject(final SessionID sessionID, final ObjectID objectID,
			final DataClayInstanceID extDataClayID, final boolean recursive) {

<span class="nc bnc" id="L4384" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4385">			LOGGER.debug(&quot;Starting unfederate object &quot; + objectID);</span>
		}
<span class="nc" id="L4387">		final Set&lt;DataClayInstanceID&gt; dcInfos = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4388">		final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;(); </span>
<span class="nc" id="L4389">		objectIDs.add(objectID);</span>
<span class="nc" id="L4390">		dcInfos.add(extDataClayID);</span>
<span class="nc" id="L4391">		unfederateObjectsInternal(sessionID, objectIDs, dcInfos, recursive);</span>

<span class="nc" id="L4393">	}</span>

	@Override 
	public void unfederateObjectWithAllDCs(final SessionID sessionID, final ObjectID objectID, 
			final boolean recursive) { 
<span class="nc bnc" id="L4398" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4399">			LOGGER.debug(&quot;Starting unfederate object with all external dataclays: &quot; + objectID);</span>
		}
<span class="nc" id="L4401">		final Set&lt;DataClayInstanceID&gt; dcInfos = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4402">		final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;(); </span>
<span class="nc" id="L4403">		objectIDs.add(objectID);</span>
<span class="nc" id="L4404">		dcInfos.addAll(metaDataSrvApi.getAllExternalDataClays());</span>
<span class="nc" id="L4405">		unfederateObjectsInternal(sessionID, objectIDs, dcInfos, recursive);</span>

<span class="nc" id="L4407">	}</span>

	@Override
	public void unfederateAllObjects(final SessionID sessionID,
			final DataClayInstanceID extDataClayID) { 
<span class="nc bnc" id="L4412" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4413">			LOGGER.debug(&quot;Starting unfederation of all objects belonging to &quot; + extDataClayID);</span>
		}
<span class="nc" id="L4415">		final Set&lt;ObjectID&gt; objectIDs = this.metaDataSrvApi.getObjectsFederatedWithDataClay(extDataClayID);</span>
<span class="nc" id="L4416">		final Set&lt;DataClayInstanceID&gt; dcInfos = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4417">		dcInfos.add(extDataClayID);</span>
<span class="nc" id="L4418">		unfederateObjectsInternal(sessionID, objectIDs, dcInfos, false);</span>
<span class="nc" id="L4419">	}</span>

	@Override
	public void unfederateAllObjectsWithAllDCs(final SessionID sessionID) { 
<span class="nc bnc" id="L4423" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4424">			LOGGER.debug(&quot;Starting unfederation of all objects with all dcs&quot;);</span>
		}
<span class="nc bnc" id="L4426" title="All 2 branches missed.">		for (final DataClayInstanceID curInstanceID : metaDataSrvApi.getAllExternalDataClays()) {</span>
<span class="nc" id="L4427">			unfederateAllObjects(sessionID, curInstanceID);</span>
<span class="nc" id="L4428">		}</span>
<span class="nc bnc" id="L4429" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4430">			LOGGER.debug(&quot;Finished unfederation of all objects with all dcs&quot;);</span>
		}
<span class="nc" id="L4432">	}</span>

	@Override
	public void migrateFederatedObjects(final SessionID sessionID,
			final DataClayInstanceID externalOriginDataClayID, 
			final DataClayInstanceID externalDestinationDataClayID) { 
<span class="nc bnc" id="L4438" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4439">			LOGGER.debug(&quot;[==Federation==] Migrating objects from {} to {}&quot;, externalOriginDataClayID, externalDestinationDataClayID);</span>
		}
<span class="nc" id="L4441">		final Set&lt;ObjectID&gt; objectIDs = this.metaDataSrvApi.getObjectsFederatedWithDataClay(externalOriginDataClayID);</span>

		// unfederate all objects from origin dataClay 
<span class="nc" id="L4444">		unfederateAllObjects(sessionID, externalOriginDataClayID); </span>

		// federate all of them to destination dataclay 
<span class="nc" id="L4447">		federateObjectsInternal(sessionID, objectIDs, externalDestinationDataClayID, false);</span>

<span class="nc" id="L4449">	}</span>

	@Override
	public void federateAllObjects(final SessionID sessionID,
			final DataClayInstanceID externalDestinationDataClayID) { 
<span class="nc bnc" id="L4454" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4455">			LOGGER.debug(&quot;[==Federation==] Federating all objects to {}&quot;, externalDestinationDataClayID);</span>
		}
<span class="nc" id="L4457">		final Set&lt;ObjectID&gt; objectsToFederate = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4458">		final Set&lt;ObjectID&gt; objectIDs = this.metaDataSrvApi.getAllObjectIDsRegistered();</span>
<span class="nc bnc" id="L4459" title="All 2 branches missed.">		for (final ObjectID objectID : objectIDs) {</span>
<span class="nc bnc" id="L4460" title="All 2 branches missed.">			if (!this.metaDataSrvApi.existsExternalObject(objectID)) { </span>
<span class="nc" id="L4461">				objectsToFederate.add(objectID);</span>
			}
<span class="nc" id="L4463">		}</span>
		// federate all of them to destination dataclay 
<span class="nc" id="L4465">		federateObjectsInternal(sessionID, objectsToFederate, externalDestinationDataClayID, false);</span>

<span class="nc" id="L4467">	}</span>

	/**
	 * Internal function to unfederate one or more objects
	 * @param sessionID ID of the session executing the unfederation
	 * @param objectIDs IDs of the object to unfederate
	 * @param extDataClayIDs All external dataclay instances the objects must be unfederated from 
	 * @param recursive Indicates all sub-objects of each object must be also unfederated from all provided dataclays.
	 */
	private void unfederateObjectsInternal(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs,
			final Set&lt;DataClayInstanceID&gt; extDataClayIDs, 
			final boolean recursive) { 

		/**
		 * NOTE: we group all calls in order to optimize resources
		 */

<span class="nc" id="L4484">		final Map&lt;DataClayInstanceID, Map&lt;ObjectID, MetaDataInfo&gt;&gt; myObjectsInfoPerDataClay = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4485">		final Map&lt;DataClayInstanceID, Map&lt;ObjectID, MetaDataInfo&gt;&gt; othersObjectsInfoPerDataClay = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4486">		final Map&lt;DataClayInstanceID, Set&lt;ObjectID&gt;&gt; allNotificationofObjectsInfoPerDataClay = new HashMap&lt;&gt;();</span>


<span class="nc bnc" id="L4489" title="All 2 branches missed.">		for (final ObjectID objectID : objectIDs) { </span>

			// ===== CHECK OBJECT IS FEDERATED BEFORE ==== //

			// owner dataClay will be null if current dataClay is not the owner
<span class="nc" id="L4494">			final DataClayInstanceID ownerDataClayID = getExternalSourceDataClayOfObject(objectID);</span>
<span class="nc bnc" id="L4495" title="All 2 branches missed.">			final boolean currentDataClayIsNotTheOwner = ownerDataClayID != null;</span>
<span class="nc" id="L4496">			boolean objectFederatedSomeExternalDCProvided = false;</span>
<span class="nc bnc" id="L4497" title="All 2 branches missed.">			for (final DataClayInstanceID extDataClayID : extDataClayIDs) {</span>
<span class="nc bnc" id="L4498" title="All 2 branches missed.">				if (currentDataClayIsNotTheOwner) { </span>
<span class="nc bnc" id="L4499" title="All 2 branches missed.">					if (metaDataSrvApi.externalObjectIsRegistered(objectID)) {</span>
<span class="nc" id="L4500">						objectFederatedSomeExternalDCProvided = true;</span>
<span class="nc" id="L4501">						break;</span>
					}
				} else { 
<span class="nc bnc" id="L4504" title="All 2 branches missed.">					if (metaDataSrvApi.checkIsFederatedWith(objectID, extDataClayID)) { </span>
<span class="nc" id="L4505">						objectFederatedSomeExternalDCProvided = true;</span>
<span class="nc" id="L4506">						break;</span>
					}
				}
<span class="nc" id="L4509">			}</span>
			// if object is not federated, skip also get references.
<span class="nc bnc" id="L4511" title="All 2 branches missed.">			if (!objectFederatedSomeExternalDCProvided) { </span>
<span class="nc" id="L4512">				continue;</span>
			}

			// =========================================== //

			// Get object metadata
<span class="nc" id="L4518">			MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4519" title="All 2 branches missed.">			if (metadataInfo == null) {</span>
<span class="nc" id="L4520">				throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
			}
			// Check session
<span class="nc bnc" id="L4523" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4524">				final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
				// Check dataset
<span class="nc bnc" id="L4526" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4527">					LOGGER.debug(&quot;Check dataset is among datacontract for object &quot; + objectID);</span>
				}
<span class="nc" id="L4529">				checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
			}
			// Get objects to notify
<span class="nc" id="L4532">			final Map&lt;ObjectID, MetaDataInfo&gt; objectsInfo = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4533">			objectsInfo.put(objectID, metadataInfo);</span>
			// If recursive, get associated object IDs and their info
<span class="nc bnc" id="L4535" title="All 2 branches missed.">			if (recursive) {</span>
<span class="nc" id="L4536">				final DataServiceAPI dsAPI = getExecutionEnvironmentAPI(</span>
<span class="nc" id="L4537">						metadataInfo.getLocations().values().iterator().next());</span>
<span class="nc" id="L4538">				final Set&lt;ObjectID&gt; setIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4539">				setIDs.add(objectID);</span>
<span class="nc" id="L4540">				final Set&lt;ObjectID&gt; otherIDs = dsAPI.getReferencedObjectsIDs(sessionID, setIDs);</span>
<span class="nc" id="L4541">				otherIDs.remove(objectID);</span>
<span class="nc bnc" id="L4542" title="All 2 branches missed.">				for (final ObjectID oid : otherIDs) {</span>
<span class="nc" id="L4543">					metadataInfo = getObjectMetadata(oid);</span>
<span class="nc" id="L4544">					objectsInfo.put(oid, metadataInfo);</span>
<span class="nc" id="L4545">				}</span>
			}	
<span class="nc bnc" id="L4547" title="All 2 branches missed.">			for (final ObjectID curObjectID : objectsInfo.keySet()) {</span>
<span class="nc bnc" id="L4548" title="All 2 branches missed.">				final boolean currentObjDataClayIsNotTheOwner = getExternalSourceDataClayOfObject(curObjectID) != null;</span>
<span class="nc bnc" id="L4549" title="All 2 branches missed.">				for (final DataClayInstanceID extDataClayID : extDataClayIDs) {</span>
<span class="nc bnc" id="L4550" title="All 2 branches missed.">					if (currentObjDataClayIsNotTheOwner) { </span>
<span class="nc" id="L4551">						Map&lt;ObjectID, MetaDataInfo&gt; othersObjectsInfo = othersObjectsInfoPerDataClay.get(extDataClayID);</span>
<span class="nc bnc" id="L4552" title="All 2 branches missed.">						if (othersObjectsInfo == null) { </span>
<span class="nc" id="L4553">							othersObjectsInfo = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4554">							othersObjectsInfoPerDataClay.put(extDataClayID, othersObjectsInfo);</span>
						}
<span class="nc" id="L4556">						othersObjectsInfo.put(curObjectID, metadataInfo);</span>
<span class="nc" id="L4557">					} else { </span>
<span class="nc" id="L4558">						Map&lt;ObjectID, MetaDataInfo&gt; myObjectsInfo = myObjectsInfoPerDataClay.get(extDataClayID);</span>
<span class="nc bnc" id="L4559" title="All 2 branches missed.">						if (myObjectsInfo == null) { </span>
<span class="nc" id="L4560">							myObjectsInfo = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4561">							myObjectsInfoPerDataClay.put(extDataClayID, myObjectsInfo);</span>
						}
<span class="nc" id="L4563">						myObjectsInfo.put(curObjectID, metadataInfo);</span>
					}
<span class="nc" id="L4565">					Set&lt;ObjectID&gt; objectsToNotify = allNotificationofObjectsInfoPerDataClay.get(extDataClayID);</span>
<span class="nc bnc" id="L4566" title="All 2 branches missed.">					if (objectsToNotify == null) { </span>
<span class="nc" id="L4567">						objectsToNotify = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4568">						allNotificationofObjectsInfoPerDataClay.put(extDataClayID, objectsToNotify);</span>
					}
<span class="nc" id="L4570">					objectsToNotify.add(curObjectID);</span>
<span class="nc" id="L4571">				}</span>
<span class="nc" id="L4572">			}</span>


<span class="nc" id="L4575">		}</span>

		// ========================= unfederation ======================== //

<span class="nc bnc" id="L4579" title="All 2 branches missed.">		for (final DataClayInstanceID extDataClayID : extDataClayIDs) {</span>
<span class="nc" id="L4580">			final DataClayInstance dcInfo = getExternalDataClayInfo(extDataClayID);</span>
<span class="nc bnc" id="L4581" title="All 2 branches missed.">			if (dcInfo == null) {</span>
<span class="nc" id="L4582">				LOGGER.warn(&quot;dataClay instance {} is not registered&quot;, extDataClayID);</span>
<span class="nc" id="L4583">				throw new DataClayException(ERRORCODE.EXTERNAL_DATACLAY_NOT_REGISTERED,</span>
						&quot;dataClay instance: &quot; + extDataClayID + &quot;, is not registered&quot;, false);
			}
<span class="nc" id="L4586">			final Map&lt;ObjectID, MetaDataInfo&gt; othersObjectsInfo = othersObjectsInfoPerDataClay.get(extDataClayID);</span>
<span class="nc" id="L4587">			final Map&lt;ObjectID, MetaDataInfo&gt; myObjectsInfo = myObjectsInfoPerDataClay.get(extDataClayID);</span>
<span class="nc" id="L4588">			final Set&lt;ObjectID&gt; objectsToNotify = allNotificationofObjectsInfoPerDataClay.get(extDataClayID);</span>
<span class="nc" id="L4589">			unfederateNotOwner(othersObjectsInfo, dcInfo);</span>
<span class="nc" id="L4590">			unfederateOwner(myObjectsInfo, dcInfo);</span>


			// ========================= NOTIFY PARTNER ======================== //
			// Propagate unfederation
			try {
<span class="nc bnc" id="L4596" title="All 4 branches missed.">				if (objectsToNotify != null &amp;&amp; !objectsToNotify.isEmpty()) {</span>
<span class="nc bnc" id="L4597" title="All 2 branches missed.">					if (DEBUG_ENABLED) { </span>
<span class="nc" id="L4598">						LOGGER.debug(&quot;Notifying dataClay {} for unfederating objects {} from {}&quot;, dcInfo, </span>
								objectsToNotify, publicIDs.dcID);
					}
<span class="nc" id="L4601">					final LogicModuleAPI lmExternal = getExternalLogicModule(dcInfo);</span>
<span class="nc" id="L4602">					lmExternal.notifyUnfederatedObjects(publicIDs.dcID, objectsToNotify);</span>
				}
<span class="nc" id="L4604">			} catch (final Exception anyEx) { </span>
<span class="nc" id="L4605">				LOGGER.warn(&quot;Notification of unfederation failed&quot;, anyEx);</span>
<span class="nc" id="L4606">			}</span>

<span class="nc" id="L4608">		}</span>

<span class="nc" id="L4610">	}</span>

	@Override
	public void notifyUnfederatedObjects(final DataClayInstanceID srcDataClayID, final Set&lt;ObjectID&gt; objectsIDs) {
		try {
<span class="nc bnc" id="L4615" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4616">				LOGGER.debug(&quot;[==Unfederation==] Notified unfederation of objects&quot;);</span>
			}
<span class="nc" id="L4618">			final DataClayInstance dcInfo = getExternalDataClayInfo(srcDataClayID);</span>
<span class="nc bnc" id="L4619" title="All 2 branches missed.">			if (dcInfo == null) {</span>
<span class="nc" id="L4620">				LOGGER.warn(&quot;dataClay instance {} is not registered&quot;, srcDataClayID);</span>
<span class="nc" id="L4621">				throw new DataClayException(ERRORCODE.EXTERNAL_DATACLAY_NOT_REGISTERED,</span>
						&quot;dataClay instance: &quot; + srcDataClayID + &quot;, is not registered&quot;, false);
			}

<span class="nc" id="L4625">			final Map&lt;ObjectID, MetaDataInfo&gt; myObjectsInfo = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4626">			final Map&lt;ObjectID, MetaDataInfo&gt; othersObjectsInfo = new HashMap&lt;&gt;();</span>

			// Unregister the external objects federated with us and check langs
<span class="nc bnc" id="L4629" title="All 2 branches missed.">			for (final ObjectID oid : objectsIDs) {</span>
<span class="nc" id="L4630">				final MetaDataInfo metadataInfo = getObjectMetadata(oid);</span>
<span class="nc" id="L4631">				final DataClayInstanceID ownerDataClayID = getExternalSourceDataClayOfObject(oid);</span>
<span class="nc bnc" id="L4632" title="All 2 branches missed.">				final boolean currentDataClayIsNotTheOwner = ownerDataClayID != null;</span>
<span class="nc bnc" id="L4633" title="All 2 branches missed.">				if (currentDataClayIsNotTheOwner) { </span>
<span class="nc" id="L4634">					othersObjectsInfo.put(oid, metadataInfo);</span>
				} else { 
<span class="nc" id="L4636">					myObjectsInfo.put(oid, metadataInfo);</span>
				}
<span class="nc" id="L4638">			}</span>

<span class="nc" id="L4640">			unfederateNotOwner(othersObjectsInfo, dcInfo);</span>
<span class="nc" id="L4641">			unfederateOwner(myObjectsInfo, dcInfo);</span>


<span class="nc" id="L4644">		} catch (final Exception exec) {</span>
<span class="nc" id="L4645">			LOGGER.debug(&quot;Exception while notifying unfederated object&quot;, exec);</span>
<span class="nc" id="L4646">			throw exec;</span>
<span class="nc" id="L4647">		}</span>

<span class="nc" id="L4649">	}</span>

	/**
	 * Unfederate objects for dataClays that are the owners of the objects
	 * @param objectsInfo Objects to unfederate
	 * @param externalDcInfo External dataClay to unfederate with
	 */
	private void unfederateOwner(final Map&lt;ObjectID, MetaDataInfo&gt; objectsInfo, final DataClayInstance externalDcInfo) { 
<span class="nc bnc" id="L4657" title="All 2 branches missed.">		if (objectsInfo == null) { </span>
<span class="nc" id="L4658">			return; //no objects to unfederate</span>
		}
<span class="nc" id="L4660">		final Iterator&lt;Entry&lt;ObjectID, MetaDataInfo&gt;&gt; it = objectsInfo.entrySet().iterator();</span>
<span class="nc bnc" id="L4661" title="All 2 branches missed.">		while (it.hasNext()) {</span>
<span class="nc" id="L4662">			final Entry&lt;ObjectID, MetaDataInfo&gt; curEntry = it.next();</span>
<span class="nc" id="L4663">			final ObjectID oid = curEntry.getKey();</span>
			// ========================= UNREGISTER ======================== //
<span class="nc bnc" id="L4665" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4666">				LOGGER.debug(&quot;Unfederating object &quot; + oid + &quot; from owner dataClay&quot;);</span>
			}
<span class="nc bnc" id="L4668" title="All 2 branches missed.">			if (!metaDataSrvApi.unfederateObjectWith(oid, externalDcInfo.getDcID())) {</span>
<span class="nc bnc" id="L4669" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4670">					LOGGER.debug(&quot;[==Unfederation==] Object is not federated with ext.dataclay &quot;</span>
							+ &quot;or was already unfederated. Skipping.&quot;);
				}
<span class="nc" id="L4673">				it.remove();</span>
			}

<span class="nc" id="L4676">		}</span>

<span class="nc" id="L4678">	}</span>

	/**
	 * Unfederate objects for dataClays that are not the owners of the objects
	 * @param objectsInfo Objects to unfederate
	 * @param externalDcInfo External dataClay to unfederate with
	 */
	private void unfederateNotOwner(final Map&lt;ObjectID, MetaDataInfo&gt; objectsInfo, final DataClayInstance externalDcInfo) { 
<span class="nc bnc" id="L4686" title="All 2 branches missed.">		if (objectsInfo == null) { </span>
<span class="nc" id="L4687">			return; //no objects to unfederate</span>
		}
<span class="nc" id="L4689">		final Iterator&lt;Entry&lt;ObjectID, MetaDataInfo&gt;&gt; it = objectsInfo.entrySet().iterator();</span>
<span class="nc" id="L4690">		final Map&lt;ObjectID, Integer&gt; referenceCounting = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4691">		final Map&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; objectsToUnfederatePerEE = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4692" title="All 2 branches missed.">		while (it.hasNext()) {</span>
<span class="nc" id="L4693">			final Entry&lt;ObjectID, MetaDataInfo&gt; curEntry = it.next();</span>
<span class="nc" id="L4694">			final ObjectID oid = curEntry.getKey();</span>
<span class="nc" id="L4695">			final MetaDataInfo metadataInfo = curEntry.getValue();</span>
			// ========================= UNREGISTER ======================== //
			// check if object is federated
<span class="nc bnc" id="L4698" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4699">				LOGGER.debug(&quot;Unfederating object &quot; + oid + &quot; from not-owner dataClay&quot;);</span>
			}
<span class="nc bnc" id="L4701" title="All 2 branches missed.">			if (metaDataSrvApi.externalObjectIsRegistered(oid)) {</span>

				// unregister external object
<span class="nc" id="L4704">				metaDataSrvApi.markExternalObjectAsUnregistered(oid);</span>

				// ========================= CALL WHEN UNFEDERATED IF NOT THE OWNER ======================== //
<span class="nc bnc" id="L4707" title="All 2 branches missed.">				for (final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locationEntry : metadataInfo.getLocations()</span>
<span class="nc" id="L4708">						.entrySet()) {</span>
<span class="nc" id="L4709">					final ExecutionEnvironment execEnv = locationEntry.getValue();</span>
<span class="nc" id="L4710">					Set&lt;ObjectID&gt; objToUnfederateInThisEE = objectsToUnfederatePerEE.get(execEnv);</span>
<span class="nc bnc" id="L4711" title="All 2 branches missed.">					if (objToUnfederateInThisEE == null) { </span>
<span class="nc" id="L4712">						objToUnfederateInThisEE = new HashSet&lt;&gt;(); </span>
<span class="nc" id="L4713">						objectsToUnfederatePerEE.put(execEnv, objToUnfederateInThisEE);</span>
					}
<span class="nc" id="L4715">					objToUnfederateInThisEE.add(oid);</span>
<span class="nc" id="L4716">				}</span>
				// Call deleteAlias
<span class="nc" id="L4718">				int decrementRef = -1;</span>
<span class="nc" id="L4719">				final String alias = metadataInfo.getAlias();</span>
<span class="nc bnc" id="L4720" title="All 2 branches missed.">				if (alias != null) {</span>
<span class="nc bnc" id="L4721" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4722">						LOGGER.debug(&quot;[==Unfederation==] Calling delete alias {}&quot;, alias);</span>
					}
<span class="nc" id="L4724">					metaDataSrvApi.deleteAlias(alias);</span>
<span class="nc" id="L4725">					decrementRef--;</span>
				}
				// Notify federation reference references
<span class="nc" id="L4728">				referenceCounting.put(oid, decrementRef); // -1 federation ref. -1 alias </span>

<span class="nc" id="L4730">			} else { </span>
<span class="nc bnc" id="L4731" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4732">					LOGGER.debug(&quot;[==Unfederation==] Object is not federated with ext.dataclay &quot;</span>
							+ &quot;or was already unfederated. Skipping.&quot;);
				}
				// object already unfederated
<span class="nc" id="L4736">				it.remove();</span>
			}
<span class="nc" id="L4738">		}</span>
<span class="nc bnc" id="L4739" title="All 2 branches missed.">		for (final Entry&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; curEntry : objectsToUnfederatePerEE.entrySet()) { </span>
<span class="nc" id="L4740">			final ExecutionEnvironment execEnv = curEntry.getKey();</span>
<span class="nc" id="L4741">			final Set&lt;ObjectID&gt; objToUnfederateInThisEE = curEntry.getValue();</span>
<span class="nc" id="L4742">			final DataServiceAPI dsApi = this.getExecutionEnvironmentAPI(execEnv);</span>
<span class="nc bnc" id="L4743" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L4744">				LOGGER.debug(&quot;[==Unfederation==] Calling unfederate of objects to {}&quot;, execEnv);</span>
			}
<span class="nc" id="L4746">			dsApi.unfederate(federationSessionID, objToUnfederateInThisEE);</span>
<span class="nc" id="L4747">		}</span>

		// Notify federation reference references
<span class="nc" id="L4750">		this.notifyGarbageCollectors(referenceCounting);</span>

<span class="nc" id="L4752">	}</span>

	// ============== Data Service ==============//

	@Override
	public void setDataSetID(final SessionID sessionID, final ObjectID objectID, final DataSetID dataSetID) {
		// Check session exists if needed
<span class="nc bnc" id="L4759" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4760">			getSessionInfo(sessionID);</span>
		}
<span class="nc" id="L4762">		metaDataSrvApi.changeDataSetID(objectID, dataSetID);</span>
<span class="nc" id="L4763">	}</span>

	@Override
	public void setDataSetIDFromGarbageCollector(final ObjectID objectID, final DataSetID dataSetID) {
<span class="nc" id="L4767">		metaDataSrvApi.changeDataSetID(objectID, dataSetID);</span>
<span class="nc" id="L4768">	}</span>

	@Override
	public VersionInfo newVersion(final SessionID sessionID, final ObjectID objectID,
			final ExecutionEnvironmentID optionalDestBackendID) {
		
<span class="nc" id="L4774">		LOGGER.info(&quot;Starting new version for object &quot; + objectID);</span>

<span class="nc" id="L4776">		final VersionInfo result = new VersionInfo();</span>

		// Get object info
<span class="nc" id="L4779">		final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4780" title="All 2 branches missed.">		if (metadataInfo == null) {</span>
<span class="nc" id="L4781">			throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
		}

<span class="nc" id="L4784">		final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
		// Check session if needed
<span class="nc bnc" id="L4786" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
			// Check dataset
<span class="nc" id="L4788">			checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
		}

		// Get backend info of the destination
<span class="nc" id="L4792">		Tuple&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; destBackend = null;</span>
<span class="nc bnc" id="L4793" title="All 2 branches missed.">		if (optionalDestBackendID != null) {</span>
<span class="nc" id="L4794">			final ExecutionEnvironment backendDest = metaDataSrvApi.getExecutionEnvironmentInfo(optionalDestBackendID);</span>
<span class="nc" id="L4795">			destBackend = new Tuple&lt;&gt;(optionalDestBackendID, backendDest);</span>
<span class="nc" id="L4796">		} else {</span>
			// TODO We could think of better policies than random (jmarti 8 Jul 2013)
<span class="nc" id="L4798">			destBackend = metaDataSrvApi.getRandomExecutionEnvironmentInfo(sessionInfo.getLanguage());</span>
		}
		// Get the data service of the destination and call newVersion
<span class="nc" id="L4801">		final ExecutionEnvironment backend = destBackend.getSecond();</span>
<span class="nc" id="L4802">		final DataServiceAPI dataServiceApi = getExecutionEnvironmentAPI(backend);</span>
<span class="nc" id="L4803">		final Tuple&lt;ObjectID, Map&lt;ObjectID, ObjectID&gt;&gt; versionInfo = dataServiceApi.newVersion(sessionID,</span>
				objectID, metadataInfo);
		// Register all the versions in MDS and get the metadata of the original objects
		// (used in consolidate)
<span class="nc" id="L4807">		final Map&lt;ObjectID, MetaDataInfo&gt; originalMD = metaDataSrvApi.registerVersions(versionInfo.getSecond(),</span>
<span class="nc" id="L4808">				destBackend.getFirst(), sessionInfo.getLanguage());</span>
<span class="nc" id="L4809">		result.setVersionOID(versionInfo.getFirst());</span>
<span class="nc" id="L4810">		result.setVersionsMapping(versionInfo.getSecond());</span>
<span class="nc" id="L4811">		result.setLocID(backend.getDataClayID());</span>

		// Only add original MD since DS will recursively update others.
<span class="nc" id="L4814">		result.setOriginalMD(originalMD);</span>

		// Could not store version in the indicated backend, try another one
<span class="nc" id="L4817">		destBackend = metaDataSrvApi.getRandomExecutionEnvironmentInfo(sessionInfo.getLanguage());</span>

<span class="nc" id="L4819">		LOGGER.info(&quot;Finished new replica for object &quot; + objectID);</span>

<span class="nc" id="L4821">		return result;</span>
	}

	@Override
	public void consolidateVersion(final SessionID sessionID, final VersionInfo version) {
		// Get object md
<span class="nc" id="L4827">		LOGGER.info(&quot;Starting consolidate version for object &quot; + version);</span>

<span class="nc" id="L4829">		final MetaDataInfo versionMD = getObjectMetadata(version.getVersionOID());</span>

<span class="nc bnc" id="L4831" title="All 2 branches missed.">		if (versionMD == null) {</span>
<span class="nc" id="L4832">			throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST, null, true);</span>
		} else {
			// Check session if needed
<span class="nc bnc" id="L4835" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4836">				final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L4837">				final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>
<span class="nc" id="L4838">				checkDataSetAmongDataContracts(versionMD.getDatasetID(), sessionDataInfo);</span>
			}

			// Consolidate version where the complete version object is stored
<span class="nc" id="L4842">			final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locations = versionMD.getLocations();</span>
<span class="nc" id="L4843">			final ExecutionEnvironmentID execDestID = versionMD.getLocations().entrySet().iterator().next().getKey();</span>
<span class="nc" id="L4844">			final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; backendSrc = locations.entrySet().iterator()</span>
<span class="nc" id="L4845">					.next();</span>
<span class="nc" id="L4846">			DataServiceAPI dataServiceApi = getExecutionEnvironmentAPI(backendSrc.getValue());</span>
<span class="nc" id="L4847">			dataServiceApi.consolidateVersion(sessionID, version);</span>

			// Delete also the version metadata
<span class="nc bnc" id="L4850" title="All 2 branches missed.">			for (final Entry&lt;ObjectID, ObjectID&gt; versionToOriginal : version.getVersionsMapping().entrySet()) {</span>
<span class="nc" id="L4851">				metaDataSrvApi.unregisterObject(versionToOriginal.getKey());</span>
<span class="nc" id="L4852">			}</span>

			// Delete possible version replicas from the rest of backends
<span class="nc" id="L4855">			final ObjectID versionID = version.getVersionOID();</span>
<span class="nc bnc" id="L4856" title="All 2 branches missed.">			for (final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; currBackend : locations.entrySet()) {</span>
<span class="nc bnc" id="L4857" title="All 2 branches missed.">				if (!currBackend.getKey().equals(backendSrc.getKey())) {</span>
					// This backend is not where we consolidated the version, so the version must be
					// deleted from here
<span class="nc" id="L4860">					dataServiceApi = getExecutionEnvironmentAPI(currBackend.getValue());</span>
<span class="nc" id="L4861">					final Set&lt;ObjectID&gt; objectsToRemove = new HashSet&lt;&gt;();</span>
<span class="nc" id="L4862">					objectsToRemove.add(versionID);</span>
<span class="nc" id="L4863">					dataServiceApi.removeObjects(sessionID, objectsToRemove, true, false, execDestID);</span>
				}
<span class="nc" id="L4865">			}</span>
		}
		
<span class="nc" id="L4868">		LOGGER.info(&quot;Finished consolidate version for object &quot; + version);</span>

<span class="nc" id="L4870">	}</span>

	@Override
	public ExecutionEnvironmentID newReplica(final SessionID sessionID, final ObjectID objectID,
			final ExecutionEnvironmentID optionalDestBackendID, final boolean recursive) {
		
<span class="nc" id="L4876">		LOGGER.info(&quot;Starting new replica for object &quot; + objectID);</span>
		
<span class="nc" id="L4878">		ExecutionEnvironmentID result = null;</span>

		// Get object info
<span class="nc" id="L4881">		final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4882" title="All 2 branches missed.">		if (metadataInfo == null) {</span>
<span class="nc" id="L4883">			throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
		}

<span class="nc" id="L4886">		final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
		// Check session if needed
<span class="nc bnc" id="L4888" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
			// Check dataset
<span class="nc" id="L4890">			checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
		}

		// Check it is read-only
<span class="nc bnc" id="L4894" title="All 4 branches missed.">		if (Configuration.Flags.CHECK_READ_ONLY.getBooleanValue() &amp;&amp; !metadataInfo.getIsReadOnly()) {</span>
<span class="nc" id="L4895">			throw new DataClayRuntimeException(ERRORCODE.OBJECT_IS_NOT_READONLY);</span>
		}

		// Get backend info of the destination
<span class="nc" id="L4899">		Tuple&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; destBackend = null;</span>
<span class="nc bnc" id="L4900" title="All 2 branches missed.">		if (optionalDestBackendID != null) {</span>
			// We want to replicate even if the root object is in the destination backend,
			// since subobjects may not be there
<span class="nc" id="L4903">			final ExecutionEnvironment backendDest = metaDataSrvApi.getExecutionEnvironmentInfo(optionalDestBackendID);</span>
<span class="nc" id="L4904">			destBackend = new Tuple&lt;&gt;(optionalDestBackendID, backendDest);</span>
<span class="nc" id="L4905">		} else {</span>
<span class="nc" id="L4906">			final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; currentLocations = metadataInfo.getLocations();</span>
<span class="nc" id="L4907">			final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; allBackends = metaDataSrvApi</span>
<span class="nc" id="L4908">					.getAllExecutionEnvironmentsInfo(sessionInfo.getLanguage());</span>
<span class="nc bnc" id="L4909" title="All 2 branches missed.">			if (allBackends.size() &gt; currentLocations.size()) {</span>
<span class="nc" id="L4910">				boolean isDifferent = false;</span>
<span class="nc bnc" id="L4911" title="All 2 branches missed.">				while (!isDifferent) {</span>
<span class="nc" id="L4912">					destBackend = metaDataSrvApi.getRandomExecutionEnvironmentInfo(sessionInfo.getLanguage());</span>
<span class="nc bnc" id="L4913" title="All 2 branches missed.">					if (!currentLocations.containsKey(destBackend.getFirst())) {</span>
<span class="nc" id="L4914">						isDifferent = true;</span>
					}
				}
<span class="nc" id="L4917">			} else {</span>
				// throw new DataClayRuntimeException(ERRORCODE.NO_BACKEND_FOR_REPLICATION);
<span class="nc" id="L4919">				throw new DataClayRuntimeException(ERRORCODE.STORAGE_LOCATION_NOT_EXIST);</span>
			}
		}

		// Replica object from any of them
		// TODO We can also retry with different origin if the exception
		// becomes from it! (9 Jul 2013 jmarti)


<span class="nc" id="L4928">		DataServiceAPI dataServiceApi = getExecutionEnvironmentAPI(destBackend.getSecond());</span>
<span class="nc" id="L4929">		final Set&lt;ObjectID&gt; replicatedObjs = dataServiceApi.newReplica(sessionID, objectID, recursive);</span>
<span class="nc bnc" id="L4930" title="All 2 branches missed.">		for (final ObjectID replicatedObj : replicatedObjs) {</span>
<span class="nc" id="L4931">			metaDataSrvApi.registerReplica(replicatedObj, destBackend.getFirst());</span>
<span class="nc" id="L4932">		}</span>


		// Go to all DataServices to modify MDS cache
		// FIXME: do we need this?
<span class="nc bnc" id="L4937" title="All 2 branches missed.">		for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; api : getExecutionEnvironments(Langs.LANG_JAVA).values()) {</span>
<span class="nc" id="L4938">			dataServiceApi = api.getFirst();</span>
<span class="nc" id="L4939">			final HashMap&lt;ObjectID, MetaDataInfo&gt; mdInfos = new HashMap&lt;&gt;();</span>
<span class="nc" id="L4940">			final MetaDataInfo mdInfo = metaDataSrvApi.getObjectMetaData(objectID);</span>
<span class="nc" id="L4941">			mdInfos.put(objectID, mdInfo);</span>
			// Inform about the related registered objects to DS
<span class="nc" id="L4943">			dataServiceApi.newMetaData(mdInfos);</span>
<span class="nc" id="L4944">		}</span>

<span class="nc" id="L4946">		result = destBackend.getFirst();</span>
		
<span class="nc" id="L4948">		LOGGER.info(&quot;Finished new replica for object &quot; + objectID);</span>

<span class="nc" id="L4950">		return result;</span>

	}

	@Override
	public List&lt;ObjectID&gt; moveObject(final SessionID sessionID, final ObjectID objectID,
			final ExecutionEnvironmentID srcLocationID, final ExecutionEnvironmentID destLocationID,
			final boolean recursive) {

<span class="nc" id="L4959">		final List&lt;ObjectID&gt; allMovedObjects = new ArrayList&lt;&gt;();</span>
		try {
			// Get object info
<span class="nc" id="L4962">			final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L4963" title="All 2 branches missed.">			if (metadataInfo == null) {</span>
<span class="nc" id="L4964">				throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
			}

			// Check session if needed
<span class="nc bnc" id="L4968" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L4969">				final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L4970">				final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>

				// Check dataset
<span class="nc" id="L4973">				checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>
			}

			// Check object is present in srcBackend
<span class="nc" id="L4977">			final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locations = metaDataSrvApi</span>
<span class="nc" id="L4978">					.getObjectBackends(objectID);</span>
<span class="nc bnc" id="L4979" title="All 2 branches missed.">			if (!locations.containsKey(srcLocationID)) {</span>
<span class="nc" id="L4980">				throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_IN_BACKEND);</span>
			}

			// Move replica object from source to dest
<span class="nc" id="L4984">			final ExecutionEnvironment srcLoc = locations.get(srcLocationID);</span>

<span class="nc" id="L4986">			final DataServiceAPI dataServiceApi = getExecutionEnvironmentAPI(srcLoc);</span>
<span class="nc" id="L4987">			final Set&lt;ObjectID&gt; movedObjs = dataServiceApi.moveObjects(sessionID, objectID, destLocationID, recursive);</span>
<span class="nc" id="L4988">			allMovedObjects.addAll(movedObjs);</span>

			// Register the movement
<span class="nc" id="L4991">			final Map&lt;ObjectID, MetaDataInfo&gt; newMetaDatas = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L4992" title="All 2 branches missed.">			for (final ObjectID movedObjID : movedObjs) {</span>
				try {
<span class="nc" id="L4994">					metaDataSrvApi.migrateObjectToBackend(movedObjID, srcLocationID, destLocationID);</span>
<span class="nc" id="L4995">					final MetaDataInfo mdInfo = metaDataSrvApi.getObjectMetaData(objectID);</span>
<span class="nc" id="L4996">					newMetaDatas.put(objectID, mdInfo);</span>
<span class="nc" id="L4997">				} catch (final Exception ex) {</span>
<span class="nc" id="L4998">					LOGGER.debug(&quot;Error in moveObject, ignoring&quot;, ex);</span>
<span class="nc" id="L4999">					continue;</span>
<span class="nc" id="L5000">				}</span>
<span class="nc" id="L5001">			}</span>

			// Update all md Caches in ALL nodes
			/*
			 * for (Tuple&lt;DataServiceAPI, StorageLocation&gt; ds : getDsAPIs().values()) {
			 * ds.getFirst().newMetaData(newMetaDatas); }
			 */
<span class="nc" id="L5008">		} catch (final Exception ex) {</span>
<span class="nc" id="L5009">			LOGGER.debug(&quot;moveObject error&quot;, ex);</span>
<span class="nc" id="L5010">			throw ex;</span>
<span class="nc" id="L5011">		}</span>

<span class="nc" id="L5013">		return allMovedObjects;</span>
	}

	@Override
	public void setObjectReadOnly(final SessionID sessionID, final ObjectID objectID) {
		// Check session if needed
<span class="nc bnc" id="L5019" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L5020">			final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L5021">			final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>

			// Get object info
<span class="nc" id="L5024">			final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L5025" title="All 2 branches missed.">			if (metadataInfo == null) {</span>
<span class="nc" id="L5026">				throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
			}

			// Check dataset
<span class="nc" id="L5030">			checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>
		}

		// Perform op
<span class="nc" id="L5034">		metaDataSrvApi.setObjectReadOnly(objectID);</span>
<span class="nc" id="L5035">	}</span>

	@Override
	public void setObjectReadWrite(final SessionID sessionID, final ObjectID objectID) {
		// Check session if needed
<span class="nc bnc" id="L5040" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L5041">			final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L5042">			final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>

			// Get object info
<span class="nc" id="L5045">			final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L5046" title="All 2 branches missed.">			if (metadataInfo == null) {</span>
<span class="nc" id="L5047">				throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
			}

			// Check dataset
<span class="nc" id="L5051">			checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>
		}

		// Perform op
<span class="nc" id="L5055">		metaDataSrvApi.setObjectReadWrite(objectID);</span>

<span class="nc" id="L5057">	}</span>

	@Override
	public MetaDataInfo getMetadataByOID(final SessionID sessionID, final ObjectID objectID) {
		try {
			// Check session
<span class="nc" id="L5063">			SessionInfo sessionInfo = null;</span>
<span class="nc bnc" id="L5064" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L5065">				sessionInfo = getSessionInfo(sessionID);</span>
			}

			// Get object info
<span class="nc" id="L5069">			final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L5070" title="All 2 branches missed.">			if (metadataInfo == null) {</span>
				// In this case, return null instead of Exception for performance purposes
<span class="nc bnc" id="L5072" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L5073">					LOGGER.debug(&quot;[==GetMetadataByOID==] Object not found. Sending null.&quot;);</span>
				}
<span class="nc" id="L5075">				return null;</span>
			}
<span class="nc bnc" id="L5077" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L5078">				LOGGER.debug(&quot;[==GetMetadataByOID==] Object found. Sending &quot; + objectID + &quot; metadata with locations &quot;</span>
<span class="nc" id="L5079">						+ metadataInfo.getLocations().keySet());</span>
			}

			// Check dataset
<span class="nc bnc" id="L5083" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L5084">				checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionInfo.getSessionDataContracts());</span>
			}
<span class="nc" id="L5086">			return metadataInfo;</span>

<span class="nc" id="L5088">		} catch (final Exception ex) {</span>
<span class="nc" id="L5089">			LOGGER.debug(&quot;getMetadataByOID error&quot;, ex);</span>
<span class="nc" id="L5090">			throw ex;</span>
		}

	}

	@Override
	public MetaDataInfo getMetadataByOIDForDS(final ObjectID objectID) {
		try {
			// Get object info
<span class="nc" id="L5099">			final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc" id="L5100">			return metadataInfo;</span>

<span class="nc" id="L5102">		} catch (final Exception ex) {</span>
<span class="nc" id="L5103">			LOGGER.debug(&quot;getMetadataByOIDForDS error&quot;, ex);</span>
<span class="nc" id="L5104">			throw ex;</span>
		}

	}

	@Override
	public SerializedParametersOrReturn executeMethodOnTarget(final SessionID sessionID, final ObjectID objectID,
			final String operationSignature, final SerializedParametersOrReturn params,
			final ExecutionEnvironmentID backendID) {
		// Get object metadata
<span class="nc" id="L5114">		final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L5115" title="All 2 branches missed.">		if (metadataInfo == null) {</span>
<span class="nc" id="L5116">			return null;</span>
		}

		// Get model info
<span class="nc" id="L5120">		final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L5121">		final Map&lt;ContractID, SessionContract&gt; sessionModelInfo = sessionInfo.getSessionContracts();</span>

		// Check datasets in session
<span class="nc bnc" id="L5124" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L5125">			final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>
<span class="nc" id="L5126">			checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>
		}

		// Get method id from the class of object
<span class="nc" id="L5130">		final MetaClassID classID = metadataInfo.getMetaclassID();</span>
<span class="nc" id="L5131">		final OperationID opID = classMgrApi.getOperationID(classID, operationSignature);</span>

		// Find an implementation that matches with the operation signature for the
		// current session
<span class="nc" id="L5135">		ImplementationID remoteImplementationID = null;</span>
<span class="nc bnc" id="L5136" title="All 2 branches missed.">		for (final SessionContract sc : sessionModelInfo.values()) {</span>
<span class="nc bnc" id="L5137" title="All 2 branches missed.">			for (final SessionInterface si : sc.getSessionInterfaces().values()) {</span>
<span class="nc bnc" id="L5138" title="All 2 branches missed.">				for (final SessionOperation so : si.getSessionOperations().values()) {</span>
<span class="nc bnc" id="L5139" title="All 2 branches missed.">					if (so.getOperationID().equals(opID)) {</span>
<span class="nc" id="L5140">						remoteImplementationID = so.getSessionRemoteImplementation().getImplementationID();</span>
					}
<span class="nc" id="L5142">				}</span>
<span class="nc" id="L5143">			}</span>
<span class="nc" id="L5144">		}</span>

<span class="nc bnc" id="L5146" title="All 2 branches missed.">		if (remoteImplementationID != null) {</span>
<span class="nc" id="L5147">			return executeMethodOnTargetInternal(sessionID, remoteImplementationID, objectID, metadataInfo, params,</span>
					backendID);
		} else {
<span class="nc" id="L5150">			throw new DataClayRuntimeException(ERRORCODE.IMPLEMENTATION_NOT_EXIST);</span>
		}
	}

	/**
	 * Internal function for execute implementation.
	 * 
	 * @param origSession
	 *            ID of the original session corresponding to initial application
	 *            launcher
	 * @param remoteImplementationID
	 *            ID of the implementation executed
	 * @param objectID
	 *            ID of the object
	 * @param metadataInfo
	 *            Info of the object
	 * @param params
	 *            Parameters to the method
	 * @param targetBackend
	 *            Backend where the task must be executed
	 * @return Object resulting of the execution of the implementation (all of them
	 *         sepparately) @
	 */
	private SerializedParametersOrReturn executeMethodOnTargetInternal(final SessionID origSession,
			final ImplementationID remoteImplementationID, final ObjectID objectID, final MetaDataInfo metadataInfo,
			final SerializedParametersOrReturn params, final ExecutionEnvironmentID targetBackend) {

<span class="nc" id="L5177">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; backendss = metadataInfo.getLocations();</span>
<span class="nc bnc" id="L5178" title="All 2 branches missed.">		if (!backendss.containsKey(targetBackend)) {</span>
			// TODO Should we create a temporal replica of the object for the execution? (17
			// Apr 2015 jmarti)
<span class="nc" id="L5181">			throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_IN_BACKEND,</span>
					&quot;Object is not in the backend where the method has to be executed&quot;, false);
		}
<span class="nc" id="L5184">		final ExecutionEnvironment backend = backendss.get(targetBackend);</span>

		// Get the language for the current session
<span class="nc" id="L5187">		final Langs sessionLang = getSessionInfo(origSession).getLanguage();</span>

		// Execute the method
		// Limit retries depending on the current set of replicas of the object
<span class="nc" id="L5191">		SerializedParametersOrReturn resultObj = null;</span>
<span class="nc" id="L5192">		final DataServiceAPI dataSrvApi = getExecutionEnvironmentAPI(backend);</span>
<span class="nc" id="L5193">		resultObj = dataSrvApi.executeImplementation(objectID, remoteImplementationID, params, origSession);</span>

<span class="nc" id="L5195">		return resultObj;</span>

	}

	@Override
	public SerializedParametersOrReturn executeImplementation(final SessionID sessionID, final OperationID operationID,
			final Triple&lt;ImplementationID, ContractID, InterfaceID&gt; remoteImplementation, final ObjectID objectID,
			final SerializedParametersOrReturn params) {

		// ----------------- SESSION CHECKS ------------- //
		final MetaDataInfo metadataInfo;
		final SessionInfo sessionInfo;
<span class="nc bnc" id="L5207" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L5208">			final Tuple&lt;SessionInfo, MetaDataInfo&gt; checkedInfo = executionClientChecksAndGetInfo(sessionID, objectID,</span>
					remoteImplementation, operationID);
<span class="nc" id="L5210">			sessionInfo = checkedInfo.getFirst();</span>
<span class="nc" id="L5211">			metadataInfo = checkedInfo.getSecond();</span>
<span class="nc" id="L5212">		} else {</span>
<span class="nc" id="L5213">			sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L5214">			metadataInfo = getObjectMetadata(objectID);</span>
		}
<span class="nc bnc" id="L5216" title="All 2 branches missed.">		if (metadataInfo == null) {</span>
<span class="nc" id="L5217">			return null;</span>
		}

		// ------------------ EXECUTE ------------------ //

		// Get the language for the current session
<span class="nc" id="L5223">		final Langs sessionLang = sessionInfo.getLanguage();</span>

		// TODO: How should this be executed? in all backends or not? (jmarti 6 Apr
		// 2018)
<span class="nc" id="L5227">		final ImplementationID remoteImplementationID = remoteImplementation.getFirst();</span>
<span class="nc" id="L5228">		final SerializedParametersOrReturn result = executeImplementationInternal(sessionID, remoteImplementationID,</span>
				objectID, metadataInfo, params, sessionLang, false);

<span class="nc" id="L5231">		return result;</span>
	}

	/**
	 * Common method to perform basic checks when processing an execution request
	 * from a client stub.
	 * 
	 * @param sessionID
	 *            ID of the session
	 * @param objectID
	 *            ID of the object
	 * @param remoteImplementation
	 *            implementation to be executed
	 * @param operationID
	 *            ID of the operation to be executed
	 * @return Info of the session and metadata
	 * @throws RemoteException
	 *             if any error occurs
	 */
	private Tuple&lt;SessionInfo, MetaDataInfo&gt; executionClientChecksAndGetInfo(final SessionID sessionID,
			final ObjectID objectID, final Triple&lt;ImplementationID, ContractID, InterfaceID&gt; remoteImplementation,
			final OperationID operationID) {
<span class="nc" id="L5253">		final ImplementationID remoteImplementationID = remoteImplementation.getFirst();</span>
<span class="nc" id="L5254">		final ContractID contractID = remoteImplementation.getSecond();</span>
<span class="nc" id="L5255">		final InterfaceID interfaceID = remoteImplementation.getThird();</span>

		// TODO: Check if this method is still required (or methods calling this) (July
		// 2018 jmarti)

		// ---------------- SESSION CHECKS ------------------ //

		// Check session
<span class="nc" id="L5263">		final SessionInfo sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L5264">		final Map&lt;ContractID, SessionContract&gt; sessionModelInfo = sessionInfo.getSessionContracts();</span>
<span class="nc" id="L5265">		final Map&lt;DataContractID, SessionDataContract&gt; sessionDataInfo = sessionInfo.getSessionDataContracts();</span>

		// Check dataset
<span class="nc" id="L5268">		final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L5269" title="All 2 branches missed.">		if (metadataInfo == null) {</span>
<span class="nc" id="L5270">			throw new DataClayRuntimeException(ERRORCODE.OBJECT_NOT_EXIST);</span>
		}
<span class="nc" id="L5272">		checkDataSetAmongDataContracts(metadataInfo.getDatasetID(), sessionDataInfo);</span>

		// Check interface and contract of implementation with the session
<span class="nc" id="L5275">		final SessionContract sessionContract = sessionModelInfo.get(contractID);</span>
<span class="nc bnc" id="L5276" title="All 4 branches missed.">		if (sessionContract == null || sessionContract.getSessionInterfaces() == null</span>
<span class="nc bnc" id="L5277" title="All 2 branches missed.">				|| sessionContract.getSessionInterfaces().isEmpty()) {</span>
<span class="nc" id="L5278">			throw new DataClayRuntimeException(ERRORCODE.SESSION_DOES_NOT_MATCH_REQ);</span>
		}
<span class="nc" id="L5280">		final SessionInterface sessionInterface = sessionContract.getSessionInterfaces().get(interfaceID);</span>
<span class="nc bnc" id="L5281" title="All 2 branches missed.">		if (sessionInterface == null) {</span>
<span class="nc" id="L5282">			throw new DataClayRuntimeException(ERRORCODE.SESSION_DOES_NOT_MATCH_REQ);</span>
		}

		// Check interface can access the operation
<span class="nc" id="L5286">		final Map&lt;OperationID, SessionOperation&gt; sessionOperations = sessionInterface.getSessionOperations();</span>
<span class="nc" id="L5287">		final SessionOperation sessionOperation = sessionOperations.get(operationID);</span>
<span class="nc bnc" id="L5288" title="All 2 branches missed.">		if (sessionOperation == null) {</span>
<span class="nc" id="L5289">			throw new DataClayRuntimeException(ERRORCODE.OPERATION_NOT_IN_INTERFACE);</span>
		}
<span class="nc" id="L5291">		final SessionImplementation sessionImplementation = sessionOperation.getSessionRemoteImplementation();</span>
<span class="nc bnc" id="L5292" title="All 2 branches missed.">		if (!sessionImplementation.getImplementationID().equals(remoteImplementationID)) {</span>
<span class="nc" id="L5293">			throw new DataClayRuntimeException(ERRORCODE.INCOMPATIBLE_IMPLEMENTATION);</span>
		}
<span class="nc" id="L5295">		return new Tuple&lt;&gt;(sessionInfo, metadataInfo);</span>
	}

	/**
	 * Internal function for execute implementation.
	 * 
	 * @param origSession
	 *            ID of the original session corresponding to initial application
	 *            launcher
	 * @param remoteImplementationID
	 *            ID of the implementation executed
	 * @param objectID
	 *            ID of the object
	 * @param metadataInfo
	 *            Info of the object
	 * @param params
	 *            Parameters to the method
	 * @param sessionLang
	 *            Session language
	 * @param allBackends Execute in all backends (for replication purposes)
	 * @return Object resulting of the execution of the implementation (all of them,
	 *         sepparately) @
	 */
	private SerializedParametersOrReturn executeImplementationInternal(final SessionID origSession,
			final ImplementationID remoteImplementationID, final ObjectID objectID, final MetaDataInfo metadataInfo,
			final SerializedParametersOrReturn params, final Langs sessionLang,
			final boolean allBackends) {

		// Randomly select a backend to execute
		// TODO Define a better backend selection policy (10 Jul 2013 jmarti)
<span class="nc" id="L5325">		final Random rand = new Random();</span>
<span class="nc" id="L5326">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locations = metadataInfo.getLocations();</span>
		final Set&lt;ExecutionEnvironmentID&gt; backends;
<span class="nc bnc" id="L5328" title="All 2 branches missed.">		if (allBackends) {</span>
<span class="nc" id="L5329">			backends = locations.keySet();</span>
		} else {
<span class="nc" id="L5331">			final int index = rand.nextInt(locations.size());</span>
<span class="nc" id="L5332">			final ExecutionEnvironmentID backendID = locations.keySet()</span>
<span class="nc" id="L5333">					.toArray(new ExecutionEnvironmentID[locations.size()])[index];</span>
<span class="nc" id="L5334">			backends = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5335">			backends.add(backendID);</span>
		}

<span class="nc" id="L5338">		SerializedParametersOrReturn resultObj = null;</span>
<span class="nc bnc" id="L5339" title="All 2 branches missed.">		for (ExecutionEnvironmentID backendID : backends) {</span>
			// Execute the method
			// Limit retries depending on the current set of replicas of the object
<span class="nc" id="L5342">			final int maxRetries = Math.max(Configuration.Flags.MAX_EXECUTION_RETRIES.getShortValue(), locations.size());</span>
<span class="nc bnc" id="L5343" title="All 2 branches missed.">			for (short i = 1; i &lt;= maxRetries; i++) {</span>
				try {
<span class="nc" id="L5345">					final ExecutionEnvironment backend = locations.get(backendID);</span>
<span class="nc" id="L5346">					final DataServiceAPI dataSrvApi = getExecutionEnvironmentAPI(backend);</span>
<span class="nc bnc" id="L5347" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L5348">						final Set&lt;ImplementationID&gt; implementationIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5349">						implementationIDs.add(remoteImplementationID);</span>
<span class="nc bnc" id="L5350" title="All 2 branches missed.">						for (final Implementation impl : this.classMgrApi.getInfoOfImplementations(implementationIDs)</span>
<span class="nc" id="L5351">								.values()) {</span>
<span class="nc" id="L5352">							LOGGER.debug(&quot;Calling executeImplementation for object {} to  backend {}, method {}&quot;,</span>
<span class="nc" id="L5353">									objectID, backend, impl.getOpNameAndDescriptor());</span>
<span class="nc" id="L5354">						}</span>
					}

<span class="nc" id="L5357">					resultObj = dataSrvApi.executeImplementation(objectID, remoteImplementationID, params, origSession);</span>
<span class="nc" id="L5358">					break;</span>
<span class="nc" id="L5359">				} catch (final DataClayException nbEx) {</span>
<span class="nc bnc" id="L5360" title="All 4 branches missed.">					if (!allBackends &amp;&amp; i &lt; maxRetries) {</span>
<span class="nc" id="L5361">						final int index = rand.nextInt(locations.size());</span>
<span class="nc" id="L5362">						backendID = locations.keySet().toArray(new ExecutionEnvironmentID[locations.size()])[index];</span>
<span class="nc" id="L5363">						LOGGER.debug(&quot;Retrying execution on object {} onto backend {}&quot;, objectID, backendID);</span>
<span class="nc" id="L5364">					} else {</span>
<span class="nc" id="L5365">						LOGGER.debug(&quot;Aborting executeImplementation procedure&quot;, nbEx);</span>
<span class="nc" id="L5366">						throw nbEx;</span>
					}
				}
			}
<span class="nc" id="L5370">		}</span>
<span class="nc" id="L5371">		return resultObj;</span>
	}

	@Override
	public void synchronizeFederatedObject(final DataClayInstanceID extDataClayID, final ObjectID objectID,
			final ImplementationID implID, final SerializedParametersOrReturn params, final boolean allBackends) {
		// Check federated object (either federated with requester ext dataClay or
		// requester federated it with us)
<span class="nc" id="L5379">		LOGGER.debug(&quot;Starting synchronization of object {} from dataClay {}&quot;, objectID, extDataClayID);</span>
<span class="nc bnc" id="L5380" title="All 2 branches missed.">		if (!metaDataSrvApi.checkIsFederatedWith(objectID, extDataClayID)</span>
<span class="nc bnc" id="L5381" title="All 2 branches missed.">				&amp;&amp; !metaDataSrvApi.externalObjectIsRegistered(objectID)) {</span>
<span class="nc" id="L5382">			LOGGER.debug(&quot;Object {} is not federated from any dataClay and not federated to dataClay {}&quot;, objectID, extDataClayID);</span>
<span class="nc" id="L5383">			return;</span>
		}

		// Get object metadata
<span class="nc" id="L5387">		final MetaDataInfo mdInfo = getObjectMetadata(objectID);</span>

		Langs language;
		SessionInfo sessionInfo;
		try {
			// Try to reuse session
<span class="nc" id="L5393">			sessionInfo = sessionMgrApi.getExtSessionInfo(extDataClayID);</span>
<span class="nc" id="L5394">			language = sessionInfo.getLanguage();</span>
<span class="nc" id="L5395">		} catch (final Exception ex) {</span>
			// Create new session
<span class="nc" id="L5397">			final MetaClass mclass = classMgrApi.getClassInfo(mdInfo.getMetaclassID());</span>
<span class="nc" id="L5398">			final String nspace = mclass.getNamespace();</span>
<span class="nc" id="L5399">			language = namespaceMgrApi.getNamespaceLang(nspace);</span>
<span class="nc" id="L5400">			final Calendar endDate = Calendar.getInstance();</span>
<span class="nc" id="L5401">			endDate.add(Calendar.YEAR, 1);</span>
<span class="nc" id="L5402">			sessionInfo = sessionMgrApi.newExtSession(extDataClayID, new AccountID(extDataClayID.getId()), language,</span>
					endDate);
<span class="nc" id="L5404">		}</span>

		// Execute
<span class="nc" id="L5407">		LOGGER.debug(&quot;Calling execute of object {} from dataClay {} and language {}&quot;, objectID, extDataClayID,</span>
				language);
<span class="nc" id="L5409">		executeImplementationInternal(sessionInfo.getSessionID(), implID, objectID, mdInfo, params, language,</span>
				allBackends);
<span class="nc" id="L5411">	}</span>

	@Override
	public Set&lt;DataClayInstanceID&gt; getDataClaysObjectIsFederatedWith(final ObjectID objectID) {
<span class="nc" id="L5415">		return metaDataSrvApi.getDataClaysOurObjectIsFederatedWith(objectID);</span>
	}

	@Override
	public DataClayInstanceID getExternalSourceDataClayOfObject(final ObjectID objectID) {
<span class="nc" id="L5420">		return metaDataSrvApi.getExternalSourceDataClayOfObject(objectID);</span>
	}


	/**
	 * Method that executes an action in a certain object. This method is called
	 * from notification manager. Note that executions from this method have NO
	 * session.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param sessionID
	 *            ID of the session of who triggered action
	 * @param params
	 *            the serialized parameters for the operation
	 * @param opID
	 *            id of the operation to be executed
	 */
	public void executeNotificationAction(final ObjectID objectID, final SessionID sessionID,
			final SerializedParametersOrReturn params, final OperationID opID) {

		// TODO: Maybe we should check session here before waiting Data Service to do so
		// (July 2018 jmarti)

		// Get object metadata
<span class="nc" id="L5445">		final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>

		// Get implementation information, to serialize parameteres
<span class="nc" id="L5448">		final Operation op = this.classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L5449">		final Map&lt;String, Type&gt; paramTypes = op.getParams();</span>
<span class="nc" id="L5450">		final String[] paramsSignatures = new String[paramTypes.size()];</span>
<span class="nc" id="L5451">		final MetaClassID[] paramsClassIDs = new MetaClassID[paramTypes.size()];</span>
<span class="nc" id="L5452">		int idx = 0;</span>
<span class="nc bnc" id="L5453" title="All 2 branches missed.">		for (final Type paramType : paramTypes.values()) {</span>
<span class="nc" id="L5454">			paramsSignatures[idx] = paramType.getSignatureOrDescriptor();</span>
<span class="nc bnc" id="L5455" title="All 2 branches missed.">			if (paramType instanceof UserType) {</span>
<span class="nc" id="L5456">				final UserType uType = (UserType) paramType;</span>
<span class="nc" id="L5457">				paramsClassIDs[idx] = uType.getClassID();</span>
			}
<span class="nc" id="L5459">			idx++;</span>
<span class="nc" id="L5460">		}</span>

		// GET ANY IMPLEMENTATION
<span class="nc" id="L5463">		final ImplementationID implementationID = op.getImplementations().get(0).getDataClayID();</span>

		// ------------------ EXECUTE ------------------ //
<span class="nc" id="L5466">		executeImplementationInternal(sessionID, implementationID, objectID, metadataInfo, params, Langs.LANG_JAVA,</span>
				false);

<span class="nc" id="L5469">	}</span>

	/**
	 * Method that executes a filterMethod in a certain object without parameters.
	 * This method is called from notification manager. Note that executions from
	 * this method have NO session.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param sessionID
	 *            ID of the session of who triggered action
	 * @param params
	 *            the serialized parameters for the operation
	 * @param opID
	 *            id of the operation to be executed
	 * @return a boolean value with the result of the execution of the
	 *         implementation (all of them, separately)
	 */
	public boolean executeFilterMethod(final ObjectID objectID, final SessionID sessionID,
			final SerializedParametersOrReturn params, final OperationID opID) {
<span class="nc" id="L5489">		boolean filterMethodResult = true;</span>

		// TODO: Maybe we should check session info here instead of waiting to reach
		// Data Service backend checks (July 2018 jmarti)

<span class="nc" id="L5494">		final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
		// Get implementation information, to serialize parameteres
<span class="nc" id="L5496">		final Operation op = this.classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L5497">		final Map&lt;String, Type&gt; paramTypes = op.getParams();</span>
<span class="nc" id="L5498">		final String[] paramsSignatures = new String[paramTypes.size()];</span>
<span class="nc" id="L5499">		final MetaClassID[] paramsClassIDs = new MetaClassID[paramTypes.size()];</span>
<span class="nc" id="L5500">		int idx = 0;</span>
<span class="nc bnc" id="L5501" title="All 2 branches missed.">		for (final Type paramType : paramTypes.values()) {</span>
<span class="nc" id="L5502">			paramsSignatures[idx] = paramType.getSignatureOrDescriptor();</span>
<span class="nc bnc" id="L5503" title="All 2 branches missed.">			if (paramType instanceof UserType) {</span>
<span class="nc" id="L5504">				final UserType uType = (UserType) paramType;</span>
<span class="nc" id="L5505">				paramsClassIDs[idx] = uType.getClassID();</span>
			}
<span class="nc" id="L5507">			idx++;</span>
<span class="nc" id="L5508">		}</span>

		// GET ANY IMPLEMENTATION
<span class="nc" id="L5511">		final ImplementationID implementationID = op.getImplementations().get(0).getDataClayID();</span>

		// ------------------ EXECUTE ------------------ //
<span class="nc" id="L5514">		final SerializedParametersOrReturn result = executeImplementationInternal(sessionID, implementationID, objectID,</span>
				metadataInfo, params, Langs.LANG_JAVA, false);
<span class="nc" id="L5516">		filterMethodResult = DataClayDeserializationLib.deserializeReturnFilterMethod(result);</span>
<span class="nc" id="L5517">		return filterMethodResult;</span>
	}

	@Override
	public boolean isPrefetchingEnabled() {
<span class="nc" id="L5522">		return Configuration.Flags.PREFETCHING_ENABLED.getBooleanValue();</span>
	}

	@Override
	public boolean objectExistsInDataClay(final ObjectID objectID) {
<span class="nc bnc" id="L5527" title="All 2 branches missed.">		for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_JAVA).values()) {</span>
<span class="nc bnc" id="L5528" title="All 2 branches missed.">			if (elem.getFirst().exists(objectID)) {</span>
<span class="nc" id="L5529">				LOGGER.debug(&quot;Found object {} in execution environment {}&quot;, objectID, elem.getSecond().toString());</span>
<span class="nc" id="L5530">				return true;</span>
			}
<span class="nc" id="L5532">		}</span>
<span class="nc bnc" id="L5533" title="All 2 branches missed.">		for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; elem : getExecutionEnvironments(Langs.LANG_PYTHON).values()) {</span>
<span class="nc bnc" id="L5534" title="All 2 branches missed.">			if (elem.getFirst().exists(objectID)) {</span>
<span class="nc" id="L5535">				LOGGER.debug(&quot;Found object {} in execution environment {}&quot;, objectID, elem.getSecond().toString());</span>
<span class="nc" id="L5536">				return true;</span>
			}
<span class="nc" id="L5538">		}</span>
<span class="nc" id="L5539">		return false;</span>

	}

	/**
	 * Get owner of the object
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return Owner of the object
	 */
	public AccountID getOwner(final ObjectID objectID) {
<span class="nc" id="L5551">		final MetaDataInfo metadataInfo = getObjectMetadata(objectID);</span>
<span class="nc" id="L5552">		return metadataInfo.getOwnerID();</span>
	}

	/**
	 * Initialize session of owner's object.
	 * 
	 * @param ownerID
	 *            ID of the owner.
	 * @return Session ID
	 */
	public SessionID initializeSessionAsOwnerOfObject(final AccountID ownerID) {
<span class="nc" id="L5563">		final Set&lt;DataSetID&gt; dataSets = new HashSet&lt;&gt;();</span>
<span class="nc" id="L5564">		DataSetID dataSetForStore = null;</span>

		// Contracts in which account is applicant
<span class="nc" id="L5567">		final Map&lt;ContractID, Contract&gt; contracts = contractMgrApi.getContractIDsOfApplicant(ownerID);</span>
<span class="nc" id="L5568">		final Set&lt;ContractID&gt; contractIDs = new HashSet&lt;&gt;(contracts.keySet());</span>

		// Contracts in which account is owner
<span class="nc" id="L5571">		final Map&lt;ContractID, Contract&gt; contractsAsProvider = contractMgrApi.getContractIDsOfProvider(ownerID);</span>
<span class="nc" id="L5572">		contractIDs.addAll(contractsAsProvider.keySet());</span>

		// DataSets in which Account is applicant
<span class="nc" id="L5575">		final Map&lt;DataContractID, DataContract&gt; datacontracts = this.datacontractMgrApi</span>
<span class="nc" id="L5576">				.getDataContractIDsOfApplicant(ownerID);</span>
<span class="nc bnc" id="L5577" title="All 2 branches missed.">		for (final DataContract dc : datacontracts.values()) {</span>
<span class="nc" id="L5578">			dataSets.add(dc.getProviderDataSetID());</span>
<span class="nc bnc" id="L5579" title="All 2 branches missed.">			if (dataSetForStore == null) {</span>
<span class="nc" id="L5580">				dataSetForStore = dc.getProviderDataSetID();</span>
			}
<span class="nc" id="L5582">		}</span>

		// DataSets of the account
<span class="nc" id="L5585">		final List&lt;DataSet&gt; allDataSetsOfowner = dataSetMgrApi.getAllDataSetsOfAccount(ownerID);</span>
<span class="nc bnc" id="L5586" title="All 2 branches missed.">		for (final DataSet ds : allDataSetsOfowner) {</span>
<span class="nc" id="L5587">			dataSets.add(ds.getDataClayID());</span>
<span class="nc bnc" id="L5588" title="All 2 branches missed.">			if (dataSetForStore == null) {</span>
<span class="nc" id="L5589">				dataSetForStore = ds.getDataClayID();</span>
			}

<span class="nc" id="L5592">		}</span>
<span class="nc" id="L5593">		final SessionInfo sessInfo = newSessionInternal(ownerID, contractIDs, dataSets, dataSetForStore,</span>
				Langs.LANG_JAVA);
<span class="nc" id="L5595">		return sessInfo.getSessionID();</span>
	}

	/**
	 * Preface for the getStubs|getBabelStubs. Validate the account and get all
	 * interfaces.
	 * 
	 * @param applicantAccountID
	 *            The applicant Account
	 * @param applicantCredential
	 *            The applicant Credential
	 * @param contractsIDs
	 *            The list of ContractIDs for the stubs to be retrieved.
	 * @return A map containing all the required data to proceed to stub generation.
	 * @throws RemoteException
	 *             if a RemoteException occurs from AccountManager or
	 *             SessionManager.
	 */
	private Map&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; getStubsInternalPreface(
			final AccountID applicantAccountID, final PasswordCredential applicantCredential,
			final List&lt;ContractID&gt; contractsIDs) {
		// Validate applicant account
<span class="nc bnc" id="L5617" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(applicantAccountID, applicantCredential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L5618">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}

		// Get info of contracts
<span class="nc" id="L5622">		final LinkedHashMap&lt;ContractID, Contract&gt; contractsInfo = contractMgrApi</span>
<span class="nc" id="L5623">				.getInfoOfSomeActiveContractsForAccount(contractsIDs, applicantAccountID);</span>

		// Get info of interfaces
<span class="nc" id="L5626">		final HashSet&lt;InterfaceID&gt; allInterfacesIDs = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L5627" title="All 2 branches missed.">		for (final Contract contractInfo : contractsInfo.values()) {</span>
<span class="nc" id="L5628">			allInterfacesIDs.addAll(contractInfo.getInterfacesInContract().keySet());</span>
<span class="nc" id="L5629">		}</span>
<span class="nc" id="L5630">		final Map&lt;InterfaceID, Interface&gt; interfacesInfo = interfaceMgrApi.getInterfacesInfo(allInterfacesIDs);</span>

		// Update Interface with names of class, properties and signatures of operations
		/*
		 * for (Interface ifaceInfo : interfacesInfo.values()) { MetaClass classInfo =
		 * classMgrApi.getClassInfo(ifaceInfo.getMetaClassID());
		 * ifaceInfo.setClassName(classInfo.getName());
		 *
		 * SortedSet&lt;Property&gt; props = classInfo.getProperties(); Map&lt;PropertyID,
		 * String&gt; propsOfClass = new HashMap&lt;PropertyID, String&gt;(); for (Property prop
		 * : props) { propsOfClass.put(prop.getID(), prop.getName()); }
		 * HashMap&lt;PropertyID, String&gt; propsOfIface = new HashMap&lt;PropertyID, String&gt;();
		 * for (PropertyID propID : ifaceInfo.getPropertiesIDs()) {
		 * propsOfIface.put(propID, propsOfClass.get(propID)); }
		 * ifaceInfo.setPropsNames(propsOfIface);
		 *
		 *
		 * Map&lt;OperationID, String&gt; opsOfClass = new HashMap&lt;OperationID, String&gt;(); for
		 * (Operation op : classInfo.getOperations()) { opsOfClass.put(op.getID(),
		 * op.getName()); } HashMap&lt;OperationID, String&gt; opsOfIface = new
		 * HashMap&lt;OperationID, String&gt;(); for (OperationID opID :
		 * ifaceInfo.getOperationsIDs()) { opsOfIface.put(opID, opsOfClass.get(opID)); }
		 * ifaceInfo.setOpsSignatures(opsOfIface); }
		 */

		// Build structures for each metaclass to be &quot;stubbed&quot;
<span class="nc" id="L5656">		final Map&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; ifacesAndContractsOfClasses = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5657" title="All 2 branches missed.">		for (final Entry&lt;ContractID, Contract&gt; curContract : contractsInfo.entrySet()) {</span>
<span class="nc" id="L5658">			final ContractID contractID = curContract.getKey();</span>
<span class="nc" id="L5659">			final Contract contractInfo = curContract.getValue();</span>

<span class="nc bnc" id="L5661" title="All 2 branches missed.">			for (final InterfaceID interfaceID : contractInfo.getInterfacesInContract().keySet()) {</span>
<span class="nc" id="L5662">				final Interface interfaceInfo = interfacesInfo.get(interfaceID);</span>
<span class="nc" id="L5663">				final MetaClassID metaClassID = interfaceInfo.getMetaClassID();</span>

				// Track info of interfaces and contracts per class
<span class="nc bnc" id="L5666" title="All 2 branches missed.">				if (!ifacesAndContractsOfClasses.containsKey(metaClassID)) {</span>
<span class="nc" id="L5667">					ifacesAndContractsOfClasses.put(metaClassID,</span>
							new LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;());
				}
<span class="nc" id="L5670">				ifacesAndContractsOfClasses.get(metaClassID).put(contractID, new Tuple&lt;&gt;(contractInfo, interfaceInfo));</span>
<span class="nc" id="L5671">			}</span>
<span class="nc" id="L5672">		}</span>

<span class="nc" id="L5674">		return ifacesAndContractsOfClasses;</span>
	}

	@Override
	public Map&lt;String, byte[]&gt; getStubs(final AccountID applicantAccountID,
			final PasswordCredential applicantCredential, final Langs language, final List&lt;ContractID&gt; contractsIDs) {
<span class="nc" id="L5680">		final Map&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; ifacesAndContractsOfClasses = getStubsInternalPreface(</span>
				applicantAccountID, applicantCredential, contractsIDs);

		// Generate stub infos
<span class="nc" id="L5684">		final Map&lt;MetaClassID, StubInfo&gt; stubInfos = new HashMap&lt;&gt;();</span>
<span class="nc" id="L5685">		final Map&lt;String, byte[]&gt; stubsBytesArrays = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5686" title="All 2 branches missed.">		for (final Entry&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; ifacesAndContractsOfClass : ifacesAndContractsOfClasses</span>
<span class="nc" id="L5687">				.entrySet()) {</span>
<span class="nc" id="L5688">			final MetaClassID metaClassID = ifacesAndContractsOfClass.getKey();</span>
			// Generate the stub info for the current class
<span class="nc" id="L5690">			final StubInfo stubInfo = getStubInfoForMetaClass(applicantAccountID, metaClassID,</span>
<span class="nc" id="L5691">					ifacesAndContractsOfClass.getValue());</span>

<span class="nc" id="L5693">			stubInfos.put(metaClassID, stubInfo);</span>
<span class="nc" id="L5694">		}</span>

		// Generate stubs
<span class="nc" id="L5697">		final Map&lt;MetaClassID, Triple&lt;String, byte[], byte[]&gt;&gt; stubAndIncludes = classMgrApi.generateStubs(language,</span>
				stubInfos);

<span class="nc bnc" id="L5700" title="All 2 branches missed.">		for (final Entry&lt;MetaClassID, Triple&lt;String, byte[], byte[]&gt;&gt; curStub : stubAndIncludes.entrySet()) {</span>

<span class="nc" id="L5702">			final MetaClassID metaClassID = curStub.getKey();</span>
<span class="nc" id="L5703">			final Triple&lt;String, byte[], byte[]&gt; triple = curStub.getValue();</span>

<span class="nc" id="L5705">			final String className = triple.getFirst();</span>
<span class="nc" id="L5706">			final byte[] stubByteArray = triple.getSecond();</span>
<span class="nc" id="L5707">			final byte[] aspect = triple.getThird();</span>
<span class="nc" id="L5708">			stubsBytesArrays.put(className, stubByteArray);</span>

			// Add aspectj
<span class="nc bnc" id="L5711" title="All 2 branches missed.">			if (aspect != null) {</span>
<span class="nc" id="L5712">				stubsBytesArrays.put(className + &quot;Aspect&quot;, aspect);</span>
			}
			// Add Yaml
			// Generate the Babel stub for the current class, and put it in the returning
			// dictionary
<span class="nc" id="L5717">			final String myBabelStub = generateBabelStub(applicantAccountID, metaClassID,</span>
<span class="nc" id="L5718">					ifacesAndContractsOfClasses.get(metaClassID));</span>
<span class="nc bnc" id="L5719" title="All 2 branches missed.">			if (myBabelStub != null) {</span>
<span class="nc" id="L5720">				final byte[] yamldoc = myBabelStub.getBytes();</span>
<span class="nc" id="L5721">				stubsBytesArrays.put(className + &quot;Yaml&quot;, yamldoc);</span>
			}
<span class="nc" id="L5723">		}</span>

<span class="nc" id="L5725">		return stubsBytesArrays;</span>

	}

	@Override
	public byte[] getBabelStubs(final AccountID applicantAccountID, final PasswordCredential applicantCredential,
			final List&lt;ContractID&gt; contractsIDs) {
<span class="nc" id="L5732">		final Map&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; ifacesAndContractsOfClasses = getStubsInternalPreface(</span>
				applicantAccountID, applicantCredential, contractsIDs);

		// Generate &quot;Babel&quot; stubs
<span class="nc" id="L5736">		final Map&lt;String, Object&gt; stubsBytesArrays = new HashMap&lt;&gt;();</span>

		for (final Entry&lt;MetaClassID, LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt;&gt; //
<span class="nc bnc" id="L5739" title="All 2 branches missed.">		ifacesAndContractsOfClass : ifacesAndContractsOfClasses.entrySet()) {</span>
<span class="nc" id="L5740">			final MetaClassID metaClassID = ifacesAndContractsOfClass.getKey();</span>

			// Get the classname
<span class="nc" id="L5743">			final String className = classMgrApi.getClassname(metaClassID);</span>
			// Generate the Babel stub for the current class, and put it in the returning
			// dictionary
<span class="nc" id="L5746">			stubsBytesArrays.put(className,</span>
<span class="nc" id="L5747">					generateBabelStub(applicantAccountID, metaClassID, ifacesAndContractsOfClass.getValue()));</span>
<span class="nc" id="L5748">		}</span>

<span class="nc" id="L5750">		final Yaml yaml = CommonYAML.getYamlObject();</span>
<span class="nc" id="L5751">		return yaml.dump(stubsBytesArrays).getBytes();</span>

	}

	@Override
	public String getClassNameForDS(final MetaClassID classID) {
<span class="nc" id="L5757">		return classMgrApi.getClassname(classID);</span>
	}

	@Override
	public Tuple&lt;String, String&gt; getClassNameAndNamespaceForDS(final MetaClassID classID) {
		try {
<span class="nc" id="L5763">			return classMgrApi.getClassNameAndNamespace(classID);</span>
<span class="nc" id="L5764">		} catch (Exception e) { </span>
<span class="nc" id="L5765">			throw e;</span>
		}
	}

	@Override
	public void registerEventListenerImplementation(final AccountID accountID, final PasswordCredential credential,
			final ECA newEventListener) {
		// Check account
		// TODO: validate account, who is allowed to register it?

		// Advises notification manager
<span class="nc bnc" id="L5776" title="All 2 branches missed.">		if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L5777">			notificationMgrApi.registerEventListenerImpl(newEventListener);</span>
		} else {
<span class="nc" id="L5779">			throw new DataClayException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;Notification manager is not active&quot;, false);</span>
		}

<span class="nc" id="L5782">	}</span>

	@Override
	public void adviseEvent(final EventMessage newEvent) {
<span class="nc bnc" id="L5786" title="All 2 branches missed.">		if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L5787">			notificationMgrApi.adviseEvent(newEvent);</span>
		} else {
<span class="nc" id="L5789">			throw new DataClayException(ERRORCODE.UNEXPECTED_EXCEPTION, &quot;Notification manager is not active&quot;, false);</span>
		}
<span class="nc" id="L5791">	}</span>

	/**
	 * @return the metaDataSrvApi
	 */
	public MetaDataService getMetaDataSrvApi() {
<span class="nc" id="L5797">		return metaDataSrvApi;</span>
	}

	/***** Register Listener *****/

	// ============== PRIVATE METHODS FOR NAMESPACES ==============//

	/**
	 * Checks that the specified account is the responsible of the given namespace
	 * 
	 * @param accountID
	 *            the account to be checked
	 * @param credential
	 *            the account credentials
	 * @param namespaceID
	 *            the id of the namespace
	 * @return Success if the account is valid and it is the responsible of the
	 *         namespace
	 */
	private Namespace checkNamespaceResponsible(final AccountID accountID, final PasswordCredential credential,
			final NamespaceID namespaceID) {
		// Validate account
<span class="nc bnc" id="L5819" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L5820">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}
		// Check namespace responsible
<span class="nc" id="L5823">		return namespaceMgrApi.checkNamespaceResponsibleAndGetInfo(namespaceID, accountID);</span>

	}

	// ============== PRIVATE METHODS FOR DATASETS ==============//

	/**
	 * Shared method that checks the responsible of a dataset
	 * 
	 * @param accountID
	 *            ID of the account to be checked
	 * @param credential
	 *            credential of the account
	 * @param datasetID
	 *            ID of the dataset to be checked
	 */
	private void checkDataSetResponsible(final AccountID accountID, final PasswordCredential credential,
			final DataSetID datasetID) {
		// Validate account
<span class="nc bnc" id="L5842" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential, AccountRole.NORMAL_ROLE)) {</span>
<span class="nc" id="L5843">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}
		// Check namespace responsible
<span class="nc bnc" id="L5846" title="All 2 branches missed.">		if (!dataSetMgrApi.checkDataSetResponsible(datasetID, accountID)) {</span>
<span class="nc" id="L5847">			throw new DataClayRuntimeException(ERRORCODE.BAD_DATASET_RESPONSIBLE);</span>
		}

<span class="nc" id="L5850">	}</span>

	// ============== PRIVATE METHODS FOR CLASS MANAGEMENT AND IMPORTS
	// ==============//

	/**
	 * Get metaclassID either because it is created in the namespace or imported in
	 * it
	 * 
	 * @param namespaceID
	 *            ID of the namespace where the class should be present
	 * @param className
	 *            the name of the classes
	 * @return ID of the metaclass
	 */
	private MetaClassID getMetaClassID(final NamespaceID namespaceID, final String className) {
<span class="nc" id="L5866">		MetaClassID result = null;</span>
		// Check the class is not in use and get the classID (checks the class belongs
		// to the namespace)
<span class="nc" id="L5869">		result = classMgrApi.getMetaClassID(namespaceID, className);</span>
<span class="nc bnc" id="L5870" title="All 2 branches missed.">		if (result == null) {</span>
			// if class manager cannot obtain the class id in namespaceID check imports
<span class="nc" id="L5872">			final Set&lt;ImportedInterface&gt; importedInterfacess = namespaceMgrApi.getImportedInterfaces(namespaceID,</span>
					className);
<span class="nc bnc" id="L5874" title="All 2 branches missed.">			if (importedInterfacess.isEmpty()) {</span>
<span class="nc" id="L5875">				throw new DataClayRuntimeException(ERRORCODE.BAD_IMPORTS);</span>
			} else {
<span class="nc" id="L5877">				result = importedInterfacess.iterator().next().getClassOfImportID();</span>
			}
		}

<span class="nc" id="L5881">		return result;</span>
	}

	// ============== PRIVATE METHODS FOR CONTRACT MANAGEMENT ==============//

	/**
	 * Method that validates the provided contract in the context of the given
	 * namespace
	 * 
	 * @param contract
	 *            the contract to validate
	 * @return The info of the interfaces of the contract checked.
	 */
	private Map&lt;InterfaceID, Interface&gt; checkContract(final Contract contract) {
<span class="nc" id="L5895">		Map&lt;InterfaceID, Interface&gt; infoOfInterfacesInContract = null;</span>
		// Get info of the interfaces for the contract
<span class="nc" id="L5897">		infoOfInterfacesInContract = interfaceMgrApi.getInterfacesOfNamespaceInfo(contract.getNamespaceID(),</span>
<span class="nc" id="L5898">				new HashSet&lt;&gt;(contract.getInterfacesInContract().keySet()));</span>

		// Checks for every interface
<span class="nc" id="L5901">		final Map&lt;InterfaceID, MetaClassID&gt; metaClassesOfInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5902" title="All 2 branches missed.">		for (final Entry&lt;InterfaceID, Interface&gt; curEntry : infoOfInterfacesInContract.entrySet()) {</span>
<span class="nc" id="L5903">			final InterfaceID interfaceID = curEntry.getKey();</span>
<span class="nc" id="L5904">			final Interface curInterface = curEntry.getValue();</span>

			// Check there is no previous interface associated with same
			// metaclass
<span class="nc bnc" id="L5908" title="All 2 branches missed.">			if (metaClassesOfInterfaces.containsValue(curInterface.getMetaClassID())) {</span>
<span class="nc" id="L5909">				throw new DataClayRuntimeException(ERRORCODE.SOME_INTERFACES_WITH_SAME_METACLASS);</span>
			} else {
<span class="nc" id="L5911">				metaClassesOfInterfaces.put(interfaceID, curInterface.getMetaClassID());</span>
			}

			// For some strange reason, doing this new was required in order to avoid a
			// misbehaviour
			// Check YAML-related MixedTest.UpToInterfaceTest
			// abarcelo 2014-10-28
<span class="nc" id="L5918">			final Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInNewContract = new LinkedHashMap&lt;&gt;(</span>
<span class="nc" id="L5919">					contract.getInterfacesInContract());</span>
			// Update with a &quot;&quot;&quot;more valid&quot;&quot;&quot; Map --??? It Works (TM)
<span class="nc" id="L5921">			contract.setInterfacesInContract(interfacesInNewContract);</span>

			// Check the implementations for the operations in the current
			// interface are right
<span class="nc" id="L5925">			final InterfaceInContract curIfaceInContract = interfacesInNewContract.get(interfaceID);</span>
<span class="nc" id="L5926">			final Map&lt;OperationID, OpImplementations&gt; allOpsImplementations = curIfaceInContract</span>
<span class="nc" id="L5927">					.getAccessibleImplementations();</span>
<span class="nc bnc" id="L5928" title="All 2 branches missed.">			if (!allOpsImplementations.keySet().containsAll(curInterface.getOperationsIDs())) {</span>
<span class="nc" id="L5929">				throw new DataClayRuntimeException(ERRORCODE.SOME_OPERATION_WITH_NO_ACCESSIBLE_IMPL);</span>
			}
<span class="nc bnc" id="L5931" title="All 2 branches missed.">			for (final Entry&lt;OperationID, OpImplementations&gt; curOpImpls : allOpsImplementations.entrySet()) {</span>
<span class="nc" id="L5932">				final OperationID operationID = curOpImpls.getKey();</span>
<span class="nc bnc" id="L5933" title="All 2 branches missed.">				if (!curInterface.getOperationsIDs().contains(operationID)) {</span>
<span class="nc" id="L5934">					throw new DataClayRuntimeException(ERRORCODE.OPERATION_NOT_IN_INTERFACE);</span>
				}

<span class="nc" id="L5937">				final OpImplementations curImpls = curOpImpls.getValue();</span>

<span class="nc" id="L5939">				final List&lt;ImplementationID&gt; implementationsOfOp = classMgrApi</span>
<span class="nc" id="L5940">						.getImplementationsOfOperation(operationID);</span>

<span class="nc bnc" id="L5942" title="All 2 branches missed.">				if (!implementationsOfOp.contains(curImpls.getLocalImplementationID())) {</span>
<span class="nc" id="L5943">					throw new DataClayRuntimeException(ERRORCODE.IMPLEMENTATION_NOT_EXIST,</span>
<span class="nc" id="L5944">							&quot; Implementation with ID &quot; + curImpls.getLocalImplementationID() + &quot; does not exist&quot;,</span>
							false);
<span class="nc bnc" id="L5946" title="All 2 branches missed.">				} else if (!implementationsOfOp.contains(curImpls.getRemoteImplementationID())) {</span>
<span class="nc" id="L5947">					throw new DataClayRuntimeException(ERRORCODE.IMPLEMENTATION_NOT_EXIST,</span>
<span class="nc" id="L5948">							&quot; Implementation with ID &quot; + curImpls.getRemoteImplementationID() + &quot; does not exist&quot;,</span>
							false);
				}
<span class="nc" id="L5951">			}</span>
<span class="nc" id="L5952">		}</span>

<span class="nc" id="L5954">		return infoOfInterfacesInContract;</span>

	}

	/**
	 * This method updates the given interfaces of a contract by analyzing their
	 * requirements (includes) and returns a merged set of interfaces for such a
	 * contract.
	 * 
	 * @param accountID
	 *            ID of the account of the contract provider
	 * @param credential
	 *            Credential of the account
	 * @param namespaceID
	 *            ID of the namespace the contract provider
	 * @param currentInterfacesInContract
	 *            the current interfaces for the contract
	 * @param infoOfInterfacesInContract
	 *            the info of the current for the contract
	 * @return Info of the resulting interfaces in contract.
	 * @throws RemoteException
	 *             if RemoteException occurs in ClassManager
	 */
	private Map&lt;InterfaceID, InterfaceInContract&gt; updateInterfacesForTheContract(final AccountID accountID,
			final PasswordCredential credential, final NamespaceID namespaceID,
			final Map&lt;InterfaceID, InterfaceInContract&gt; currentInterfacesInContract,
			final Map&lt;InterfaceID, Interface&gt; infoOfInterfacesInContract) {

		// Init result with current interfaces in contract
<span class="nc" id="L5983">		final Map&lt;InterfaceID, InterfaceInContract&gt; objResult = new HashMap&lt;&gt;();</span>
<span class="nc" id="L5984">		objResult.putAll(currentInterfacesInContract);</span>

		// Keep the metaclasses of the interfaces in contract
		final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; //
<span class="nc" id="L5988">		metaClassesOfInterfacesInContract = new HashMap&lt;&gt;();</span>

		// Start with the current interfaces in contract
<span class="nc" id="L5991">		Map&lt;InterfaceID, InterfaceInContract&gt; interfacesInContractToBeAnalyzed = //</span>
				new HashMap&lt;&gt;(currentInterfacesInContract);

<span class="nc bnc" id="L5994" title="All 2 branches missed.">		while (!interfacesInContractToBeAnalyzed.isEmpty()) {</span>
			// Analyze includes required for the interfaces in contract and
			// separate
			// considering if they are related with classes created in the
			// namespace or not (imports)
<span class="nc" id="L5999">			final Set&lt;MetaClass&gt; importedIncludesInfo = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6000">			final Set&lt;MetaClass&gt; nonImportedIncludesInfo = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L6002" title="All 2 branches missed.">			for (final Entry&lt;InterfaceID, InterfaceInContract&gt; curEntry : interfacesInContractToBeAnalyzed.entrySet()) {</span>
<span class="nc" id="L6003">				final InterfaceID curInterfaceID = curEntry.getKey();</span>
<span class="nc" id="L6004">				final InterfaceInContract curInterfaceInContract = curEntry.getValue();</span>

				// Info of the current interface in contract
<span class="nc" id="L6007">				final Interface curInterface = infoOfInterfacesInContract.get(curInterfaceID);</span>
<span class="nc" id="L6008">				final MetaClassID metaClassID = curInterface.getMetaClassID();</span>
<span class="nc" id="L6009">				final Set&lt;PropertyID&gt; propertyIDs = curInterface.getPropertiesIDs();</span>
<span class="nc" id="L6010">				final Set&lt;OperationID&gt; operationIDs = curInterface.getOperationsIDs();</span>

				// Accessible implementations for current interface
<span class="nc" id="L6013">				final Map&lt;OperationID, OpImplementations&gt; accessibleImpls = curInterfaceInContract</span>
<span class="nc" id="L6014">						.getAccessibleImplementations();</span>

<span class="nc" id="L6016">				final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; operationsAndImpls = //</span>
						new HashMap&lt;&gt;();
<span class="nc bnc" id="L6018" title="All 2 branches missed.">				for (final OperationID curOpID : operationIDs) {</span>
<span class="nc" id="L6019">					final OpImplementations accessibleImplsForCurrentOp = accessibleImpls.get(curOpID);</span>
<span class="nc" id="L6020">					final HashSet&lt;ImplementationID&gt; implsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6021">					implsIDs.add(accessibleImplsForCurrentOp.getLocalImplementationID());</span>
<span class="nc" id="L6022">					implsIDs.add(accessibleImplsForCurrentOp.getRemoteImplementationID());</span>
<span class="nc" id="L6023">					operationsAndImpls.put(curOpID, implsIDs);</span>
<span class="nc" id="L6024">				}</span>

				// Get parent class ID
<span class="nc" id="L6027">				final MetaClass curClassInfo = classMgrApi.getClassInfo(metaClassID);</span>
<span class="nc" id="L6028">				MetaClassID parentClassID = null;</span>
<span class="nc bnc" id="L6029" title="All 2 branches missed.">				if (curClassInfo.getParentType() != null) {</span>
<span class="nc" id="L6030">					parentClassID = curClassInfo.getParentType().getClassID();</span>
				}

				// =&gt; CLASS MANAGER
				// Get all the needed &quot;includes&quot; for the current interface
				// in contract
<span class="nc" id="L6036">				final Tuple&lt;Set&lt;MetaClass&gt;, Set&lt;MetaClass&gt;&gt; curResult = classMgrApi</span>
<span class="nc" id="L6037">						.getClassIncludesOfOperationsPropsAndImpls(operationsAndImpls, propertyIDs, namespaceID,</span>
								parentClassID);

				// We have them separated considering if they are includes
				// present in namespace from imported classes
				// or they are classes created in itup
<span class="nc" id="L6043">				importedIncludesInfo.addAll(curResult.getFirst());</span>
<span class="nc" id="L6044">				nonImportedIncludesInfo.addAll(curResult.getSecond());</span>

				// Index interfaces in contract by metaclass and also with
				// the parent class info
<span class="nc" id="L6048">				metaClassesOfInterfacesInContract.put(metaClassID,</span>
						new Triple&lt;&gt;(curInterface, curInterfaceInContract, parentClassID));
<span class="nc" id="L6050">			}</span>

			// Init interfacesInContract to be analyzed in next iteration
<span class="nc" id="L6053">			interfacesInContractToBeAnalyzed = new HashMap&lt;&gt;();</span>

			// Set of includes required that refer to classes already
			// created in namespace
<span class="nc" id="L6057">			final Map&lt;MetaClassID, MetaClass&gt; setOfclassesRequiredCreatedInNamespace = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L6058" title="All 2 branches missed.">			for (final MetaClass mclassInfo : nonImportedIncludesInfo) {</span>
<span class="nc bnc" id="L6059" title="All 2 branches missed.">				if (!metaClassesOfInterfacesInContract.containsKey(mclassInfo.getDataClayID())) {</span>
<span class="nc" id="L6060">					setOfclassesRequiredCreatedInNamespace.put(mclassInfo.getDataClayID(), mclassInfo);</span>
				}
<span class="nc" id="L6062">			}</span>
<span class="nc bnc" id="L6063" title="All 2 branches missed.">			if (!setOfclassesRequiredCreatedInNamespace.isEmpty()) {</span>

				final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; //
<span class="nc" id="L6066">				interfacesForClasses = registerReqInterfacesForClasses(accountID, credential, namespaceID,</span>
						setOfclassesRequiredCreatedInNamespace);

<span class="nc bnc" id="L6069" title="All 2 branches missed.">				for (final MetaClassID mclassID : interfacesForClasses.keySet()) {</span>
<span class="nc" id="L6070">					final Triple&lt;Interface, InterfaceInContract, MetaClassID&gt; curInterface = interfacesForClasses</span>
<span class="nc" id="L6071">							.get(mclassID);</span>
<span class="nc" id="L6072">					interfacesInContractToBeAnalyzed.put(curInterface.getFirst().getDataClayID(),</span>
<span class="nc" id="L6073">							curInterface.getSecond());</span>
<span class="nc" id="L6074">					infoOfInterfacesInContract.put(curInterface.getFirst().getDataClayID(), curInterface.getFirst());</span>
<span class="nc" id="L6075">				}</span>
			}

			// Set of includes required that are present in namespace due to
			// imported classes
<span class="nc" id="L6080">			final Map&lt;MetaClassID, String&gt; setOfIncludesRequiredNotInNamespace = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L6081" title="All 2 branches missed.">			for (final MetaClass mclassInfo : importedIncludesInfo) {</span>
<span class="nc bnc" id="L6082" title="All 2 branches missed.">				if (!metaClassesOfInterfacesInContract.containsKey(mclassInfo.getDataClayID())) {</span>
<span class="nc" id="L6083">					setOfIncludesRequiredNotInNamespace.put(mclassInfo.getDataClayID(), mclassInfo.getName());</span>
				}
<span class="nc" id="L6085">			}</span>
<span class="nc bnc" id="L6086" title="All 2 branches missed.">			if (!setOfIncludesRequiredNotInNamespace.isEmpty()) {</span>

				final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; //
<span class="nc" id="L6089">				ifacesForImportedIncludes = registerReqMergedInterfacesFromImports(accountID, credential, namespaceID,</span>
						metaClassesOfInterfacesInContract, setOfIncludesRequiredNotInNamespace);

<span class="nc bnc" id="L6092" title="All 2 branches missed.">				for (final MetaClassID mclassID : ifacesForImportedIncludes.keySet()) {</span>
<span class="nc" id="L6093">					final Triple&lt;Interface, InterfaceInContract, MetaClassID&gt; curInterface = ifacesForImportedIncludes</span>
<span class="nc" id="L6094">							.get(mclassID);</span>
<span class="nc" id="L6095">					interfacesInContractToBeAnalyzed.put(curInterface.getFirst().getDataClayID(),</span>
<span class="nc" id="L6096">							curInterface.getSecond());</span>
<span class="nc" id="L6097">					infoOfInterfacesInContract.put(curInterface.getFirst().getDataClayID(), curInterface.getFirst());</span>
<span class="nc" id="L6098">				}</span>
			}
<span class="nc" id="L6100">		}</span>

		// Update Interfaces In Contract depending on their inheritance
		// relationship
<span class="nc bnc" id="L6104" title="All 2 branches missed.">		for (final MetaClassID mclassID : metaClassesOfInterfacesInContract.keySet()) {</span>
<span class="nc" id="L6105">			final Triple&lt;Interface, InterfaceInContract, MetaClassID&gt; curInterfaceInContract = metaClassesOfInterfacesInContract</span>
<span class="nc" id="L6106">					.get(mclassID);</span>
<span class="nc" id="L6107">			objResult.put(curInterfaceInContract.getFirst().getDataClayID(), curInterfaceInContract.getSecond());</span>
<span class="nc" id="L6108">		}</span>

<span class="nc" id="L6110">		return objResult;</span>
	}

	/**
	 * This method autogenerates the interfaces for a contract related with a
	 * specific set of classes created on a specific namespace
	 * 
	 * @param accountID
	 *            Account performing the action
	 * @param credential
	 *            Credential of the account
	 * @param namespaceID
	 *            the id of the namespace
	 * @param setOfClassesRequiredCreatedInNamespace
	 *            the set of classes and its related info
	 * @return The interfaces for a contract
	 * @throws RemoteException
	 *             if a RemoteException occurs in InterfaceManager or ClassManager
	 */
	private Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; registerReqInterfacesForClasses(
			final AccountID accountID, final PasswordCredential credential, final NamespaceID namespaceID,
			final Map&lt;MetaClassID, MetaClass&gt; setOfClassesRequiredCreatedInNamespace) {

<span class="nc" id="L6133">		final String namespace = namespaceMgrApi.getNamespaceInfo(namespaceID).getName();</span>
<span class="nc" id="L6134">		final String accountName = accountMgrApi.getAccount(accountID).getUsername();</span>
		// Init result
<span class="nc" id="L6136">		final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; newInterfacesInContract = //</span>
				new HashMap&lt;&gt;();

<span class="nc bnc" id="L6139" title="All 2 branches missed.">		for (final Entry&lt;MetaClassID, MetaClass&gt; curEntry : setOfClassesRequiredCreatedInNamespace.entrySet()) {</span>
<span class="nc" id="L6140">			final MetaClassID mclassID = curEntry.getKey();</span>
<span class="nc" id="L6141">			final MetaClass currentMclassInfo = curEntry.getValue();</span>

<span class="nc" id="L6143">			final Set&lt;String&gt; operationsSignatures = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6144">			final Set&lt;OpImplementations&gt; opImpls = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6145">			final Map&lt;OperationID, OpImplementations&gt; actualOpImpls = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L6146" title="All 2 branches missed.">			for (final Operation op : currentMclassInfo.getOperations()) {</span>
<span class="nc" id="L6147">				operationsSignatures.add(op.getNameAndDescriptor());</span>
<span class="nc" id="L6148">				final OpImplementations opImplem = new OpImplementations(op.getNameAndDescriptor(), 0, 0);</span>
<span class="nc" id="L6149">				opImpls.add(opImplem);</span>
<span class="nc" id="L6150">				final ImplementationID implID = op.getImplementations().get(0).getDataClayID();</span>
<span class="nc" id="L6151">				opImplem.setLocalImplementationID(implID);</span>
<span class="nc" id="L6152">				opImplem.setRemoteImplementationID(implID);</span>
<span class="nc" id="L6153">				actualOpImpls.put(op.getDataClayID(), opImplem);</span>
<span class="nc" id="L6154">			}</span>

<span class="nc" id="L6156">			final Set&lt;String&gt; propNames = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L6157" title="All 2 branches missed.">			for (final Property prop : currentMclassInfo.getProperties()) {</span>
<span class="nc" id="L6158">				propNames.add(prop.getName());</span>
<span class="nc" id="L6159">			}</span>

			// Register the new Interface for the class
<span class="nc" id="L6162">			final Interface newInterface = new Interface(accountName, namespace, namespace, currentMclassInfo.getName(),</span>
					propNames, operationsSignatures);

<span class="nc" id="L6165">			this.newInterface(accountID, credential, newInterface);</span>

<span class="nc" id="L6167">			MetaClassID parentID = null;</span>
<span class="nc bnc" id="L6168" title="All 2 branches missed.">			if (currentMclassInfo.getParentType() != null) {</span>
<span class="nc" id="L6169">				parentID = currentMclassInfo.getParentType().getClassID();</span>
			}

			// Update the interfaces in contract
<span class="nc" id="L6173">			final InterfaceInContract interfaceInContract = new InterfaceInContract(newInterface, opImpls);</span>
<span class="nc" id="L6174">			interfaceInContract.setAccessibleImplementations(actualOpImpls);</span>
<span class="nc" id="L6175">			newInterfacesInContract.put(mclassID, new Triple&lt;&gt;(newInterface, interfaceInContract, parentID));</span>
<span class="nc" id="L6176">		}</span>

<span class="nc" id="L6178">		return newInterfacesInContract;</span>
	}

	/**
	 * @breief Registers the required merged interfaces from the given imports being
	 *         used for the interfaces In Contract
	 * @param accountID
	 *            the account that creates the contract
	 * @param credential
	 *            Account credentials
	 * @param namespaceID
	 *            the id for the contract
	 * @param metaClassesOfInterfacesInContract
	 *            interfaces in contract indexed by class
	 * @param setOfIncludesRequiredNotCreatedInNamespaceButImported
	 *            the set of classes needed to satisfy the interfaces in contract
	 * @return Returns the info of the registered interfaces in contract register
	 * @throws RemoteException
	 *             if an exception occurs in NamespaceManager, ContractManager or
	 *             InterfaceManager
	 *
	 */
	private Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; registerReqMergedInterfacesFromImports(
			final AccountID accountID, final PasswordCredential credential, final NamespaceID namespaceID,
			final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; metaClassesOfInterfacesInContract,
			final Map&lt;MetaClassID, String&gt; setOfIncludesRequiredNotCreatedInNamespaceButImported) {

		// Init result
<span class="nc" id="L6206">		final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; newInterfacesInContract = //</span>
				new HashMap&lt;&gt;();

		// Init the already done interfaces in contract
<span class="nc" id="L6210">		final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; alreadyDoneInterfacesInContract = //</span>
				new HashMap&lt;&gt;(metaClassesOfInterfacesInContract);

		// =&gt; NAMESPACE MANAGER
		// Get imports and check that contain all the requirements
<span class="nc" id="L6215">		final Map&lt;MetaClassID, Set&lt;ImportedInterface&gt;&gt; importsInfo = namespaceMgrApi</span>
<span class="nc" id="L6216">				.getImportedInterfacesForMetaclasses(namespaceID,</span>
<span class="nc" id="L6217">						new HashSet&lt;&gt;(setOfIncludesRequiredNotCreatedInNamespaceButImported.keySet()));</span>
<span class="nc bnc" id="L6218" title="All 2 branches missed.">		for (final Entry&lt;MetaClassID, String&gt; curInclude : setOfIncludesRequiredNotCreatedInNamespaceButImported</span>
<span class="nc" id="L6219">				.entrySet()) {</span>
<span class="nc" id="L6220">			final MetaClassID classID = curInclude.getKey();</span>
<span class="nc" id="L6221">			final String className = curInclude.getValue();</span>
<span class="nc bnc" id="L6222" title="All 4 branches missed.">			if (!importsInfo.containsKey(classID) || importsInfo.get(classID).isEmpty()) {</span>
<span class="nc" id="L6223">				throw new DataClayRuntimeException(ERRORCODE.CLASS_NOT_IMPORTED,</span>
						&quot;Class &quot; + className + &quot; not imported in namespace &quot; + namespaceID, false);
			}
<span class="nc" id="L6226">		}</span>

		// =&gt; CONTRACT MANAGER
		// Get info of the interfaces in contract used for the imports
<span class="nc" id="L6230">		final Map&lt;ContractID, HashSet&lt;InterfaceID&gt;&gt; interfacesInContractOfImports = new HashMap&lt;&gt;();</span>
<span class="nc" id="L6231">		final Set&lt;InterfaceID&gt; interfacesIDsOfImports = new HashSet&lt;&gt;();</span>

		// For each class...
<span class="nc bnc" id="L6234" title="All 2 branches missed.">		for (final Set&lt;ImportedInterface&gt; importsInfoOfClass : importsInfo.values()) {</span>
			// For each import for the class...
<span class="nc bnc" id="L6236" title="All 2 branches missed.">			for (final ImportedInterface importInfoOfClass : importsInfoOfClass) {</span>
<span class="nc" id="L6237">				final ContractID curContractID = importInfoOfClass.getContractID();</span>
<span class="nc" id="L6238">				final InterfaceID curInterfaceID = importInfoOfClass.getInterfaceID();</span>
<span class="nc bnc" id="L6239" title="All 2 branches missed.">				if (!interfacesInContractOfImports.containsKey(curContractID)) {</span>
<span class="nc" id="L6240">					final HashSet&lt;InterfaceID&gt; interfacesInCurContractOfImports = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6241">					interfacesInContractOfImports.put(curContractID, interfacesInCurContractOfImports);</span>
				}
<span class="nc" id="L6243">				interfacesInContractOfImports.get(curContractID).add(curInterfaceID);</span>
<span class="nc" id="L6244">				interfacesIDsOfImports.add(curInterfaceID);</span>
<span class="nc" id="L6245">			}</span>
<span class="nc" id="L6246">		}</span>
<span class="nc" id="L6247">		final Map&lt;ContractID, Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt;&gt; ifacesInContractOfImportedIncludes = //</span>
<span class="nc" id="L6248">				contractMgrApi.getInfoOfMultipleInterfacesPerActiveContractsForAccount(accountID,</span>
						interfacesInContractOfImports);

		// =&gt; INTERFACE MANAGER
		// Get info of the interfaces used for the imports
<span class="nc" id="L6253">		final Map&lt;InterfaceID, Interface&gt; interfacesOfImportedIncludesInfo = interfaceMgrApi</span>
<span class="nc" id="L6254">				.getInterfacesInfo(interfacesIDsOfImports);</span>

		// Index includes by class
<span class="nc" id="L6257">		final Map&lt;MetaClassID, Map&lt;InterfaceID, InterfaceInContract&gt;&gt; infoOfInterfacesInContractOfImportedIncludesPerClass = //</span>
				new HashMap&lt;&gt;();

<span class="nc bnc" id="L6260" title="All 2 branches missed.">		for (final Tuple&lt;Map&lt;InterfaceID, InterfaceInContract&gt;, Calendar&gt; curInterfacesInContract : ifacesInContractOfImportedIncludes</span>
<span class="nc" id="L6261">				.values()) {</span>

<span class="nc bnc" id="L6263" title="All 2 branches missed.">			for (final Entry&lt;InterfaceID, InterfaceInContract&gt; curEntry : curInterfacesInContract.getFirst()</span>
<span class="nc" id="L6264">					.entrySet()) {</span>
<span class="nc" id="L6265">				final InterfaceID interfaceID = curEntry.getKey();</span>
<span class="nc" id="L6266">				final InterfaceInContract curInterfaceInContract = curEntry.getValue();</span>

<span class="nc" id="L6268">				final MetaClassID mclassID = interfacesOfImportedIncludesInfo.get(interfaceID).getMetaClassID();</span>
<span class="nc bnc" id="L6269" title="All 2 branches missed.">				if (!metaClassesOfInterfacesInContract.containsKey(mclassID)) {</span>
<span class="nc bnc" id="L6270" title="All 2 branches missed.">					if (!infoOfInterfacesInContractOfImportedIncludesPerClass.containsKey(mclassID)) {</span>
<span class="nc" id="L6271">						final Map&lt;InterfaceID, InterfaceInContract&gt; aux = new HashMap&lt;&gt;();</span>
<span class="nc" id="L6272">						infoOfInterfacesInContractOfImportedIncludesPerClass.put(mclassID, aux);</span>
					}
<span class="nc" id="L6274">					infoOfInterfacesInContractOfImportedIncludesPerClass.get(mclassID).put(interfaceID,</span>
							curInterfaceInContract);
				}
<span class="nc" id="L6277">			}</span>
<span class="nc" id="L6278">		}</span>

		// Build and register Interfaces and the necesssary info for the
		// contract
<span class="nc bnc" id="L6282" title="All 2 branches missed.">		for (final MetaClassID mclassID : infoOfInterfacesInContractOfImportedIncludesPerClass.keySet()) {</span>
<span class="nc bnc" id="L6283" title="All 2 branches missed.">			if (!alreadyDoneInterfacesInContract.containsKey(mclassID)) {</span>
<span class="nc" id="L6284">				final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; registeredClasses = //</span>
<span class="nc" id="L6285">						buildRegisterInterfacesInContract(accountID, credential, namespaceID, mclassID,</span>
								alreadyDoneInterfacesInContract, interfacesOfImportedIncludesInfo,
								infoOfInterfacesInContractOfImportedIncludesPerClass);
<span class="nc" id="L6288">				alreadyDoneInterfacesInContract.putAll(registeredClasses);</span>
<span class="nc" id="L6289">				newInterfacesInContract.putAll(registeredClasses);</span>
			}
<span class="nc" id="L6291">		}</span>
<span class="nc" id="L6292">		return newInterfacesInContract;</span>
	}

	/**
	 * Registers an interface for the given class by merging the contents of all the
	 * interfaces corresponding to the imports
	 * 
	 * @param accountID
	 *            Account performing the action
	 * @param credential
	 *            Credential of the account
	 * @param namespaceID
	 *            the ID of the namespace where merged interface is created
	 * @param currentClassToRegister
	 *            the ID of the class of the merged interface
	 * @param alreadyDoneInterfacesInContract
	 *            the classes that have been already registered with the same
	 *            process (for recursive purposes)
	 * @param interfacesOfImportedIncludesInfo
	 *            the info of the interfaces of imported includes in the namespace
	 * @param ifacesInContractOfImportedIncludesPerClass
	 *            the info of the interfaces in contract that were used to import
	 *            the includes in the namespace (indexed by class)
	 * @return the auto-generated interfaces in contract for the class to be
	 *         registered (and its parents if needed)
	 * @throws RemoteException
	 *             if a RemoteException occurs in InterfaceManager or ClassManager
	 */
	private Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; buildRegisterInterfacesInContract(
			final AccountID accountID, final PasswordCredential credential, final NamespaceID namespaceID,
			final MetaClassID currentClassToRegister,
			final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; alreadyDoneInterfacesInContract,
			final Map&lt;InterfaceID, Interface&gt; interfacesOfImportedIncludesInfo,
			final Map&lt;MetaClassID, Map&lt;InterfaceID, InterfaceInContract&gt;&gt; ifacesInContractOfImportedIncludesPerClass) {

		// Init result
<span class="nc" id="L6328">		final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; currentResult = //</span>
				new HashMap&lt;&gt;();

		// Init stuff to be merged
<span class="nc" id="L6332">		final Set&lt;String&gt; operationSignatures = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6333">		final Set&lt;String&gt; propertiesNames = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6334">		MetaClassID parentClassID = null;</span>

		// Merge info of all the interfaces in contract used to import the
		// current class in the namespace
<span class="nc" id="L6338">		final Map&lt;InterfaceID, InterfaceInContract&gt; ifacesInContractOfImportedIncludesForClassToBeRegistered = //</span>
<span class="nc" id="L6339">				ifacesInContractOfImportedIncludesPerClass.get(currentClassToRegister);</span>

<span class="nc bnc" id="L6341" title="All 2 branches missed.">		for (final InterfaceID ifaceID : ifacesInContractOfImportedIncludesForClassToBeRegistered.keySet()) {</span>
<span class="nc" id="L6342">			final Interface curInterfaceOfImportedInclude = interfacesOfImportedIncludesInfo.get(ifaceID);</span>

			// Get parent class ID
<span class="nc" id="L6345">			final MetaClassID curClassID = curInterfaceOfImportedInclude.getMetaClassID();</span>
<span class="nc" id="L6346">			final MetaClass curClassInfo = classMgrApi.getClassInfo(curClassID);</span>

<span class="nc" id="L6348">			parentClassID = null;</span>
<span class="nc bnc" id="L6349" title="All 2 branches missed.">			if (curClassInfo.getParentType() != null) {</span>
<span class="nc" id="L6350">				parentClassID = curClassInfo.getParentType().getClassID();</span>
			}

			// If it is a child class, register parent first if it needs to be
			// registered (RECURSIVELY)
<span class="nc bnc" id="L6355" title="All 4 branches missed.">			if (parentClassID != null &amp;&amp; ifacesInContractOfImportedIncludesPerClass.containsKey(parentClassID)</span>
<span class="nc bnc" id="L6356" title="All 2 branches missed.">					&amp;&amp; !currentResult.containsKey(parentClassID)</span>
<span class="nc bnc" id="L6357" title="All 2 branches missed.">					&amp;&amp; !alreadyDoneInterfacesInContract.containsKey(parentClassID)) {</span>
<span class="nc" id="L6358">				final Map&lt;MetaClassID, Triple&lt;Interface, InterfaceInContract, MetaClassID&gt;&gt; partialResult = //</span>
<span class="nc" id="L6359">						buildRegisterInterfacesInContract(accountID, credential, namespaceID, parentClassID,</span>
								alreadyDoneInterfacesInContract, interfacesOfImportedIncludesInfo,
								ifacesInContractOfImportedIncludesPerClass);
<span class="nc" id="L6362">				currentResult.putAll(partialResult);</span>
			}

			// Merge operations and properties for the interface
<span class="nc" id="L6366">			operationSignatures.addAll(curInterfaceOfImportedInclude.getOperationsSignatureInIface());</span>
<span class="nc" id="L6367">			propertiesNames.addAll(curInterfaceOfImportedInclude.getPropertiesInIface());</span>
<span class="nc" id="L6368">		}</span>

		// Merge operations and properties that are enrichments of the class in
		// the namespace
<span class="nc" id="L6372">		final Tuple&lt;Set&lt;PropertyID&gt;, Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt;&gt; enrichmentsOfClassInNamespace = classMgrApi</span>
<span class="nc" id="L6373">				.getEnrichmentsInNamespaceOfClass(currentClassToRegister, namespaceID);</span>
<span class="nc bnc" id="L6374" title="All 2 branches missed.">		for (final PropertyID propID : enrichmentsOfClassInNamespace.getFirst()) {</span>
<span class="nc" id="L6375">			final Property prop = classMgrApi.getPropertyInfo(propID);</span>
<span class="nc" id="L6376">			propertiesNames.add(prop.getName());</span>
<span class="nc" id="L6377">		}</span>
<span class="nc bnc" id="L6378" title="All 2 branches missed.">		for (final OperationID opID : enrichmentsOfClassInNamespace.getSecond().keySet()) {</span>
<span class="nc" id="L6379">			final Operation op = classMgrApi.getOperationInfo(opID);</span>
<span class="nc" id="L6380">			operationSignatures.add(op.getNameAndDescriptor());</span>
<span class="nc" id="L6381">		}</span>

		// Select the implementations for the operations of the merged interface
<span class="nc" id="L6384">		final Map&lt;OperationID, OpImplementations&gt; opImpls = selectImplementationsForMergedInterface(</span>
<span class="nc" id="L6385">				enrichmentsOfClassInNamespace.getSecond(), ifacesInContractOfImportedIncludesForClassToBeRegistered);</span>

		// Register the merged interface for the current include to be
		// registered
		// as the merge of imported interfaces present in namespace for the
		// corresponding class
<span class="nc" id="L6391">		final String namespaceOfAccount = namespaceMgrApi.getNamespaceInfo(namespaceID).getName();</span>
<span class="nc" id="L6392">		final MetaClass classInfo = classMgrApi.getClassInfo(currentClassToRegister);</span>
<span class="nc" id="L6393">		final String accountName = accountMgrApi.getAccount(accountID).getUsername();</span>
		final InterfaceInContract interfaceInContract;
<span class="nc" id="L6395">		final Interface newInterface = new Interface(accountName, namespaceOfAccount, classInfo.getNamespace(),</span>
<span class="nc" id="L6396">				classInfo.getName(), propertiesNames, operationSignatures);</span>

<span class="nc" id="L6398">		this.newInterface(accountID, credential, newInterface);</span>

<span class="nc" id="L6400">		final Set&lt;OpImplementations&gt; finalOps = new HashSet&lt;&gt;(opImpls.values());</span>
<span class="nc" id="L6401">		interfaceInContract = new InterfaceInContract(newInterface, finalOps);</span>
<span class="nc" id="L6402">		interfaceInContract.setAccessibleImplementations(opImpls);</span>
<span class="nc" id="L6403">		currentResult.put(currentClassToRegister, new Triple&lt;&gt;(newInterface, interfaceInContract, parentClassID));</span>

<span class="nc" id="L6405">		return currentResult;</span>
	}

	/**
	 * Select the implementations for operations from those ified in the given
	 * interfaces in contract (currently it selects the first OpImplementations that
	 * finds for every Operation it parses from the given interfaces in contracts)
	 * 
	 * @param enrichedOperations
	 *            the operations created as enrichments of the imported includes
	 * @param infoOfInterfacesInContractOfImportedIncludesForClassToBeRegistered
	 *            the information of the interfaces in contract related with the
	 *            includes of the class accessible via imports
	 * @return The selection of accessible implementations for each operation
	 */
	private Map&lt;OperationID, OpImplementations&gt; selectImplementationsForMergedInterface(
			final Map&lt;OperationID, Set&lt;ImplementationID&gt;&gt; enrichedOperations,
			final Map&lt;InterfaceID, InterfaceInContract&gt; infoOfInterfacesInContractOfImportedIncludesForClassToBeRegistered) {

<span class="nc" id="L6424">		final Map&lt;OperationID, OpImplementations&gt; result = new HashMap&lt;&gt;();</span>

		// TODO Default behaviour is selecting the first available
		// implementation as for local and remote
		// we should discuss this (jmarti 3 Sep 2013)

		// Init opImpls of the operations created as enrichments of the imported
		// includes
<span class="nc bnc" id="L6432" title="All 2 branches missed.">		for (final Entry&lt;OperationID, Set&lt;ImplementationID&gt;&gt; entry : enrichedOperations.entrySet()) {</span>
<span class="nc" id="L6433">			final OperationID curEnrichmentID = entry.getKey();</span>
<span class="nc" id="L6434">			final Operation op = classMgrApi.getOperationInfo(curEnrichmentID);</span>
<span class="nc" id="L6435">			final OpImplementations newOpImpls = new OpImplementations(op.getNameAndDescriptor(), 0, 0);</span>
<span class="nc" id="L6436">			final ImplementationID implID = op.getImplementations().get(0).getDataClayID();</span>
<span class="nc" id="L6437">			newOpImpls.setLocalImplementationID(implID);</span>
<span class="nc" id="L6438">			newOpImpls.setRemoteImplementationID(implID);</span>
<span class="nc" id="L6439">			result.put(op.getDataClayID(), newOpImpls);</span>
<span class="nc" id="L6440">		}</span>

		// Init opImpls of the operations already present from the imported
		// includes
<span class="nc bnc" id="L6444" title="All 2 branches missed.">		for (final InterfaceInContract curInterfaceInContract : infoOfInterfacesInContractOfImportedIncludesForClassToBeRegistered</span>
<span class="nc" id="L6445">				.values()) {</span>
<span class="nc" id="L6446">			final Map&lt;OperationID, OpImplementations&gt; curOpImpls = curInterfaceInContract</span>
<span class="nc" id="L6447">					.getAccessibleImplementations();</span>
<span class="nc bnc" id="L6448" title="All 2 branches missed.">			for (final Entry&lt;OperationID, OpImplementations&gt; curEntry : curOpImpls.entrySet()) {</span>
<span class="nc" id="L6449">				result.put(curEntry.getKey(), curEntry.getValue());</span>
<span class="nc" id="L6450">			}</span>
<span class="nc" id="L6451">		}</span>

<span class="nc" id="L6453">		return result;</span>
	}

	// ============== PRIVATE METHODS FOR STUBS AND DATA MANAGEMENT ==============//

	/**
	 * Return the object locations of an object
	 * 
	 * @param objectID
	 *            ID of the obejct
	 * @return object locations of given object id
	 * @throws RuntimeException
	 *             if an exception occurs
	 */
	private MetaDataInfo getObjectMetadata(final ObjectID objectID) {
		// Get object locations (replicas)
<span class="nc" id="L6469">		final MetaDataInfo metadataInfo = metaDataSrvApi.getObjectMetaData(objectID);</span>
<span class="nc" id="L6470">		return metadataInfo;</span>
	}

	/**
	 * Checks provided session and returns its info
	 * 
	 * @param sessionID
	 *            ID of the session
	 * @return The information of the session
	 * @throws RemoteException
	 *             if a RemoteException occurs from SessionManager
	 */
	private SessionInfo getSessionInfo(final SessionID sessionID) {
		// Get session info
<span class="nc" id="L6484">		final SessionInfo result = sessionMgrApi.getSessionInfo(sessionID);</span>
<span class="nc" id="L6485">		return result;</span>
	}

	/**
	 * Method that validates the dataset for store among the datacontracts and
	 * calculates the more restrictive end date given all the data contracts.
	 * 
	 * @param dataContractsInfo
	 *            Info of the data contracts to be taken into account.
	 * @param datasetsInfo
	 *            Info of the datasets to be taken into account.
	 * @param dataSetForStore
	 *            Dataset defined for storing objects.
	 * @return Success if the dataset ified for storing objects is among data
	 *         contracts.
	 */
	private Tuple&lt;DataContractID, Calendar&gt; validateDataSetForStore(
			final Map&lt;DataContractID, DataContract&gt; dataContractsInfo, final Map&lt;String, DataSet&gt; datasetsInfo,
			final DataSetID dataSetForStore) {
<span class="nc" id="L6504">		DataContractID dataContractIDforStore = null;</span>
<span class="nc" id="L6505">		Calendar endDate = null;</span>
<span class="nc bnc" id="L6506" title="All 2 branches missed.">		for (final Entry&lt;DataContractID, DataContract&gt; curDataContractEntry : dataContractsInfo.entrySet()) {</span>
<span class="nc" id="L6507">			final DataContractID curDataContractID = curDataContractEntry.getKey();</span>
<span class="nc" id="L6508">			final DataContract curDataContract = curDataContractEntry.getValue();</span>
<span class="nc" id="L6509">			final DataSetID curDataSetProvider = curDataContract.getProviderDataSetID();</span>
<span class="nc bnc" id="L6510" title="All 2 branches missed.">			if (curDataSetProvider.equals(dataSetForStore)) {</span>
<span class="nc" id="L6511">				dataContractIDforStore = curDataContractID;</span>
			}
<span class="nc" id="L6513">			final Calendar curEndDate = curDataContract.getEndDate();</span>
<span class="nc bnc" id="L6514" title="All 4 branches missed.">			if (endDate == null || curEndDate.before(endDate)) {</span>
<span class="nc" id="L6515">				endDate = curEndDate;</span>
			}
<span class="nc" id="L6517">		}</span>
<span class="nc bnc" id="L6518" title="All 2 branches missed.">		if (dataContractIDforStore == null) {</span>
<span class="nc" id="L6519">			throw new DataClayRuntimeException(ERRORCODE.DATASET_FOR_STORE_NOT_AMONG_DATACONTRACTS);</span>
		}
<span class="nc bnc" id="L6521" title="All 2 branches missed.">		if (endDate.before(Calendar.getInstance())) {</span>
<span class="nc" id="L6522">			throw new DataClayRuntimeException(ERRORCODE.APPLIABLE_END_DATE_FOR_SESSION_IS_BEFORE_CURRENT_DATE);</span>
		}
<span class="nc" id="L6524">		return new Tuple&lt;&gt;(dataContractIDforStore, endDate);</span>
	}

	/**
	 * Method that checks whether a dataset is accessible from the given data
	 * contracts
	 * 
	 * @param datasetID
	 *            ID of the dataset to be checked
	 * @param dataContractsInfo
	 *            info of the available data contracts
	 */
	private void checkDataSetAmongDataContracts(final DataSetID datasetID,
			final Map&lt;DataContractID, SessionDataContract&gt; dataContractsInfo) {
<span class="nc" id="L6538">		boolean dataSetFound = false;</span>
<span class="nc bnc" id="L6539" title="All 2 branches missed.">		for (final SessionDataContract dataContract : dataContractsInfo.values()) {</span>
<span class="nc" id="L6540">			dataSetFound = dataContract.getDataSetOfProvider().equals(datasetID);</span>
<span class="nc bnc" id="L6541" title="All 2 branches missed.">			if (dataSetFound) {</span>
<span class="nc" id="L6542">				break;</span>
			}
<span class="nc" id="L6544">		}</span>
<span class="nc bnc" id="L6545" title="All 2 branches missed.">		if (!dataSetFound) {</span>
<span class="nc" id="L6546">			throw new DataClayRuntimeException(ERRORCODE.DATASET_NOT_AMONG_DATACONTRACTS);</span>
		}
<span class="nc" id="L6548">	}</span>

	/**
	 * Retrieve the StubInfo from info of Interfaces and Contracts.
	 *
	 * @param applicantAccountID
	 *            The applicantAccountID for the resulting StubInfo.
	 * @param metaClassID
	 *            The ID for the MetaClass. All provided Interfaces should be
	 *            consistent with it.
	 * @param infoOfInterfacesAndContractsOfClass
	 *            Information for Interfaces and Contracts.
	 * @return The StubInfo for the specified class.
	 * @throws RemoteException
	 *             thrown by ClassManager
	 */
	private StubInfo getStubInfoForMetaClass(final AccountID applicantAccountID, final MetaClassID metaClassID,
			final LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt; infoOfInterfacesAndContractsOfClass) {
<span class="nc bnc" id="L6566" title="All 2 branches missed.">		if (applicantAccountID == null) {</span>
<span class="nc" id="L6567">			throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
					&quot;Applicant account ID is null (private function)&quot;, false);
<span class="nc bnc" id="L6569" title="All 2 branches missed.">		} else if (infoOfInterfacesAndContractsOfClass == null) {</span>
<span class="nc" id="L6570">			throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
					&quot;Info of interfaces and contracts of class is null (private function)&quot;, false);
<span class="nc bnc" id="L6572" title="All 2 branches missed.">		} else if (infoOfInterfacesAndContractsOfClass.isEmpty()) {</span>
<span class="nc" id="L6573">			throw new DataClayRuntimeException(ERRORCODE.NULL_OR_EMPTY_PARAMETER_EXCEPTION,</span>
					&quot;Info of interfaces and contracts of class is empty (private function)&quot;, false);
		}

		// Merge of operations and properties
<span class="nc" id="L6578">		final Map&lt;String, ImplementationStubInfo&gt; implsInInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc" id="L6579">		final Map&lt;String, ImplementationStubInfo&gt; implsInInterfacesByID = new HashMap&lt;&gt;();</span>

<span class="nc" id="L6581">		final Map&lt;String, PropertyStubInfo&gt; propertiesInInterfaces = new HashMap&lt;&gt;();</span>

<span class="nc" id="L6583">		final List&lt;String&gt; propertyListForStub = new LinkedList&lt;&gt;();</span>

<span class="nc" id="L6585">		final MetaClass classInfo = classMgrApi.getClassInfo(metaClassID);</span>

<span class="nc bnc" id="L6587" title="All 2 branches missed.">		for (final Entry&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt; curInfo : infoOfInterfacesAndContractsOfClass</span>
<span class="nc" id="L6588">				.entrySet()) {</span>
<span class="nc" id="L6589">			final ContractID contractID = curInfo.getKey();</span>
<span class="nc" id="L6590">			final Contract contractInfo = curInfo.getValue().getFirst();</span>
<span class="nc" id="L6591">			final Interface interfaceInfo = curInfo.getValue().getSecond();</span>
<span class="nc" id="L6592">			final InterfaceID interfaceID = interfaceInfo.getDataClayID();</span>

<span class="nc bnc" id="L6594" title="All 2 branches missed.">			if (!metaClassID.equals(interfaceInfo.getMetaClassID())) {</span>
<span class="nc" id="L6595">				throw new DataClayRuntimeException(ERRORCODE.BAD_INTERFACE,</span>
						&quot;All interfaces should be defined for the same MetaClass&quot;, false);
			}

			// Build the info for the properties of the stub
<span class="nc" id="L6600">			final SortedSet&lt;Property&gt; propertiesInStub = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L6601" title="All 2 branches missed.">			for (final PropertyID propertyID : interfaceInfo.getPropertiesIDs()) {</span>
<span class="nc" id="L6602">				final Property prop = classMgrApi.getPropertyInfo(propertyID);</span>
<span class="nc" id="L6603">				propertiesInStub.add(prop);</span>

<span class="nc bnc" id="L6605" title="All 2 branches missed.">				if (!propertiesInInterfaces.containsKey(propertyID.toString())) {</span>
<span class="nc" id="L6606">					final PropertyStubInfo psi = new PropertyStubInfo(propertyID, prop.getName(), prop.getType(),</span>
<span class="nc" id="L6607">							prop.getGetterOperationID(), prop.getSetterOperationID(), prop.getNamespace(),</span>
<span class="nc" id="L6608">							prop.getNamespaceID(), prop.getBeforeUpdate(), prop.getAfterUpdate(), prop.getInMaster());</span>
<span class="nc" id="L6609">					propertiesInInterfaces.put(prop.getName(), psi);</span>
				}
<span class="nc" id="L6611">			}</span>
			// Now add all the names of properties, sorted
<span class="nc bnc" id="L6613" title="All 2 branches missed.">			for (final Property prop : propertiesInStub) {</span>
<span class="nc" id="L6614">				propertyListForStub.add(prop.getName());</span>
<span class="nc" id="L6615">			}</span>

			// Build the info for the operations of the stub
<span class="nc bnc" id="L6618" title="All 2 branches missed.">			for (final OperationID operationID : interfaceInfo.getOperationsIDs()) {</span>
				// TODO: We could think about a better mechanism to select which is the remote
				// implementation
				// for the operations of the stub, now we are getting LAST one (6 Feb 2014
				// dgasull)
<span class="nc" id="L6623">				final Map&lt;OperationID, OpImplementations&gt; opsImpls = contractInfo.getInterfacesInContract()</span>
<span class="nc" id="L6624">						.get(interfaceID).getAccessibleImplementations();</span>
<span class="nc" id="L6625">				final OpImplementations opImpls = opsImpls.get(operationID);</span>
<span class="nc" id="L6626">				final Operation op = classMgrApi.getOperationInfo(operationID);</span>

				// Get info of remote implementation to get responsible
<span class="nc" id="L6629">				final HashSet&lt;ImplementationID&gt; implsIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6630">				implsIDs.add(opImpls.getRemoteImplementationID());</span>
<span class="nc" id="L6631">				final Implementation implInfo = classMgrApi.getInfoOfImplementations(implsIDs)</span>
<span class="nc" id="L6632">						.get(opImpls.getRemoteImplementationID());</span>

<span class="nc" id="L6634">				final ImplementationStubInfo implStubInfo = new ImplementationStubInfo(implInfo.getNamespace(),</span>
<span class="nc" id="L6635">						implInfo.getClassName(), op.getNameAndDescriptor(), op.getParams(), op.getParamsOrder(),</span>
<span class="nc" id="L6636">						op.getReturnType(), op.getDataClayID(), opImpls.getLocalImplementationID(),</span>
<span class="nc" id="L6637">						opImpls.getRemoteImplementationID(), contractID, interfaceID, applicantAccountID,</span>
<span class="nc" id="L6638">						implInfo.getNamespaceID(), implInfo.getPosition());</span>
<span class="nc" id="L6639">				implsInInterfaces.put(implInfo.getOpNameAndDescriptor(), implStubInfo);</span>
<span class="nc" id="L6640">				implsInInterfacesByID.put(implStubInfo.getLocalImplID().toString(), implStubInfo);</span>
<span class="nc" id="L6641">				implsInInterfacesByID.put(implStubInfo.getRemoteImplID().toString(), implStubInfo);</span>
<span class="nc" id="L6642">			}</span>
<span class="nc" id="L6643">		}</span>

		/*
		 * // WARNING abarcelo -- Removed the language check because this function
		 * should be agnostic // Before, the namespacesIDs were being tracked --and here
		 * they were checked.
		 *
		 * // Get namespaces info Map&lt;NamespaceID, Namespace&gt; namespacesInfo =
		 * namespaceMgrApi.getNamespacesInfo(namespacesIDs);
		 * checkNamespacesLanguage(namespacesInfo); // TODO maybe the language check
		 * should be done on getStubs (for non-Babel scenarios)?
		 */

<span class="nc" id="L6656">		String nameOfParentClass = null;</span>
<span class="nc bnc" id="L6657" title="All 2 branches missed.">		if (classInfo.getParentType() != null) {</span>
<span class="nc" id="L6658">			nameOfParentClass = classInfo.getParentType().getTypeName();</span>
		}

<span class="nc" id="L6661">		return new StubInfo(classInfo.getNamespace(), classInfo.getName(), nameOfParentClass, applicantAccountID,</span>
<span class="nc" id="L6662">				classInfo.getDataClayID(), classInfo.getNamespaceID(), implsInInterfacesByID, implsInInterfaces,</span>
				propertiesInInterfaces, propertyListForStub,
<span class="nc" id="L6664">				new HashSet&lt;&gt;(infoOfInterfacesAndContractsOfClass.keySet()));</span>
	}

	/**
	 * Retrieve the StubInfo with all implementations and information.
	 *
	 * @param metaClassID
	 *            The ID for the MetaClass. All provided Interfaces should be
	 *            consistent with it.
	 * @return The StubInfo for the specified class.
	 * @throws RemoteException
	 *             thrown by ClassManager
	 */
	private StubInfo getStubInfoForExecutionClass(final MetaClassID metaClassID) {

		// Merge of operations and properties
<span class="nc" id="L6680">		final Map&lt;String, ImplementationStubInfo&gt; implsInInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc" id="L6681">		final Map&lt;String, ImplementationStubInfo&gt; implsInInterfacesByID = new HashMap&lt;&gt;();</span>

<span class="nc" id="L6683">		final Map&lt;String, PropertyStubInfo&gt; propertiesInInterfaces = new HashMap&lt;&gt;();</span>
<span class="nc" id="L6684">		final List&lt;String&gt; propertyListForStub = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L6685">		final MetaClass classInfo = classMgrApi.getClassInfo(metaClassID);</span>

		// Build the info for the properties of the stub
<span class="nc" id="L6688">		final SortedSet&lt;Property&gt; propertiesInStub = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L6689" title="All 2 branches missed.">		for (final Property prop : classInfo.getProperties()) {</span>
<span class="nc" id="L6690">			final PropertyID propertyID = prop.getDataClayID();</span>
<span class="nc" id="L6691">			propertiesInStub.add(prop);</span>
<span class="nc bnc" id="L6692" title="All 2 branches missed.">			if (!propertiesInInterfaces.containsKey(propertyID.toString())) {</span>
<span class="nc" id="L6693">				propertiesInInterfaces.put(prop.getName(),</span>
<span class="nc" id="L6694">						new PropertyStubInfo(propertyID, prop.getName(), prop.getType(), prop.getGetterOperationID(),</span>
<span class="nc" id="L6695">								prop.getSetterOperationID(), prop.getNamespace(), prop.getNamespaceID(),</span>
<span class="nc" id="L6696">								prop.getBeforeUpdate(), prop.getAfterUpdate(), prop.getInMaster()));</span>
			}
<span class="nc" id="L6698">		}</span>
		// Now add all the names of properties, sorted
<span class="nc bnc" id="L6700" title="All 2 branches missed.">		for (final Property prop : propertiesInStub) {</span>
<span class="nc" id="L6701">			propertyListForStub.add(prop.getName());</span>
<span class="nc" id="L6702">		}</span>

		// Build the info for the operations of the stub
<span class="nc bnc" id="L6705" title="All 2 branches missed.">		for (final Operation op : classInfo.getOperations()) {</span>
<span class="nc bnc" id="L6706" title="All 2 branches missed.">			for (final Implementation impl : op.getImplementations()) {</span>
				// Get info of remote implementation to get responsible
<span class="nc" id="L6708">				final ImplementationStubInfo implStubInfo = new ImplementationStubInfo(impl.getNamespace(),</span>
<span class="nc" id="L6709">						impl.getClassName(), op.getNameAndDescriptor(), op.getParams(), op.getParamsOrder(),</span>
<span class="nc" id="L6710">						op.getReturnType(), op.getDataClayID(), impl.getDataClayID(), impl.getDataClayID(), null, null,</span>
<span class="nc" id="L6711">						null, impl.getNamespaceID(), impl.getPosition());</span>

				// Prepare opNameAndSignature : opName + $$ + numImpl + signature
<span class="nc" id="L6714">				final String opNameAndSignatureExec = op.getName() + &quot;$$&quot; + impl.getPosition() + op.getDescriptor();</span>
<span class="nc" id="L6715">				implsInInterfaces.put(opNameAndSignatureExec, implStubInfo);</span>
<span class="nc" id="L6716">				implsInInterfacesByID.put(implStubInfo.getLocalImplID().toString(), implStubInfo);</span>
<span class="nc" id="L6717">				implsInInterfacesByID.put(implStubInfo.getRemoteImplID().toString(), implStubInfo);</span>
<span class="nc" id="L6718">			}</span>
<span class="nc" id="L6719">		}</span>

<span class="nc" id="L6721">		String nameOfParentClass = null;</span>
<span class="nc bnc" id="L6722" title="All 2 branches missed.">		if (classInfo.getParentType() != null) {</span>
			// Execution class must include namespace
<span class="nc" id="L6724">			nameOfParentClass = classInfo.getNamespace() + &quot;.&quot; + classInfo.getParentType().getTypeName();</span>
		}
<span class="nc" id="L6726">		return new StubInfo(classInfo.getNamespace(), classInfo.getName(), nameOfParentClass, null,</span>
<span class="nc" id="L6727">				classInfo.getDataClayID(), classInfo.getNamespaceID(), implsInInterfacesByID, implsInInterfaces,</span>
				propertiesInInterfaces, propertyListForStub, null);
	}

	/**
	 * Method that generates the &quot;Babel&quot; stub (language independent YAML-based)
	 * corresponding to the interfaces in contracts provided.
	 * 
	 * @param applicantAccountID
	 *            the applicant for the stub
	 * @param metaClassID
	 *            The ID for the MetaClass. All provided Interfaces should be
	 *            consistent with it.
	 * @param infoOfInterfacesAndContractsOfClass
	 *            info of the contracts related with the class of the stub to be
	 *            generated
	 * @return The yaml representation of the babel stub. FAIL otherwise.
	 */
	private String generateBabelStub(final AccountID applicantAccountID, final MetaClassID metaClassID,
			final LinkedHashMap&lt;ContractID, Tuple&lt;Contract, Interface&gt;&gt; infoOfInterfacesAndContractsOfClass) {
<span class="nc" id="L6747">		final StubInfo stubInfo = getStubInfoForMetaClass(applicantAccountID, metaClassID,</span>
				infoOfInterfacesAndContractsOfClass);
<span class="nc" id="L6749">		final Yaml yaml = CommonYAML.getYamlObject();</span>
<span class="nc" id="L6750">		final String babelStubStructure = yaml.dump(stubInfo);</span>
<span class="nc" id="L6751">		return babelStubStructure;</span>

	}

	@Override
	public void activateTracing(final int currentAvailableTaskID) {
<span class="nc" id="L6757">		LOGGER.info(&quot;Extrae activating trace with task ID {}&quot;, currentAvailableTaskID);</span>
		
<span class="nc" id="L6759">		synchronized (DataClayExtrae.class) { //All workers could try to do it</span>
<span class="nc bnc" id="L6760" title="All 2 branches missed.">			if (DataClayExtrae.extraeTracingIsEnabled()) { </span>
<span class="nc" id="L6761">				LOGGER.info(&quot;Extrae already enabled&quot;);</span>
<span class="nc" id="L6762">				return; </span>
			}
			try {
<span class="nc" id="L6765">				int nextTaskID = 1;</span>
<span class="nc bnc" id="L6766" title="All 2 branches missed.">				if (currentAvailableTaskID != 0) { </span>
					// A task ID available = 0 means that the client was activated only for dataclay without compss
					// therefore LogicModule task id is 1
<span class="nc" id="L6769">					nextTaskID = currentAvailableTaskID;</span>
				}

<span class="nc" id="L6772">				LOGGER.info(&quot;Initializing extrae with next available task id {}&quot;, nextTaskID);</span>
<span class="nc" id="L6773">				DataClayExtrae.setCurrentAvailableTaskID(nextTaskID);</span>
<span class="nc" id="L6774">				DataClayExtrae.initializeExtrae(true);</span>

				// DataServices Paraver traces
<span class="nc bnc" id="L6777" title="All 2 branches missed.">				for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_JAVA)</span>
<span class="nc" id="L6778">						.values()) {</span>
<span class="nc" id="L6779">					LOGGER.info(&quot;Activating Extrae in node {}&quot;, curApi.getSecond());</span>
<span class="nc" id="L6780">					curApi.getFirst().activateTracing(DataClayExtrae.getAndIncrementCurrentAvailableTaskID());</span>
<span class="nc" id="L6781">				}</span>
<span class="nc bnc" id="L6782" title="All 2 branches missed.">				for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_PYTHON)</span>
<span class="nc" id="L6783">						.values()) {</span>
<span class="nc" id="L6784">					LOGGER.info(&quot;Activating Extrae in node {}&quot;, curApi.getSecond());</span>
<span class="nc" id="L6785">					curApi.getFirst().activateTracing(DataClayExtrae.getAndIncrementCurrentAvailableTaskID());</span>

<span class="nc" id="L6787">				}</span>
<span class="nc" id="L6788">			} catch (final Exception ex) {</span>
<span class="nc" id="L6789">				LOGGER.debug(&quot;activateTracing error&quot;, ex);</span>
<span class="nc" id="L6790">				throw ex;</span>
<span class="nc" id="L6791">			}</span>
<span class="nc" id="L6792">		}</span>
<span class="nc" id="L6793">	}</span>

	@Override
	public void deactivateTracing() {
<span class="nc bnc" id="L6797" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L6798">			LOGGER.debug(&quot;** DEACTIVATING EXTRAE TRACING **&quot;);</span>
		}
		// DataServices Paraver traces
<span class="nc" id="L6801">		synchronized (DataClayExtrae.class) { //All workers could try to do it</span>
<span class="nc bnc" id="L6802" title="All 2 branches missed.">			if (DataClayExtrae.extraeTracingIsEnabled()) { //sanity check</span>
<span class="nc" id="L6803">				LOGGER.debug(&quot;Starting deactivation of traces&quot;);</span>
<span class="nc bnc" id="L6804" title="All 2 branches missed.">				for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_JAVA)</span>
<span class="nc" id="L6805">						.values()) {</span>
<span class="nc" id="L6806">					LOGGER.debug(&quot;Calling deactivate tracing to DS: &quot; + curApi.getSecond());</span>
<span class="nc" id="L6807">					curApi.getFirst().deactivateTracing();</span>
<span class="nc" id="L6808">				}</span>
<span class="nc bnc" id="L6809" title="All 2 branches missed.">				for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_PYTHON)</span>
<span class="nc" id="L6810">						.values()) {</span>
<span class="nc" id="L6811">					LOGGER.debug(&quot;Calling deactivate tracing to EE: &quot; + curApi.getSecond());</span>
<span class="nc" id="L6812">					curApi.getFirst().deactivateTracing();</span>
<span class="nc" id="L6813">				}</span>
<span class="nc" id="L6814">				DataClayExtrae.finishTracing(true);</span>
			}
<span class="nc" id="L6816">		}</span>
<span class="nc" id="L6817">	}</span>

	@Override
	public void cleanMetaDataCaches() {
<span class="nc" id="L6821">		this.metaDataSrvApi.cleanCaches();</span>
<span class="nc" id="L6822">	}</span>

	@Override
	public Map&lt;String, byte[]&gt; getTraces() { 
<span class="nc" id="L6826">		LOGGER.info(&quot;Getting Extrae traces&quot;);</span>
<span class="nc" id="L6827">		synchronized (DataClayExtrae.class) { //All workers could try to do it</span>
<span class="nc" id="L6828">			final Map&lt;String, byte[]&gt; allTraces = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L6829" title="All 2 branches missed.">			if (DataClayExtrae.isGeneratedTraces()) {</span>
				// Call DSs 
<span class="nc bnc" id="L6831" title="All 2 branches missed.">				for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_JAVA)</span>
<span class="nc" id="L6832">						.values()) {</span>
<span class="nc" id="L6833">					LOGGER.debug(&quot;Calling get traces to DS: &quot; + curApi.getSecond());</span>
<span class="nc" id="L6834">					allTraces.putAll(curApi.getFirst().getTraces());</span>
<span class="nc" id="L6835">				}</span>
<span class="nc bnc" id="L6836" title="All 2 branches missed.">				for (final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; curApi : this.getExecutionEnvironments(Langs.LANG_PYTHON)</span>
<span class="nc" id="L6837">						.values()) {</span>
<span class="nc" id="L6838">					LOGGER.debug(&quot;Calling get traces to DS: &quot; + curApi.getSecond());</span>
<span class="nc" id="L6839">					allTraces.putAll(curApi.getFirst().getTraces());</span>
<span class="nc" id="L6840">				}</span>
<span class="nc" id="L6841">				allTraces.putAll(DataClayExtrae.getTraces());</span>
			}
<span class="nc" id="L6843">			return allTraces;</span>
		}

	}

	/**
	 * Wait for all asynchronous request to finish.
	 */
	public void waitAndProcessAllAsyncRequests() {
<span class="nc" id="L6852">		grpcClient.waitAndProcessAllAsyncRequests();</span>
<span class="nc" id="L6853">	}</span>

	@Override
	public void closeManagerDb() {

<span class="nc" id="L6858">		this.accountMgrApi.getDbHandler().close();</span>
<span class="nc" id="L6859">		this.classMgrApi.getDbHandler().close();</span>
<span class="nc" id="L6860">		this.contractMgrApi.getDbHandler().close();</span>
<span class="nc" id="L6861">		this.datacontractMgrApi.getDbHandler().close();</span>
<span class="nc" id="L6862">		this.dataSetMgrApi.getDbHandler().close();</span>
<span class="nc" id="L6863">		this.namespaceMgrApi.getDbHandler().close();</span>
<span class="nc" id="L6864">		this.interfaceMgrApi.getDbHandler().close();</span>
<span class="nc bnc" id="L6865" title="All 2 branches missed.">		if (this.notificationMgrApi != null) {</span>
<span class="nc" id="L6866">			this.notificationMgrApi.getNotificationDB().close();</span>
		}
<span class="nc" id="L6868">		this.sessionMgrApi.getDbHandler().close();</span>

<span class="nc" id="L6870">	}</span>

	/**
	 * Finish cache threads.
	 * 
	 * @if some exception occurs
	 */
	public void finishCacheThreads() {
<span class="nc" id="L6878">		LOGGER.debug(&quot;Finishing client connections...&quot;);</span>
<span class="nc" id="L6879">		grpcClient.finishClientConnections();</span>
<span class="nc" id="L6880">		this.sessionMgrApi.finishCacheThreads();</span>
<span class="nc" id="L6881">		storageLocations.clear();</span>
<span class="nc" id="L6882">		execEnvironments.clear();</span>
<span class="nc" id="L6883">	}</span>

	@Override
	public void closeDb() {
<span class="nc bnc" id="L6887" title="All 2 branches missed.">		if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>
<span class="nc" id="L6888">			this.notificationMgrApi.closeManager();</span>
		}
<span class="nc" id="L6890">		this.metaDataSrvApi.closeDbHandler();</span>
<span class="nc" id="L6891">	}</span>

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public AccountManagerDB getAccountManagerDB() {
<span class="nc" id="L6899">		return this.accountMgrApi.getDbHandler();</span>
	}

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public ClassManagerDB getClassManagerDB() {
<span class="nc" id="L6908">		return this.classMgrApi.getDbHandler();</span>
	}

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public ContractManagerDB getContractManagerDB() {
<span class="nc" id="L6917">		return this.contractMgrApi.getDbHandler();</span>
	}

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public DataContractManagerDB getDataContractManagerDB() {
<span class="nc" id="L6926">		return this.datacontractMgrApi.getDbHandler();</span>
	}

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public DataSetManagerDB getDataSetManagerDB() {
<span class="nc" id="L6935">		return this.dataSetMgrApi.getDbHandler();</span>
	}

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public NamespaceManagerDB getNamespaceManagerDB() {
<span class="nc" id="L6944">		return this.namespaceMgrApi.getDbHandler();</span>
	}

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public InterfaceManagerDB getInterfaceManagerDB() {
<span class="nc" id="L6953">		return this.interfaceMgrApi.getDbHandler();</span>
	}

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public NotificationManagerDB getNotificationManagerDB() {
<span class="nc" id="L6962">		return this.notificationMgrApi.getNotificationDB();</span>
	}

	/**
	 * Get manager db. For testing purposes.
	 * 
	 * @return Manager db.
	 */
	public SessionManagerDB getSessionManagerDB() {
<span class="nc" id="L6971">		return this.sessionMgrApi.getDbHandler();</span>
	}

	/**
	 * Get logic db. For testing purposes.
	 * 
	 * @return metadataservice db.
	 */
	public MetaDataServiceDB getMetaDataServiceDb() {
<span class="nc" id="L6980">		return this.metaDataSrvApi.getDbHandler();</span>
	}

	/**
	 * Get Class manager (for testing purposes)
	 * 
	 * @return ClassManager of this logicModule
	 */
	public ClassManager getClassManager() {
<span class="nc" id="L6989">		return this.classMgrApi;</span>
	}

	@Override
	public ContractID getContractIDOfDataClayProvider(final AccountID accountID, final PasswordCredential credential) {
		// Validate account
<span class="nc bnc" id="L6995" title="All 2 branches missed.">		if (!accountMgrApi.validateAccount(accountID, credential)) {</span>
<span class="nc" id="L6996">			throw new DataClayRuntimeException(ERRORCODE.INVALID_CREDENTIALS);</span>
		}
<span class="nc bnc" id="L6998" title="All 2 branches missed.">		if (publicIDs.dcPublicContractID == null) {</span>
<span class="nc" id="L6999">			throw new DataClayRuntimeException(ERRORCODE.CONTRACT_NOT_EXIST, &quot;No dataClay public contract&quot;, false);</span>
		}
<span class="nc" id="L7001">		return publicIDs.dcPublicContractID;</span>
	}

	/**
	 * @return the shuttingDown
	 */
	public boolean isShuttingDown() {
<span class="nc" id="L7008">		return shuttingDown;</span>
	}

	/**
	 * @param theshuttingDown
	 *            the shuttingDown to set
	 */
	public void setShuttingDown(final boolean theshuttingDown) {
<span class="nc" id="L7016">		this.shuttingDown = theshuttingDown;</span>
<span class="nc" id="L7017">	}</span>

	/**
	 * For testing purposes.
	 * 
	 * @return DBHandler of this LM.
	 */
	public DBHandler getDbHandler() {
<span class="nc" id="L7025">		return logicModuleHandler;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>