<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataClay.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.api</a> &gt; <span class="el_source">DataClay.java</span></div><h1>DataClay.java</h1><pre class="source lang-java linenums">package es.bsc.dataclay.api;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.objectweb.asm.commons.Method;

import es.bsc.dataclay.DataClayMockObject;
import es.bsc.dataclay.DataClayObject;
import es.bsc.dataclay.commonruntime.ClientManagementLib;
import es.bsc.dataclay.commonruntime.ClientRuntime;
import es.bsc.dataclay.commonruntime.DataClayRuntime;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.exceptions.metadataservice.ObjectNotRegisteredException;
import es.bsc.dataclay.extrae.DataClayExtrae;
import es.bsc.dataclay.tool.GetBackends;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.ProcessEnvironment;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.ContractID;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.SessionID;
import es.bsc.dataclay.util.management.accountmgr.PasswordCredential;
import es.bsc.dataclay.util.management.metadataservice.MetaDataInfo;
import es.bsc.dataclay.util.structs.Triple;

/**
 * This class contains the dataClay public API.
 */
public final class DataClay {

	/** Logger. */
<span class="nc" id="L51">	private static final Logger LOGGER = LogManager.getLogger(&quot;DataClay.api&quot;);</span>

	/** Default config file location */
<span class="nc" id="L54">	private static final String CONFIGFILEPATH = &quot;.&quot; + File.separatorChar + &quot;cfgfiles&quot; + File.separatorChar</span>
			+ &quot;session.properties&quot;;

	/** Environment variable where configuration file can be specified. */
	public static final String CONFIGFILEPATH_ENV = &quot;DATACLAYSESSIONCONFIG&quot;;

	/** Indicates if debug is enabled. */
<span class="nc" id="L61">	protected static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>
	/** Prop name for account. */
	private static final String ACCOUNT_PROP = &quot;Account&quot;;
	/** Prop name for password. */
	private static final String PASSWORD_PROP = &quot;Password&quot;;
	/** Prop name for stubs classpath. */
	private static final String CLASSPATH_STUBS_PROP = &quot;StubsClasspath&quot;;
	/** Prop name for datasets. */
	private static final String DATASETS_PROP = &quot;DataSets&quot;;
	/** Prop name for default dataset for store. */
	private static final String DATASET_STORE = &quot;DataSetForStore&quot;;
	/** Prop name for defining client.properties path. */
	private static final String DATACLAY_CLIENT_CONFIG = &quot;DataClayClientConfig&quot;;
	/** Prop name for defining global.properties path. */
	private static final String DATACLAY_GLOBAL_CONFIG = &quot;DataClayGlobalConfig&quot;;
	/** Prop name for defining if tracing is enabled. */
	private static final String TRACING_ENABLED = &quot;Tracing&quot;;
	/** Prop name for defining first available Extrae task ID. */
	private static final String EXTRAE_STARTING_TASK_ID = &quot;ExtraeStartingTaskID&quot;;
	/** Indicates path to extrae wrapper library. */
	private static final String JAVACLAY_EXTRAE_WRAPPER_LIB_PROP = &quot;javaClayExtraeWrapperLib&quot;;
	/** Prop name for the contracts (optional, used under Python). */
	private static final String CONTRACTS_PROP = &quot;Contracts&quot;;
	/** Prop name to specify the &quot;local&quot; backend */
	private static final String LOCAL_BACKEND = &quot;LocalBackend&quot;;

	/** Token that user might use to specify the 'local' location in a data op */
	private static final String LOCALTOKEN = &quot;LOCAL&quot;;

	/** Separator token for datasets. */
	public static final String DATASET_SEPARATOR_TOKEN = &quot;:&quot;;

	/** Indicates Extrae was initialized by COMPSs. */
<span class="nc" id="L94">	private static boolean EXTRAE_COMPSS = false;</span>

	/**
	 * UserClientLib for the session. WARNING: CURRENTLY IS PUBLIC IN ORDER TO ALLOW
	 * THREADS CREATED IN CLIENT TO USE THE COMMONLIB. Check design.
	 */
	public static ClientRuntime commonLib;
	/** Backends by name. */
	private static Map&lt;String, Set&lt;BackendID&gt;&gt; pyBackendsByName;
	private static Map&lt;String, Set&lt;BackendID&gt;&gt; jBackendsByName;
	/** Execution Environments by hostname. */
	private static Map&lt;String, Set&lt;BackendID&gt;&gt; pyBackendsByHostname;
	private static Map&lt;String, Set&lt;BackendID&gt;&gt; jBackendsByHostname;
	/** Backends by ID. */
	private static ConcurrentHashMap&lt;BackendID, Backend&gt; backendsByID;
	private static ConcurrentHashMap&lt;BackendID, Backend&gt; jBackendsByID;
	private static ConcurrentHashMap&lt;BackendID, Backend&gt; pyBackendsByID;

	/** LOCAL BackendID */
	public static BackendID jLOCAL;
	public static BackendID pLOCAL;

	/**
	 * Forbidden constructor
	 */
	private DataClay() {

	}

<span class="nc" id="L123">	private static String setCfgFilePath = null;</span>

	public static void setSessionFile(final String path) throws DataClayException {
<span class="nc bnc" id="L126" title="All 4 branches missed.">		if (path == null || path.isEmpty()) {</span>
<span class="nc" id="L127">			throw new DataClayException(&quot;Null or empty config file path&quot;);</span>
		}
<span class="nc" id="L129">		setCfgFilePath = path;</span>
<span class="nc" id="L130">	}</span>

	/**
	 * Finish connections to DataClay.
	 *
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	public static void finish() throws DataClayException {
		try {

<span class="nc bnc" id="L141" title="All 2 branches missed.">			if (DataClayExtrae.extraeTracingIsEnabled()) {</span>
<span class="nc" id="L142">				LOGGER.info(&quot;Extrae is active, deactivating it...&quot;);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">				if (EXTRAE_COMPSS) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">					if (DataClayExtrae.getWrapperTaskID() == 0) {</span>
<span class="nc" id="L145">						LOGGER.info(&quot;Calling deactivate extrae in dataclay services&quot;);</span>
<span class="nc" id="L146">						DataClay.deactivateTracingInDataClayServices();</span>
<span class="nc" id="L147">						LOGGER.info(&quot;Getting traces in dataclay services&quot;);</span>

<span class="nc" id="L149">						deactivateTracing(true);</span>
<span class="nc" id="L150">						getTracesInDataClayServices();</span>
					}  else {
<span class="nc" id="L152">						deactivateTracing(false);</span>
					}

				} else {

<span class="nc bnc" id="L157" title="All 2 branches missed.">					if (DataClayExtrae.getWrapperTaskID() == 0) {</span>
<span class="nc" id="L158">						LOGGER.info(&quot;Calling deactivate extrae in dataclay services&quot;);</span>
<span class="nc" id="L159">						DataClay.deactivateTracingInDataClayServices();</span>
<span class="nc" id="L160">						LOGGER.info(&quot;Getting traces in dataclay services&quot;);</span>
<span class="nc" id="L161">						deactivateTracing(true);</span>
<span class="nc" id="L162">						getTracesInDataClayServices();</span>


						// Merge

						// -- Linux --
<span class="nc" id="L168">						String command = &quot;mpi2prv -keep-mpits -no-syn -f TRACE.mpits -o ./trace/dctrace.prv&quot;;</span>
						// Run a shell command
<span class="nc" id="L170">						System.out.println(command);</span>
<span class="nc" id="L171">						Process process = Runtime.getRuntime().exec(command);</span>

						// Run a shell script
						// Process process = Runtime.getRuntime().exec(&quot;path/to/hello.sh&quot;);

						// -- Windows --
						// Run a command
						//Process process = Runtime.getRuntime().exec(&quot;cmd /c dir C:\\Users\\mkyong&quot;);
<span class="nc" id="L179">						BufferedReader err = new BufferedReader(new InputStreamReader(process.getErrorStream()));</span>
<span class="nc" id="L180">						BufferedReader input = new BufferedReader(new InputStreamReader(process.getInputStream()));</span>
						String line;
<span class="nc bnc" id="L182" title="All 2 branches missed.">						while ((line = input.readLine()) != null) {</span>
<span class="nc" id="L183">							System.out.println(line);</span>
						}
<span class="nc bnc" id="L185" title="All 2 branches missed.">						while ((line = err.readLine()) != null) {</span>
<span class="nc" id="L186">							System.err.println(line);</span>
						}
<span class="nc" id="L188">						System.out.flush();</span>
<span class="nc" id="L189">						System.err.flush();</span>
						try {
<span class="nc" id="L191">							process.waitFor();  // wait for process to complete</span>
<span class="nc" id="L192">						} catch (InterruptedException e) {</span>
<span class="nc" id="L193">							System.err.println(e);  // &quot;Can'tHappen&quot;</span>
<span class="nc" id="L194">						}</span>

<span class="nc" id="L196">					} else {</span>
<span class="nc" id="L197">						deactivateTracing(true);</span>
					}

				}


			}
<span class="nc" id="L204">		} catch (final Exception e) {</span>
<span class="nc" id="L205">			e.printStackTrace();</span>
<span class="nc" id="L206">		}</span>

		try {
<span class="nc" id="L209">			ClientManagementLib.finishConnections();</span>
<span class="nc" id="L210">		} catch (final Exception e) {</span>
<span class="nc" id="L211">			throw new DataClayException(e);</span>
<span class="nc" id="L212">		}</span>
<span class="nc" id="L213">	}</span>

	/**
	 * Method that initializes the lib.
	 *
	 * @param configFilePath
	 *            path where the cfg file is stored.
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	public static void init() throws DataClayException {
<span class="nc" id="L224">		initInternal(1, Langs.LANG_JAVA);</span>
<span class="nc" id="L225">	}</span>

	/**
	 * Initialize dataClay waiting for the following number of backends of language provided.
	 * @param numBackends
	 *            Number of backends to wait for
	 * @param language language of backend to wait for
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	public static void init(final int numBackends, final Langs language) throws DataClayException {
<span class="nc" id="L236">		initInternal(numBackends, language);</span>
<span class="nc" id="L237">	}</span>

	/**
	 * Initialize dataClay waiting for the following number of backends of language provided.
	 * @param numBackends
	 *            Number of backends to wait for
	 * @param language language of backend to wait for
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	private static void initInternal(final int numBackends, final Langs language) throws DataClayException {
		try {
			final File f;
			String configFilePath;
<span class="nc bnc" id="L251" title="All 2 branches missed.">			if (setCfgFilePath != null) {</span>
<span class="nc" id="L252">				configFilePath = setCfgFilePath;</span>
			} else {
<span class="nc" id="L254">				configFilePath = ProcessEnvironment.getInstance().get(CONFIGFILEPATH_ENV);</span>
			}
<span class="nc bnc" id="L256" title="All 4 branches missed.">			if (configFilePath != null &amp;&amp; !configFilePath.isEmpty()) {</span>
<span class="nc" id="L257">				f = new File(configFilePath);</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">				if (f.isFile() &amp;&amp; f.exists()) {</span>
<span class="nc" id="L259">					LOGGER.info(&quot;Found {}. Initializing session with properties located at {}&quot;, CONFIGFILEPATH_ENV,</span>
							configFilePath);
				}
			} else {
<span class="nc" id="L263">				final Path path = Paths.get(CONFIGFILEPATH).normalize();</span>
<span class="nc" id="L264">				LOGGER.info(&quot;Session file not found or {}  not properly set Trying default location {}&quot;,</span>
<span class="nc" id="L265">						CONFIGFILEPATH_ENV, path.toAbsolutePath());</span>
<span class="nc" id="L266">				configFilePath = path.toAbsolutePath().toString();</span>
<span class="nc" id="L267">				f = new File(configFilePath);</span>
			}

<span class="nc" id="L270">			final FileInputStream configFile = new FileInputStream(f);</span>
<span class="nc" id="L271">			final Properties prop = new Properties();</span>
<span class="nc" id="L272">			prop.load(configFile);</span>
<span class="nc" id="L273">			configFile.close();</span>

			// Parse global properties
<span class="nc" id="L276">			final String globalConfig = prop.getProperty(DATACLAY_GLOBAL_CONFIG);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">			if (globalConfig != null) {</span>
<span class="nc" id="L278">				Configuration.Flags.reloadGlobalConfiguration(globalConfig);</span>
			}

			// Parse config properties
<span class="nc" id="L282">			String dcClientConfig = prop.getProperty(DATACLAY_CLIENT_CONFIG);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">			if (dcClientConfig != null) {</span>
<span class="nc" id="L284">				dcClientConfig = dcClientConfig.trim();</span>
<span class="nc" id="L285">				ClientManagementLib.initializeCMLib(dcClientConfig);</span>
			} else {
<span class="nc" id="L287">				ClientManagementLib.initializeCMLib(null);</span>
			}

			// Wait for one DS to be ready
			try {
<span class="nc bnc" id="L292" title="All 2 branches missed.">				while ( GetBackends.getBackends(&quot;admin&quot;,&quot;admin&quot;,language).size() &lt; numBackends) {</span>
<span class="nc" id="L293">					System.out.println(&quot;[dataClay] Waiting for backend to be ready...&quot;);</span>
<span class="nc" id="L294">					Thread.sleep(2000L); //sleep 2 seconds</span>
				}
<span class="nc" id="L296">			} catch (final Exception e) {</span>
<span class="nc" id="L297">				e.printStackTrace();</span>
<span class="nc" id="L298">			}</span>

<span class="nc" id="L300">			final String account = prop.getProperty(ACCOUNT_PROP).trim();</span>
<span class="nc" id="L301">			final AccountID accountID = ClientManagementLib.getAccountID(account);</span>

<span class="nc" id="L303">			final String password = prop.getProperty(PASSWORD_PROP).trim();</span>
<span class="nc" id="L304">			final PasswordCredential credential = new PasswordCredential(password);</span>

<span class="nc" id="L306">			final String dataSetsStr = prop.getProperty(DATASETS_PROP);</span>
<span class="nc" id="L307">			final String[] dataSetsArray = dataSetsStr.split(DATASET_SEPARATOR_TOKEN);</span>
<span class="nc" id="L308">			final HashSet&lt;String&gt; dataSets = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">			for (final String dataSet : dataSetsArray) {</span>
<span class="nc" id="L310">				dataSets.add(dataSet.trim());</span>
			}
<span class="nc" id="L312">			final String dataSetForStore = prop.getProperty(DATASET_STORE).trim();</span>

			// The properties may contain the list of contracts
<span class="nc" id="L315">			final String allContracts = prop.getProperty(CONTRACTS_PROP);</span>

			// Init session
			final SessionID sessionID;
<span class="nc bnc" id="L319" title="All 2 branches missed.">			if (allContracts == null) {</span>
				// No contracts specified, walk the stubs
<span class="nc" id="L321">				final String classPathOfStubs = prop.getProperty(CLASSPATH_STUBS_PROP);</span>
<span class="nc" id="L322">				sessionID = ClientManagementLib.newSession(accountID, credential, classPathOfStubs, dataSets,</span>
						dataSetForStore);
<span class="nc" id="L324">			} else {</span>
				// Contracts are a comma-separated field, used in Python code
<span class="nc" id="L326">				final Set&lt;ContractID&gt; contracts = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">				for (final String contract : allContracts.split(&quot;,&quot;)) {</span>
<span class="nc" id="L328">					contracts.add(new ContractID(contract.trim()));</span>
				}

<span class="nc" id="L331">				sessionID = ClientManagementLib.newSession(accountID, credential, contracts, dataSets, dataSetForStore);</span>
			}

			// Init all backend structures
<span class="nc" id="L335">			initBackendsInternalInfo(accountID, credential);</span>

			// Init commonLib
<span class="nc" id="L338">			commonLib = ClientManagementLib.getDataClayClientLib();</span>

			// Init local backend if needed
<span class="nc" id="L341">			final String localBackendName = prop.getProperty(LOCAL_BACKEND);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">			if (localBackendName != null) {</span>
<span class="nc" id="L343">				Set&lt;BackendID&gt; localBackends = jBackendsByName.get(localBackendName);</span>
<span class="nc bnc" id="L344" title="All 4 branches missed.">				if (localBackends != null &amp;&amp; !localBackends.isEmpty()) {</span>
<span class="nc" id="L345">					BackendID bkID = null;</span>
					// Get first backend ID, which is an almost random policy
<span class="nc bnc" id="L347" title="All 2 branches missed.">					for (final BackendID aBkID : localBackends) {</span>
<span class="nc" id="L348">						bkID = aBkID;</span>
<span class="nc" id="L349">						break;</span>
					}

<span class="nc" id="L352">					commonLib.setLocalBackend(bkID);</span>
<span class="nc" id="L353">					jLOCAL = bkID;</span>
				}

<span class="nc" id="L356">				localBackends = pyBackendsByName.get(localBackendName);</span>
<span class="nc bnc" id="L357" title="All 4 branches missed.">				if (localBackends != null &amp;&amp; !localBackends.isEmpty()) {</span>
<span class="nc" id="L358">					BackendID bkID = null;</span>
					// Get first backend ID, which is an almost random policy
<span class="nc bnc" id="L360" title="All 2 branches missed.">					for (final BackendID aBkID : localBackends) {</span>
<span class="nc" id="L361">						bkID = aBkID;</span>
<span class="nc" id="L362">						break;</span>
					}

<span class="nc" id="L365">					commonLib.setLocalBackend(bkID);</span>
<span class="nc" id="L366">					pLOCAL = bkID;</span>
				}
			}

<span class="nc" id="L370">			LOGGER.info(&quot;Session: {}&quot;, sessionID);</span>
<span class="nc" id="L371">			LOGGER.info(&quot;dataClay ID: {}&quot;, commonLib.getDataClayID());</span>
<span class="nc" id="L372">			LOGGER.info(&quot;Backends: {}&quot;, getJBackendsByName());</span>
<span class="nc" id="L373">			LOGGER.info(&quot;Python Backends: {}&quot;, getPyBackendsByName());</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">			if (localBackendName != null) {</span>
<span class="nc" id="L375">				LOGGER.info(&quot;Default {} backend: {}&quot;, LOCALTOKEN, localBackendName);</span>
			}


<span class="nc" id="L379">			String javaClayExtraeWrapperLib = prop.getProperty(JAVACLAY_EXTRAE_WRAPPER_LIB_PROP);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">			if (javaClayExtraeWrapperLib!= null) {</span>
<span class="nc" id="L381">				Configuration.Flags.JAVACLAY_EXTRAE_WRAPPER_LIB.setValue(javaClayExtraeWrapperLib);</span>
			}
			/***************************** TRACING **********************************/
			/**
			 * ### READ #### 
			 * Activating tracing with tracing_enabled property set True and starting task id = 0
			 * means we are only tracing dataClay. dataClay client will not increment current available
			 * task ID and will send a 0 to LM, which will understand the 0 as  &quot;only dataClay tracing&quot;
			 * since for compss it is never 0.
			 * Activating tracing with tracing_enabled property set True and starting task id != 0 means
			 * we are tracing COMPSs  and dataClay.
			 * Current client will not initialize Extrae or increment task id since COMPSs already initializes
			 * it for us (as a worker).
			 * In any case, none of them needs to add synchronization event or increment the available task id (only services).
			 * Incrementing available task id is useful to send to N EE/DS nodes.
			 * Remember that activating traces does not mean the application will be traced if Aspects are not properly applied.
			 */
<span class="nc" id="L398">			final String tracingEnabledStr = prop.getProperty(TRACING_ENABLED);</span>
<span class="nc" id="L399">			boolean tracingEnabled = false;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">			if (tracingEnabledStr != null) {</span>
<span class="nc" id="L401">				tracingEnabled = Boolean.valueOf(tracingEnabledStr);</span>
			}
<span class="nc bnc" id="L403" title="All 2 branches missed.">			if (tracingEnabled) {</span>
<span class="nc" id="L404">				LOGGER.info(&quot;Extrae tracing requested&quot;);</span>
<span class="nc" id="L405">				final String strStartingTaskID = prop.getProperty(EXTRAE_STARTING_TASK_ID);</span>
				// Trace with Extrae if enabled. Application will NOT be traced if no 
				// initialization was done (COMPSs initializes it for us) 
				// or Paraver aspects injection were NOT applied.
<span class="nc" id="L409">				LOGGER.info(&quot;Found Starting task id = &quot; + strStartingTaskID);</span>
<span class="nc bnc" id="L410" title="All 4 branches missed.">				if (strStartingTaskID == null || strStartingTaskID.equals(&quot;0&quot;)) {</span>
<span class="nc" id="L411">					DataClay.activateTracing(true);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">					if (DataClayExtrae.getWrapperTaskID() == 0) {</span>
<span class="nc" id="L413">						LOGGER.info(&quot;Activating extrae in all nodes&quot;);</span>
<span class="nc" id="L414">						DataClay.activateTracingInDataClayServices();</span>
					}

				} else {
<span class="nc" id="L418">					EXTRAE_COMPSS = true;</span>

<span class="nc" id="L420">					DataClayExtrae.setCurrentAvailableTaskID(Integer.valueOf(strStartingTaskID));</span>

					// Starting task ID specified, Extrae is supposed to be previously initialized
<span class="nc" id="L423">					DataClay.activateTracing(false);</span>
<span class="nc" id="L424">					LOGGER.info(&quot;Found Extrae tracing Task ID specified: {}&quot;, strStartingTaskID);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">					if (DataClayExtrae.getWrapperTaskID() == 0) { // only in master node (app client withou compss)</span>
<span class="nc" id="L426">						LOGGER.info(&quot;Activating extrae in all nodes&quot;);</span>
<span class="nc" id="L427">						DataClay.activateTracingInDataClayServices();</span>
					}
				}

			}

			/****************************************************************************/

<span class="nc" id="L435">		} catch (final Exception ex) {</span>
<span class="nc" id="L436">			LOGGER.debug(&quot;Exception during init()&quot;, ex);</span>
<span class="nc" id="L437">			throw new DataClayException(ex);</span>
<span class="nc" id="L438">		}</span>
<span class="nc" id="L439">	}</span>

	/**
	 * This method initializes the structures containing backend info (st loc and
	 * exec env) present in any hostname.
	 *
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	private static void initBackendsInternalInfo(final AccountID accountID, final PasswordCredential credential)
			throws DataClayException {
		try {
<span class="nc" id="L451">			backendsByID = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc" id="L453">			jBackendsByName = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L454">			jBackendsByHostname = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc" id="L456">			jBackendsByID = new ConcurrentHashMap&lt;&gt;(</span>
<span class="nc" id="L457">					ClientManagementLib.getExecutionEnvironmentsInfo(accountID, credential, Langs.LANG_JAVA));</span>

<span class="nc" id="L459">			backendsByID.putAll(jBackendsByID);</span>

<span class="nc bnc" id="L461" title="All 2 branches missed.">			for (final Backend backend : jBackendsByID.values()) {</span>
<span class="nc" id="L462">				final BackendID bkID = backend.getDataClayID();</span>

<span class="nc" id="L464">				final String hostname = backend.getHostname();</span>
<span class="nc" id="L465">				final String name = backend.getName();</span>

<span class="nc" id="L467">				Set&lt;BackendID&gt; setExecEnvsPerHostname = jBackendsByHostname.get(hostname);</span>
<span class="nc" id="L468">				Set&lt;BackendID&gt; setExecEnvsPerName = jBackendsByName.get(name);</span>

<span class="nc bnc" id="L470" title="All 2 branches missed.">				if (setExecEnvsPerHostname == null) {</span>
<span class="nc" id="L471">					setExecEnvsPerHostname = new HashSet&lt;&gt;();</span>
<span class="nc" id="L472">					jBackendsByHostname.put(hostname, setExecEnvsPerHostname);</span>
				}

<span class="nc bnc" id="L475" title="All 2 branches missed.">				if (setExecEnvsPerName == null) {</span>
<span class="nc" id="L476">					setExecEnvsPerName = new HashSet&lt;&gt;();</span>
<span class="nc" id="L477">					jBackendsByName.put(hostname, setExecEnvsPerName);</span>
				}

<span class="nc" id="L480">				setExecEnvsPerHostname.add(bkID);</span>
<span class="nc" id="L481">				setExecEnvsPerName.add(bkID);</span>
<span class="nc" id="L482">			}</span>

<span class="nc" id="L484">			LOGGER.info(&quot;Java Backends: {}&quot;, jBackendsByID);</span>

<span class="nc" id="L486">			pyBackendsByName = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L487">			pyBackendsByHostname = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc" id="L489">			pyBackendsByID = new ConcurrentHashMap&lt;&gt;(</span>
<span class="nc" id="L490">					ClientManagementLib.getExecutionEnvironmentsInfo(accountID, credential, Langs.LANG_PYTHON));</span>

<span class="nc" id="L492">			backendsByID.putAll(pyBackendsByID);</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">			for (final Backend backend : pyBackendsByID.values()) {</span>
<span class="nc" id="L495">				final BackendID bkID = backend.getDataClayID();</span>

<span class="nc" id="L497">				final String hostname = backend.getHostname();</span>
<span class="nc" id="L498">				final String name = backend.getName();</span>

<span class="nc" id="L500">				Set&lt;BackendID&gt; setExecEnvsPerHostname = pyBackendsByHostname.get(hostname);</span>
<span class="nc" id="L501">				Set&lt;BackendID&gt; setExecEnvsPerName = pyBackendsByName.get(name);</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">				if (setExecEnvsPerHostname == null) {</span>
<span class="nc" id="L504">					setExecEnvsPerHostname = new HashSet&lt;&gt;();</span>
<span class="nc" id="L505">					pyBackendsByHostname.put(hostname, setExecEnvsPerHostname);</span>
				}

<span class="nc bnc" id="L508" title="All 2 branches missed.">				if (setExecEnvsPerName == null) {</span>
<span class="nc" id="L509">					setExecEnvsPerName = new HashSet&lt;&gt;();</span>
<span class="nc" id="L510">					pyBackendsByName.put(hostname, setExecEnvsPerName);</span>
				}

<span class="nc" id="L513">				setExecEnvsPerHostname.add(bkID);</span>
<span class="nc" id="L514">				setExecEnvsPerName.add(bkID);</span>
<span class="nc" id="L515">			}</span>

<span class="nc" id="L517">			LOGGER.info(&quot;Python Backends: {}&quot;, pyBackendsByID);</span>

<span class="nc" id="L519">		} catch (final Exception ex) {</span>
<span class="nc" id="L520">			LOGGER.debug(&quot;Backend initialization error&quot;, ex);</span>
<span class="nc" id="L521">			throw new DataClayException(ex);</span>
<span class="nc" id="L522">		}</span>
<span class="nc" id="L523">	}</span>

	/**
	 * If the object is accessible, initializes an instance of a stub with the given
	 * objectID.
	 *
	 * @param objectIDstr
	 *            ID of the object
	 * @return An instance of the stub representing the given objectID
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	public static Object getByID(final String objectIDstr) throws DataClayException {
		try {

<span class="nc" id="L538">			final Triple&lt;ObjectID, BackendID, MetaClassID&gt; ids = string2IDandHintID(objectIDstr);</span>
<span class="nc" id="L539">			final ObjectID objectID = ids.getFirst();</span>
<span class="nc" id="L540">			final BackendID hint = ids.getSecond();</span>
<span class="nc" id="L541">			final MetaClassID classID = ids.getThird();</span>

<span class="nc bnc" id="L543" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L544">				DataClayRuntime.LOGGER</span>
<span class="nc" id="L545">						.debug(&quot;[==GetByID from StorageItf==] Creating instance from oid string &quot; + objectIDstr);</span>
			}

			// Class id is null, so asking metadata
<span class="nc" id="L549">			final DataClayObject result = commonLib.getPersistedObjectByOID(objectID, classID, hint);</span>
<span class="nc" id="L550">			return result;</span>

<span class="nc" id="L552">		} catch (final Exception ex) {</span>
<span class="nc" id="L553">			LOGGER.debug(&quot;getbyID error&quot;, ex);</span>
<span class="nc" id="L554">			throw new DataClayException(ex);</span>
		}
	}

	/**
	 * Gets any location of an object.
	 *
	 * @param objectIDstr
	 *            object to retrieve its location
	 * @return a location of the object.
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	public static String getLocation(final String objectIDstr) throws DataClayException {
		try {
<span class="nc bnc" id="L569" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L570">				DataClayRuntime.LOGGER.debug(&quot;[dataClay] Get location for &quot; + objectIDstr);</span>
			}
<span class="nc bnc" id="L572" title="All 4 branches missed.">			if (objectIDstr == null || objectIDstr.trim().isEmpty()) {</span>
<span class="nc" id="L573">				throw new DataClayException(&quot;ERROR in getLocation: Null or empty object string : &quot; + objectIDstr);</span>
			}
<span class="nc" id="L575">			final Triple&lt;ObjectID, BackendID, MetaClassID&gt; objectData = string2IDandHintID(objectIDstr);</span>
<span class="nc" id="L576">			return backendsByID.get(objectData.getSecond()).getHostname();</span>
<span class="nc" id="L577">		} catch (final DataClayException e) {</span>
<span class="nc" id="L578">			throw e;</span>
<span class="nc" id="L579">		} catch (final Exception ex) {</span>
<span class="nc" id="L580">			LOGGER.debug(&quot;getLocation error&quot;, ex);</span>
<span class="nc" id="L581">			throw new DataClayException(ex);</span>
		}
	}

	/**
	 * Gets all the locations of an object.
	 *
	 * @param objectIDstr
	 *            object to retrieve its locations.
	 * @return locations of an object.
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	public static List&lt;String&gt; getLocations(final String objectIDstr) throws DataClayException {
		try {
<span class="nc bnc" id="L596" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L597">				DataClayRuntime.LOGGER.debug(&quot;[dataClay] GetLocations for &quot; + objectIDstr);</span>
			}
<span class="nc bnc" id="L599" title="All 4 branches missed.">			if (objectIDstr == null || objectIDstr.trim().isEmpty()) {</span>
<span class="nc" id="L600">				throw new DataClayException(&quot;ERROR in getLocations: Null or empty object string : &quot; + objectIDstr);</span>
			}
<span class="nc" id="L602">			final Triple&lt;ObjectID, BackendID, MetaClassID&gt; objectData = string2IDandHintID(objectIDstr);</span>
<span class="nc" id="L603">			final ObjectID objectID = objectData.getFirst();</span>
<span class="nc" id="L604">			final BackendID hint = objectData.getSecond();</span>

			// Get locations of the object
<span class="nc" id="L607">			final Set&lt;BackendID&gt; currentLocations = commonLib.getAllLocations(objectID);</span>
<span class="nc bnc" id="L608" title="All 4 branches missed.">			if (currentLocations == null || currentLocations.isEmpty()) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">				if (hint == null) {</span>
<span class="nc" id="L610">					throw new DataClayException(&quot;ERROR in getLocations: object not accessible or does not exist&quot;);</span>
				}
<span class="nc bnc" id="L612" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L613">					LOGGER.debug(&quot;No locations for object {}, assuming volatile and returning hint {}&quot;, objectID, hint);</span>
				}
<span class="nc" id="L615">				return Arrays.asList(backendsByID.get(hint).getHostname());</span>
			}
<span class="nc" id="L617">			final LinkedList&lt;String&gt; result = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">			for (final BackendID location : currentLocations) {</span>
<span class="nc" id="L619">				result.add(backendsByID.get(location).getHostname());</span>
<span class="nc" id="L620">			}</span>
<span class="nc" id="L621">			return result;</span>
<span class="nc" id="L622">		} catch (final DataClayException e) {</span>
<span class="nc" id="L623">			throw e;</span>
<span class="nc" id="L624">		} catch (final Exception ex) {</span>
<span class="nc" id="L625">			LOGGER.debug(&quot;Failed while performing getLocations on {}&quot;, objectIDstr);</span>
<span class="nc" id="L626">			LOGGER.debug(&quot;Current error:&quot;, ex);</span>
<span class="nc" id="L627">			throw new DataClayException(ex);</span>
		}
	}

	/**
	 * Move a replica from source host to dest host.
	 *
	 * @param objectIDstr
	 *            object which replica must be moved.
	 * @param srcHost
	 *            source location of the object replica.
	 * @param destHost
	 *            target location of the object replica.
	 * @throws DataClayException
	 *             if an exception occurs. E.g. if source or dest hosts have no
	 *             backend registered.
	 */
	public static void moveReplica(final String objectIDstr, final String srcHost, final String destHost)
			throws DataClayException {
		try {
<span class="nc bnc" id="L647" title="All 4 branches missed.">			if (srcHost == null || srcHost.trim().isEmpty()) {</span>
<span class="nc" id="L648">				throw new DataClayException(&quot;ERROR in moveReplica: srcHost '&quot; + srcHost + &quot;' is null or empty.&quot;);</span>
			}
<span class="nc bnc" id="L650" title="All 4 branches missed.">			if (destHost == null || destHost.trim().isEmpty()) {</span>
<span class="nc" id="L651">				throw new DataClayException(&quot;ERROR in moveReplica: destHost '&quot; + destHost + &quot;' is null or empty.&quot;);</span>
			}
<span class="nc bnc" id="L653" title="All 2 branches missed.">			if (srcHost.equals(destHost)) {</span>
<span class="nc" id="L654">				throw new DataClayException(</span>
						&quot;ERROR in moveReplica: src &quot; + srcHost + &quot; and dest &quot; + destHost + &quot; are the same.&quot;);
			}
<span class="nc" id="L657">			final Triple&lt;ObjectID, BackendID, MetaClassID&gt; ids = string2IDandHintID(objectIDstr);</span>
<span class="nc" id="L658">			final ObjectID objectID = ids.getFirst();</span>
<span class="nc" id="L659">			final BackendID hint = ids.getSecond();</span>
<span class="nc" id="L660">			final MetaClassID classID = ids.getThird();</span>
<span class="nc" id="L661">			final Set&lt;BackendID&gt; currentBackends = commonLib.getAllLocations(objectID);</span>
<span class="nc" id="L662">			final BackendID oneBK = currentBackends.iterator().next();</span>
<span class="nc" id="L663">			final Langs lang = backendsByID.get(oneBK).getLang();</span>

			// Select backend for the provided src host
<span class="nc" id="L666">			BackendID srcLocID = null;</span>
<span class="nc" id="L667">			Set&lt;BackendID&gt; srcBackends = null;</span>
<span class="nc bnc" id="L668" title="All 3 branches missed.">			switch (lang) {</span>
				case LANG_JAVA:
<span class="nc bnc" id="L670" title="All 2 branches missed.">					if (LOCALTOKEN.equals(srcHost)) {</span>
<span class="nc" id="L671">						srcLocID = jLOCAL;</span>
					} else {
<span class="nc" id="L673">						srcBackends = jBackendsByHostname.get(srcHost);</span>
					}
<span class="nc" id="L675">					break;</span>
				case LANG_PYTHON:
<span class="nc bnc" id="L677" title="All 2 branches missed.">					if (LOCALTOKEN.equals(srcHost)) {</span>
<span class="nc" id="L678">						srcLocID = pLOCAL;</span>
					} else {
<span class="nc" id="L680">						srcBackends = pyBackendsByHostname.get(srcHost);</span>
					}
<span class="nc" id="L682">					break;</span>
				default:
<span class="nc" id="L684">					throw new DataClayException(&quot;ERROR in moveReplica: unsupported language&quot;);</span>
			}
<span class="nc bnc" id="L686" title="All 2 branches missed.">			if (srcLocID == null) {</span>
<span class="nc bnc" id="L687" title="All 4 branches missed.">				if (srcBackends == null || srcBackends.isEmpty()) {</span>
<span class="nc" id="L688">					throw new DataClayException(&quot;ERROR in moveReplica: src host &quot; + srcHost + &quot; has no backends&quot;);</span>
				}
<span class="nc bnc" id="L690" title="All 2 branches missed.">				for (final BackendID bkID : srcBackends) {</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">					if (currentBackends.contains(bkID)) { // find backend containing a replica</span>
<span class="nc" id="L692">						srcLocID = bkID;</span>
<span class="nc" id="L693">						break;</span>
					}
<span class="nc" id="L695">				}</span>
			}
<span class="nc bnc" id="L697" title="All 2 branches missed.">			if (srcLocID == null) {</span>
<span class="nc" id="L698">				throw new DataClayException(&quot;ERROR in moveReplica: no replica found in src host &quot; + srcHost);</span>
			}

			// Select dest backend for the provided dest host
<span class="nc" id="L702">			BackendID destLocID = null;</span>
<span class="nc" id="L703">			Set&lt;BackendID&gt; destBackends = null;</span>
<span class="nc bnc" id="L704" title="All 3 branches missed.">			switch (lang) {</span>
				case LANG_JAVA:
<span class="nc bnc" id="L706" title="All 2 branches missed.">					if (LOCALTOKEN.equals(destHost)) {</span>
<span class="nc" id="L707">						destLocID = jLOCAL;</span>
					} else {
<span class="nc" id="L709">						destBackends = jBackendsByHostname.get(destHost);</span>
					}
<span class="nc" id="L711">					break;</span>
				case LANG_PYTHON:
<span class="nc bnc" id="L713" title="All 2 branches missed.">					if (LOCALTOKEN.equals(destHost)) {</span>
<span class="nc" id="L714">						destLocID = pLOCAL;</span>
					} else {
<span class="nc" id="L716">						destBackends = pyBackendsByHostname.get(destHost);</span>
					}
<span class="nc" id="L718">					break;</span>
				default:
<span class="nc" id="L720">					throw new DataClayException(&quot;ERROR in moveReplica: unsupported language&quot;);</span>
			}
<span class="nc bnc" id="L722" title="All 2 branches missed.">			if (destLocID == null) {</span>
<span class="nc bnc" id="L723" title="All 4 branches missed.">				if (destBackends == null || destBackends.isEmpty()) {</span>
<span class="nc" id="L724">					throw new DataClayException(&quot;ERROR in moveReplica: dest host &quot; + destHost + &quot; has no backends&quot;);</span>
				}
<span class="nc bnc" id="L726" title="All 2 branches missed.">				for (final BackendID bkID : destBackends) {</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">					if (!currentBackends.contains(bkID)) { // find backend NOT containing a replica</span>
<span class="nc" id="L728">						destLocID = bkID;</span>
<span class="nc" id="L729">						break;</span>
					}
<span class="nc" id="L731">				}</span>
			}
<span class="nc bnc" id="L733" title="All 2 branches missed.">			if (destLocID == null) {</span>
<span class="nc" id="L734">				throw new DataClayException(</span>
						&quot;ERROR in moveReplica: no suitable backend found (or replica already present in dest)&quot;);
			}

			// Move replica
<span class="nc" id="L739">			commonLib.moveObject(objectID, classID, hint, srcLocID, destLocID, true);</span>

<span class="nc" id="L741">			LOGGER.info(&quot;Object {} moved from {} to {}&quot;, objectID, srcLocID, destLocID);</span>

<span class="nc" id="L743">		} catch (</span>

				final Exception e) {
<span class="nc" id="L746">			throw new DataClayException(e);</span>
<span class="nc" id="L747">		}</span>
<span class="nc" id="L748">	}</span>

	/**
	 * Create a new replica of the given object.
	 *
	 * @param objectIDstr
	 *            objectID to be replicated.
	 * @param destHost
	 *            target location of the object replica.
	 * @throws DataClayException
	 *             if an exception occurs
	 */
	public static void newReplica(final String objectIDstr, final String destHost) throws DataClayException {
		try {
<span class="nc" id="L762">			final Triple&lt;ObjectID, BackendID, MetaClassID&gt; ids = string2IDandHintID(objectIDstr);</span>
<span class="nc" id="L763">			final ObjectID objectID = ids.getFirst();</span>
<span class="nc" id="L764">			final BackendID hint = ids.getSecond();</span>
<span class="nc" id="L765">			final MetaClassID classID = ids.getThird();</span>
<span class="nc" id="L766">			final Set&lt;BackendID&gt; currentBackends = commonLib.getAllLocations(objectID);</span>
<span class="nc" id="L767">			final BackendID oneBK = currentBackends.iterator().next();</span>
<span class="nc" id="L768">			final Langs lang = backendsByID.get(oneBK).getLang();</span>

			// Select dest backend for the provided dest host
<span class="nc" id="L771">			BackendID destLocID = null;</span>
<span class="nc" id="L772">			Set&lt;BackendID&gt; destBackends = null;</span>
<span class="nc bnc" id="L773" title="All 3 branches missed.">			switch (lang) {</span>
				case LANG_JAVA:
<span class="nc bnc" id="L775" title="All 2 branches missed.">					if (LOCALTOKEN.equals(destHost)) {</span>
<span class="nc" id="L776">						destLocID = jLOCAL;</span>
					} else {
<span class="nc" id="L778">						destBackends = jBackendsByHostname.get(destHost);</span>
					}
<span class="nc" id="L780">					break;</span>
				case LANG_PYTHON:
<span class="nc bnc" id="L782" title="All 2 branches missed.">					if (LOCALTOKEN.equals(destHost)) {</span>
<span class="nc" id="L783">						destLocID = pLOCAL;</span>
					} else {
<span class="nc" id="L785">						destBackends = pyBackendsByHostname.get(destHost);</span>
					}
<span class="nc" id="L787">					break;</span>
				default:
<span class="nc" id="L789">					throw new DataClayException(&quot;ERROR in newReplica: unsupported language&quot;);</span>
			}
<span class="nc bnc" id="L791" title="All 2 branches missed.">			if (destLocID == null) {</span>
<span class="nc bnc" id="L792" title="All 4 branches missed.">				if (destBackends == null || destBackends.isEmpty()) {</span>
<span class="nc" id="L793">					throw new DataClayException(&quot;ERROR in newReplica: dest host &quot; + destHost + &quot; has no backends&quot;);</span>
				}
<span class="nc bnc" id="L795" title="All 2 branches missed.">				for (final BackendID bkID : destBackends) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">					if (!currentBackends.contains(bkID)) { // find backend NOT containing a replica</span>
<span class="nc" id="L797">						destLocID = bkID;</span>
<span class="nc" id="L798">						break;</span>
					}
<span class="nc" id="L800">				}</span>
			}
			// Replicate
<span class="nc bnc" id="L803" title="All 2 branches missed.">			if (destLocID == null) {</span>
<span class="nc" id="L804">				throw new DataClayException(</span>
						&quot;ERROR in newReplica: no suitable backend found (or replica already present in dest)&quot;);
			}
<span class="nc" id="L807">			commonLib.newReplica(objectID, classID, hint, destLocID, true);</span>

<span class="nc" id="L809">		} catch (final Exception e) {</span>
<span class="nc" id="L810">			throw new DataClayException(e);</span>
<span class="nc" id="L811">		}</span>

<span class="nc" id="L813">	}</span>

	/**
	 * Executes a method on a specific target assynchronously.
	 *
	 * @param objectIDstr
	 *            ID of the target object.
	 * @param method
	 *            method to be executed
	 * @param params
	 *            parameters for the operation.
	 * @param callback
	 *            callback handler to communicate the result when the execution
	 *            finishes.
	 * @return an id of the executed request that will receive the callback handler
	 *         with the corresponding response
	 * @throws DataClayException
	 *             if an exception occurs.
	 */
	public static String executeTask(final String objectIDstr, final java.lang.reflect.Method method,
									 final Object[] params, final CallbackHandler callback) throws DataClayException {
<span class="nc" id="L834">		final Method m = Method.getMethod(method);</span>
<span class="nc" id="L835">		return executeTask(objectIDstr, m.getName() + m.getDescriptor(), params, callback);</span>
	}

	/**
	 * Executes a method on a specific target assynchronously.
	 *
	 * @param objectIDstr
	 *            ID of the target object.
	 * @param operationSignature
	 *            signature of the method to be executed.
	 * @param params
	 *            parameters for the operation.
	 * @param callback
	 *            callback handler to communicate the result when the execution
	 *            finishes.
	 * @return an id of the executed request that will receive the callback handler
	 *         with the corresponding response
	 * @throws DataClayException
	 *             if an exception occurs.
	 */
	public static String executeTask(final String objectIDstr, final String operationSignature, final Object[] params,
									 final CallbackHandler callback) throws DataClayException {
<span class="nc bnc" id="L857" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L858">			DataClayRuntime.LOGGER.debug(&quot;[dataClay] Executing task for &quot; + objectIDstr);</span>
		}
<span class="nc" id="L860">		final Triple&lt;ObjectID, BackendID, MetaClassID&gt; ids = string2IDandHintID(objectIDstr);</span>
<span class="nc" id="L861">		final ObjectID objectID = ids.getFirst();</span>
<span class="nc" id="L862">		final BackendID backendID = ids.getSecond();</span>
<span class="nc" id="L863">		MetaClassID classID = ids.getThird();</span>

		// Lock, since this function is called concurrently
<span class="nc bnc" id="L866" title="All 2 branches missed.">		if (classID == null) {</span>
<span class="nc" id="L867">			commonLib.lock(objectID);</span>
<span class="nc" id="L868">			final MetaDataInfo metadata = commonLib.getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">			if (metadata == null) {</span>
				// no metadata available, throw exception
				// NOTE: if it is a volatile and hint failed, it means that object is actually
				// not registered
<span class="nc" id="L873">				throw new ObjectNotRegisteredException(objectID);</span>
			}
<span class="nc" id="L875">			commonLib.unlock(objectID);</span>
<span class="nc" id="L876">			classID = metadata.getMetaclassID();</span>
		}
<span class="nc" id="L878">		final String className = commonLib.getClassName(classID);</span>

		// Generate unique id for the request
<span class="nc" id="L881">		final UUID id = UUID.randomUUID();</span>

<span class="nc" id="L883">		new Thread(&quot;&quot; + id) {</span>
			@Override
			public void run() {
				try {
<span class="nc bnc" id="L887" title="All 2 branches missed.">					if (Configuration.mockTesting) {</span>
<span class="nc" id="L888">						DataClayMockObject.setCurrentThreadLib(ClientManagementLib.getDataClayClientLib());</span>
					}
<span class="nc" id="L890">					final Object result = commonLib.executeRemoteTask(objectID, className, operationSignature, params,</span>
							backendID);
<span class="nc bnc" id="L892" title="All 4 branches missed.">					if (className == null || className.isEmpty()) {</span>
<span class="nc" id="L893">						throw new DataClayException(</span>
<span class="nc" id="L894">								&quot;Cannot get object info of &quot; + objectID + &quot; with session &quot; + commonLib.getSessionID());</span>
					}
<span class="nc" id="L896">					callback.eventListener(new CallbackEvent(this.getName(), CallbackEvent.EventType.SUCCESS, result,</span>
							className, operationSignature));
<span class="nc" id="L898">				} catch (final Exception ex) {</span>
<span class="nc" id="L899">					LOGGER.debug(&quot;executeTask-&gt;run() error&quot;, ex);</span>
<span class="nc" id="L900">					callback.eventListener(</span>
<span class="nc" id="L901">							new CallbackEvent(this.getName(), CallbackEvent.EventType.FAIL, ex.getMessage()));</span>
<span class="nc" id="L902">				}</span>
<span class="nc" id="L903">			}</span>
<span class="nc" id="L904">		}.start();</span>

<span class="nc" id="L906">		return &quot;&quot; + id;</span>
	}

	/**
	 * Processes and retrieves the callback event produced by a task execution.
	 *
	 * @param callbackEvent
	 *            the event to be processed
	 * @return The task result.
	 * @throws DataClayException
	 *             if any exception occurs
	 */
	public static Object getResult(final CallbackEvent callbackEvent) throws DataClayException {
		try {
<span class="nc" id="L920">			return callbackEvent.getContent();</span>
<span class="nc" id="L921">		} catch (final Exception ex) {</span>
<span class="nc" id="L922">			throw new DataClayException(ex);</span>
		}
	}

	/**
	 * Translates from string representation of an objectID to an ObjectID.
	 *
	 * @param objectIDstr
	 *            string representation of the object.
	 * @return the ObjectID built from its string representation.
	 * @throws DataClayException
	 */
	public static Triple&lt;ObjectID, BackendID, MetaClassID&gt; string2IDandHintID(final String objectIDstr)
			throws DataClayException {
<span class="nc bnc" id="L936" title="All 4 branches missed.">		if (objectIDstr == null || objectIDstr.trim().isEmpty()) {</span>
<span class="nc" id="L937">			throw new DataClayException(&quot;ERROR: malformed objectIDstr '&quot; + objectIDstr + &quot;'&quot;);</span>
		}
<span class="nc" id="L939">		final String[] idsStr = objectIDstr.split(&quot;:&quot;);</span>
<span class="nc" id="L940">		final ObjectID objectID = new ObjectID(UUID.fromString(idsStr[0]));</span>
<span class="nc" id="L941">		BackendID hint = null;</span>
<span class="nc bnc" id="L942" title="All 4 branches missed.">		if (idsStr.length &gt; 1 &amp;&amp; !idsStr[1].isEmpty()) {</span>
<span class="nc" id="L943">			hint = new ExecutionEnvironmentID(UUID.fromString(idsStr[1]));</span>
		}
<span class="nc" id="L945">		MetaClassID classID = null;</span>
<span class="nc bnc" id="L946" title="All 4 branches missed.">		if (idsStr.length &gt; 2 &amp;&amp; !idsStr[2].isEmpty()) {</span>
<span class="nc" id="L947">			classID = new MetaClassID(UUID.fromString(idsStr[2]));</span>
		}
<span class="nc" id="L949">		final Triple&lt;ObjectID, BackendID, MetaClassID&gt; ids = new Triple&lt;&gt;(objectID, hint, classID);</span>
<span class="nc" id="L950">		return ids;</span>
	}

	/**
	 * Translates from ObjectID to string representation.
	 *
	 * @param objectID
	 *            ID of the object.
	 * @param hint
	 *            hint where the object should be
	 * @param classID
	 *            class id of the object
	 * @return string representation of the giving object.
	 */
	public static String ids2String(final ObjectID objectID, final BackendID hint, final MetaClassID classID) {
<span class="nc" id="L965">		String strHint = &quot;&quot;;</span>
<span class="nc" id="L966">		String strClass = &quot;&quot;;</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">		if (hint != null) {</span>
<span class="nc" id="L968">			strHint = hint.toString();</span>
		}
<span class="nc bnc" id="L970" title="All 2 branches missed.">		if (classID != null) {</span>
<span class="nc" id="L971">			strClass = classID.toString();</span>
		}
<span class="nc" id="L973">		return objectID.getId().toString() + &quot;:&quot; + strHint + &quot;:&quot; + strClass;</span>
	}

	/**
	 * Retrieves the info of a backend
	 *
	 * @param backendID
	 *            id of the backend
	 * @return info of the backend
	 */
	public static Backend getBackendInfo(final BackendID backendID) {
<span class="nc" id="L984">		return backendsByID.get(backendID);</span>
	}

	/**
	 * Retrieves the info of all known backends indexed by ID
	 *
	 * @return map of backends indexed by ID
	 */
	public static Map&lt;BackendID, Backend&gt; getBackends() {
<span class="nc" id="L993">		return backendsByID;</span>
	}

	/**
	 * Retrieves the info of all Java backends
	 *
	 * @return map of backends indexed by ID
	 */
	public static Map&lt;BackendID, Backend&gt; getJBackends() {
<span class="nc" id="L1002">		return jBackendsByID;</span>
	}

	/**
	 * Retrieves the info of all Python backends
	 *
	 * @return map of backends indexed by ID
	 */
	public static Map&lt;BackendID, Backend&gt; getPyBackends() {
<span class="nc" id="L1011">		return pyBackendsByID;</span>
	}

	/**
	 * Getter for commonLib property.
	 *
	 * @return common lib reference
	 */
	public static ClientRuntime getCommonLib() {
<span class="nc" id="L1020">		return commonLib;</span>
	}

	/**
	 * Getter for sessionID property.
	 *
	 * @return sessionID
	 */
	public static SessionID getSessionID() {
<span class="nc" id="L1029">		return commonLib.getSessionID();</span>
	}

	public static int getMDmisses() {
<span class="nc" id="L1033">		return commonLib.misses;</span>
	}

	public static int getMDhits() {
<span class="nc" id="L1037">		return commonLib.hits;</span>
	}

	public static Map&lt;String, Set&lt;BackendID&gt;&gt; getPyBackendsByName() {
<span class="nc" id="L1041">		return pyBackendsByName;</span>
	}

	public static Map&lt;String, Set&lt;BackendID&gt;&gt; getJBackendsByName() {
<span class="nc" id="L1045">		return jBackendsByName;</span>
	}

	public static Map&lt;String, Set&lt;BackendID&gt;&gt; getPyBackendsByHostname() {
<span class="nc" id="L1049">		return pyBackendsByHostname;</span>
	}

	public static Map&lt;String, Set&lt;BackendID&gt;&gt; getJBackendsByHostname() {
<span class="nc" id="L1053">		return jBackendsByHostname;</span>
	}


	/**
	 * Retrieves current dataClay instance ID
	 *
	 * @return id of current dataClay instance
	 */
	public static DataClayInstanceID getDataClayID() {
<span class="nc" id="L1063">		return ClientManagementLib.getDataClayID();</span>
	}

	/**
	 * Retrieves the id of the external dataClay which Logic Module is located at
	 * provided host and listening on specified port.
	 *
	 * @param dcHost
	 *            host where the external dataClay is located.
	 * @param dcPort
	 *            port where the external dataClay is listening.
	 * @return id of the external dataClay
	 */
	public static DataClayInstanceID getDataClayID(final String dcHost, final int dcPort) {
<span class="nc" id="L1077">		return ClientManagementLib.getExternalDataClayID(dcHost, dcPort);</span>
	}

	/**
	 * Registers an external dataClay to enable future object federation with it.
	 * Also returns its dataClay instance id.
	 *
	 * @param dcHost
	 *            host where the external dataClay is located.
	 * @param dcPort
	 *            port where the external dataClay is listening.
	 * @return id of the external dataClay
	 */
	public static DataClayInstanceID registerDataClay(final String dcHost, final int dcPort) {
<span class="nc" id="L1091">		return ClientManagementLib.registerExternalDataClay(dcHost, dcPort);</span>
	}

	/**
	 * Activate tracing in dataClay services
	 *
	 */
	public static void activateTracingInDataClayServices() {
<span class="nc" id="L1099">		ClientManagementLib.activateTracingInDataClayServices();</span>
<span class="nc" id="L1100">	}</span>

	/**
	 * Dectivate tracing
	 */
	public static void deactivateTracingInDataClayServices() {
<span class="nc" id="L1106">		ClientManagementLib.deactivateTracingInDataClayServices();</span>
<span class="nc" id="L1107">	}</span>

	/**
	 * Activate tracing
	 */
	public static void activateTracing(
			final boolean initializeWrapper) {
<span class="nc" id="L1114">		ClientManagementLib.activateTracing(initializeWrapper);</span>
<span class="nc" id="L1115">	}</span>

	/**
	 * Dectivate tracing
	 */
	public static void deactivateTracing(final boolean finalizeWrapper) {
<span class="nc" id="L1121">		ClientManagementLib.deactivateTracing(finalizeWrapper);</span>
<span class="nc" id="L1122">	}</span>

	/**
	 * Get traces in dataClay services and store it in current workspace
	 */
	public final static void getTracesInDataClayServices() {
<span class="nc" id="L1128">		ClientManagementLib.getTracesInDataClayServices();</span>
<span class="nc" id="L1129">	}</span>

	/**
	 * Unfederate all objects belonging/federated with external dataClay with id provided
	 * @param extDataClayID External dataClay ID
	 */
	public static void unfederateAllObjects(final DataClayInstanceID extDataClayID) {
<span class="nc" id="L1136">		ClientManagementLib.unfederateAllObjects(extDataClayID);</span>
<span class="nc" id="L1137">	}</span>

	/**
	 * Unfederate all objects belonging/federated with ANY external dataClay 
	 */
	public static void unfederateAllObjects() {
<span class="nc" id="L1143">		ClientManagementLib.unfederateAllObjectsWithAllDCs();</span>
<span class="nc" id="L1144">	}</span>

	/**
	 * Migrate (unfederate and federate) all current dataClay objects from specified external dataclay di to
	 * destination dataclay. 
	 * @param originDataClayID Origin dataclay id
	 * @param destinationDataClayID Destination dataclay id
	 */
	public static void migrateFederatedObjects(final DataClayInstanceID originDataClayID,
											   final DataClayInstanceID destinationDataClayID) {
<span class="nc" id="L1154">		ClientManagementLib.migrateFederatedObjects(originDataClayID, destinationDataClayID);</span>
<span class="nc" id="L1155">	}</span>

	/**
	 * Federate all dataClay objects from specified current dataClay
	 * destination dataclay. 
	 * @param destinationDataClayID Destination dataclay id
	 */
	public static void federateAllObjects(
			final DataClayInstanceID destinationDataClayID) {
<span class="nc" id="L1164">		ClientManagementLib.federateAllObjects(destinationDataClayID);</span>
<span class="nc" id="L1165">	}</span>

	/**
	 * Import classes in namespace specified from an external dataClay
	 * @param externalNamespace External namespace to get
	 * @param extDataClayID External dataClay ID
	 */
	public static void importModelsFromExternalDataClay(final String externalNamespace,
														final DataClayInstanceID extDataClayID) {
<span class="nc" id="L1174">		ClientManagementLib.importModelsFromExternalDataClay(externalNamespace, extDataClayID);</span>
<span class="nc" id="L1175">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>