<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClientRuntime.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.commonruntime</a> &gt; <span class="el_source">ClientRuntime.java</span></div><h1>ClientRuntime.java</h1><pre class="source lang-java linenums">package es.bsc.dataclay.commonruntime;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

import es.bsc.dataclay.DataClayObject;
import es.bsc.dataclay.api.BackendID;
import es.bsc.dataclay.api.DataClayException;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.dataservice.api.DataServiceAPI;
import es.bsc.dataclay.exceptions.metadataservice.ObjectNotRegisteredException;
import es.bsc.dataclay.heap.ClientHeapManager;
import es.bsc.dataclay.heap.HeapManager;
import es.bsc.dataclay.loader.ClientObjectLoader;
import es.bsc.dataclay.loader.DataClayObjectLoader;
import es.bsc.dataclay.serialization.DataClaySerializable;
import es.bsc.dataclay.serialization.lib.DataClaySerializationLib;
import es.bsc.dataclay.serialization.lib.ObjectWithDataParamOrReturn;
import es.bsc.dataclay.serialization.lib.SerializedParametersOrReturn;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.classloaders.DataClayClassLoader;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.SessionID;
import es.bsc.dataclay.util.management.metadataservice.MetaDataInfo;
import es.bsc.dataclay.util.management.metadataservice.RegistrationInfo;
import es.bsc.dataclay.util.management.sessionmgr.SessionInfo;
import es.bsc.dataclay.util.management.stubs.StubInfo;

/**
 * This class contains functions for users to interact with DataClay.
 */
public final class ClientRuntime extends DataClayRuntime {

	/** Client session. */
	private SessionInfo clientSession;

	/** User-defined 'LOCAL' backend */
<span class="fc" id="L46">	private BackendID localBackend = null;</span>

	/**
	 * Constructor for Mock tests.
	 */
<span class="fc" id="L51">	public ClientRuntime() {</span>
<span class="fc" id="L52">		this.dataClayObjLoader = new ClientObjectLoader(this);</span>
<span class="fc" id="L53">		this.dataClayHeapManager = new ClientHeapManager(this);</span>
<span class="fc" id="L54">		this.threadPool = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {</span>
			@Override
			public Thread newThread(final Runnable r) {
<span class="nc" id="L57">				final Thread t = Executors.defaultThreadFactory().newThread(r);</span>
<span class="nc" id="L58">				t.setDaemon(true);</span>
<span class="nc" id="L59">				t.setName(&quot;Client-MemoryGC&quot;);</span>
<span class="nc" id="L60">				return t;</span>
			}
		});
<span class="fc" id="L63">	}</span>

	/**
	 * Initialize connections.
	 * 
	 * @param logicModuleHost
	 *            Name of the host of the logic module
	 * @param logicModulePort
	 *            Port of the logic module
	 * @param originHostName
	 *            Name of the host using the lib.
	 */
	@Override
	public void initialize(final String logicModuleHost, final int logicModulePort, final String originHostName)
			throws Exception {
<span class="nc" id="L78">		super.initialize(logicModuleHost, logicModulePort, originHostName);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">		if (Configuration.Flags.MEMORY_GC_ENABLED.getBooleanValue()) {</span>
			// Create Repetitively task
<span class="nc" id="L81">			this.threadPool.scheduleAtFixedRate(dataClayHeapManager, 0,</span>
<span class="nc" id="L82">					Configuration.Flags.MEMMGMT_CHECK_TIME_INTERVAL.getLongValue(), TimeUnit.MILLISECONDS);</span>
		}

<span class="nc" id="L85">	}</span>

	@Override
	public DataClayObject getOrNewPersistentInstance(final MetaClassID classID, final ObjectID objectID,
			final BackendID hint) {

<span class="nc" id="L91">		MetaClassID theClassID = classID;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">		if (theClassID == null) {</span>
<span class="nc" id="L93">			final MetaDataInfo mdInfo = super.getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">			if (mdInfo == null) {</span>
				// WARNING: If this is a volatile, class id should not be null, so no metadata
				// should be search.
				// NOTE: if it is a volatile and hint failed, it means that object is actually
				// not registered
<span class="nc" id="L99">				throw new ObjectNotRegisteredException(objectID);</span>
			}
<span class="nc" id="L101">			theClassID = mdInfo.getMetaclassID();</span>
		}

<span class="nc" id="L104">		return this.dataClayObjLoader.getOrNewPersistentInstance(theClassID, objectID, hint);</span>
	}

	/**
	 * Sets ID of backend to be identified as LOCAL backend.
	 * 
	 * @param backendID
	 *            ID of LOCAL backend.
	 */
	public void setLocalBackend(final BackendID backendID) {
<span class="nc" id="L114">		localBackend = backendID;</span>
<span class="nc" id="L115">	}</span>

	/**
	 * Retrieves current default backend
	 * 
	 * @return
	 */
	@Override
	public BackendID getLocalBackend() {
<span class="nc" id="L124">		return localBackend;</span>
	}

	/**
	 * Set sessionID for client
	 * 
	 * @param newSessionfo
	 *            Info of session
	 */
	public void setSessionInfo(final SessionInfo newSessionfo) {
<span class="nc" id="L134">		this.clientSession = newSessionfo;</span>
<span class="nc" id="L135">	}</span>

	@Override
	public SessionID getSessionID() {
<span class="nc" id="L139">		return clientSession.getSessionID();</span>
	}

	/**
	 * Get Heap Manager
	 * 
	 * @return Heap Manager
	 */
	@Override
	public HeapManager getDataClayHeapManager() {
<span class="nc" id="L149">		return this.dataClayHeapManager;</span>
	}

	@Override
	protected Object executeRemoteImplementationInternal(final DataClayObject objectInWhichToExec,
			final ImplementationID implID, final Object[] params) {
<span class="nc bnc" id="L155" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
			try {
<span class="nc" id="L157">				final StubInfo stubInfo = objectInWhichToExec.getStubInfo();</span>
<span class="nc" id="L158">				final String methodSignature = stubInfo.getImplementationByID(implID.toString()).getSignature();</span>
<span class="nc" id="L159">				LOGGER.debug(&quot;[==Execution==] ** New execution ** For method &quot; + methodSignature</span>
<span class="nc" id="L160">						+ &quot;. Client requests a new remote execution for object &quot; + objectInWhichToExec.getObjectID()</span>
						+ &quot; and implementation &quot; + implID);
<span class="nc" id="L162">			} catch (final Exception ex) {</span>
<span class="nc" id="L163">				LOGGER.debug(&quot;Error while retrieving debug information on executeRemoteImplementationInternal&quot;, ex);</span>
<span class="nc" id="L164">			}</span>
		}

		// ============================== PARAMS/RETURNS ========================== //
<span class="nc" id="L168">		boolean usingHint = false;</span>
<span class="nc" id="L169">		BackendID execLocationID = null;</span>
		// === HINT === //
<span class="nc bnc" id="L171" title="All 2 branches missed.">		if (objectInWhichToExec.getHint() != null) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L173">				LOGGER.debug(&quot;[==Execution==] Using HINT for &quot; + objectInWhichToExec.getObjectID());</span>
			}
<span class="nc" id="L175">			execLocationID = objectInWhichToExec.getHint();</span>
<span class="nc" id="L176">			usingHint = true;</span>
		} else {
<span class="nc" id="L178">			execLocationID = chooseLocation(objectInWhichToExec, null);</span>
		}

		try {
<span class="nc" id="L182">			return super.callExecuteToDS(objectInWhichToExec, params, implID, execLocationID, usingHint);</span>
		} finally {
<span class="nc bnc" id="L184" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L185">				LOGGER.debug(&quot;[==Execution==] ** Finished execution ** For object &quot; + objectInWhichToExec.getObjectID()</span>
				+ &quot; and implementation &quot; + implID);
			}
		}
	}

	@Override
	public BackendID makePersistent(final DataClayObject dcObject, final BackendID optionalDestBackendID,
			final boolean recursive, final String alias) {
<span class="nc bnc" id="L194" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L195">			LOGGER.debug(&quot;[==MakePersistent==] Starting make persistent of object &quot; + dcObject.getObjectID());</span>
		}

<span class="nc" id="L198">		final SessionID sessionID = checkAndGetSession(new String[] {}, new Object[] {});</span>
<span class="nc" id="L199">		BackendID location = dcObject.getHint();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">		if (location == null) {</span>
<span class="nc" id="L201">			location = optionalDestBackendID;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			if (location == null) {</span>
<span class="nc" id="L203">				location = chooseLocation(dcObject, alias);</span>
			}
		}

<span class="nc bnc" id="L207" title="All 2 branches missed.">		if (!dcObject.isPersistent()) {</span>
			// Force registration due to alias
<span class="nc bnc" id="L209" title="All 2 branches missed.">			if (alias != null) {</span>
<span class="nc" id="L210">				final RegistrationInfo regInfo = new RegistrationInfo(dcObject.getObjectID(), dcObject.getMetaClassID(),</span>
<span class="nc" id="L211">						sessionID, dcObject.getDataSetID());</span>
				// TODO ask DANI
				// it is important to register the object once we are sure it is in EE.
<span class="nc" id="L214">				final ObjectID newID = logicModule.registerObject(regInfo, (ExecutionEnvironmentID) location, alias, Langs.LANG_JAVA);</span>
<span class="nc" id="L215">				this.updateObjectID(dcObject, newID);</span>
			}

			// Serialize objects
<span class="nc" id="L219">			dcObject.setMasterLocation(location);</span>

<span class="nc" id="L221">			final SerializedParametersOrReturn objectsToPersist = this.serializeMakePersistent(location, dcObject, null, recursive);</span>

			// Avoid some race-conditions in communication (make persistent + execute where
			// execute arrives before).
<span class="nc bnc" id="L225" title="All 2 branches missed.">			for (final Entry&lt;Integer, ObjectWithDataParamOrReturn&gt; param : objectsToPersist.getVolatileObjs().entrySet()) {</span>
<span class="nc" id="L226">				super.volatileParametersBeingSend.add(param.getValue().getObjectID());</span>
<span class="nc" id="L227">			}</span>

			// Call EE
<span class="nc" id="L230">			final DataServiceAPI dsAPI = getRemoteExecutionEnvironment(location);</span>
<span class="nc" id="L231">			dsAPI.makePersistent(sessionID, objectsToPersist);</span>

			// Avoid some race-conditions in communication (make persistent + execute where
			// execute arrives before).
<span class="nc bnc" id="L235" title="All 2 branches missed.">			for (final Entry&lt;Integer, ObjectWithDataParamOrReturn&gt; param : objectsToPersist.getVolatileObjs().entrySet()) {</span>
<span class="nc" id="L236">				super.volatileParametersBeingSend.remove(param.getValue().getObjectID());</span>
<span class="nc" id="L237">			}</span>
			// =========================== //
		}

<span class="nc" id="L241">		return location;</span>
	}

	/**
	 * Serialize for make persistent.
	 * 
	 * @param location
	 *            Where objects will be stored
	 * @param objectToPersist
	 *            Object to persist
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 * @param recursive
	 *            Indicates if sub-objects must be serialized also.
	 * @return Serialized parameters
	 */
	public final SerializedParametersOrReturn serializeMakePersistent(final BackendID location,
			final DataClayObject objectToPersist, final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps,
			final boolean recursive) {
<span class="nc bnc" id="L260" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L261">			LOGGER.debug(&quot;[==Serialization==] Serializing for make persistent.&quot;);</span>
		}

<span class="nc" id="L264">		final List&lt;DataClaySerializable&gt; wrapList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L265">		wrapList.add(objectToPersist);</span>

		// Serialize
		// IfaceBitMaps = null. From client stub is controlling it.
<span class="nc bnc" id="L269" title="All 2 branches missed.">		final SerializedParametersOrReturn serObject = DataClaySerializationLib.serializeParamsOrReturn(wrapList,</span>
				ifaceBitMaps, this, false, location, !recursive); // no hint volatiles since volatiles are not going to

<span class="nc bnc" id="L272" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L273">			LOGGER.debug(&quot;[==Serialization==] Serialized &quot; + serObject);</span>
		}

		// client
<span class="nc" id="L277">		return serObject;</span>
	}

	@Override
	public boolean isDSLib() {
<span class="fc" id="L282">		return false;</span>
	}

	@Override
	public String getClassNameInternal(final MetaClassID classID) {
<span class="nc" id="L287">		return DataClayClassLoader.getClass(classID).getName();</span>
	}

	@Override
	public BackendID getHint() {
<span class="nc" id="L292">		return null;</span>
	}

	@Override
	protected Map&lt;MetaClassID, byte[]&gt; getIfaceBitMaps() {
<span class="nc" id="L297">		return clientSession.getIfaceBitmaps();</span>
	}

	/**
	 * Close session.
	 */
	public void closeSession() {
<span class="nc" id="L304">		this.logicModule.closeSession(this.getSessionID());</span>
<span class="nc" id="L305">	}</span>

	@Override
	protected DataClayObjectLoader getDataClayObjectLoader() {
<span class="nc" id="L309">		return this.dataClayObjLoader;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>