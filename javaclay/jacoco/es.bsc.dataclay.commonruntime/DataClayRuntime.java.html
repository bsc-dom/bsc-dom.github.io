<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataClayRuntime.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.commonruntime</a> &gt; <span class="el_source">DataClayRuntime.java</span></div><h1>DataClayRuntime.java</h1><pre class="source lang-java linenums">package es.bsc.dataclay.commonruntime;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Paths;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;

import es.bsc.dataclay.util.management.metadataservice.*;
import es.bsc.dataclay.util.structs.MemoryCache;
import es.bsc.dataclay.util.structs.Tuple;
import org.apache.commons.io.FileUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import es.bsc.dataclay.DataClayObject;
import es.bsc.dataclay.api.BackendID;
import es.bsc.dataclay.api.DataClay;
import es.bsc.dataclay.communication.grpc.clients.CommonGrpcClient;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.dataservice.api.DataServiceAPI;
import es.bsc.dataclay.exceptions.DataClayException;
import es.bsc.dataclay.exceptions.DataClayRuntimeException;
import es.bsc.dataclay.exceptions.ErrorDefs.ERRORCODE;
import es.bsc.dataclay.exceptions.metadataservice.AliasAlreadyInUseException;
import es.bsc.dataclay.exceptions.metadataservice.ObjectAlreadyRegisteredException;
import es.bsc.dataclay.exceptions.metadataservice.ObjectNotRegisteredException;
import es.bsc.dataclay.extrae.DataClayExtrae;
import es.bsc.dataclay.heap.HeapManager;
import es.bsc.dataclay.heap.LockerPool;
import es.bsc.dataclay.loader.DataClayObjectLoader;
import es.bsc.dataclay.logic.api.LogicModuleAPI;
import es.bsc.dataclay.serialization.DataClaySerializable;
import es.bsc.dataclay.serialization.lib.DataClayDeserializationLib;
import es.bsc.dataclay.serialization.lib.DataClaySerializationLib;
import es.bsc.dataclay.serialization.lib.ObjectWithDataParamOrReturn;
import es.bsc.dataclay.serialization.lib.PersistentParamOrReturn;
import es.bsc.dataclay.serialization.lib.SerializedParametersOrReturn;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.DataClayObjectMetaData;
import es.bsc.dataclay.util.ids.AccountID;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.SessionID;
import es.bsc.dataclay.util.info.VersionInfo;
import es.bsc.dataclay.util.management.accountmgr.PasswordCredential;
import es.bsc.dataclay.util.management.classmgr.Type;
import es.bsc.dataclay.util.management.classmgr.UserType;
import es.bsc.dataclay.util.management.stubs.ImplementationStubInfo;
import es.bsc.dataclay.util.management.stubs.StubInfo;
import es.bsc.dataclay.util.structs.MemoryCache;
import es.bsc.dataclay.util.structs.Triple;
import io.grpc.StatusRuntimeException;
import org.apache.logging.log4j.core.LifeCycle;

import javax.xml.crypto.Data;

/**
 * This class contains functions to interact with DataClay. This is an abstract class in order to provide same functionalities
 * to calls done from client-side and the ones done from a backend side.
 */
public abstract class DataClayRuntime {
	/** Logger. */
<span class="fc" id="L71">	public static final Logger LOGGER = LogManager.getLogger(&quot;DataClayRuntime&quot;);</span>

	/** Indicates if debug is enabled. */
<span class="fc" id="L74">	public static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

	/** Indicates if runtime was initialized. */
<span class="fc" id="L77">	private boolean initialized = false;</span>

	/** GRPC client. */
	private CommonGrpcClient grpcClient;

	/** Logic Module API for communication. */
	protected LogicModuleAPI logicModule;

	/** Current dataClay instance ID. */
	private DataClayInstanceID dataClayInstanceID;

	/**
	 * DataClay Heap manager to manage GC, reference counting, lockers and others.
	 */
	protected HeapManager dataClayHeapManager;

	/** Pool of lockers. */
<span class="fc" id="L94">	protected final LockerPool lockerPool = new LockerPool();</span>

	/** Execution Environments cache. */
<span class="fc" id="L97">	private Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvsCache = new ConcurrentHashMap&lt;&gt;();</span>

	/** Cache of metaData. */
<span class="fc" id="L100">	public MemoryCache&lt;ObjectID, MetaDataInfo&gt; metaDataCache = new MemoryCache&lt;&gt;();</span>
	
	/** Cache of alias -&gt; oid. */
	protected MemoryCache&lt;String, Triple&lt;ObjectID, MetaClassID, BackendID&gt;&gt; aliasCache;

	/** DataClay object loader. */
	public DataClayObjectLoader dataClayObjLoader;

	/** Under deserialization volatiles per thread. */
<span class="fc" id="L109">	public final Map&lt;ObjectID, ObjectWithDataParamOrReturn&gt; underDeserializationVolatiles = new ConcurrentHashMap&lt;&gt;();</span>


	/** Pool for tasks. Initialized in sub-classes. */
	protected ScheduledExecutorService threadPool;

	/**
	 * Set of object ids of volatile parameters that were send but did not arrive to any node yet.
	 */
<span class="fc" id="L118">	protected final Set&lt;ObjectID&gt; volatileParametersBeingSend = ConcurrentHashMap.newKeySet();</span>

<span class="fc" id="L120">	public int misses = 0;</span>
<span class="fc" id="L121">	public int hits = 0;</span>

	// CHECKSTYLE:ON

	// ================================================== //
	// ================= COMMUNICATION ================== //
	// ================================================== //

	/**
	 * Constructor.
	 */
<span class="fc" id="L132">	protected DataClayRuntime() {</span>
<span class="fc" id="L133">		this.aliasCache = new MemoryCache&lt;&gt;();</span>
<span class="fc" id="L134">	}</span>

	/**
	 * Initialize session and connections.
	 * 
	 * @param logicModuleHost
	 *            Name of the host of the logic module
	 * @param logicModulePort
	 *            Port of the logic module
	 * @param originHostName
	 *            Name of the host using the lib.
	 * @throws Exception
	 *             if connection could not be done for some reason.
	 */
	protected void initialize(final String logicModuleHost, final int logicModulePort, final String originHostName)
			throws Exception {
<span class="nc" id="L150">		LOGGER.info(&quot;Connecting to LM at {}:{} ...&quot;, logicModuleHost, logicModulePort);</span>
<span class="nc" id="L151">		grpcClient = new CommonGrpcClient(originHostName);</span>
<span class="nc" id="L152">		logicModule = grpcClient.getLogicModuleAPI(logicModuleHost, logicModulePort);</span>
<span class="nc" id="L153">		LOGGER.info(&quot;Connected to LM!&quot;);</span>
<span class="nc" id="L154">		this.setInitialized(true);</span>
<span class="nc" id="L155">	}</span>

	/**
	 * Get the logic module API.
	 * 
	 * @return The logic module API
	 */
	public final LogicModuleAPI getLogicModuleAPI() {
<span class="nc" id="L163">		return this.logicModule;</span>
	}

	/**
	 * Get all execution environments information.
	 * @param lang Language
	 * @param forceUpdateCache Indicates cache must be forcibly updated
	 * @return All execution locations information
	 */
	public final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getAllExecutionEnvironmentsInfo(
			final Langs lang, final boolean forceUpdateCache) {
		// Check cache
<span class="nc bnc" id="L175" title="All 6 branches missed.">		if ((execEnvsCache != null &amp;&amp; forceUpdateCache) || (execEnvsCache == null)){</span>
<span class="nc" id="L176">			execEnvsCache.putAll(logicModule.getAllExecutionEnvironmentsInfo(lang, true, this.isDSLib()));</span>
		}
<span class="nc" id="L178">		return execEnvsCache;</span>
	
	}

	/**
	 * Get ExecutionEnvironment information
	 *
	 * @param execLocationID
	 *            Execution location ID
	 * @return Execution location information
	 */
	public final ExecutionEnvironment getExecutionEnvironmentInfo(final BackendID execLocationID) {
<span class="nc" id="L190">		ExecutionEnvironment execEnv = null;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">		for (Langs language : Langs.values()) {</span>
<span class="nc" id="L192">			Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvs = getAllExecutionEnvironmentsInfo(language, false);</span>
<span class="nc" id="L193">			execEnv = execEnvs.get(execLocationID);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">			if (execEnv == null) {</span>

<span class="nc" id="L196">				LOGGER.debug(&quot;Execution environment info &quot; + execLocationID + &quot; not found in cache: &quot; + execEnvs.keySet());</span>
<span class="nc" id="L197">				execEnvs = getAllExecutionEnvironmentsInfo(language, true);</span>
<span class="nc" id="L198">				execEnv = execEnvs.get(execLocationID);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">				if (execEnv != null) {</span>
<span class="nc" id="L200">					break;</span>
				}
			} else {
				break;
			}
		}
<span class="nc" id="L206">		return execEnv;</span>
	}


	/**
	 * Get all execution environments in provided host
	 * @param lang Language
	 * @param hostname Host name
	 * @return Set of execution environments in provided host
	 */
	public Map&lt;BackendID, ExecutionEnvironment&gt; getAllExecutionEnvironmentsAtHost(final Langs lang, final String hostname) {
<span class="nc" id="L217">		Map&lt;BackendID, ExecutionEnvironment&gt; execEnvsAtHost = new HashMap&lt;&gt;();</span>
<span class="nc" id="L218">		Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvs = getAllExecutionEnvironmentsInfo(lang, false);</span>
		// check if there is any execution.env in that host, otherwise update cache
<span class="nc bnc" id="L220" title="All 2 branches missed.">		for (ExecutionEnvironment env : execEnvs.values()) {</span>
<span class="nc" id="L221">			LOGGER.debug(&quot;Checking if environment hostname {} matches required hostname {}&quot;, env.getHostname(), hostname);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">			if (env.getHostname().equals(hostname)) {</span>
<span class="nc" id="L223">				execEnvsAtHost.put(env.getDataClayID(), env);</span>
			}
<span class="nc" id="L225">		}</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">		if (execEnvsAtHost.isEmpty()) {</span>
<span class="nc" id="L227">			execEnvs = getAllExecutionEnvironmentsInfo(lang, true);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">			for (ExecutionEnvironment env : execEnvs.values()) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">				if (env.getHostname().equals(hostname)) {</span>
<span class="nc" id="L230">					execEnvsAtHost.put(env.getDataClayID(), env);</span>
				}
<span class="nc" id="L232">			}</span>
		}
<span class="nc" id="L234">		return execEnvsAtHost;</span>
	}

	/**
	 * Get all execution environments in provided dataClay instance
	 * @param lang Language
	 * @param dataClayInstanceID ID of dataClay to check
	 * @param forceUpdate Indicates exec envs must be updated
	 * @return Set of execution environments in provided dataClay instance
	 */
	public Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; getAllExecutionEnvironmentsAtDataClay(final Langs lang,
																					  final DataClayInstanceID dataClayInstanceID,
																								   final boolean forceUpdate) {
<span class="nc" id="L247">		Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvsAtDC = new HashMap&lt;&gt;();</span>
<span class="nc" id="L248">		Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvs = null;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">		if (!forceUpdate) {</span>
<span class="nc" id="L250">			execEnvs = getAllExecutionEnvironmentsInfo(lang, false);</span>
			// check if there is any execution.env in that host, otherwise update cache
<span class="nc bnc" id="L252" title="All 2 branches missed.">			for (ExecutionEnvironment env : execEnvs.values()) {</span>
<span class="nc" id="L253">				LOGGER.debug(&quot;Checking if environment hostname {} matches required hostname {}&quot;, env.getDataClayInstanceID(), dataClayInstanceID);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">				if (env.getDataClayInstanceID().equals(dataClayInstanceID)) {</span>
<span class="nc" id="L255">					execEnvsAtDC.put(env.getDataClayID(), env);</span>
				}
<span class="nc" id="L257">			}</span>
		}
<span class="nc bnc" id="L259" title="All 2 branches missed.">		if (execEnvsAtDC.isEmpty()) {</span>
<span class="nc" id="L260">			execEnvs = getAllExecutionEnvironmentsInfo(lang, true);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">			for (ExecutionEnvironment env : execEnvs.values()) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">				if (env.getDataClayInstanceID().equals(dataClayInstanceID)) {</span>
<span class="nc" id="L263">					execEnvsAtDC.put(env.getDataClayID(), env);</span>
				}
<span class="nc" id="L265">			}</span>
		}
<span class="nc" id="L267">		return execEnvsAtDC;</span>
	}

	/**
	 * Get all backend names
	 * @param lang Language
	 * @param forceUpdateCache Indicates cache must be forcibly updated
	 * @return All backed names information
	 */
	public Set&lt;String&gt; getAllBackendsNames(final Langs lang, final boolean forceUpdateCache) {
<span class="nc" id="L277">		Set&lt;String&gt; result = null;</span>
<span class="nc" id="L278">		result = new HashSet&lt;&gt;();</span>
<span class="nc" id="L279">		Collection&lt;ExecutionEnvironment&gt; execEnvs = getAllExecutionEnvironmentsInfo(lang, true).values();</span>
<span class="nc" id="L280">		DataClayInstanceID curDcID = getDataClayID();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">		for (ExecutionEnvironment execEnv : execEnvs) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">			if (execEnv.getDataClayInstanceID().equals(curDcID)) {</span>
<span class="nc" id="L283">				result.add(execEnv.getName());</span>
			}
<span class="nc" id="L285">		}</span>
<span class="nc" id="L286">		return result;</span>
	}

	/**
	 * Get exec. environments with name provided
	 * @param lang Language
	 * @param backendName Name of backend
	 * @return All backends with name provided
	 */
	public Set&lt;BackendID&gt; getBackendsWithName(final Langs lang, final String backendName) {
<span class="nc" id="L296">		Set&lt;BackendID&gt; execEnvsWithName = new HashSet&lt;&gt;();</span>
<span class="nc" id="L297">		Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; execEnvs = getAllExecutionEnvironmentsInfo(Langs.LANG_JAVA, false);</span>
		// check if there is any execution.env in that host, otherwise update cache
<span class="nc" id="L299">		DataClayInstanceID curDcID = getDataClayID();</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">		for (ExecutionEnvironment env : execEnvs.values()) {</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">			if (env.getName().equals(backendName) &amp;&amp; env.getDataClayInstanceID().equals(curDcID)) {</span>
<span class="nc" id="L302">				execEnvsWithName.add(env.getDataClayID());</span>
			}
<span class="nc" id="L304">		}</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">		if (execEnvsWithName.isEmpty()) {</span>
<span class="nc" id="L306">			execEnvs = getAllExecutionEnvironmentsInfo(Langs.LANG_JAVA, true);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">			for (ExecutionEnvironment env : execEnvs.values()) {</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">				if (env.getName().equals(backendName) &amp;&amp; env.getDataClayInstanceID().equals(curDcID)) {</span>
<span class="nc" id="L309">					execEnvsWithName.add(env.getDataClayID());</span>
				}
<span class="nc" id="L311">			}</span>
		}
<span class="nc" id="L313">		return execEnvsWithName;</span>
	}

	/**
	 * Get execution location
	 * 
	 * @param objectID
	 *            ID of the object connected.
	 * @return ExecutionEnvironmentID by hash
	 */
	public final ExecutionEnvironmentID getBackendIDFromObjectID(final ObjectID objectID) {
		// Apply hash to choose which DS to go.
<span class="nc" id="L325">		List&lt;BackendID&gt; allEEs = new ArrayList&lt;&gt;(this.getAllExecutionEnvironmentsAtDataClay(Langs.LANG_JAVA,</span>
<span class="nc" id="L326">				this.getDataClayID(), false).keySet());</span>
<span class="nc" id="L327">		final int hashCode = objectID.hashCode();</span>
<span class="nc" id="L328">		final int whichDS = hashCode % allEEs.size();</span>
<span class="nc" id="L329">		final int hash = Math.abs(whichDS);</span>
<span class="nc" id="L330">		final ExecutionEnvironmentID stLocID = (ExecutionEnvironmentID) allEEs.get(hash);</span>
<span class="nc" id="L331">		return stLocID;</span>
	}

	/**
	 * Get remote execution environment
	 * 
	 * @param execLocationID
	 *            ID of remote execution environment
	 * @return Remote execution environment
	 */
	public final DataServiceAPI getRemoteExecutionEnvironment(final BackendID execLocationID) {

<span class="nc" id="L343">		final ExecutionEnvironment execEnvironment = getExecutionEnvironmentInfo(execLocationID);</span>
		try {
<span class="nc" id="L345">			return grpcClient.getDataServiceAPI(execEnvironment.getHostname(), execEnvironment.getPort());</span>
<span class="nc" id="L346">		} catch (final InterruptedException ex) {</span>
<span class="nc" id="L347">			LOGGER.debug(&quot;getRemoteExecutionEnvironment error&quot;, ex);</span>
			// Force to be runtime exc. so Clients can receive the exception
<span class="nc" id="L349">			throw new RuntimeException(ex.getCause());</span>
		}
	}

	/**
	 * Get remote execution environment
	 * 
	 * @param execLocationID
	 *            ID of remote execution environment
	 * @return Remote execution environment
	 */
	public DataServiceAPI getRemoteDSAPI(final ExecutionEnvironmentID execLocationID) {
<span class="nc" id="L361">		ExecutionEnvironment execEnv = this.getExecutionEnvironmentInfo(execLocationID);</span>
		try {
<span class="nc" id="L363">			return grpcClient.getDataServiceAPI(execEnv.getHostname(), execEnv.getPort());</span>
<span class="nc" id="L364">		} catch (final InterruptedException ex) {</span>
<span class="nc" id="L365">			LOGGER.debug(&quot;getRemoteExecutionEnvironmentForDS&quot;, ex);</span>
			// Force to be runtime exc. so Clients can receive the exception
<span class="nc" id="L367">			throw new RuntimeException(ex.getCause());</span>
		}
	}


	/**
	 * Get external dataClay info
	 * 
	 * @param extDataClayID
	 *            id of the external dataClay instance
	 * @return info of the external dataClay instance
	 */
	public DataClayInstance getExternalDataClayInfo(final DataClayInstanceID extDataClayID) {
<span class="nc" id="L380">		return this.getLogicModuleAPI().getExternalDataClayInfo(extDataClayID);</span>
	}
	

	/**
	 * Method that registers the info of a dataClay instance
	 * 
	 * @param dcHost
	 *            entry port host of the external dataClay
	 * @param dcPort
	 *            entry point port of the external dataClay
	 * @return ID of external registered dataClay.
	 */
	public DataClayInstanceID registerExternalDataClay(final String dcHost, final Integer dcPort) {
<span class="nc" id="L394">		return this.getLogicModuleAPI().registerExternalDataClay(dcHost, dcPort);</span>

	}
	
	/**
	 * ADMIN usage only. Method that registers the info of a dataClay instance but with overriden authority for SSL connections.
	 * @param adminAccountID admin account id
	 * @param  adminCredential admin credentials
	 * @param dcHost
	 *            entry port host of the external dataClay
	 * @param dcPort
	 *            entry point port of the external dataClay
	 * @param authority authority to use
	 * @return ID of external registered dataClay.
	 */
	public DataClayInstanceID registerExternalDataClayOverrideAuthority(final AccountID adminAccountID,
			final PasswordCredential adminCredential, final String dcHost, final int dcPort, final String authority) {
<span class="nc" id="L411">		return this.getLogicModuleAPI().registerExternalDataClayOverrideAuthority(adminAccountID, adminCredential, dcHost, dcPort, authority);</span>

	}
	
	/**
	 * Get external dataClay info
	 * 
	 * @param hostname
	 *            host name of the external dataClay instance
	 * @param port
	 *            port of the external dataClay instance.
	 * @return info of the external dataClay instance
	 */
	public DataClayInstanceID getExternalDataClayID(final String hostname, final int port) {
<span class="nc" id="L425">		return this.getLogicModuleAPI().getExternalDataClayID(hostname, port);</span>
	}

	/**
	 * Get ID of the current instance of dataClay
	 * 
	 * @return the dataClay ID
	 */
	public DataClayInstanceID getDataClayID() {
<span class="nc bnc" id="L434" title="All 2 branches missed.">		if (this.dataClayInstanceID == null) {</span>
<span class="nc" id="L435">			dataClayInstanceID =  this.getLogicModuleAPI().getDataClayID();</span>
		}
<span class="nc" id="L437">		return dataClayInstanceID;</span>
	}

	/**
	 * Get hint of current backend. If client, returns null.
	 * 
	 * @return ID of current backend.
	 */
	public abstract BackendID getHint();

	/**
	 * Finish connections to server
	 */
	public final void finishConnections() {
<span class="nc" id="L451">		LOGGER.info(&quot;Finishing connections ... &quot;);</span>
<span class="nc" id="L452">		LOGGER.debug(&quot;Stopping Grpc connections&quot;);</span>
<span class="nc" id="L453">		this.grpcClient.finishClientConnections();</span>
<span class="nc" id="L454">		LOGGER.debug(&quot;Stopping thread pool&quot;);</span>
<span class="nc" id="L455">		this.threadPool.shutdown();</span>
<span class="nc" id="L456">		this.threadPool = null; </span>
<span class="nc" id="L457">		this.grpcClient = null;</span>
<span class="nc" id="L458">		this.dataClayInstanceID = null;</span>
<span class="nc" id="L459">		boolean aliveThreads = true;</span>
<span class="nc" id="L460">		DataClayObject.clearStubInfosCache();</span>
<span class="nc" id="L461">		DataClayObject.clearExecStubInfosCache();</span>
<span class="nc" id="L462">		DataClayObject.clientRuntime = null;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">		for (int i = 0; i &lt; 10; i++) { //maximum retries</span>
<span class="nc" id="L464">			boolean foundAliveThread = false;</span>
<span class="nc" id="L465">			String threadName = null;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">			for (Thread t : Thread.getAllStackTraces().keySet()) {</span>
<span class="nc" id="L467">				threadName = t.getName();</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">				if (threadName.startsWith(&quot;grpc-&quot;)) {</span>
<span class="nc" id="L469">					foundAliveThread = true;</span>
<span class="nc" id="L470">					break;</span>
				}
<span class="nc" id="L472">			}</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">			if (foundAliveThread) { </span>
<span class="nc" id="L474">				LOGGER.warn(&quot;WARNING: Waiting for &quot; + threadName + &quot; thread to finish...&quot;);</span>
				try {
<span class="nc" id="L476">					Thread.sleep(300);</span>
<span class="nc" id="L477">				} catch (InterruptedException e) {</span>
<span class="nc" id="L478">					e.printStackTrace();</span>
<span class="nc" id="L479">				}</span>
			} else { 
<span class="nc" id="L481">				aliveThreads = false;</span>
<span class="nc" id="L482">				break; </span>
			}
		}
<span class="nc bnc" id="L485" title="All 2 branches missed.">		for (Thread t : Thread.getAllStackTraces().keySet()) {</span>
<span class="nc" id="L486">			String threadName = t.getName();</span>
<span class="nc" id="L487">			LOGGER.debug(&quot;Found alive thread while exiting: &quot; + threadName);</span>
<span class="nc" id="L488">		}</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">		if (aliveThreads) { </span>
<span class="nc" id="L490">			LOGGER.warn(&quot;WARNING: Some threads still alive while exiting application.&quot;);</span>
		}
		//((LifeCycle) LogManager.getContext()).stop();
<span class="nc" id="L493">		this.setInitialized(false);</span>
<span class="nc" id="L494">	}</span>

	/**
	 * Get the IDs of the backends in which the object identified by the stub instance provided is located and the classname of
	 * the object.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return Object metadata.
	 */
	public final MetaDataInfo getObjectMetadata(final ObjectID objectID) {
<span class="nc" id="L505">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;ObjectID&quot; }, new Object[] { objectID });</span>
<span class="nc" id="L506">		MetaDataInfo mdInfo = metaDataCache.get(objectID);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">		if (mdInfo == null) {</span>
<span class="nc" id="L508">			misses++;</span>

<span class="nc bnc" id="L510" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L511">				LOGGER.debug(&quot;[==Metadata Cache==] Not found entry in metadata cache for {}.&quot;</span>
						+ &quot;Asking LogicModule. WARNING: if the object is volatile, please &quot;
						+ &quot; note that it might be not registered yet (WIP).&quot;, objectID);
			}

<span class="nc" id="L516">			mdInfo = logicModule.getMetadataByOID(sessionID, objectID);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">				if (mdInfo == null) {</span>
<span class="nc" id="L519">					LOGGER.warn(&quot;Cannot get metadata for {}&quot;, objectID);</span>
				} else {
<span class="nc" id="L521">					LOGGER.debug(</span>
							&quot;[==Metadata Cache==] Adding entry in metadata cache for {} : {}&quot;,
							objectID, mdInfo);
				}
			}
<span class="nc bnc" id="L526" title="All 2 branches missed.">			if (mdInfo != null) {</span>
<span class="nc" id="L527">				metaDataCache.put(objectID, mdInfo);</span>
			}

		} else {
<span class="nc" id="L531">			hits++;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L533">				LOGGER.debug(&quot;[==Metadata Cache==] Found entry in metadata cache for {} : {}&quot;, objectID,</span>
						mdInfo);
			}
		}
<span class="nc" id="L537">		return mdInfo;</span>
	}

	/**
	 * Remove metadata of object from cache
	 *
	 * @param objectID
	 *            ID of the object
	 */
	public final void removeObjectMetadataFromCache(final ObjectID objectID) {
<span class="nc" id="L547">		metaDataCache.remove(objectID);</span>
<span class="nc" id="L548">	}</span>

												// ================================================== //
	// ================= FUNCTIONS ================== //
	// ================================================== //

	/**
	 * Retrieves a copy of the specified object and all its subobjects
	 * 
	 * @param oid
	 *            id of the object to be retrieved
	 * @param recursive
	 *            retrieve a copy of the whole object copying also its subobjects or only the main object
	 * @return a volatile instance of the object
	 */
	public final DataClayObject getCopyOfObject(final ObjectID oid, final boolean recursive) {
<span class="nc" id="L564">		final SessionID sessionID = getSessionID();</span>

		// Get an arbitrary object location
<span class="nc" id="L567">		final BackendID execLocationID = getLocation(oid);</span>
<span class="nc" id="L568">		final DataServiceAPI dsAPI = getRemoteExecutionEnvironment(execLocationID);</span>

		// Retrieve objects
<span class="nc" id="L571">		final SerializedParametersOrReturn copiedObject = dsAPI.getCopyOfObject(sessionID, oid, recursive);</span>
<span class="nc" id="L572">		final Object[] result = DataClayDeserializationLib.deserializeParamsOrReturn(copiedObject, null, this);</span>

<span class="nc" id="L574">		return (DataClayObject) result[0];</span>
	}

	/**
	 * Updates a specific object (into) with the fields of another one (from)
	 * 
	 * @param into
	 *            target object where data is put
	 * @param from
	 *            object containing the data to put
	 */
	public final void updateObject(final ObjectID into, final DataClayObject from) {
<span class="nc" id="L586">		final SessionID sessionID = getSessionID();</span>

		// Get an arbitrary object location
<span class="nc" id="L589">		final BackendID execLocationID = getLocation(into);</span>
<span class="nc" id="L590">		final DataServiceAPI dsAPI = getRemoteExecutionEnvironment(execLocationID);</span>
<span class="nc" id="L591">		final List&lt;DataClaySerializable&gt; aux = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L592">		aux.add(from);</span>

<span class="nc" id="L594">		final SerializedParametersOrReturn serFrom = DataClaySerializationLib.serializeParamsOrReturn(aux, null, this,</span>
				true, execLocationID, false);

<span class="nc" id="L597">		final Map&lt;Integer, ObjectWithDataParamOrReturn&gt; volObjects = serFrom.getVolatileObjs();</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">		if (volObjects != null) {</span>
<span class="nc" id="L599">			final Map&lt;ObjectID, ObjectID&gt; newIDs = new HashMap&lt;&gt;();</span>

			// Set new ids to all volatile objects to decouple them from client-side
			// Notice that 'from' object will be set with 'into' object ID to
			// force the deserialization at the EE on 'into' object
<span class="nc bnc" id="L604" title="All 2 branches missed.">			for (final Entry&lt;Integer, ObjectWithDataParamOrReturn&gt; curEntry : volObjects.entrySet()) {</span>
<span class="nc" id="L605">				final ObjectID curObjectID = curEntry.getValue().getObjectID();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">				if (!newIDs.containsKey(curObjectID)) {</span>
					final ObjectID newID;
<span class="nc bnc" id="L608" title="All 2 branches missed.">					if (curObjectID.equals(from.getObjectID())) {</span>
<span class="nc" id="L609">						newID = into;</span>
					} else {
<span class="nc" id="L611">						newID = new ObjectID();</span>
					}
<span class="nc" id="L613">					newIDs.put(curObjectID, newID);</span>
				}
<span class="nc" id="L615">				curEntry.getValue().setObjectID(newIDs.get(curObjectID));</span>
<span class="nc" id="L616">			}</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">			for (final Entry&lt;Integer, ObjectWithDataParamOrReturn&gt; curEntry : volObjects.entrySet()) {</span>
<span class="nc" id="L618">				final DataClayObjectMetaData md = curEntry.getValue().getMetaData();</span>
<span class="nc" id="L619">				final Map&lt;Integer, ObjectID&gt; oids = md.getOids();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">				for (final Entry&lt;Integer, ObjectID&gt; curOIDEntry : oids.entrySet()) {</span>
<span class="nc" id="L621">					final ObjectID newID = newIDs.get(curOIDEntry.getValue());</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">					if (newID != null) {</span>
<span class="nc" id="L623">						curOIDEntry.setValue(newID);</span>
					}
<span class="nc" id="L625">				}</span>
<span class="nc" id="L626">			}</span>
		}

<span class="nc" id="L629">		dsAPI.updateObject(sessionID, into, serFrom);</span>
<span class="nc" id="L630">	}</span>

	/**
	 * All volatiles provided are under deserialization. This function solves problems of 'hashcode' and other special functions
	 * needed during deserializations. See executeImpl.
	 * 
	 * @param volatileSet
	 *            Volatiles under deserialization.
	 */
	public void addVolatileUnderDeserialization(final Collection&lt;ObjectWithDataParamOrReturn&gt; volatileSet) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">		for (ObjectWithDataParamOrReturn vol : volatileSet) {</span>
<span class="nc" id="L641">			underDeserializationVolatiles.put(vol.getObjectID(), vol);</span>
<span class="nc" id="L642">		}</span>
<span class="nc" id="L643">	}</span>

	/**
	 * Remove volatiles under deserialization.
	 * @param volatileSet
	 *            Volatiles under deserialization.
	 */
	public void removeVolatilesUnderDeserialization(final Collection&lt;ObjectWithDataParamOrReturn&gt; volatileSet) {
<span class="nc bnc" id="L651" title="All 2 branches missed.">		for (ObjectWithDataParamOrReturn vol : volatileSet) {</span>
<span class="nc" id="L652">			underDeserializationVolatiles.remove(vol.getObjectID());</span>
<span class="nc" id="L653">		}</span>

<span class="nc" id="L655">	}</span>

	/**
	 * Get from Heap or create a new volatile in EE and load data on it.
	 * 
	 * @param classID
	 *            ID of class of the object
	 * @param objectID
	 *            ID of the object
	 * @param hint
	 *            Hint of the object
	 * @param objWithData
	 *            Data of the object
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 * @return Loaded volatile instance in EE.
	 */
	public DataClayObject getOrNewAndLoadVolatile(final MetaClassID classID, final ObjectID objectID,
			final BackendID hint, final ObjectWithDataParamOrReturn objWithData,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps) {
<span class="nc" id="L675">		return dataClayObjLoader.getOrNewAndLoadVolatile(classID, objectID, hint, objWithData, ifaceBitMaps);</span>
	}

	/**
	 * Get session ID
	 * 
	 * @return Session ID
	 */
	public abstract SessionID getSessionID();

	/**
	 * Check connection and parameters
	 * 
	 * @param paramNames
	 *            Names of parameters
	 * @param params
	 *            Parameters to check
	 */
	public final void checkConnectionAndParams(final String[] paramNames, final Object[] params) {
<span class="nc" id="L694">		RuntimeUtils.checkConnection(logicModule);</span>
<span class="nc" id="L695">		RuntimeUtils.checkNullParams(paramNames, params);</span>
<span class="nc" id="L696">	}</span>

	/**
	 * Check parameters and connections and session
	 * 
	 * @param paramNames
	 *            Names of parameters
	 * @param params
	 *            Parameters to check
	 * @return Session ID
	 */
	public final SessionID checkAndGetSession(final String[] paramNames, final Object[] params) {
<span class="nc" id="L708">		checkConnectionAndParams(paramNames, params);</span>
<span class="nc" id="L709">		final SessionID sessionID = getSessionID();</span>
<span class="nc" id="L710">		RuntimeUtils.checkSession(sessionID);</span>
<span class="nc" id="L711">		return sessionID;</span>
	}

	/**
	 * Method that gets info of an object given its ID if the object is accessible by using the given sesion.
	 * 
	 * @param alias
	 *            alias of the object
	 * @return Currently id of object and hint.
	 */
	public final Triple&lt;ObjectID, MetaClassID, BackendID&gt; getObjectInfoByAlias(final String alias) {
<span class="nc" id="L722">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;Alias&quot; }, new Object[] { alias });</span>

<span class="nc" id="L724">		Triple&lt;ObjectID, MetaClassID, BackendID&gt; result = aliasCache.get(alias);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L727">				LOGGER.debug(&quot;[==Alias==] Object with alias &quot; + alias + &quot; not found in cache. Asking LM.&quot;);</span>
			}
<span class="nc" id="L729">			final Triple&lt;ObjectID, MetaClassID, ExecutionEnvironmentID&gt; aux = logicModule.getObjectFromAlias(sessionID,</span>
					alias);
<span class="nc" id="L731">			result = new Triple&lt;&gt;(aux.getFirst(), aux.getSecond(), aux.getThird());</span>
<span class="nc" id="L732">			aliasCache.put(alias, result);</span>
		}
<span class="nc" id="L734">		return result;</span>
	}

	/**
	 * Method that gets an object given its alias.
	 * 
	 * @param alias
	 *            alias of the object
	 * @return The object identified by alias provided
	 */
	public final DataClayObject getObjectByAlias(final String alias) {
		final ObjectID oid;
		final MetaClassID mid;
		final BackendID bid;

<span class="nc" id="L749">		final Triple&lt;ObjectID, MetaClassID, BackendID&gt; objInfo = getObjectInfoByAlias(alias);</span>
<span class="nc" id="L750">		oid = objInfo.getFirst();</span>
<span class="nc" id="L751">		mid = objInfo.getSecond();</span>
<span class="nc" id="L752">		bid = objInfo.getThird();</span>

<span class="nc bnc" id="L754" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L755">			LOGGER.debug(&quot;[==GetByAlias==] Creating instance from alias &quot; + oid);</span>
		}

<span class="nc" id="L758">		return this.getPersistedObjectByOID(oid, mid, bid);</span>
	}

	/**
	 * Method that gets an object given its alias and metaclass id.
	 * 
	 * @param alias
	 *            alias of the object
	 * @param metaClassID
	 *            if of the object's metaclass
	 * @param safe
	 *            if true, check that alias exists
	 * @return The object identified by the proved alias and metaclass.
	 */
	public final DataClayObject getObjectByAlias(final String alias, MetaClassID metaClassID, boolean safe) {
<span class="nc bnc" id="L773" title="All 2 branches missed.">		if(safe) {</span>
<span class="nc" id="L774">			return this.getObjectByAlias(alias);</span>
		}

<span class="nc" id="L777">		final ObjectID oid = getObjectIDFromAlias(alias);</span>
<span class="nc" id="L778">		final BackendID bid = this.getBackendIDFromObjectID(oid);</span>

<span class="nc bnc" id="L780" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L781">			LOGGER.debug(&quot;[==GetByAlias==] Creating instance from alias &quot; + oid);</span>
		}

<span class="nc" id="L784">		return this.getPersistedObjectByOID(oid, metaClassID, bid);</span>
	}

	/**
	 * Method that deletes the alias of an object
	 * 
	 * @param alias
	 *            alias of the object to be removed
	 */
	public final void deleteAlias(final String alias) {
<span class="nc" id="L794">		final SessionID sessionID = getSessionID();</span>
<span class="nc" id="L795">		ObjectID objectID = logicModule.deleteAlias(sessionID, alias);</span>
<span class="nc" id="L796">		aliasCache.remove(alias);</span>
<span class="nc" id="L797">	}</span>

	/**
	 * Method that deletes the alias of an object provided
	 * @param dcObject the object
	 */
	public abstract void deleteAlias(final DataClayObject dcObject);

	/**
	 * Method that gets DataSetID from an object with id provided
	 * 
	 * @param oid
	 *            ID of the object
	 * @return DataSet of the object
	 */
	public final DataSetID getDataSetIDFromObject(final ObjectID oid) {
<span class="nc" id="L813">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;ObjectID&quot; }, new Object[] { oid });</span>
<span class="nc" id="L814">		final DataSetID dsID = logicModule.getObjectDataSetID(sessionID, oid);</span>
<span class="nc" id="L815">		return dsID;</span>
	}

	/**
	 * Get class name from ID.
	 * 
	 * @param classID
	 *            ID of class
	 * @return Class name
	 */
	public abstract String getClassNameInternal(final MetaClassID classID);

	/**
	 * Get class name from ID
	 * 
	 * @param classID
	 *            Class ID
	 * @return Class name
	 */
	public final String getClassName(final MetaClassID classID) {
<span class="nc" id="L835">		checkAndGetSession(new String[] { &quot;classID&quot; }, new Object[] { classID });</span>

<span class="nc" id="L837">		return getClassNameInternal(classID);</span>
	}

	/**
	 * Helper function to prepare information for new replica - version - consolidate algorithms
	 * @param objectID ID of the object
	 * @param objectHint object hint
	 * @param optDestBackendID Destination backend ID to get information from (can be null)
	 * @param optDestHostname Destination hostname to get information from (can be null)
	 * @param differentLocation if true, indicates that destination backend should be different than any location of the object
	 * @return Tuple with destination backend API to call and:
	 * 		Either information of dest backend with id provided, some exec env in host provided or random exec env.
	 */
	private final Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; prepareNewReplicaVersionConsolidate(final ObjectID objectID,
																									final BackendID objectHint,
																									final BackendID optDestBackendID,
																								  final String optDestHostname,
																								  final boolean differentLocation) {
		// Get an arbitrary object location
<span class="nc" id="L856">		BackendID execLocationID = objectHint;</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">		if (objectHint == null) {</span>
<span class="nc" id="L858">			execLocationID = getLocation(objectID);</span>
		}
		// Get language from origin location
<span class="nc" id="L861">		Langs objectLanguage = this.getExecutionEnvironmentInfo(execLocationID).getLang();</span>
<span class="nc" id="L862">		final DataServiceAPI dsAPI = getRemoteExecutionEnvironment(execLocationID);</span>
<span class="nc" id="L863">		ExecutionEnvironmentID destBackendID = (ExecutionEnvironmentID) optDestBackendID;</span>
<span class="nc" id="L864">		ExecutionEnvironment destBackend = null;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">		if (destBackendID == null) {</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">			if (optDestHostname != null) {</span>
				// Get some execution environment in that host
<span class="nc" id="L868">				Map&lt;BackendID, ExecutionEnvironment&gt; execsInHost = getAllExecutionEnvironmentsAtHost(objectLanguage,</span>
						optDestHostname);
<span class="nc bnc" id="L870" title="All 4 branches missed.">				if (execsInHost != null &amp;&amp; !execsInHost.isEmpty()) {</span>
<span class="nc" id="L871">					destBackend = execsInHost.values().iterator().next();</span>
<span class="nc" id="L872">					destBackendID = destBackend.getDataClayID();</span>
				}
			}
<span class="nc bnc" id="L875" title="All 2 branches missed.">			if (destBackend == null) {</span>
				// no destination backend specified, get one randomly in which object is
				// not registered
				// === RANDOM === //
<span class="nc" id="L879">				Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; backends =</span>
<span class="nc" id="L880">						this.getAllExecutionEnvironmentsAtDataClay(objectLanguage, this.getDataClayID(), false);</span>

<span class="nc bnc" id="L882" title="All 2 branches missed.">				if (differentLocation) {</span>
<span class="nc" id="L883">					Set&lt;BackendID&gt; locations = this.getAllLocations(objectID);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">					for (Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; eeEntry : backends.entrySet()) {</span>
<span class="nc" id="L885">						ExecutionEnvironmentID eeID = eeEntry.getKey();</span>
<span class="nc" id="L886">						ExecutionEnvironment execEnv = eeEntry.getValue();</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">						if (!locations.contains(eeID)) {</span>
<span class="nc" id="L888">							destBackendID = eeID;</span>
<span class="nc" id="L889">							destBackend = execEnv;</span>
<span class="nc" id="L890">							break;</span>
						}
<span class="nc" id="L892">					}</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">					if (destBackend == null) {</span>
<span class="nc" id="L894">						LOGGER.debug(&quot;Could not find any different location for replica, updating available exec envs&quot;);</span>

<span class="nc" id="L896">						backends =</span>
<span class="nc" id="L897">								this.getAllExecutionEnvironmentsAtDataClay(objectLanguage, this.getDataClayID(), true);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">						for (Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; eeEntry : backends.entrySet()) {</span>
<span class="nc" id="L899">							ExecutionEnvironmentID eeID = eeEntry.getKey();</span>
<span class="nc" id="L900">							ExecutionEnvironment execEnv = eeEntry.getValue();</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">							if (!locations.contains(eeID)) {</span>
<span class="nc" id="L902">								destBackendID = eeID;</span>
<span class="nc" id="L903">								destBackend = execEnv;</span>
<span class="nc" id="L904">								break;</span>
							}
<span class="nc" id="L906">						}</span>
					}
				}
<span class="nc bnc" id="L909" title="All 2 branches missed.">				if (destBackend == null) {</span>
<span class="nc" id="L910">					destBackendID = (ExecutionEnvironmentID) execLocationID;</span>
<span class="nc" id="L911">					destBackend = this.getExecutionEnvironmentInfo(destBackendID);</span>
				}
<span class="nc" id="L913">			}</span>
		} else {
<span class="nc" id="L915">			destBackend = getExecutionEnvironmentInfo(destBackendID);</span>
		}

<span class="nc" id="L918">		return new Tuple&lt;&gt;(dsAPI, destBackend);</span>
	}

	/**
	 * Creates a persistent new version of an object and its subobjects (always recursive). If a Backend is provided the object
	 * is versioned to this backend, otherwise it is versioned to any backend
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param objectHint object hint
	 * @param classID ID of the class of the object
	 * @param dataSetID ID of the dataset of the object
	 * @param optDestBackendID ID of the backend in which to store the version the object (optional)
	 * @param optDestHostname Hostname of the backend in which to replicate the object (optional)
	 * @return Version ID and destination backend ID
	 */
	public final Tuple&lt;ObjectID, BackendID&gt; newVersion(final ObjectID objectID,
													   final ExecutionEnvironmentID objectHint,
			final MetaClassID classID, final DataSetID dataSetID,
			final BackendID optDestBackendID, final String optDestHostname) {
<span class="nc" id="L938">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;ObjectID&quot; }, new Object[] { objectID });</span>

		// FIXME: retry in different replica location if it fails
<span class="nc" id="L941">		Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; destInfo = this.prepareNewReplicaVersionConsolidate(objectID, objectHint,</span>
				optDestBackendID, optDestHostname, false);
<span class="nc" id="L943">		DataServiceAPI dsAPI = destInfo.getFirst();</span>
<span class="nc" id="L944">		ExecutionEnvironment destBackend = destInfo.getSecond();</span>
<span class="nc" id="L945">		ExecutionEnvironmentID destBackendID = destBackend.getDataClayID();</span>
<span class="nc" id="L946">		ObjectID newVersionOID = dsAPI.newVersion(sessionID, objectID, destBackendID);</span>

		// update cache of metadata info
<span class="nc" id="L949">		Set&lt;ExecutionEnvironmentID&gt; locations = new HashSet&lt;&gt;();</span>
<span class="nc" id="L950">		locations.add((ExecutionEnvironmentID) destBackendID);</span>
<span class="nc" id="L951">		MetaDataInfo newMetaDataInfo = new MetaDataInfo(newVersionOID,</span>
				dataSetID, classID, false, locations, null, null);
<span class="nc" id="L953">		this.metaDataCache.put(newVersionOID, newMetaDataInfo);</span>
<span class="nc" id="L954">		return new Tuple&lt;&gt;(newVersionOID, destBackendID);</span>
	}

	/**
	 * Makes the object with finalVersionID the definitive version of the object with originalObjectID. The original version is
	 * deleted.
	 * 
	 * @param versionOID ID of version object to consolidate
	 * @param objectHint object hint
	 */
	public final void consolidateVersion(final ObjectID versionOID, final ExecutionEnvironmentID objectHint) {
		// FIXME: retry in different replica location if it fails
<span class="nc" id="L966">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;versionOID&quot; }, new Object[] { versionOID });</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L968">			LOGGER.debug(&quot;[==Consolidate==] Consolidate version &quot; + &quot;with oid &quot; + versionOID);</span>
		}
		// Get object location
<span class="nc" id="L971">		BackendID execLocationID = objectHint;</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">		if (objectHint == null) {</span>
<span class="nc" id="L973">			execLocationID = getLocation(versionOID);</span>
		}
		// Get language from origin location
<span class="nc" id="L976">		final DataServiceAPI dsAPI = getRemoteExecutionEnvironment(execLocationID);</span>
<span class="nc" id="L977">		dsAPI.consolidateVersion(sessionID, versionOID);</span>
<span class="nc" id="L978">	}</span>

	/**
	 * Replicates an object. If a Backend is provided the object is replicated to this backend, otherwise it is replicated to
	 * any backend
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param objectHint object hint
	 * @param optDestBackendID
	 *            ID of the backend in which to replicate the object (optional)
	 * @param optDestHostname Hostname of the backend in which to replicate the object (optional)
	 * @param recursive
	 *            Indicates if we should also replicate all sub-objects or not.
	 * @return The ID of the backend in which the replica was created or NULL if some error is thrown.
	 * 
	 */
	public final BackendID newReplica(final ObjectID objectID, final BackendID objectHint,
									  final BackendID optDestBackendID, final String optDestHostname,
									  final boolean recursive) {
		// FIXME: retry in different replica location if it fails

<span class="nc" id="L1000">		final SessionID sessionID = checkAndGetSession(new String[] { }, new Object[] {  });</span>

<span class="nc" id="L1002">		Tuple&lt;DataServiceAPI, ExecutionEnvironment&gt; destInfo = this.prepareNewReplicaVersionConsolidate(objectID, objectHint,</span>
				optDestBackendID, optDestHostname, true);
<span class="nc" id="L1004">		DataServiceAPI dsAPI = destInfo.getFirst();</span>
<span class="nc" id="L1005">		ExecutionEnvironment destBackend = destInfo.getSecond();</span>
<span class="nc" id="L1006">		Set&lt;ObjectID&gt; replicatedObjects = dsAPI.newReplica(sessionID, objectID, destBackend.getDataClayID(), recursive);</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">		for (ObjectID replicatedObjectID : replicatedObjects) {</span>
			// update metadata of the object in cache (if present!)
<span class="nc" id="L1009">			MetaDataInfo mdInfo = getObjectMetadata(replicatedObjectID);</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">			if (mdInfo != null) {</span>
<span class="nc" id="L1011">				mdInfo.getLocations().add(destBackend.getDataClayID());</span>
			}

			// Add replica location
<span class="nc" id="L1015">			DataClayObject dcObj = this.getFromHeap(objectID);</span>
<span class="nc" id="L1016">			dcObj.addReplicaLocations(destBackend.getDataClayID());</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">			if (dcObj.getOriginLocation() == null) {</span>
				// ONLY AT CLIENT SIDE: if it has origin location then keep that origin location
				// at client side there cannot be two replicas of same oid
<span class="nc" id="L1020">				dcObj.setOriginLocation((ExecutionEnvironmentID) objectHint);</span>
			}
<span class="nc" id="L1022">		}</span>
<span class="nc" id="L1023">		return destBackend.getDataClayID();</span>
	}

	/**
	 * Move the replica of an object from one backend to another.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param classID
	 *            Class ID of the object
	 * @param hint
	 *            Hint of the object
	 * @param srcBackendID
	 *            ID of the backend containing the replica
	 * @param destBackendID
	 *            ID of the destination backend
	 * @param recursive
	 *            Indicates if movement must be recursive or not.
	 */
	public final void moveObject(final ObjectID objectID, final MetaClassID classID, final BackendID hint,
			final BackendID srcBackendID, final BackendID destBackendID, final boolean recursive) {

<span class="nc bnc" id="L1045" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1046">			LOGGER.debug(&quot;[==MOVE==] Moving object &quot; + objectID + &quot; from &quot; + srcBackendID + &quot; to &quot; + destBackendID</span>
					+ &quot;, recursive = &quot; + recursive);
		}

<span class="nc bnc" id="L1050" title="All 2 branches missed.">		if (srcBackendID.equals(destBackendID)) {</span>
<span class="nc" id="L1051">			return; // ignore</span>
		}

<span class="nc" id="L1054">		final SessionID sessionID = checkAndGetSession(</span>
				new String[] { &quot;ObjectID&quot;, &quot;SrcStorageLocationID&quot;, &quot;DestStorageLocationID&quot; },
				new Object[] { objectID, srcBackendID, destBackendID });

		// FIXME: new replica/version/consolidate/move algorithms should not require
		// registered metadata in
		// LogicModule since new make persistent implementation behaves like volatiles
		// and metadata is created
		// eventually, not synchronously. Currently, we try to register it and if it is
		// already registered, just
		// continue.
		// Make sure object is registered.
<span class="nc" id="L1066">		final RegistrationInfo regInfo = new RegistrationInfo(objectID, classID, sessionID, null, null);</span>
		// alias must be null
		// NOTE: LogicModule register object function does not return an exception for
		// already registered
		// object. We should never call registerObject for already registered objects
		// and that's dataClay
		// code (check isPendingToRegister in EE or isPersistent,.. see makePersistent),
		// and remember that,
		// this is a workaround, registerObject should never be called for
		// replica/version/consolidate algorithms,
		// we must change the algorithms to not depend on metadata.
		// Also, location in which to register the object is the hint (in case it is not
		// registered yet).
<span class="nc" id="L1079">		List&lt;RegistrationInfo&gt; regInfos = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1080">		regInfos.add(regInfo);</span>
<span class="nc" id="L1081">		logicModule.registerObjects(regInfos, (ExecutionEnvironmentID) hint, Langs.LANG_JAVA);</span>

<span class="nc" id="L1083">		final List&lt;ObjectID&gt; movedObjs = logicModule.moveObject(sessionID, objectID,</span>
				(ExecutionEnvironmentID) srcBackendID, (ExecutionEnvironmentID) destBackendID, recursive);

<span class="nc" id="L1086">		final BackendID newhint = destBackendID;</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">		for (final ObjectID movedOID : movedObjs) {</span>
<span class="nc" id="L1088">			final DataClayObject obj = this.getFromHeap(movedOID);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">			if (obj != null) {</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1091">					LOGGER.debug(&quot;[==Hint==] Setting hint (moveObject) on instance &quot; + obj.getObjectID()</span>
<span class="nc" id="L1092">					+ &quot; the hint : &quot; + getDSNameOfHint(newhint));</span>
				}
<span class="nc" id="L1094">				obj.setHint(newhint);</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">				if (obj.getMasterLocation() != null) {</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">					if (obj.getMasterLocation().equals(getHint())) {</span>
<span class="nc" id="L1097">						obj.setMasterLocation(newhint);</span>
					}
				}
			}
<span class="nc" id="L1101">			this.metaDataCache.remove(movedOID);</span>
<span class="nc" id="L1102">		}</span>
<span class="nc" id="L1103">	}</span>

	/**
	 * Set a persistent object as read only Logic module API used for communication
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param classID
	 *            Class ID of the object
	 * @param hint
	 *            Hint of the object
	 */
	public final void setObjectReadOnly(final ObjectID objectID, final MetaClassID classID, final BackendID hint) {
<span class="nc" id="L1116">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;ObjectID&quot; }, new Object[] { objectID });</span>
		// TODO: call DS to set object read only
<span class="nc" id="L1118">	}</span>

	/**
	 * Set a persistent object as read write
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param classID
	 *            Class ID of the object
	 * @param hint
	 *            Hint of the object
	 */
	public final void setObjectReadWrite(final ObjectID objectID, final MetaClassID classID, final BackendID hint) {
<span class="nc" id="L1131">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;ObjectID&quot; }, new Object[] { objectID });</span>
		// TODO: call DS to set object read only
<span class="nc" id="L1133">	}</span>

	/**
	 * Get the ID of some backend in which the object identified by the stub instance provided is located
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return ID of some backend in which the object is located or NULL if some error is thrown.
	 */
	public final BackendID getLocation(final ObjectID objectID) {
<span class="nc" id="L1143">		checkConnectionAndParams(new String[] { &quot;ObjectID&quot; }, new Object[] { objectID });</span>

<span class="nc bnc" id="L1145" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1146">			LOGGER.debug(&quot;[==GetLocation==] Obtaining location for &quot; + objectID);</span>
		}
<span class="nc" id="L1148">		BackendID locationID = null;</span>

		// Get Hint
<span class="nc" id="L1151">		final DataClayObject obj = this.getFromHeap(objectID);</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">		if (obj != null) {</span>
<span class="nc" id="L1153">			locationID = obj.getHint();</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1155">				LOGGER.debug(&quot;[==GetLocation==] Obtained location for &quot; + objectID + &quot; from exec.hint: &quot; + locationID);</span>
			}
		}
<span class="nc bnc" id="L1158" title="All 2 branches missed.">		if (locationID != null) {</span>
<span class="nc" id="L1159">			return locationID;</span>
		} else {
			// If the object is not initialized well trying to obtain location from metadata
<span class="nc" id="L1162">			MetaDataInfo metadata = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">			if (metadata == null) {</span>
				// no metadata available, throw exception
				// NOTE: if it is a volatile and hint failed, it means that object is actually
				// not registered
<span class="nc" id="L1167">				throw new ObjectNotRegisteredException(objectID);</span>
			}
<span class="nc" id="L1169">			return metadata.getLocations().iterator().next();</span>
		}
	}

	/**
	 * Get the IDs of the backends in which the object identified by the stub instance provided is located.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return IDs of the backends in which the object is located or NULL if some error is thrown.
	 */
	public final Set&lt;BackendID&gt; getAllLocations(final ObjectID objectID) {
<span class="nc" id="L1181">		checkConnectionAndParams(new String[] { &quot;ObjectID&quot; }, new Object[] { objectID });</span>
<span class="nc" id="L1182">		LOGGER.debug(&quot;Getting all locations of object &quot; + objectID);</span>
		// First get object locations
<span class="nc" id="L1184">		Set&lt;BackendID&gt; locations = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1185">		DataClayObject dcObject = this.getFromHeap(objectID);</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">		if (dcObject != null) {</span>
<span class="nc" id="L1187">			Set&lt;ExecutionEnvironmentID&gt; replicaLocs = dcObject.getReplicaLocations();</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">			if (replicaLocs != null) {</span>
<span class="nc" id="L1189">				LOGGER.debug(&quot;Found replica locations:&quot; + replicaLocs);</span>
<span class="nc" id="L1190">				locations.addAll(replicaLocs);</span>
			}
<span class="nc bnc" id="L1192" title="All 2 branches missed.">			if (dcObject.getOriginLocation() != null) {</span>
<span class="nc" id="L1193">				LOGGER.debug(&quot;Found origin location:&quot; + dcObject.getOriginLocation());</span>
<span class="nc" id="L1194">				locations.add(dcObject.getOriginLocation());</span>
			}
		}
<span class="nc" id="L1197">		final MetaDataInfo metadata = getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">		if (metadata != null) {</span>
<span class="nc" id="L1199">			locations.addAll(metadata.getLocations());</span>
<span class="nc" id="L1200">			LOGGER.debug(&quot;Found metadata in cache, adding: &quot; + metadata.getLocations());</span>
			// Get Hint
<span class="nc" id="L1202">			final DataClayObject obj = this.getFromHeap(objectID);</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">			if (obj != null) {</span>
<span class="nc" id="L1204">				final BackendID locationID = obj.getHint();</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">				if (locationID != null) {</span>
<span class="nc" id="L1206">					LOGGER.debug(&quot;Adding hint location: &quot; + locationID);</span>
<span class="nc" id="L1207">					locations.add(locationID);</span>
				}
			}
<span class="nc" id="L1210">			LOGGER.debug(&quot;Found locations: &quot; + locations);</span>
<span class="nc" id="L1211">			return locations;</span>
		} else {
			// Get Hint
<span class="nc" id="L1214">			final DataClayObject obj = this.getFromHeap(objectID);</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">			if (obj != null) {</span>
<span class="nc" id="L1216">				final BackendID locationID = obj.getHint();</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">				if (locationID != null) {</span>
<span class="nc" id="L1218">					LOGGER.debug(&quot;Not found metadata in cache, adding hint location: &quot; + locationID);</span>
<span class="nc" id="L1219">					locations.add(locationID);</span>
				} else {
<span class="nc" id="L1221">					throw new DataClayRuntimeException(ERRORCODE.UNEXPECTED_EXCEPTION,</span>
							&quot;The object &quot; + objectID + &quot; is not initialized well, hint missing or not exist&quot;, true);
				}
			}
<span class="nc" id="L1225">			LOGGER.debug(&quot;Found locations: &quot; + locations);</span>
<span class="nc" id="L1226">			return locations;</span>
		}
	}

	/**
	 * Get name of node associated to hint.
	 * 
	 * @param hint
	 *            Hint
	 * @return name of node associated to hint
	 */
	public final String getDSNameOfHint(final BackendID hint) {
<span class="nc bnc" id="L1238" title="All 2 branches missed.">		if (hint == null) {</span>
<span class="nc" id="L1239">			return null;</span>
		}
<span class="nc" id="L1241">		return this.getExecutionEnvironmentInfo(hint).getName();</span>
	}

	/**
	 * Serialize parameters.
	 * 
	 * @param objectInWhichToExec
	 *            Object in which to run method that needs serialization of parameters
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 * @param implID
	 *            ImplementationID
	 * @param params
	 *            Parameters or return to serialize
	 * @param forUpdate
	 *            Indicates whether this serialization is for an update or not
	 * @param hintVolatiles
	 *            Hint to set to volatiles
	 * @return Serialized parameters
	 */
	public final SerializedParametersOrReturn serializeParams(final DataClayObject objectInWhichToExec,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps, final ImplementationID implID, final Object[] params,
			final boolean forUpdate, final BackendID hintVolatiles) {
<span class="nc bnc" id="L1264" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1265">			String paramTypes = &quot;&quot;;</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">			for (Object param : params) {</span>
<span class="nc" id="L1267">				paramTypes = paramTypes + param.getClass().getName() + &quot;, &quot;;</span>
			}
<span class="nc" id="L1269">			LOGGER.debug(&quot;[==Serialization==] Serializing parameters: &quot; + paramTypes);</span>

		}

		// Wrap parameters
<span class="nc" id="L1274">		final List&lt;DataClaySerializable&gt; wrappedParams = objectInWhichToExec.wrapParameters(implID, params);</span>
		// Serialize parameters
		// IfaceBitMaps = null. From client stub is controlling it.
<span class="nc bnc" id="L1277" title="All 2 branches missed.">		if (wrappedParams.isEmpty()) {</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1279">				LOGGER.debug(&quot;[==Serialization==] No parameters to serialize&quot;);</span>
			}
<span class="nc" id="L1281">			return null;</span>
		} else {
<span class="nc" id="L1283">			final SerializedParametersOrReturn serParams = DataClaySerializationLib</span>
<span class="nc" id="L1284">					.serializeParamsOrReturn(wrappedParams, ifaceBitMaps, this, forUpdate, hintVolatiles, false);</span>
<span class="nc" id="L1285">			return serParams;</span>
		}
	}

	/**
	 * Serialize parameters.
	 * 
	 * @param objectInWhichToExec
	 *            Object in which to run method that needs serialization of parameters
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 * @param implID
	 *            ImplementationID
	 * @param ret
	 *            Return to serialize
	 * @return Serialized parameters
	 */
	public final SerializedParametersOrReturn serializeReturn(final DataClayObject objectInWhichToExec,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps, final ImplementationID implID, final Object ret) {
<span class="nc bnc" id="L1304" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1305">			LOGGER.debug(&quot;[==Serialization==] Serializing return&quot;);</span>
		}
<span class="nc bnc" id="L1307" title="All 2 branches missed.">		if (ret == null) {</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1309">				LOGGER.debug(&quot;[==Serialization==] No return to serialize&quot;);</span>
			}
<span class="nc" id="L1311">			return null;</span>
		}

		// Return of an object from DataClay is always persistent. Should not find any
		// volatile.

		// Wrap parameters
<span class="nc" id="L1318">		final List&lt;DataClaySerializable&gt; wrapList = objectInWhichToExec.wrapReturn(implID, ret);</span>

		// Serialize parameters
		// IfaceBitMaps = null. From client stub is controlling it.
<span class="nc" id="L1322">		final SerializedParametersOrReturn serReturn = DataClaySerializationLib.serializeParamsOrReturn(wrapList,</span>
				ifaceBitMaps, this, false, null, false); // no hint volatiles since volatiles are not going to client

<span class="nc bnc" id="L1325" title="All 2 branches missed.">		if (!serReturn.getVolatileObjs().isEmpty()) {</span>
<span class="nc" id="L1326">			LOGGER.error(&quot;Sending volatile objects to client or other DS from DS&quot;);</span>
		}

<span class="nc" id="L1329">		return serReturn;</span>
	}

	/**
	 * Deserialize parameters.
	 * 
	 * @param objectInWhichToExec
	 *            Object in which to run method that needs deserialization of parameters.
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 * @param implID
	 *            ImplementationID
	 * @param serializedParams
	 *            Parameters to deserialize
	 * @return Serialized parameters
	 */
	public final Object[] deserializeParams(final DataClayObject objectInWhichToExec,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps, final ImplementationID implID,
			final SerializedParametersOrReturn serializedParams) {
<span class="nc bnc" id="L1348" title="All 2 branches missed.">		if (serializedParams == null) {</span>
<span class="nc" id="L1349">			return null;</span>
		}
<span class="nc bnc" id="L1351" title="All 2 branches missed.">		if (serializedParams.needWrappers()) {</span>
			// Create wrappers for language/immutable parameters
<span class="nc" id="L1353">			LOGGER.debug(&quot;[==Serialization==] Setting wrapper params&quot;);</span>
<span class="nc" id="L1354">			objectInWhichToExec.setWrappersParams(implID, serializedParams);</span>
		}
<span class="nc bnc" id="L1356" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1357">			LOGGER.debug(&quot;[==Serialization==] Deserializing parameters&quot;);</span>
		}
<span class="nc" id="L1359">		return DataClayDeserializationLib.deserializeParamsOrReturn(serializedParams, ifaceBitMaps, this);</span>
	}

	/**
	 * Deserialize int heap objects provided for a make persistent call.
	 * 
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 * @param serializedParams
	 *            Objects to deserialize
	 * @return the deserialized parameters
	 */
	public final Object[] deserializeIntoHeap(final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps,
			final List&lt;ObjectWithDataParamOrReturn&gt; serializedParams) {
<span class="nc bnc" id="L1373" title="All 2 branches missed.">		if (serializedParams == null) {</span>
<span class="nc" id="L1374">			return null;</span>
		}
<span class="nc" id="L1376">		return DataClayDeserializationLib.deserializeParamsOrReturn(new SerializedParametersOrReturn(serializedParams),</span>
				ifaceBitMaps, this);
	}

	/**
	 * Deserialize return.
	 * 
	 * @param objectInWhichToExec
	 *            Object in which to run method that needs deserialization of return.
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 * @param implID
	 *            ImplementationID
	 * @param serializedReturn
	 *            Return to deserialize
	 * @return Deserialized return
	 */
	public final Object deserializeReturn(final DataClayObject objectInWhichToExec,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps, final ImplementationID implID,
			final SerializedParametersOrReturn serializedReturn) {
<span class="nc bnc" id="L1396" title="All 2 branches missed.">		if (serializedReturn == null) {</span>
<span class="nc" id="L1397">			return null;</span>
		}
<span class="nc" id="L1399">		objectInWhichToExec.setWrappersReturn(implID, serializedReturn);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1401">			LOGGER.debug(&quot;[==Serialization==] Deserializing return&quot;);</span>
		}
<span class="nc" id="L1403">		return DataClayDeserializationLib.deserializeParamsOrReturn(serializedReturn, ifaceBitMaps, this)[0];</span>
	}

	/**
	 * Internal Method that executes an implementation depending on client or server.
	 * 
	 * @param objectInWhichToExec
	 *            Object in which to exec
	 * @param implID
	 *            Implementation ID
	 * @param params
	 *            Parameters
	 * @return the result of execution.
	 * @note This function is called from a stub
	 */
	protected abstract Object executeRemoteImplementationInternal(final DataClayObject objectInWhichToExec,
			final ImplementationID implID, final Object[] params);

	/**
	 * Method that executes an implementation.
	 * 
	 * @param objectInWichToExec
	 *            Object in which to exec
	 * @param implIDStr
	 *            Implementation ID as string
	 * @param params
	 *            Parameters
	 * @return the result of execution.
	 * @note This function is called from a stub
	 */
	public final Object executeRemoteImplementation(final DataClayObject objectInWichToExec, final String implIDStr,
			final Object[] params) {
<span class="nc" id="L1435">		final SessionID sessionID = getSessionID();</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L1437">			RuntimeUtils.checkSession(sessionID);</span>
		}
<span class="nc" id="L1439">		final ImplementationID implID = new ImplementationID(implIDStr);</span>
<span class="nc" id="L1440">		return this.executeRemoteImplementationInternal(objectInWichToExec, implID, params);</span>
	}

	/**
	 * Get interface bitmaps.
	 * 
	 * @return Interface bitmaps
	 */
	protected abstract Map&lt;MetaClassID, byte[]&gt; getIfaceBitMaps();

	/**
	 * Execute a remote implementation in Location specified.
	 * 
	 * @param dcObject
	 *            Object used as a 'portal' to other DS.
	 * @param params
	 *            Parameters to send
	 * @param remoteImplID
	 *            ID of implementation to execute
	 * @param remoteLocationID
	 *            Location in which to execute
	 * @param usingHint
	 *            TRUE if using hint.
	 * @return Result of execution.
	 */
	public final Object callExecuteToDS(final DataClayObject dcObject, final Object[] params,
			final ImplementationID remoteImplID, final BackendID remoteLocationID, final boolean usingHint) {

<span class="nc" id="L1468">		final SessionID sessionID = getSessionID();</span>
		// ===== SERIALIZE PARAMETERS ===== //
		// Between DS - DS, ifaceBitMaps = null
		// Serialize parameters
<span class="nc" id="L1472">		SerializedParametersOrReturn serResult = null;</span>
<span class="nc" id="L1473">		boolean executed = false;</span>
<span class="nc" id="L1474">		BackendID execLocationID = remoteLocationID;</span>
<span class="nc" id="L1475">		DataServiceAPI dsAPI = null;</span>
<span class="nc" id="L1476">		short numMisses = 0;</span>
<span class="nc" id="L1477">		final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps = null; // TODO: add iface bitmaps? (too expensive?)</span>
<span class="nc" id="L1478">		final SerializedParametersOrReturn serializedParams = serializeParams(dcObject, ifaceBitMaps, remoteImplID,</span>
				params, false, execLocationID);
<span class="nc bnc" id="L1480" title="All 4 branches missed.">		if (serializedParams != null &amp;&amp; serializedParams.getVolatileObjs() != null) {</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">			for (final Entry&lt;Integer, ObjectWithDataParamOrReturn&gt; param : serializedParams.getVolatileObjs()</span>
<span class="nc" id="L1482">					.entrySet()) {</span>
<span class="nc" id="L1483">				volatileParametersBeingSend.add(param.getValue().getObjectID());</span>
<span class="nc" id="L1484">			}</span>
		}
<span class="nc bnc" id="L1486" title="All 4 branches missed.">		while (!executed &amp;&amp; numMisses &lt; Configuration.Flags.MAX_EXECUTION_RETRIES.getShortValue()) {</span>
			try {
<span class="nc bnc" id="L1488" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1489">					final ExecutionEnvironment execEnv = this.getExecutionEnvironmentInfo(execLocationID);</span>
<span class="nc" id="L1490">					LOGGER.debug(&quot;[==JUMP==] Request execution to  &quot; + execEnv.getName() + &quot; for object &quot;</span>
<span class="nc" id="L1491">							+ dcObject.getObjectID());</span>
				}

<span class="nc" id="L1494">				dsAPI = getRemoteExecutionEnvironment(execLocationID);</span>
<span class="nc" id="L1495">				serResult = dsAPI.executeImplementation(dcObject.getObjectID(), remoteImplID, serializedParams,</span>
						sessionID);
<span class="nc" id="L1497">				executed = true;</span>
<span class="nc" id="L1498">			} catch (StatusRuntimeException | OutOfMemoryError | DataClayException er) {</span>

				// AliasAlreadyInUse should be thrown. TODO: define better exceptions.
<span class="nc bnc" id="L1501" title="All 2 branches missed.">				if (er instanceof AliasAlreadyInUseException) {</span>
					// This can happen with registered methods calling makePersistent
<span class="nc" id="L1503">					throw er;</span>
				}

				// ===== POSSIBLE RACE CONDITION ===== //
				// There was a previous miss and we updated the metadata cache
				// It is possible that a race condition might happened. Same volatile was send
				// concurrently but data only goes in one of these calls.
				// Check if any persistent parameter is a volatile being send. If so, repeat the
				// call.
<span class="nc" id="L1512">				boolean isRaceCondition = false;</span>
<span class="nc bnc" id="L1513" title="All 4 branches missed.">				if (serializedParams != null &amp;&amp; serializedParams.getPersistentRefs() != null) {</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">					for (final Entry&lt;Integer, PersistentParamOrReturn&gt; param : serializedParams.getPersistentRefs()</span>
<span class="nc" id="L1515">							.entrySet()) {</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">						if (volatileParametersBeingSend.contains(param.getValue().getObjectID())) {</span>
<span class="nc" id="L1517">							isRaceCondition = true;</span>
<span class="nc" id="L1518">							break;</span>
						}
<span class="nc" id="L1520">					}</span>
				}

<span class="nc bnc" id="L1523" title="All 2 branches missed.">				if (!isRaceCondition) {</span>
					// TODO Check if we really want numMisses to be incremented here
<span class="nc" id="L1525">					numMisses++;</span>

					// =================== UPDATE METADATA CACHE (due to a MISS) ===================
					// //
					// If remote DS sends a DbObjectNotExists means that it might be possible that
					// THIS DataService contains wrong information
					// in its cache and must remove it and seek for new one.
<span class="nc" id="L1532">					LOGGER.debug(&quot;Execution failed in location &quot; + execLocationID);</span>
					// PREFER NOT TRIED LOCATION (In case Backend failed and we have replicas)

<span class="nc" id="L1535">					Set&lt;ExecutionEnvironmentID&gt; locations = dcObject.getReplicaLocations();</span>
<span class="nc bnc" id="L1536" title="All 4 branches missed.">					if (locations == null || locations.isEmpty()) {</span>
<span class="nc" id="L1537">						final MetaDataInfo metadata = getObjectMetadata(dcObject.getObjectID());</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">						if (metadata == null) {</span>

							// no metadata available, throw exception
							// NOTE: if it is a volatile and hint failed, it means that object is actually
							// not registered
<span class="nc" id="L1543">							throw new ObjectNotRegisteredException(dcObject.getObjectID());</span>
						} else {
<span class="nc" id="L1545">							locations = metadata.getLocations();</span>
						}
					}

<span class="nc" id="L1549">					boolean foundDifferentLocation = false;</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">					for (final ExecutionEnvironmentID curLoc : locations) {</span>
<span class="nc" id="L1551">						LOGGER.debug(&quot;Found location &quot; + curLoc);</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">						if (!curLoc.equals(execLocationID)) {</span>
<span class="nc" id="L1553">							execLocationID = curLoc;</span>
<span class="nc" id="L1554">							foundDifferentLocation = true;</span>
<span class="nc" id="L1555">							LOGGER.debug(&quot;Found different location &quot; + execLocationID);</span>
<span class="nc" id="L1556">							break;</span>
						}
<span class="nc" id="L1558">					}</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">					if (!foundDifferentLocation) {</span>
<span class="nc" id="L1560">						LOGGER.debug(&quot;Using random location in retry: &quot; + execLocationID);</span>
<span class="nc" id="L1561">						execLocationID = locations.iterator().next();</span>
					}
<span class="nc bnc" id="L1563" title="All 2 branches missed.">					if (usingHint) {</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1565">							LOGGER.debug(&quot;[==Hint==] Setting hint (Retry remote execution) on instance &quot;</span>
<span class="nc" id="L1566">									+ dcObject.getObjectID() + &quot; the hint : &quot; + getDSNameOfHint(execLocationID));</span>
						}
<span class="nc" id="L1568">						dcObject.setHint(execLocationID);</span>
					}

<span class="nc bnc" id="L1571" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1572">						LOGGER.debug(&quot;[==Miss Jump==] MISS. The object &quot; + dcObject.getObjectID()</span>
						+ &quot; was not in the exec.location &quot; + execLocationID + &quot;. Retrying execution.&quot;);
					}
				}

<span class="nc" id="L1577">			}</span>
		}



<span class="nc bnc" id="L1582" title="All 4 branches missed.">		if (serializedParams != null &amp;&amp; serializedParams.getVolatileObjs() != null) {</span>
			// update hints in volatiles
<span class="nc bnc" id="L1584" title="All 2 branches missed.">			for (final ObjectWithDataParamOrReturn volatil : serializedParams.getVolatileObjs().values()) {</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1586">					LOGGER.debug(&quot;[==Hint==] Setting hint (exec) in object &quot; + volatil.getObjectID() + &quot; hint: &quot;</span>
							+ remoteLocationID);
				}
<span class="nc bnc" id="L1589" title="All 2 branches missed.">				if (numMisses &gt; 0) {</span>
					// if there was a miss, it means that the persistent object in which we were executing 
					// was not in the choosen location. As you can see in the serialize parameters function above
					// we provide the execution environment as hint to set to volatile parameters. In EE, before
					// deserialization of volatiles we check if the persistent object in which to execute a method is
					// there, if not, EE raises and exception. Therefore, if there was a miss, we know that the 
					// hint we set in volatile parameters is wrong, because they are going to be deserialized/stored
					// in the same location as the object with the method to execute
<span class="nc" id="L1597">					volatil.getDataClayObject().setHint(remoteLocationID); </span>
				}
<span class="nc" id="L1599">				volatileParametersBeingSend.remove(volatil.getObjectID());</span>

<span class="nc" id="L1601">			}</span>

		}

<span class="nc bnc" id="L1605" title="All 2 branches missed.">		if (dsAPI == null) {</span>
<span class="nc" id="L1606">			throw new DataClayException(ERRORCODE.UNEXPECTED_EXCEPTION,</span>
					&quot;[dataClay] ERROR: Trying to execute remotely but&quot;
							+ &quot; not initialized/found. Please, check initialization of StorageItf or ClientManagementLib &quot;
							+ &quot; was successfull or contact administrator.&quot;,
							true);
		}

<span class="nc bnc" id="L1613" title="All 2 branches missed.">		if (!executed) {</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1615">				LOGGER.error(</span>
						&quot;Trying to execute remotely object {} of class {}, &quot;
								+ &quot; but something went wrong. Maybe the object is still not stored &quot;
								+ &quot; (in case of asynchronous makepersistent) and waiting time is not enough.&quot;
								+ &quot; Maybe the object does not exist anymore due to a remove. Or Maybe an &quot;
								+ &quot;exception happened in the server and the call failed.&quot;,
<span class="nc" id="L1621">								dcObject.getObjectID(), dcObject.getClass().getName());</span>
			}
<span class="nc" id="L1623">			throw new RuntimeException(&quot;[dataClay] ERROR: Trying to execute remotely object &quot; + dcObject.getObjectID()</span>
<span class="nc" id="L1624">			+ &quot; of class &quot; + dcObject.getClass().getName()</span>
			+ &quot; but something went wrong. Maybe the object is still not stored &quot;
			+ &quot; (in case of asynchronous makepersistent) and waiting time is not enough.&quot;
			+ &quot; Maybe the object does not exist anymore due to a remove. Or Maybe an &quot;
			+ &quot;exception happened in the server and the call failed.&quot;);
		}

		// ===== DESERIALIZE RETURN ===== //
		// Deserialize return
<span class="nc" id="L1633">		return deserializeReturn(dcObject, ifaceBitMaps, remoteImplID, serResult);</span>
	}

	/**
	 * Synchronize
	 * @param dcObject
	 *            Object used as a 'portal' to other DS.
	 * @param params
	 *            Parameters to send
	 * @param remoteImplID
	 *            ID of implementation to execute
	 */
	public abstract void synchronize(final DataClayObject dcObject, final Object[] params,
			final ImplementationID remoteImplID);

	/**
	 * Check if string is UUID
	 * 
	 * @param string
	 *            string to check
	 * @return TRUE if it is an uuid. FALSE otherwise.
	 */
	private boolean isUUID(final String string) {
		try {
<span class="nc" id="L1657">			UUID.fromString(string);</span>
<span class="nc" id="L1658">			return true;</span>
<span class="nc" id="L1659">		} catch (final Exception ex) {</span>
<span class="nc" id="L1660">			return false;</span>
		}
	}

	/**
	 * Check if string is Compss DataClayID
	 * 
	 * @param string
	 *            string to check
	 * @return TRUE if it is an uuid. FALSE otherwise.
	 */
	private boolean isCompssDataClayID(final String string) {
<span class="nc bnc" id="L1672" title="All 2 branches missed.">		if (string.contains(&quot;:&quot;)) {</span>
<span class="nc" id="L1673">			final String[] ids = string.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L1674" title="All 2 branches missed.">			if (isUUID(ids[0])) {</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">				if (ids.length &gt; 0) {</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">					if (isUUID(ids[1])) {</span>
<span class="nc" id="L1677">						return true;</span>
					}
				} else {
<span class="nc" id="L1680">					return true;</span>
				}
			}
		}
<span class="nc" id="L1684">		return false;</span>
	}

	/**
	 * Method that executes an implementation
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param className
	 *            Name of the class of the object
	 * @param operationNameAndSignature
	 *            Name and Signature of the operation to be executed
	 * @param params
	 *            parameters for the operation
	 * @param target
	 *            the backend where the execution must be performed
	 * @return the resulting object corresponding to the execution of the operation if it succeeds. null otherwise. &lt;br&gt;
	 *         if the method is void, it returns null also but no ERROR is prompt.
	 */
	public final Object executeRemoteTask(final ObjectID objectID, final String className,
			final String operationNameAndSignature, final Object[] params, final BackendID target) {

<span class="nc bnc" id="L1706" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1707">			LOGGER.debug(&quot;[==ExecuteTask==] Executing task &quot; + operationNameAndSignature + &quot; in object &quot; + objectID</span>
					+ &quot; of class &quot; + className);
		}

<span class="nc" id="L1711">		checkAndGetSession(new String[] { &quot;ObjectID&quot;, &quot;ClassName&quot;, &quot;operationNameAndSignature&quot;, &quot;target&quot; },</span>
				new Object[] { objectID, className, operationNameAndSignature, target });

		// Get class ID
<span class="nc" id="L1715">		final StubInfo stubInfo = DataClayObject.getStubInfoFromClass(className);</span>
<span class="nc" id="L1716">		final ImplementationStubInfo opStubInfo = stubInfo</span>
<span class="nc" id="L1717">				.getImplementationByNameAndSignature(operationNameAndSignature);</span>
<span class="nc" id="L1718">		final Map&lt;String, Type&gt; paramsSpecs = opStubInfo.getParams();</span>
<span class="nc" id="L1719">		final List&lt;String&gt; paramsOrder = opStubInfo.getParamsOrder();</span>

<span class="nc bnc" id="L1721" title="All 2 branches missed.">		for (int i = 0; i &lt; params.length; i++) {</span>
			// Check if parameter is String
<span class="nc bnc" id="L1723" title="All 2 branches missed.">			if (params[i] instanceof String) {</span>
<span class="nc" id="L1724">				final String oid = (String) params[i];</span>
				// CHECKSTYLE:OFF
<span class="nc bnc" id="L1726" title="All 2 branches missed.">				if (this.isCompssDataClayID(oid)) {</span>
					// ======== TURN STRING UUIDS TO DATACLAY OBJECTS ======== //
					// It can be a persistent object
					// CHECKSTYLE:ON
					// Serialize it as an object
					try {
<span class="nc" id="L1732">						final Triple&lt;ObjectID, BackendID, MetaClassID&gt; ids = DataClay.string2IDandHintID(oid);</span>
<span class="nc" id="L1733">						final ObjectID paramObjectID = ids.getFirst();</span>
<span class="nc" id="L1734">						final BackendID hint = ids.getSecond();</span>
<span class="nc" id="L1735">						final Type paramSpec = paramsSpecs.get(paramsOrder.get(i));</span>
<span class="nc" id="L1736">						final UserType paramSpecUType = (UserType) paramSpec;</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1738">							LOGGER.debug(&quot;[==ExecuteTask==] Creating instance for param of task &quot; + paramObjectID);</span>
						}
<span class="nc" id="L1740">						final DataClayObject instance = this.getPersistedObjectByOID(paramObjectID,</span>
<span class="nc" id="L1741">								paramSpecUType.getClassID(), hint);</span>
<span class="nc" id="L1742">						params[i] = instance;</span>
<span class="nc" id="L1743">					} catch (final Exception ex) {</span>
<span class="nc" id="L1744">						throw new RuntimeException(ex.getMessage());</span>
<span class="nc" id="L1745">					}</span>
				}
			}
		}

		// Creating a portal and using its 'wrapParameters' method is much more
		// efficient than
		// providing a 'switch-case' serialization. The wrapParameters function cannot
		// be static generic call
		// since it depends on the class (like run)
<span class="nc bnc" id="L1755" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1756">			LOGGER.debug(&quot;[==ExecuteTask==] Creating portal instance for task &quot; + objectID);</span>
		}
<span class="nc" id="L1758">		final DataClayObject portal = this.getPersistedObjectByOID(objectID, stubInfo.getClassID(), null);</span>
<span class="nc" id="L1759">		return callExecuteToDS(portal, params, opStubInfo.getRemoteImplID(), target, false);</span>
	}

	/**
	 * Check if instance exists in Heap or create a new PERSISTENT instance if needed
	 * 
	 * @param classID
	 *            ID of the class in case it is needed (not need to query) if null, look for class id in metadata.
	 * @param objectID
	 *            ID of object
	 * @param hint
	 *            Can be null. Hint in case object is a volatile in another DS and we need information.
	 * @return Instance
	 */
	public abstract DataClayObject getOrNewPersistentInstance(final MetaClassID classID, final ObjectID objectID,
			final BackendID hint);

	/**
	 * Create a new instance in a remote server and persist it.
	 * 
	 * @param classID
	 *            ID of the class of the instance to create
	 * @param stubInfo
	 *            Stub information
	 * @param implID
	 *            ID of the implementation of the constructor
	 * @param params
	 *            Parameters to send to constructor
	 * @param locID
	 *            (optional) Storage Location/ Execution Environment in which to store object.
	 * @return ObjectID of persisted instance.
	 */
	public final ObjectID newRemotePersistentInstance(final MetaClassID classID, final StubInfo stubInfo,
			final ImplementationID implID, final Object[] params, final BackendID locID) {
<span class="nc" id="L1793">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;classID&quot;, &quot;stubInfo&quot;, &quot;implID&quot; },</span>
				new Object[] { classID, stubInfo, implID });

<span class="nc" id="L1796">		final ImplementationStubInfo implStubInfo = stubInfo.getImplementationByID(implID.toString());</span>
		// Serialize parameters
<span class="nc bnc" id="L1798" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1799">			LOGGER.debug(</span>
<span class="nc" id="L1800">					&quot;[==NewRemote==] New remote persistent instance. Going to execute &quot; + implStubInfo.getSignature());</span>
<span class="nc" id="L1801">			LOGGER.debug(&quot;[==Serialization==] Serializing parameters for: &quot; + implStubInfo.getSignature());</span>
		}

		// Creating a portal and using its 'wrapParameters' method is much more
		// efficient than
		// providing a 'switch-case' serialization. The wrapParameters function cannot
		// be static generic call
		// since it depends on the class (like run)
<span class="nc" id="L1809">		final DataClayObject portal = getOrNewPersistentInstance(stubInfo.getClassID(), new ObjectID(), null);</span>
		// IfaceBitMaps = null. From client stub is controlling it.

<span class="nc" id="L1812">		BackendID execLocationID = locID;</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">		if (execLocationID == null) {</span>
			// === RANDOM === //
<span class="nc" id="L1815">			execLocationID = this.getAllExecutionEnvironmentsInfo(Langs.LANG_JAVA, false).keySet().iterator().next();</span>
		}

		// Serialize parameters
<span class="nc" id="L1819">		final SerializedParametersOrReturn serializedParams = serializeParams(portal, null, implID, params, false,</span>
				execLocationID);

<span class="nc" id="L1822">		final DataServiceAPI dsAPI = this.getRemoteExecutionEnvironment(execLocationID);</span>
<span class="nc" id="L1823">		return dsAPI.newPersistentInstance(sessionID, classID, implID, null, serializedParams);</span>

	}

	/**
	 * This method creates a new Persistent Object using the provided stub instance and, if indicated, all its associated
	 * objects also Logic module API used for communication
	 * 
	 * @param dcObject
	 *            Instance to make persistent
	 * @param optionalDestBackendID
	 *            Indicates which is the destination backend
	 * @param recursive
	 *            Indicates if make persistent is recursive
	 * @param alias
	 *            Alias for the object
	 * @return ID of the backend in which te object was persisted.
	 * @note This function is called from a stub/execution class
	 */
	public abstract BackendID makePersistent(final DataClayObject dcObject, final BackendID optionalDestBackendID,
			final boolean recursive, final String alias);


	/**
	 * Federate an object with an external dataClay
	 *
	 * @param dcObject
	 *            object to federate
	 * @param externalDataClayID
	 *            id of the external dataClay ID
	 * @param recursive
	 *            Indicates if subobjects should be federated as well
	 */
	public void federateObject(final DataClayObject dcObject,
							   final DataClayInstanceID externalDataClayID,
							   final boolean recursive) {

<span class="nc" id="L1860">		ExecutionEnvironmentID externalExecutionEnvironmentID =</span>
<span class="nc" id="L1861">				this.getAllExecutionEnvironmentsAtDataClay(Langs.LANG_JAVA, externalDataClayID, false).keySet().iterator().next();</span>
<span class="nc" id="L1862">		this.federateToBackend(dcObject, externalExecutionEnvironmentID, recursive);</span>
<span class="nc" id="L1863">	}</span>

	/**
	 * Federate an object with an external dataClay
	 *
	 * @param dcObject
	 *            object to federate
	 * @param externalExecutionEnvironmentID
	 *            id of the external execution environment id
	 * @param recursive
	 *            Indicates if subobjects should be federated as well
	 */
	public abstract void federateToBackend(final DataClayObject dcObject,
							   final ExecutionEnvironmentID externalExecutionEnvironmentID,
							   final boolean recursive);
	/**
	 * Unfederate an object with an external dataClay
	 *
	 * @param dcObject
	 *            object to unfederate
	 * @param externalDataClayID
	 *            id of the external dataClay
	 * @param recursive
	 *            Indicates if subobjects should be unfederated as well
	 */
	public void unfederateObject(final DataClayObject dcObject,
								 final DataClayInstanceID externalDataClayID,
								 final boolean recursive) {
<span class="nc" id="L1891">		this.unfederateFromBackend(dcObject, null, recursive);</span>
<span class="nc" id="L1892">	}</span>

	/**
	 * Unfederate an object with an external backend
	 *
	 * @param dcObject
	 *            object to unfederate
	 * @param externalExecutionEnvironmentID
	 *            id of the external execution environment id
	 * @param recursive
	 *            Indicates if subobjects should be unfederated as well
	 */
	public abstract void unfederateFromBackend(final DataClayObject dcObject,
								 final ExecutionEnvironmentID externalExecutionEnvironmentID,
								 final boolean recursive);
	
	/**
	 * Unfederate an object with all external dataClays
	 * 
	 * @param dcObject
	 *            object to unfederate
	 * @param recursive
	 *            Indicates if subobjects should be federated as well
	 */
	public void unfederateObjectWithAllDCs(final DataClayObject dcObject, final boolean recursive) {
<span class="nc" id="L1917">		throw new UnsupportedOperationException();</span>

	}
	
	/**
	 * Unfederate all objects belonging/federated with external dataClay with id provided
	 * @param extDataClayID External dataClay ID
	 */
	public void unfederateAllObjects(final DataClayInstanceID extDataClayID) {
<span class="nc" id="L1926">		throw new UnsupportedOperationException();</span>
	}
	
	/**
	 * Unfederate all objects belonging/federated with ANY external dataClay 
	 */
	public void unfederateAllObjectsWithAllDCs() {
<span class="nc" id="L1933">		throw new UnsupportedOperationException();</span>

	}
	
	/**
	 * Federate all dataClay objects from specified current dataClay
	 * destination dataclay. 
	 * @param destinationDataClayID Destination dataclay id
	 */
	public void federateAllObjects(
			final DataClayInstanceID destinationDataClayID) {
<span class="nc" id="L1944">		throw new UnsupportedOperationException();</span>
	}

	/**
	 * Import classes in namespace specified from an external dataClay
	 * @param externalNamespace External namespace to get
	 * @param extDataClayID External dataClay ID
	 */
	public void importModelsFromExternalDataClay(final String externalNamespace,
															 final DataClayInstanceID extDataClayID) {
<span class="nc" id="L1954">		logicModule.importModelsFromExternalDataClay(externalNamespace, extDataClayID);</span>

<span class="nc" id="L1956">	}</span>
	
	/**
	 * Migrate (unfederate and federate) all current dataClay objects from specified external dataclay di to
	 * destination dataclay. 
	 * @param originDataClayID Origin dataclay id
	 * @param destinationDataClayID Destination dataclay id
	 */
	public void migrateFederatedObjects(final DataClayInstanceID originDataClayID, 
			final DataClayInstanceID destinationDataClayID) {
<span class="nc" id="L1966">		throw new UnsupportedOperationException();</span>
	}

	/**
	 * Set DataSet ID
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param newDataSetID
	 *            New DataSetID
	 */
	public final void setDataSetID(final ObjectID objectID, final DataSetID newDataSetID) {
<span class="nc" id="L1978">		final SessionID sessionID = checkAndGetSession(new String[] { &quot;newDataSetID&quot; }, new Object[] { newDataSetID });</span>
<span class="nc" id="L1979">		this.logicModule.setDataSetID(sessionID, objectID, newDataSetID);</span>

<span class="nc" id="L1981">	}</span>

	/**
	 * Recovers Object from OID and class ID
	 * 
	 * @param objectID
	 *            ObjectID of the object
	 * @param classID
	 *            ClassID of the object. Can be NULL. Null class ID makes dataClay to ask for object Mdata.
	 * @param hint
	 *            Hint of the object. Can be NULL if no hint.
	 * @return Instance of the object.
	 */
	public final DataClayObject getPersistedObjectByOID(final ObjectID objectID, final MetaClassID classID,
			final BackendID hint) {
<span class="nc bnc" id="L1996" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1997">			LOGGER.debug(&quot;[==GetByOID==] Getting/Creating instance from getPersistedObjectByOID.&quot;);</span>
		}
<span class="nc" id="L1999">		return getOrNewPersistentInstance(classID, objectID, hint);</span>
	}

	/**
	 * Wait for asynchronous requests to finish.
	 */
	public final void waitForAsyncRequestToFinish() {

		// Client traces
<span class="nc" id="L2008">		grpcClient.waitAndProcessAllAsyncRequests();</span>
<span class="nc" id="L2009">	}</span>

	/**
	 * Get Heap Manager
	 * 
	 * @return Heap Manager
	 */
	public abstract HeapManager getDataClayHeapManager();

	/**
	 * Remove reference from Heap. Even if we remove it from the heap, the object won't be Garbage collected by JavaGC till
	 * HeapManager flushes the object and releases it.
	 * 
	 * @param objectID
	 *            ID of the object
	 */
	public final void removeFromHeap(final ObjectID objectID) {
<span class="nc" id="L2026">		this.dataClayHeapManager.removeFromHeap(objectID);</span>
<span class="nc" id="L2027">	}</span>

	/**
	 * Add to Heap
	 * 
	 * @param dcObject
	 *            the object
	 */
	public final void addToHeap(final DataClayObject dcObject) {
<span class="nc" id="L2036">		this.dataClayHeapManager.addToHeap(dcObject);</span>
<span class="nc" id="L2037">	}</span>

	/**
	 * Check if object exists in dataClay.
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return TRUE if object exists. FALSE otherwise.
	 */
	public boolean objectExistsInDataClay(final ObjectID objectID) {
<span class="nc" id="L2047">		LOGGER.debug(&quot;Checking object {} exists&quot;, objectID);</span>
<span class="nc" id="L2048">		return this.logicModule.objectExistsInDataClay(objectID);</span>
	}

	/**
	 * Get number of objects in dataClay
	 */
	public int getNumObjects() {
<span class="nc" id="L2055">		LOGGER.debug(&quot;Getting number of objects in dataClay&quot;);</span>
<span class="nc" id="L2056">		return this.logicModule.getNumObjects();</span>
	}


	/**
	 * Get from Heap
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return The object in Heap or null if not present
	 */
	public DataClayObject getFromHeap(final ObjectID objectID) {
<span class="nc" id="L2068">		return this.dataClayHeapManager.getObject(objectID);</span>
	}

	/**
	 * Check if there is an object with ID provided.
	 * 
	 * @param objectID
	 *            ID of the object.
	 * @return TRUE if exists in memory. FALSE otherwise.
	 */
	public final boolean existsInHeap(final ObjectID objectID) {
<span class="nc" id="L2079">		return dataClayHeapManager.existsObject(objectID);</span>
	}

	/**
	 * Detach object from current session in use, i.e. remove reference from current session provided to object,
	 * &quot;dear garbage-collector, current session is not using the object anymore&quot;
	 *
	 * @param objectID ID of the object to detach
	 * @param hint Hint of the object to detach (can be null)
	 */
	public abstract void detachObjectFromSession(final ObjectID objectID, final ExecutionEnvironmentID hint);

	/**
	 * ADVANCED FUNCTION. Try not to use it. This function flushes all objects in Heap.
	 */
	public final void flushAll() {
<span class="nc" id="L2095">		this.dataClayHeapManager.flushAll();</span>
<span class="nc" id="L2096">	}</span>

	/**
	 * Get number of objects in heap.
	 * 
	 * @return Heap size.
	 */
	public final int heapSize() {
<span class="nc" id="L2104">		return this.dataClayHeapManager.heapSize();</span>
	}


	/**
	 * Get number of loaded objects in heap.
	 *
	 * @return number of loaded objects in heap.
	 */
	public final int numLoadedObjs() {
<span class="nc" id="L2114">		return this.dataClayHeapManager.numLoadedObjs();</span>
	}


	/**
	 * Activate tracing in dataClay services
	 * 
	 */
	public final void activateTracingInDataClayServices() {
<span class="nc bnc" id="L2123" title="All 2 branches missed.">		if (DataClayExtrae.extraeTracingIsEnabled()) { //sanity check, only activate if extrae was properly initialized</span>
<span class="nc" id="L2124">			this.logicModule.activateTracing(DataClayExtrae.getCurrentAvailableTaskID());</span>
		}
<span class="nc" id="L2126">	}</span>

	/**
	 * Dectivate tracing
	 */
	public final void deactivateTracingInDataClayServices() {
<span class="nc bnc" id="L2132" title="All 2 branches missed.">		if (DataClayExtrae.extraeTracingIsEnabled()) { //sanity check, only activate if extrae was properly initialized</span>
<span class="nc" id="L2133">			this.logicModule.deactivateTracing();</span>
		}
<span class="nc" id="L2135">	}</span>

	/**
	 * Activate tracing
	 */
	public final void activateTracing(
			final boolean initializeWrapper) {
<span class="nc" id="L2142">		DataClayExtrae.initializeExtrae(initializeWrapper);</span>
<span class="nc" id="L2143">	}</span>

	/**
	 * Deactivate tracing
	 */
	public final void deactivateTracing(final boolean finalizeWrapper) {
<span class="nc" id="L2149">		DataClayExtrae.finishTracing(finalizeWrapper);</span>
<span class="nc" id="L2150">	}</span>

	/**
	 * Get traces in dataClay services and store it in current workspace
	 */
	public final void getTracesInDataClayServices() {
		
<span class="nc" id="L2157">		final Map&lt;String, byte[]&gt; traces = logicModule.getTraces();</span>
		
		/*
		final Map&lt;String, Map&lt;String, byte[]&gt;&gt; filesPerHost = new HashMap&lt;&gt;();
		
		for (final Entry&lt;String, byte[]&gt; traceFile : traces.entrySet()) { 

		}*/
		
<span class="nc" id="L2166">		int curTask = 0;</span>
<span class="nc" id="L2167">		final String setPath = &quot;set-0&quot;;</span>
<span class="nc" id="L2168">		final String traceMpitsPath = &quot;TRACE.mpits&quot;;</span>
		try {
			
<span class="nc" id="L2171">			FileUtils.forceMkdir(new File(setPath));</span>
<span class="nc" id="L2172">			File traceMpitsFile = new File(traceMpitsPath);</span>

<span class="nc bnc" id="L2174" title="All 2 branches missed.">			for (final Entry&lt;String, byte[]&gt; traceFile : traces.entrySet()) { </span>

<span class="nc" id="L2176">				final String fileName = traceFile.getKey();</span>
<span class="nc" id="L2177">				final byte[] fileBytes = traceFile.getValue();</span>

<span class="nc" id="L2179">					File tmpTraceFile = new File(setPath + File.separator + fileName);</span>
<span class="nc" id="L2180">					final String path = tmpTraceFile.getAbsolutePath();</span>
<span class="nc" id="L2181">					LOGGER.info(&quot;Storing file &quot; + path);</span>
					
					// Store Extrae temporary files
<span class="nc" id="L2184">					FileUtils.writeByteArrayToFile(tmpTraceFile, fileBytes);</span>
					
<span class="nc bnc" id="L2186" title="All 2 branches missed.">					if (fileName.endsWith(&quot;.mpit&quot;)) {</span>
<span class="nc" id="L2187">						final String newFilePointer = path + &quot; named\n&quot;;</span>
<span class="nc" id="L2188">						LOGGER.info(&quot;Adding line to &quot; + traceMpitsFile.getAbsolutePath() + &quot; file: &quot; + newFilePointer);</span>
<span class="nc" id="L2189">						FileUtils.writeStringToFile(traceMpitsFile, newFilePointer,Charset.defaultCharset(), true);</span>
					}
<span class="nc" id="L2191">					curTask++;	</span>
<span class="nc" id="L2192">			}</span>
			
			// cat trace.mpits
<span class="nc" id="L2195">			Scanner input = new Scanner(traceMpitsFile);</span>

<span class="nc bnc" id="L2197" title="All 2 branches missed.">			while (input.hasNextLine())</span>
			{
<span class="nc" id="L2199">				LOGGER.info(input.nextLine());</span>
			}
<span class="nc" id="L2201">			input.close();</span>
			
<span class="nc" id="L2203">		} catch (final Exception e) {</span>
<span class="nc" id="L2204">			e.printStackTrace();</span>
<span class="nc" id="L2205">		}</span>
		
		
		
		
<span class="nc" id="L2210">	}</span>

	/**
	 * @return GRPC client.
	 */
	public final CommonGrpcClient getCommonGrpcClient() {
<span class="nc" id="L2216">		return this.grpcClient;</span>
	}

	/**
	 * Get DataClay object loader.
	 * 
	 * @return Object loader.
	 */
	protected abstract DataClayObjectLoader getDataClayObjectLoader();

	/**
	 * Lock object
	 * 
	 * @param objectID
	 *            ID of object
	 */
	public final void lock(final ObjectID objectID) {
<span class="nc" id="L2233">		this.lockerPool.lock(objectID);</span>
<span class="nc" id="L2234">	}</span>

	/**
	 * Unlock object
	 * 
	 * @param objectID
	 *            ID of object
	 */
	public final void unlock(final ObjectID objectID) {
<span class="nc" id="L2243">		this.lockerPool.unlock(objectID);</span>
<span class="nc" id="L2244">	}</span>

	/**
	 * Clean lockers
	 */
	public final void cleanLockers() {
<span class="nc" id="L2250">		this.lockerPool.cleanLockers();</span>
<span class="nc" id="L2251">	}</span>

	/**
	 * Get number of lockers
	 * 
	 * @return Number of lockers
	 */
	public final int numLockers() {
<span class="nc" id="L2259">		return this.lockerPool.numLockers();</span>
	}

	/**
	 * @return TRUE if library is for DataClay, FALSE for clients.
	 */
	public abstract boolean isDSLib();

	/**
	 * @return the 'LOCAL' location if defined
	 */
	public abstract BackendID getLocalBackend();

	/**
	 * ONLY for EE. Add +1 reference associated to thread session
	 * 
	 * @param objectID
	 *            ID of the object
	 */
	public void addSessionReference(final ObjectID objectID) {
		// do nothing: TODO: specialize it in a better way
<span class="nc" id="L2280">	}</span>

	/**
	 * Indicates if runtime was initialized or not
	 * 
	 * @return TRUE if runtime is initialized. FALSE otherwise.
	 */
	public boolean isInitialized() {
<span class="nc" id="L2288">		return initialized;</span>
	}

	/**
	 * Set initialized flag
	 * 
	 * @param theinitialized
	 *            Value to set
	 */
	public void setInitialized(final boolean theinitialized) {
<span class="nc" id="L2298">		this.initialized = theinitialized;</span>
<span class="nc" id="L2299">	}</span>

	public static ObjectID getObjectIDFromAlias(String alias) {
<span class="nc" id="L2302">		return new ObjectID(UUID.nameUUIDFromBytes(alias.getBytes()));</span>
	}

	protected ExecutionEnvironmentID getBackendIDFromAlias(String alias) {
<span class="nc" id="L2306">		return this.getBackendIDFromObjectID(getObjectIDFromAlias(alias));</span>
	}

	/**
	 * Choose execution/make persistent location.
	 *
	 * @param dcObject
	 *            DataClay object.
	 * @return Chosen location.
	 */
	protected BackendID chooseLocation(final DataClayObject dcObject, final String alias) {
<span class="nc bnc" id="L2317" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2318">			LOGGER.debug(&quot;[==Execution==] Using Hash execution location for &quot; + dcObject.getObjectID());</span>
		}

		final BackendID location;

<span class="nc bnc" id="L2323" title="All 2 branches missed.">		if(alias != null) {</span>
<span class="nc" id="L2324">			location = getBackendIDFromAlias(alias);</span>
		}else {
<span class="nc" id="L2326">			location = getBackendIDFromObjectID(dcObject.getObjectID());</span>
		}

<span class="nc" id="L2329">		dcObject.setHint(location);</span>
<span class="nc" id="L2330">		return location;</span>
	}

	/**
	 * Update the object id in both DataClayObject and HeapManager
	 *
	 * @param dcObject
	 *            DataClay object.
	 * @param newObjectID
	 *            the new object id.
	 */
	protected void updateObjectID(DataClayObject dcObject, ObjectID newObjectID) {
<span class="nc" id="L2342">		final ObjectID oldObjectID = dcObject.getObjectID();</span>
<span class="nc" id="L2343">		dcObject.setObjectIDUnsafe(newObjectID);</span>
<span class="nc" id="L2344">		dataClayHeapManager.removeFromHeap(oldObjectID);</span>
<span class="nc" id="L2345">		dataClayHeapManager.addToHeap(dcObject);;</span>
<span class="nc" id="L2346">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>