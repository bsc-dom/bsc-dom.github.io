<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataServiceRuntime.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.commonruntime</a> &gt; <span class="el_source">DataServiceRuntime.java</span></div><h1>DataServiceRuntime.java</h1><pre class="source lang-java linenums">package es.bsc.dataclay.commonruntime;

import java.util.Calendar;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import es.bsc.dataclay.DataClayExecutionObject;
import es.bsc.dataclay.DataClayObject;
import es.bsc.dataclay.api.BackendID;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.dataservice.DataService;
import es.bsc.dataclay.exceptions.dataservice.ExecuteMethodException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.heap.ExecutionEnvironmentHeapManager;
import es.bsc.dataclay.heap.HeapManager;
import es.bsc.dataclay.loader.DataClayObjectLoader;
import es.bsc.dataclay.loader.ExecutionObjectLoader;
import es.bsc.dataclay.serialization.lib.ObjectWithDataParamOrReturn;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.classloaders.DataClayClassLoaderSrv;
import es.bsc.dataclay.util.ids.DataSetID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.SessionID;
import es.bsc.dataclay.util.management.metadataservice.RegistrationInfo;
import es.bsc.dataclay.util.reflection.Reflector;
import es.bsc.dataclay.util.structs.LruCache;
import es.bsc.dataclay.util.structs.LruCacheByDate;
import es.bsc.dataclay.util.structs.Tuple;

/**
 * This class contains functions for node to interact with other nodes.
 */
public final class DataServiceRuntime extends DataClayRuntime {
	/** Logger. */
<span class="nc" id="L49">	private static final Logger LOGGER = LogManager.getLogger(&quot;DataServiceRuntime&quot;);</span>

	/** Ref to DS if this lib serves to a DS. */
	public DataService dsRef;

	/** Information of session per thread. */
<span class="nc" id="L55">	private final ThreadLocal&lt;SessionID&gt; dsSessionIDs = new ThreadLocal&lt;&gt;();</span>

	/** Cache of sessions. */
	private final LruCacheByDate&lt;SessionID, Tuple&lt;Tuple&lt;DataSetID, Set&lt;DataSetID&gt;&gt;, Calendar&gt;&gt; sessionsCache;

	/** Cache of datasets. */
	private final LruCache&lt;DataSetID, Boolean&gt; datasetsCache;

	/**
	 * References hold by sessions. Resource note: Maximum size of this map is maximum number of objects allowed in EE x
	 * sessions. TODO: think about compressing it.
	 */
<span class="nc" id="L67">	private final Map&lt;ObjectID, Set&lt;SessionID&gt;&gt; referencesHoldBySessions = new ConcurrentHashMap&lt;&gt;();</span>

	/**
	 * Per each session, it's expiration date. This is used to control 'retained' objects from sessions in Garbage collection.
	 */
<span class="nc" id="L72">	private final Map&lt;SessionID, Date&gt; sessionsExpireDates = new ConcurrentHashMap&lt;&gt;();</span>

	/**
	 * Sessions in quarantine. note: maximum size of this map is max number of sessions per EE: This map is needed to solve a
	 * race condition in Global Garbage collection (@see getReferenceCounting).
	 */
<span class="nc" id="L78">	private final Set&lt;SessionID&gt; quarantineSessions = new HashSet&lt;&gt;();</span>

	/**
	 * Indicates if tasks (garbage collectors,...) were scheduled or not. This is done to manage. multiple initializations.
	 */
<span class="nc" id="L83">	public boolean tasksScheduled = false;</span>

	/**
	 * Constructor.
	 * 
	 * @param newdsRef
	 *            DS reference
	 */
<span class="nc" id="L91">	public DataServiceRuntime(final DataService newdsRef) {</span>
<span class="nc" id="L92">		this.dsRef = newdsRef;</span>

<span class="nc" id="L94">		this.dataClayObjLoader = new ExecutionObjectLoader(this);</span>
<span class="nc" id="L95">		this.dataClayHeapManager = new ExecutionEnvironmentHeapManager(this);</span>
<span class="nc" id="L96">		this.sessionsCache = new LruCacheByDate&lt;&gt;(Configuration.Flags.MAX_ENTRIES_DATASERVICE_CACHE.getIntValue());</span>
<span class="nc" id="L97">		this.datasetsCache = new LruCache&lt;&gt;(Configuration.Flags.MAX_ENTRIES_DATASERVICE_CACHE.getIntValue());</span>

<span class="nc" id="L99">		this.threadPool = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {</span>
			@Override
			public Thread newThread(final Runnable r) {
<span class="nc" id="L102">				final Thread t = Executors.defaultThreadFactory().newThread(r);</span>
<span class="nc" id="L103">				t.setDaemon(true);</span>
<span class="nc" id="L104">				t.setName(getDataService().dsName + &quot;-MemoryGC&quot;);</span>
<span class="nc" id="L105">				return t;</span>
			}
		});
<span class="nc" id="L108">	}</span>

	/**
	 * Initialize connections.
	 * 
	 * @param logicModuleHost
	 *            Name of the host of the logic module
	 * @param logicModulePort
	 *            Port of the logic module
	 * @param originHostName
	 *            Name of the host using the lib.
	 * @throws Exception
	 *             if connection could not be done for some reason.
	 */
	@Override
	public void initialize(final String logicModuleHost, final int logicModulePort, final String originHostName)
			throws Exception {
<span class="nc" id="L125">		super.initialize(logicModuleHost, logicModulePort, originHostName);</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">		if (Configuration.Flags.MEMORY_GC_ENABLED.getBooleanValue() &amp;&amp; !tasksScheduled) {</span>
			// Create Repetitively task
<span class="nc" id="L128">			this.threadPool.scheduleAtFixedRate(dataClayHeapManager, 0,</span>
<span class="nc" id="L129">					Configuration.Flags.MEMMGMT_CHECK_TIME_INTERVAL.getLongValue(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L130">			tasksScheduled = true;</span>
		}
<span class="nc" id="L132">	}</span>
	
	@Override
	public DataClayExecutionObject getOrNewPersistentInstance(final MetaClassID classID, final ObjectID objectID,
			final BackendID hint) {
<span class="nc" id="L137">		return (DataClayExecutionObject) this.dataClayObjLoader.getOrNewPersistentInstance(classID, objectID, hint);</span>
	}

	/**
	 * Get object from memory or database and WAIT in case we are still waiting for it to be persisted.
	 * 
	 * @param objectID
	 *            ID of the object to get
	 * @param retry
	 *            Indicates if we should retry and wait.
	 * @return The the object.
	 */
	public DataClayExecutionObject getOrNewInstanceFromDB(final ObjectID objectID, final boolean retry) {
<span class="nc" id="L150">		return ((ExecutionObjectLoader) dataClayObjLoader).getOrNewPersistentInstanceFromDB(objectID, retry);</span>
	}

	/**
	 * Get from Heap or create a new volatile in EE and load data on it.
	 * 
	 * @param classID
	 *            ID of class of the object
	 * @param objectID
	 *            ID of the object
	 * @param hint
	 *            Hint of the object
	 * @param objWithData
	 *            Data of the object
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 * @return Loaded volatile instance in EE.
	 */
	@Override
	public DataClayObject getOrNewAndLoadVolatile(final MetaClassID classID, final ObjectID objectID,
			final BackendID hint, final ObjectWithDataParamOrReturn objWithData,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps) {
<span class="nc" id="L172">		return dataClayObjLoader.getOrNewAndLoadVolatile(classID, objectID, hint, objWithData, ifaceBitMaps);</span>
	}

	/**
	 * Deserialize data into instance.
	 * 
	 * @param instance
	 *            Instance to be filled.
	 * @param data
	 *            Data
	 * @param ifaceBitMaps
	 *            Interface bitmaps
	 */
	public void deserializeDataIntoInstance(final DataClayExecutionObject instance,
			final ObjectWithDataParamOrReturn data, final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps) {
<span class="nc" id="L187">		dataClayObjLoader.deserializeDataIntoInstance(instance, data, ifaceBitMaps);</span>
<span class="nc" id="L188">	}</span>

	@Override
	public SessionID getSessionID() {
<span class="nc" id="L192">		return dsSessionIDs.get();</span>
	}

	/**
	 * Checks session is valid.
	 * 
	 * @param dataSetID
	 *            dataSetID to be accessed
	 * @param sessionID
	 *            id of the session
	 */
	public void checkSession(final DataSetID dataSetID, final SessionID sessionID) {
<span class="nc" id="L204">		Boolean isPublic = datasetsCache.get(dataSetID);</span>
		// TODO: Redudant check if at newSession time is already checking this (July
		// 2018 jmarti)
<span class="nc bnc" id="L207" title="All 2 branches missed.">		if (isPublic == null) {</span>
<span class="nc" id="L208">			isPublic = getLogicModuleAPI().checkDataSetIsPublic(dataSetID);</span>
<span class="nc" id="L209">			datasetsCache.put(dataSetID, isPublic);</span>
		}
<span class="nc bnc" id="L211" title="All 2 branches missed.">		if (isPublic) {</span>
<span class="nc" id="L212">			return;</span>
		}
<span class="nc" id="L214">		final Tuple&lt;Tuple&lt;DataSetID, Set&lt;DataSetID&gt;&gt;, Calendar&gt; sessionInfo = getSessionInfo(sessionID);</span>
<span class="nc" id="L215">		final Set&lt;DataSetID&gt; accessibleDatasets = sessionInfo.getFirst().getSecond();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">		if (!accessibleDatasets.contains(dataSetID)) {</span>
<span class="nc" id="L217">			throw new ExecuteMethodException(&quot;Inaccessible dataset &quot; + dataSetID);</span>
		}
<span class="nc" id="L219">	}</span>

	/**
	 * Get session info
	 * 
	 * @param sessionID
	 *            ID of session
	 * @return Session info.
	 */
	private Tuple&lt;Tuple&lt;DataSetID, Set&lt;DataSetID&gt;&gt;, Calendar&gt; getSessionInfo(final SessionID sessionID) {
<span class="nc" id="L229">		Tuple&lt;Tuple&lt;DataSetID, Set&lt;DataSetID&gt;&gt;, Calendar&gt; sessionInfo = sessionsCache.get(sessionID);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">		if (sessionInfo == null) {</span>
<span class="nc" id="L231">			sessionInfo = getLogicModuleAPI().getInfoOfSessionForDS(sessionID);</span>
<span class="nc" id="L232">			sessionsCache.put(sessionID, sessionInfo);</span>
		}
<span class="nc" id="L234">		return sessionInfo;</span>
	}

	/**
	 * Set instance to be weak proxy.
	 * 
	 * @param instance
	 *            Instance to modify.
	 * @param newHint
	 *            Hint to set into instance.
	 */
	public void setWeakProxy(final DataClayExecutionObject instance, final ExecutionEnvironmentID newHint) {
<span class="nc" id="L246">		lock(instance.getObjectID());</span>
		try {
<span class="nc" id="L248">			instance.setLoaded(false);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L250">				LOGGER.debug(&quot;[==Hint==] Setting hint (setWeakProxy) on instance &quot; + instance.getObjectID()</span>
<span class="nc" id="L251">						+ &quot; the hint : &quot; + getDSNameOfHint(newHint));</span>
			}
<span class="nc" id="L253">			instance.setHint(newHint);</span>
<span class="nc" id="L254">			Reflector.nullifyAllFields(instance);</span>
		} finally {
<span class="nc" id="L256">			unlock(instance.getObjectID());</span>
		}
<span class="nc" id="L258">	}</span>

	/**
	 * All volatiles provided are under deserialization. This function solves problems of 'hashcode' and other special functions
	 * needed during deserializations. See executeImpl.
	 * 
	 * @param volatileMap
	 *            Volatiles under deserialization.
	 */
	@Override
	public void addVolatileUnderDeserialization(final Map&lt;Integer, ObjectWithDataParamOrReturn&gt; volatileMap) {
<span class="nc" id="L269">		underDeserializationVolatiles.put(Thread.currentThread().getId(), volatileMap);</span>
<span class="nc" id="L270">	}</span>

	/**
	 * Remove volatiles under deserialization.
	 */
	@Override
	public void removeVolatilesUnderDeserialization() {
<span class="nc" id="L277">		underDeserializationVolatiles.remove(Thread.currentThread().getId());</span>
<span class="nc" id="L278">	}</span>

	/**
	 * Check if there is a volatile object with ID provided and if so, deserialize it since it is needed.
	 * 
	 * @param volatileObj
	 *            Object to check.
	 * @param ifaceBitMaps
	 *            Interface bitmaps for deserialization.
	 * @return TRUE if it was filled and volatile, FALSE otherwise.
	 */
	private boolean checkAndFillVolatileUnderDeserialization(final DataClayExecutionObject volatileObj,
			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps) {
<span class="nc" id="L291">		final ObjectID objectID = volatileObj.getObjectID();</span>
<span class="nc" id="L292">		final Map&lt;Integer, ObjectWithDataParamOrReturn&gt; volatileMap = underDeserializationVolatiles</span>
<span class="nc" id="L293">				.get(Thread.currentThread().getId());</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">		if (volatileMap != null) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">			for (final ObjectWithDataParamOrReturn volatileParamOrRet : volatileMap.values()) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">				if (volatileParamOrRet.getObjectID().equals(objectID)) {</span>
					// Deserialize it
<span class="nc" id="L298">					getOrNewAndLoadVolatile(volatileObj.getMetaClassID(), objectID, volatileObj.getHint(),</span>
							volatileParamOrRet, ifaceBitMaps);
<span class="nc" id="L300">					return true;</span>
				}
<span class="nc" id="L302">			}</span>
		}
<span class="nc" id="L304">		return false;</span>
	}

	@Override
	protected Object executeRemoteImplementationInternal(final DataClayObject object, final ImplementationID implID,
			final Object[] params) {

<span class="nc bnc" id="L311" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L312">			LOGGER.debug(&quot;[==Execution==] Object &quot; + object.getObjectID()</span>
<span class="nc" id="L313">					+ &quot; was unloaded. Checking reason. System.id = &quot; + System.identityHashCode(object));</span>
		}

<span class="nc" id="L316">		final DataClayExecutionObject objectInWhichToExec = (DataClayExecutionObject) object;</span>

		// ============================== PARAMS/RETURNS ========================== //
		// Check if object is being deserialized (params/returns)
<span class="nc" id="L320">		boolean volatileUnderDeserialization = false;</span>
<span class="nc" id="L321">		volatileUnderDeserialization = checkAndFillVolatileUnderDeserialization(objectInWhichToExec, null);</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">		if (volatileUnderDeserialization) {</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L325">				LOGGER.debug(&quot;[==Execution==] Object &quot; + objectInWhichToExec.getObjectID()</span>
						+ &quot; is a volatile under deserialization, executing in &quot; + &quot;System.id = &quot;
<span class="nc" id="L327">						+ System.identityHashCode(objectInWhichToExec));</span>
			}
<span class="nc" id="L329">			return this.dsRef.runImplementation(objectInWhichToExec, implID, params);</span>
		}

<span class="nc" id="L332">		ExecutionEnvironmentID remoteLocID = null;</span>
<span class="nc" id="L333">		boolean usingHint = false;</span>
<span class="nc" id="L334">		boolean inThisLocation = false;</span>
<span class="nc" id="L335">		final ObjectID objectID = objectInWhichToExec.getObjectID();</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">		if (objectInWhichToExec.getHint() != null) {</span>
			// ==================================== HINT ===================================
			// //
<span class="nc" id="L340">			final ExecutionEnvironmentID hint = (ExecutionEnvironmentID) objectInWhichToExec.getHint();</span>
<span class="nc" id="L341">			inThisLocation = hint.equals(this.dsRef.getExecutionEnvironmentID());</span>
<span class="nc" id="L342">			remoteLocID = hint;</span>
<span class="nc" id="L343">			usingHint = true;</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">				if (inThisLocation) {</span>
<span class="nc" id="L346">					LOGGER.debug(&quot;[==Execution==] Object &quot; + objectInWhichToExec.getObjectID()</span>
							+ &quot; has a Hint, pointing to this node. System.id = &quot;
<span class="nc" id="L348">							+ System.identityHashCode(objectInWhichToExec));</span>
				} else {
<span class="nc" id="L350">					LOGGER.debug(&quot;[==Execution==] Object &quot; + objectInWhichToExec.getObjectID()</span>
							+ &quot; has a Hint, pointing to another node &quot; + &quot;(&quot; + remoteLocID + &quot;). System.id = &quot;
<span class="nc" id="L352">							+ System.identityHashCode(objectInWhichToExec));</span>
				}
			}
<span class="nc" id="L355">		} else {</span>
			// Get
<span class="nc" id="L357">			remoteLocID = (ExecutionEnvironmentID) getLocation(objectID);</span>
			// remoteLocID = getExecutionEnvironmentLocation(objectID);
<span class="nc" id="L359">			inThisLocation = remoteLocID.equals(this.dsRef.getExecutionEnvironmentID());</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L361">				LOGGER.debug(&quot;[==Execution==] Object &quot; + objectInWhichToExec.getObjectID()</span>
						+ &quot; is not a proxy and has no hint. Obtained actual location = &quot; + remoteLocID + &quot; System.id = &quot;
<span class="nc" id="L363">						+ System.identityHashCode(objectInWhichToExec));</span>
			}
		}

		// ==================================== THIS LOCATION
		// =================================== //
<span class="nc bnc" id="L369" title="All 2 branches missed.">		if (inThisLocation) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L371">				LOGGER.debug(&quot;[==Execution==] Object &quot; + objectInWhichToExec.getObjectID()</span>
						+ &quot; is in this node. Loading it from Db. System.id = &quot;
<span class="nc" id="L373">						+ System.identityHashCode(objectInWhichToExec));</span>
			}
			try {
<span class="nc" id="L376">				((ExecutionObjectLoader) this.dataClayObjLoader).loadDataClayObjectFromDb(objectInWhichToExec, true);</span>
<span class="nc" id="L377">				return this.dsRef.runImplementation(objectInWhichToExec, implID, params);</span>
<span class="nc" id="L378">			} catch (final DbObjectNotExistException dbe) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L380">					LOGGER.debug(&quot;[==Execution==] Object &quot; + objectInWhichToExec.getObjectID()</span>
							+ &quot; is NOT in this node. Maybe hint or metadata information was wrong due to a movement. &quot;
							+ &quot; Obtaining exec.location again. &quot; + &quot; System.id = &quot;
<span class="nc" id="L383">							+ System.identityHashCode(objectInWhichToExec));</span>
				}
				// not actually here (maybe hint was wrong)
				// remoteLocID = getExecutionEnvironmentLocation(objectID);
<span class="nc" id="L387">				remoteLocID = (ExecutionEnvironmentID) getLocation(objectID);</span>
			}

		}

<span class="nc bnc" id="L392" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L393">			final String methodSignature = objectInWhichToExec.getStubInfo().getImplementationByID(implID.toString())</span>
<span class="nc" id="L394">					.getSignature();</span>
<span class="nc" id="L395">			LOGGER.debug(&quot;[==JUMP==] Object &quot; + objectInWhichToExec.getObjectID() + &quot; of class &quot;</span>
<span class="nc" id="L396">					+ objectInWhichToExec.getClass().getName()</span>
					+ &quot; is NOT in this node. Going to do a remote call. Method to call: &quot; + methodSignature
<span class="nc" id="L398">					+ &quot;. System.id = &quot; + System.identityHashCode(objectInWhichToExec));</span>
		}
		// ==================================== REMOTE LOCATION
		// =================================== //
<span class="nc" id="L402">		return callExecuteToDS(objectInWhichToExec, params, implID, remoteLocID, usingHint);</span>

	}

	@Override
	public BackendID makePersistent(final DataClayObject dcObject, final BackendID optionalDestBackendID,
			final boolean recursive, final String alias) {
<span class="nc bnc" id="L409" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L410">			LOGGER.debug(&quot;[==MakePersistent==] Starting make persistent of object &quot; + dcObject.getObjectID());</span>
		}
<span class="nc" id="L412">		final SessionID sessionID = checkAndGetSession(new String[] {}, new Object[] {});</span>
<span class="nc" id="L413">		final DataClayExecutionObject execObject = (DataClayExecutionObject) dcObject;</span>

<span class="nc" id="L415">		BackendID location = execObject.getHint();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">		if (location == null) {</span>
<span class="nc" id="L417">			location = optionalDestBackendID;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">			if (location == null) {</span>
<span class="nc" id="L419">				location = chooseLocation(dcObject, alias);</span>
			}
		}

<span class="nc bnc" id="L423" title="All 4 branches missed.">		if (alias != null &amp;&amp; execObject.isPendingToRegister()) {</span>
<span class="nc" id="L424">			final RegistrationInfo regInfo = new RegistrationInfo(execObject.getObjectID(),</span>
<span class="nc" id="L425">					execObject.getMetaClassID(), sessionID, execObject.getDataSetID());</span>
			// Location of object is 'this' EE.
			// TODO: Review if we use hint of the object or the hint of the runtime.
<span class="nc" id="L428">			final ObjectID newID = logicModule.registerObject(regInfo, (ExecutionEnvironmentID) dcObject.getHint(), alias,</span>
					Langs.LANG_JAVA);
<span class="nc" id="L430">			this.updateObjectID(dcObject, newID);</span>
<span class="nc" id="L431">			execObject.setPendingToRegister(false);</span>
		}

<span class="nc" id="L434">		return location;</span>
	}

	@Override
	public String getClassNameInternal(final MetaClassID classID) {
<span class="nc" id="L439">		return DataClayClassLoaderSrv.getClass(classID).getName();</span>
	}

	/**
	 * Set session ID for thread
	 * 
	 * @param threadID
	 *            ID of the thread
	 * @param sessionID
	 *            ID of session
	 */
	public void setCurrentThreadSessionID(final SessionID sessionID) {
<span class="nc bnc" id="L451" title="All 2 branches missed.">		if (sessionID != null) {</span>
<span class="nc" id="L452">			dsSessionIDs.set(sessionID);</span>
		}
<span class="nc" id="L454">	}</span>

	/**
	 * Remove session ID for thread
	 * 
	 * @param threadID
	 *            ID of thread
	 */
	public void removeCurrentThreadSessionID() {
<span class="nc" id="L463">		dsSessionIDs.remove();</span>
<span class="nc" id="L464">	}</span>

	// /**
	// * Get ID of storage of this node.
	// *
	// * @return storage location id
	// */
	// public StorageLocationID getStorageLocationIDOfDS() {
	// return dsRef.getStorageLocationID();
	// }

	/**
	 * Get ID of execution environment of this node.
	 * 
	 * @return execution environment id
	 */
	public ExecutionEnvironmentID getExecutionEnvironmentIDOfDS() {
<span class="nc" id="L481">		return dsRef.getExecutionEnvironmentID();</span>
	}

	/**
	 * Directly store objects in DS.
	 * 
	 * @param sessionID
	 *            ID of session
	 * @param objsToStore
	 *            serialized objects to store.
	 */
	public void storeObjects(final SessionID sessionID, final List&lt;ObjectWithDataParamOrReturn&gt; objsToStore) {

<span class="nc bnc" id="L494" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">			for (final ObjectWithDataParamOrReturn obj : objsToStore) {</span>
<span class="nc" id="L496">				LOGGER.debug(&quot;#Sending from client lib: &quot; + obj.getObjectID());</span>
<span class="nc" id="L497">			}</span>
		}
<span class="nc" id="L499">		dsRef.storeObjects(sessionID, objsToStore, false, null);</span>
<span class="nc" id="L500">	}</span>

	/**
	 * Get Heap Manager
	 * 
	 * @return Heap Manager
	 */
	@Override
	public HeapManager getDataClayHeapManager() {
<span class="nc" id="L509">		return this.dataClayHeapManager;</span>
	}

	/**
	 * Add a new Hard reference to the object provided. All code in stubs/exec classes using objects in dataClayheap are using
	 * weak references. In order to avoid objects to be GC without a flush in DB, HeapManager has hard-references to them and is
	 * the only one able to release them. This function creates the hard-reference.
	 * 
	 * @param object
	 *            Object to add
	 */
	public void retainInHeap(final DataClayObject object) {
<span class="nc" id="L521">		((ExecutionEnvironmentHeapManager) this.dataClayHeapManager).retainInHeap(object);</span>
<span class="nc" id="L522">	}</span>

	/**
	 * Release hard reference to object with ID provided. Without hard reference, the object can be Garbage collected by Java
	 * GC.
	 * 
	 * @param objectID
	 *            ID of the object
	 */
	public void releaseFromHeap(final ObjectID objectID) {
<span class="nc" id="L532">		((ExecutionEnvironmentHeapManager) this.dataClayHeapManager).releaseFromHeap(objectID);</span>
<span class="nc" id="L533">	}</span>

	@Override
	public boolean isDSLib() {
<span class="nc" id="L537">		return true;</span>
	}

	@Override
	public ExecutionEnvironmentID getLocalBackend() {
<span class="nc" id="L542">		return null;</span>
	}

	/**
	 * Get DataService reference
	 * 
	 * @return DataService reference
	 */
	public DataService getDataService() {
<span class="nc" id="L551">		return dsRef;</span>
	}

	@Override
	public ExecutionEnvironmentID getHint() {
<span class="nc" id="L556">		return dsRef.getExecutionEnvironmentID();</span>
	}

	@Override
	protected Map&lt;MetaClassID, byte[]&gt; getIfaceBitMaps() {
<span class="nc" id="L561">		return null;</span>
	}

	/**
	 * Add +1 reference due to a new alias.
	 * 
	 * @param objectID
	 *            ID of the object
	 */
	public void addAliasReference(final ObjectID objectID) {
<span class="nc bnc" id="L571" title="All 2 branches missed.">		if (Configuration.Flags.GLOBAL_GC_ENABLED.getBooleanValue()) {</span>
<span class="nc" id="L572">			this.aliasReferences.add(objectID);</span>
		}
<span class="nc" id="L574">	}</span>

	/**
	 * Add +1 reference associated to thread session
	 * 
	 * @param objectID
	 *            ID of the object
	 */
	@Override
	public void addSessionReference(final ObjectID objectID) {
<span class="nc bnc" id="L584" title="All 2 branches missed.">		if (Configuration.Flags.GLOBAL_GC_ENABLED.getBooleanValue()) {</span>
<span class="nc" id="L585">			final SessionID sessionID = this.getSessionID();</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">			if (sessionID == null) {</span>
<span class="nc" id="L587">				return; // session ID can be null in case of whenFederated</span>
			}
<span class="nc bnc" id="L589" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L590">				LOGGER.debug(&quot;Object &quot; + objectID + &quot; is now being used by session &quot; + sessionID);</span>
			}

<span class="nc" id="L593">			Set&lt;SessionID&gt; referencesInSession = this.referencesHoldBySessions.get(objectID);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">			if (referencesInSession == null) {</span>
				// race condition: two objects in same session creates set of object ids
<span class="nc" id="L596">				this.lock(objectID);</span>
				try {
<span class="nc" id="L598">					referencesInSession = this.referencesHoldBySessions.get(objectID);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">					if (referencesInSession == null) {</span>
<span class="nc" id="L600">						referencesInSession = new HashSet&lt;&gt;();</span>
<span class="nc" id="L601">						this.referencesHoldBySessions.put(objectID, referencesInSession);</span>
					}
				} finally {
<span class="nc" id="L604">					this.unlock(objectID);</span>
				}
			}
<span class="nc" id="L607">			referencesInSession.add(sessionID);</span>

			// add expiration date of session if not present
			// IMPORTANT: if CHECK_SESSION=FALSE then we use a default expiration date for
			// all sessions
			// In this case, sessions must be explicitly closed otherwise GC is never going
			// to clean unused objects from
			// sessions.
			// Concurrency note: adding two times same expiration date is not a problem
			// since exp. date is the same. We avoid
			// locking.
<span class="nc bnc" id="L618" title="All 2 branches missed.">			if (!sessionsExpireDates.containsKey(sessionID)) {</span>
				final Date expirationDate;
<span class="nc bnc" id="L620" title="All 2 branches missed.">				if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L621">					final Calendar endDate = this.getSessionInfo(sessionID).getSecond();</span>
<span class="nc" id="L622">					expirationDate = endDate.getTime();</span>
<span class="nc" id="L623">				} else {</span>
<span class="nc" id="L624">					expirationDate = Configuration.Flags.EXPIRATION_DATE_IF_NOCHECK_SESSION.getDate();</span>
				}
				// === concurrency note === //
				// T1 is here, before put. This is a session that was already used and was
				// restarted.
				// T2 is in @getReferenceCounting and wants to remove session since it expired.
				// What if T2 removes it after the put?
				// Synchronization is needed to avoid this. It is not a big penalty if session
				// expiration date was already
				// added.
<span class="nc" id="L634">				synchronized (sessionID) {</span>
<span class="nc" id="L635">					sessionsExpireDates.put(sessionID, expirationDate);</span>
<span class="nc" id="L636">				}</span>
			}
		}
<span class="nc" id="L639">	}</span>

	/**
	 * Close session in EE. Subtract session references for GC.
	 * 
	 * @param sessionID
	 *            ID of session closing.
	 */
	public void closeSessionInEE(final SessionID sessionID) {
<span class="nc bnc" id="L648" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L649">			LOGGER.debug(&quot;Closing session &quot; + sessionID);</span>
		}

		// Closing session means set expiration date to now
<span class="nc" id="L653">		sessionsExpireDates.put(sessionID, new Date()); // new date means current date</span>

<span class="nc" id="L655">	}</span>

	/**
	 * Get IDs of references retained by EE.
	 * 
	 * @return References retained by EE (sessions, alias...)
	 */
	public Set&lt;ObjectID&gt; getRetainedReferences() {

<span class="nc bnc" id="L664" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L665">			LOGGER.debug(&quot;Get retained references&quot;);</span>
		}

<span class="nc" id="L668">		final ExecutionEnvironmentHeapManager heapManger = (ExecutionEnvironmentHeapManager) this.dataClayHeapManager;</span>

<span class="nc" id="L670">		final Set&lt;ObjectID&gt; retainedRefs = new HashSet&lt;&gt;();</span>

		// memory references
<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L674">			LOGGER.debug(&quot;Adding memory references: &quot; + heapManger.getObjectIDsRetained());</span>
		}
<span class="nc" id="L676">		retainedRefs.addAll(heapManger.getObjectIDsRetained());</span>

<span class="nc bnc" id="L678" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L679">			LOGGER.debug(&quot;Checking references hold by sessions: &quot; + this.referencesHoldBySessions.size());</span>
		}
		// session references
<span class="nc" id="L682">		final Date now = new Date();</span>
<span class="nc" id="L683">		final Set&lt;ObjectID&gt; oidsUsingSession = new HashSet&lt;&gt;(this.referencesHoldBySessions.keySet()); // create a copy</span>
<span class="nc" id="L684">		oidsUsingSession.removeAll(retainedRefs); // ignore references already retained</span>
<span class="nc" id="L685">		final Set&lt;SessionID&gt; sessionsToClose = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">		for (final ObjectID oid : oidsUsingSession) {</span>
<span class="nc" id="L687">			final Set&lt;SessionID&gt; sessionsOfObj = this.referencesHoldBySessions.get(oid);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L689">				LOGGER.debug(&quot;Object {} is retained by sessions: {}&quot;, oid, sessionsOfObj);</span>
			}
<span class="nc" id="L691">			final Iterator&lt;SessionID&gt; iterator = sessionsOfObj.iterator(); // use iterator to remove while iterating</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">			while (iterator.hasNext()) {</span>
<span class="nc" id="L693">				final SessionID curSession = iterator.next();</span>

				// ===== CHECK SESSION EXPIRED ===== //
				// ==== session counting design - Race condition ==== //
				// Race condition: object is send between two nodes and they are both notifying
				// 0 references. This is not
				// solved using quarantine in SL since during quarantine period they could do
				// the same and always send 0: while
				// one is
				// notifying 0, the other keeps the object, and send to the other before
				// notifying 0.
				// In order to avoid this, since session reference is added every time we
				// communicate
				// (even between nodes! not only client - node)
				// we do NOT remove session reference till GGC asks TWO times

				// Explicit closes of sessions set expire date to &quot;now&quot; but user can restart a
				// session
				// so, even if session is in quarantine, we must check date.

<span class="nc" id="L713">				boolean sessionExpired = false;</span>
<span class="nc" id="L714">				final Date expireDate = this.sessionsExpireDates.get(curSession);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L716">					LOGGER.debug(&quot;Session {} expires at {}&quot;, curSession, expireDate);</span>
				}
<span class="nc bnc" id="L718" title="All 4 branches missed.">				if (expireDate != null &amp;&amp; now.after(expireDate)) {</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L720">						LOGGER.debug(&quot;Session {} is expired. It expired at {}&quot;, curSession, expireDate);</span>
					}
<span class="nc bnc" id="L722" title="All 2 branches missed.">					if (quarantineSessions.contains(curSession)) {</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L724">							LOGGER.debug(&quot;Session &quot; + curSession + &quot; is in quarantine. Checking.&quot;);</span>
						}
						// session is actually removed.
<span class="nc" id="L727">						sessionExpired = true;</span>
<span class="nc" id="L728">						quarantineSessions.remove(curSession);</span>

						// check again expiration date to see if it is expired. If expired, remove.
<span class="nc" id="L731">						final Date curExpireDate = this.sessionsExpireDates.get(curSession);</span>
<span class="nc bnc" id="L732" title="All 4 branches missed.">						if (curExpireDate != null &amp;&amp; now.after(curExpireDate)) {</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">							if (DEBUG_ENABLED) {</span>
<span class="nc" id="L734">								LOGGER.debug(&quot;Session &quot; + curSession + &quot; has actually expired.&quot;);</span>
							}
							// do not remove expiration date from session till there is no objects in that
							// session
							// add it to sessions to close after all processing
<span class="nc" id="L739">							sessionsToClose.add(curSession);</span>
						}

<span class="nc" id="L742">					} else {</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L744">							LOGGER.debug(&quot;Session &quot; + curSession + &quot; has expired.  Adding session to quarantine.&quot;);</span>
						}
						// add it to quarantine sessions
<span class="nc" id="L747">						quarantineSessions.add(curSession);</span>
					}
<span class="nc bnc" id="L749" title="All 4 branches missed.">				} else if (expireDate != null &amp;&amp; !now.after(expireDate)) {</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L751">						LOGGER.debug(&quot;Session &quot; + curSession + &quot; is not expired yet but has expiration date &quot;);</span>
					}
					// check if session was in quarantine: if so, remove it from there (session
					// restart)
<span class="nc" id="L755">					quarantineSessions.remove(curSession);</span>
				} else {
<span class="nc bnc" id="L757" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L758">						LOGGER.debug(&quot;Session &quot; + curSession + &quot; has no expiration date.&quot;);</span>
					}
				}
<span class="nc bnc" id="L761" title="All 2 branches missed.">				if (sessionExpired) {</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L763">						LOGGER.debug(&quot;Session &quot; + curSession + &quot; is actually expired for oid &quot; + oid);</span>
					}
					// close session
<span class="nc" id="L766">					iterator.remove(); // remove session reference from the object.</span>

					// === concurrency note === //
					// when should we remove an entry in the referencesHoldBySessions map?
					// 1 - when no session is using the object
					// 2 - when object is not in memory
					// so, we check both here and we remove it if needed:
					// TODO: review this, what if after the check, sessions are added and we remove
					// it?
<span class="nc bnc" id="L775" title="All 2 branches missed.">					if (sessionsOfObj.size() == 0) {</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L777">							LOGGER.debug(&quot;Removing session reference to object {}&quot;, oid);</span>
						}
<span class="nc" id="L779">						this.referencesHoldBySessions.remove(oid);</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">					} else if (sessionsOfObj.size() &gt; 0) {</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L782">							LOGGER.debug(&quot;Not removing session reference since object {} has more sessions&quot;, oid);</span>
						}
					}

				} else {
<span class="nc bnc" id="L787" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L788">						LOGGER.debug(&quot;Adding session reference to: &quot; + oid);</span>
					}
					// add session reference
<span class="nc" id="L791">					retainedRefs.add(oid);</span>
				}
<span class="nc" id="L793">			}</span>
<span class="nc" id="L794">		}</span>

		// Remove all expired sessions if, and only if, there is no object retained by
		// it. TODO: improve this implementation.
<span class="nc bnc" id="L798" title="All 2 branches missed.">		for (final SessionID sessionToClose : sessionsToClose) {</span>
<span class="nc" id="L799">			boolean sessionBeingUsed = false;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">			for (final Set&lt;SessionID&gt; objSessions : referencesHoldBySessions.values()) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">				if (objSessions.contains(sessionToClose)) {</span>
<span class="nc" id="L802">					sessionBeingUsed = true;</span>
<span class="nc" id="L803">					break;</span>
				}
<span class="nc" id="L805">			}</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">			if (!sessionBeingUsed) {</span>
<span class="nc" id="L807">				this.sessionsExpireDates.remove(sessionToClose);</span>
			}
<span class="nc" id="L809">		}</span>

<span class="nc" id="L811">		return retainedRefs;</span>
	}

	@Override
	protected DataClayObjectLoader getDataClayObjectLoader() {
<span class="nc" id="L816">		return this.dataClayObjLoader;</span>
	}

	@Override
	public DataClayExecutionObject getFromHeap(final ObjectID objectID) {
<span class="nc" id="L821">		return (DataClayExecutionObject) this.dataClayHeapManager.getObject(objectID);</span>
	}

	/**
	 * Finish cache threads.
	 * 
	 * @if some exception occurs
	 */
	public void finishCacheThreads() {
		try {
<span class="nc" id="L831">			this.sessionsCache.finishCacheThreads();</span>
<span class="nc" id="L832">		} catch (final InterruptedException ex) {</span>
<span class="nc" id="L833">			LOGGER.debug(&quot;finishCacheThreads error&quot;, ex);</span>
<span class="nc" id="L834">		}</span>
<span class="nc" id="L835">	}</span>

	/**
	 * Clean caches.
	 */
	public void cleanCaches() {
<span class="nc" id="L841">		sessionsCache.clear();</span>
<span class="nc" id="L842">		datasetsCache.clear();</span>
<span class="nc" id="L843">		metaDataCache.clear();</span>
<span class="nc" id="L844">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>