<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.dataservice</a> &gt; <span class="el_source">DataService.java</span></div><h1>DataService.java</h1><pre class="source lang-java linenums">
/**
 * @file DataService.java
 * @date Oct 23, 2012
 */
package es.bsc.dataclay.dataservice;

// CHECKSTYLE:OFF
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Timer;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.objectweb.asm.util.CheckClassAdapter;

import org.objectweb.asm.ClassReader;

import es.bsc.dataclay.DataClayExecutionObject;
import es.bsc.dataclay.DataClayMockObject;
import es.bsc.dataclay.DataClayObject;
import es.bsc.dataclay.commonruntime.DataServiceRuntime;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.dataservice.api.DataServiceAPI;
import es.bsc.dataclay.dataservice.server.DataServiceSrv;
import es.bsc.dataclay.dbhandler.DBHandler;
import es.bsc.dataclay.dbhandler.DBHandlerConf;
import es.bsc.dataclay.exceptions.DataClayClassNotFoundException;
import es.bsc.dataclay.exceptions.DataClayException;
import es.bsc.dataclay.exceptions.JavaExecutionException;
import es.bsc.dataclay.exceptions.dataservice.ClassDeploymentException;
import es.bsc.dataclay.exceptions.dataservice.CleanExecutionClassesDirException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.exceptions.metadataservice.ObjectNotRegisteredException;
import es.bsc.dataclay.extrae.DataClayExtrae;
import es.bsc.dataclay.logic.api.LogicModuleAPI;
import es.bsc.dataclay.serialization.DataClaySerializable;
import es.bsc.dataclay.serialization.java.util.CollectionWrapper;
import es.bsc.dataclay.serialization.lib.DataClayDeserializationLib;
import es.bsc.dataclay.serialization.lib.DataClaySerializationLib;
import es.bsc.dataclay.serialization.lib.ObjectWithDataParamOrReturn;
import es.bsc.dataclay.serialization.lib.SerializedParametersOrReturn;
import es.bsc.dataclay.storagelocation.StorageLocationService;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.DataClayObjectMetaData;
import es.bsc.dataclay.util.FileAndAspectsUtils;
import es.bsc.dataclay.util.classloaders.DataClayClassLoaderSrv;
import es.bsc.dataclay.util.events.message.EventMessage;
import es.bsc.dataclay.util.events.type.DeletedObjEventType;
import es.bsc.dataclay.util.events.type.EventType;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.SessionID;
import es.bsc.dataclay.util.ids.StorageLocationID;
import es.bsc.dataclay.util.info.VersionInfo;
import es.bsc.dataclay.util.management.classmgr.MetaClass;
import es.bsc.dataclay.util.management.classmgr.Type;
import es.bsc.dataclay.util.management.metadataservice.ExecutionEnvironment;
import es.bsc.dataclay.util.management.metadataservice.MetaDataInfo;
import es.bsc.dataclay.util.management.metadataservice.RegistrationInfo;
import es.bsc.dataclay.util.management.metadataservice.StorageLocation;
import es.bsc.dataclay.util.management.stubs.ImplementationStubInfo;
import es.bsc.dataclay.util.management.stubs.StubInfo;
import es.bsc.dataclay.util.reflection.Reflector;
import es.bsc.dataclay.util.structs.LruCache;
import es.bsc.dataclay.util.structs.Tuple;
import io.grpc.StatusRuntimeException;

// CHECKSTYLE:ON

/**
 * This class is responsible to manage data of the objects stored in the system.
 * 
 */
public final class DataService implements DataServiceAPI {

	/** DatService name. */
	public final String dsName;

	/** DataService hostname. */
	private final String dsHostname;

	/** DataService port. */
	private final int dsPort;

	// CHECKSTYLE:OFF
	/** Logger. */
<span class="nc" id="L110">	private static final Logger LOGGER = LogManager.getLogger(&quot;DataService&quot;);</span>

	/** Indicates if debug is enabled. */
<span class="nc" id="L113">	private static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

	/** Server instance. */
	private final DataServiceSrv ownServer;

	/** DataService StorageLocationID. */
	private StorageLocationID storageLocationID;

	/** DataService StorageLocationID. */
	private ExecutionEnvironmentID executionEnvironmentID;

	/** Runtime. */
	public DataServiceRuntime runtime;

	/** Storage location associated to this service. */
	private final StorageLocationService storageLocation;

	/** Lazy task runner. */
	private LazyTasksRunner lazyTasksRunner;

	/** Timer. */
	private Timer lazyTasksTimer;

	/** Timer to activate paraver. */
	private Timer activatePrvTimer;

	/**
	 * Instantiates an DataService that uses the DB in the provided path.
	 * 
	 * @param newdsName
	 *            DataService name
	 * @param newdsHostname
	 *            DataService host name
	 * @param newdsTCPPort
	 *            DataService tcp port
	 * @param dbHandlerconf
	 *            Configuration of the DbHandler to use by the manager.
	 * @param theownServer
	 *            Reference to server instance using this DataService
	 *            implementation.
	 * @post Creates a Data Service and initializes the objectDB in the path
	 *       provided.
	 */
	public DataService(final String newdsName, final String newdsHostname, final int newdsTCPPort,
<span class="nc" id="L157">			final DBHandlerConf dbHandlerconf, final DataServiceSrv theownServer) {</span>
<span class="nc" id="L158">		dsName = newdsName;</span>
<span class="nc" id="L159">		dsHostname = newdsHostname;</span>
<span class="nc" id="L160">		dsPort = newdsTCPPort;</span>
<span class="nc" id="L161">		ownServer = theownServer;</span>
<span class="nc" id="L162">		this.storageLocation = new StorageLocationService(dbHandlerconf);</span>
<span class="nc" id="L163">		this.runtime = new DataServiceRuntime(this);</span>
<span class="nc" id="L164">		initEEInfo();</span>


<span class="nc" id="L167">	}</span>

	/**
	 * Initialize caches from persistent files
	 * 
	 */
	private void initEEInfo() {
		try {
<span class="nc" id="L175">			final FileInputStream fis = new FileInputStream(Configuration.Flags.EE_PERSISTENT_INFO_PATH.getStringValue()</span>
					+ &quot;ee&quot; + this.dsName + &quot;.info&quot;);
<span class="nc" id="L177">			final ObjectInputStream ois = new ObjectInputStream(fis);</span>
<span class="nc" id="L178">			final ExecutionEnvironmentPersistentInfo persInfo = (ExecutionEnvironmentPersistentInfo) ois.readObject();</span>
<span class="nc" id="L179">			this.executionEnvironmentID = persInfo.getExecutionEnvironmentID();</span>
<span class="nc" id="L180">			this.storageLocationID = persInfo.getStorageLocationID();</span>
<span class="nc" id="L181">			LOGGER.info(&quot;Initialized from file execution environment ID :&quot; + this.executionEnvironmentID);</span>
<span class="nc" id="L182">			LOGGER.info(&quot;Initialized from file storage location ID :&quot; + this.storageLocationID);</span>
<span class="nc" id="L183">			ois.close();</span>
<span class="nc" id="L184">			fis.close();</span>
<span class="nc" id="L185">		} catch (final IOException ioe) {</span>
<span class="nc" id="L186">			this.executionEnvironmentID = new ExecutionEnvironmentID(); </span>
<span class="nc" id="L187">			this.storageLocationID = new StorageLocationID();</span>
<span class="nc" id="L188">			LOGGER.info(&quot;Initialized execution environment ID :&quot; + this.executionEnvironmentID);</span>
<span class="nc" id="L189">			LOGGER.info(&quot;Initialized storage location ID :&quot; + this.storageLocationID);</span>
<span class="nc" id="L190">		} catch (final Exception ex) {</span>
<span class="nc" id="L191">			LOGGER.debug(&quot;init EE information error&quot;, ex);</span>
<span class="nc" id="L192">			return;</span>
<span class="nc" id="L193">		}</span>

<span class="nc" id="L195">	}</span>

	/**
	 * Store EE information.
	 */
	public void persistEEInfo() {
		try {
<span class="nc" id="L202">			final FileOutputStream fos = new FileOutputStream(Configuration.Flags.EE_PERSISTENT_INFO_PATH.getStringValue()</span>
					+ &quot;ee&quot; + this.dsName + &quot;.info&quot;);
<span class="nc" id="L204">			final ObjectOutputStream oos = new ObjectOutputStream(fos);</span>
<span class="nc" id="L205">			final ExecutionEnvironmentPersistentInfo eeInfo = new ExecutionEnvironmentPersistentInfo(</span>
					this.executionEnvironmentID, this.storageLocationID);
<span class="nc" id="L207">			oos.writeObject(eeInfo);</span>
<span class="nc" id="L208">			oos.close();</span>
<span class="nc" id="L209">			fos.close();</span>
<span class="nc" id="L210">		} catch (final IOException ioe) {</span>
<span class="nc" id="L211">			LOGGER.debug(&quot;persist EE info IO error&quot;, ioe);</span>
<span class="nc" id="L212">		}</span>

<span class="nc" id="L214">	}</span>

	/**
	 * Perform a local initialization, and perform the autoregisterDataService to
	 * the LogicModule
	 * 
	 * @param logicModuleHost
	 *            Logic Module host
	 * @param tcpLogicModulePort
	 *            Logic Module port
	 * @param dataServiceName
	 *            DS name
	 * @throws Exception
	 *             If an error occurs during this process
	 */
	public void initLocalWithAutoregistration(final String logicModuleHost, final int tcpLogicModulePort,
			final String dataServiceName) throws Exception {

<span class="nc" id="L232">		this.runtime.initialize(logicModuleHost, tcpLogicModulePort, dataServiceName);</span>
<span class="nc" id="L233">		DataClayObject.setLib(runtime);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">		if (Configuration.Flags.PREFETCHING_ENABLED.getBooleanValue()) {</span>
<span class="nc" id="L235">			lazyTasksRunner = new LazyTasksRunner(this);</span>
<span class="nc" id="L236">			lazyTasksTimer = new Timer();</span>
<span class="nc" id="L237">			lazyTasksTimer.schedule(lazyTasksRunner, 0, Configuration.Flags.PREFETCHING_TASKS_INTERVAL.getLongValue());</span>
		}

<span class="nc bnc" id="L240" title="All 2 branches missed.">		if (activatePrvTimer != null) {</span>
<span class="nc" id="L241">			activatePrvTimer.cancel();</span>
		}

<span class="nc" id="L244">		final LogicModuleAPI lmAPI = this.runtime.getLogicModuleAPI();</span>
<span class="nc" id="L245">		lmAPI.autoregisterSL(this.storageLocationID, dsName, dsHostname, dsPort);</span>
<span class="nc" id="L246">		lmAPI.autoregisterEE(executionEnvironmentID, dsName, dsHostname, dsPort, Langs.LANG_JAVA);</span>
<span class="nc" id="L247">		this.storageLocation.initialize(runtime, this.executionEnvironmentID);</span>
<span class="nc" id="L248">	}</span>

	/**
	 * Returns the backendID of this DS.
	 * 
	 * @return ID of the backend assigned to this DS.
	 */
	public StorageLocationID getStorageLocationID() {
<span class="nc" id="L256">		return storageLocationID;</span>
	}

	/**
	 * Returns the backendID of this DS.
	 * 
	 * @return ID of the backend assigned to this DS.
	 */
	public ExecutionEnvironmentID getExecutionEnvironmentID() {
<span class="nc" id="L265">		return executionEnvironmentID;</span>
	}

	/**
	 * Returns reference to metadata cache
	 * 
	 * @return reference to metadata cache
	 */
	public LruCache&lt;ObjectID, MetaDataInfo&gt; getMetaDataCache() {
<span class="nc" id="L274">		return runtime.getMetaDataCache();</span>
	}

	@Override
	public void initBackendID(final StorageLocationID newbackendID) {
<span class="nc" id="L279">		this.storageLocationID = newbackendID;</span>
<span class="nc" id="L280">	}</span>

	@Override
	public void associateExecutionEnvironment(final ExecutionEnvironmentID newexecutionEnvironmentID) {
<span class="nc" id="L284">		LOGGER.debug(&quot;Associating &quot; + newexecutionEnvironmentID + &quot; to &quot; + this.dsName);</span>
<span class="nc" id="L285">		this.storageLocation.associateExecutionEnvironment(newexecutionEnvironmentID);</span>

<span class="nc" id="L287">	}</span>

	@Override
	public void deployMetaClasses(final String namespaceName, final Map&lt;String, MetaClass&gt; deploymentPack) {
<span class="nc" id="L291">		throw new UnsupportedOperationException(&quot;Deploy MetaClass not supported for Java DataService&quot;);</span>
	}

	public static byte[] checkGeneratedClass(byte[] classBytes) {
<span class="nc" id="L295">		ClassReader cr = new ClassReader(classBytes);</span>
<span class="nc" id="L296">		StringWriter sw = new StringWriter();</span>
<span class="nc" id="L297">		PrintWriter pw = new PrintWriter(sw);		   </span>
<span class="nc" id="L298">		CheckClassAdapter.verify(cr, true, pw);</span>

<span class="nc" id="L300">		return classBytes;</span>
	}

	public static void validateClass(ClassReader reader, ClassLoader loader) {
<span class="nc" id="L304">		StringWriter writer = new StringWriter();</span>
<span class="nc" id="L305">		PrintWriter printWriter = new PrintWriter(writer);</span>

<span class="nc" id="L307">		Exception error = null;</span>
		try {
<span class="nc" id="L309">			CheckClassAdapter.verify(reader, loader, true, printWriter);</span>
<span class="nc" id="L310">		} catch (Exception e) {</span>
<span class="nc" id="L311">			error = e;</span>
<span class="nc" id="L312">		}</span>

<span class="nc" id="L314">		String contents = writer.toString();</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">		if (error != null || contents.length() &gt; 0) {</span>
<span class="nc" id="L316">			throw new IllegalStateException(writer.toString(), error);</span>
		}
<span class="nc" id="L318">	}</span>


	@Override
	public void deployClasses(final String namespaceName, final Map&lt;Tuple&lt;String, MetaClassID&gt;, byte[]&gt; classesToDeploy,
			final Map&lt;String, byte[]&gt; classesAspects, final Map&lt;String, byte[]&gt; stubYamls) {
<span class="nc" id="L324">		runtime.setCurrentThreadSessionID(new SessionID());</span>

		// Create temporary directories
<span class="nc" id="L327">		final String namespaceDir = Configuration.Flags.EXECUTION_CLASSES_PATH.getStringValue();</span>

		// Create directories if needed
<span class="nc" id="L330">		FileAndAspectsUtils.createDirectory(namespaceDir);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">		for (final Entry&lt;Tuple&lt;String, MetaClassID&gt;, byte[]&gt; curEntry : classesToDeploy.entrySet()) {</span>
<span class="nc" id="L333">			final String className = curEntry.getKey().getFirst();</span>
<span class="nc" id="L334">			final String finalClassName = namespaceName + &quot;.&quot; + className;</span>
<span class="nc" id="L335">			final byte[] classToDeploy = curEntry.getValue();</span>
			try {
<span class="nc" id="L337">				FileAndAspectsUtils.storeClass(namespaceDir, finalClassName + &quot;.class&quot;, classToDeploy);</span>

<span class="nc" id="L339">			} catch (final Exception ex) {</span>
<span class="nc" id="L340">				ex.printStackTrace();</span>
<span class="nc" id="L341">				LOGGER.debug(&quot;deployClasses error (while storing .class files)&quot;, ex);</span>
<span class="nc" id="L342">				throw new ClassDeploymentException(namespaceName, className, ex.getMessage());</span>
<span class="nc" id="L343">			}</span>
<span class="nc" id="L344">		}</span>

<span class="nc bnc" id="L346" title="All 2 branches missed.">		for (final Entry&lt;Tuple&lt;String, MetaClassID&gt;, byte[]&gt; curEntry : classesToDeploy.entrySet()) {</span>
<span class="nc" id="L347">			final String className = curEntry.getKey().getFirst();</span>
<span class="nc" id="L348">			final String finalClassName = namespaceName + &quot;.&quot; + className;</span>
<span class="nc" id="L349">			final byte[] classToDeploy = curEntry.getValue();</span>
			//  Verify class 
<span class="nc" id="L351">			checkGeneratedClass(classToDeploy);</span>
<span class="nc" id="L352">			DataClayClassLoaderSrv.getClass(finalClassName);</span>
<span class="nc" id="L353">		}</span>

		// Store yamls into final path
<span class="nc bnc" id="L356" title="All 2 branches missed.">		for (final Entry&lt;String, byte[]&gt; curEntry : stubYamls.entrySet()) {</span>
<span class="nc" id="L357">			final String className = curEntry.getKey();</span>
<span class="nc" id="L358">			final String finalClassName = namespaceName + &quot;.&quot; + className;</span>
<span class="nc" id="L359">			final byte[] yamlToStore = curEntry.getValue();</span>
			try {
<span class="nc" id="L361">				FileAndAspectsUtils.storeClass(namespaceDir, finalClassName + &quot;Yaml.yaml&quot;, yamlToStore);</span>
<span class="nc" id="L362">			} catch (final Exception ex) {</span>
<span class="nc" id="L363">				LOGGER.debug(&quot;deployClasses error (while storing .yaml files)&quot;, ex);</span>
<span class="nc" id="L364">				throw new ClassDeploymentException(namespaceName, className, ex.getMessage());</span>
<span class="nc" id="L365">			}</span>
<span class="nc" id="L366">		}</span>
<span class="nc" id="L367">	}</span>

	@Override
	public void enrichClass(final String namespaceName, final String className, final byte[] classToDeploy,
			final byte[] classAspects, final byte[] stubYaml) {

		try {

<span class="nc" id="L375">			final String finalClassName = namespaceName + &quot;.&quot; + className;</span>

<span class="nc" id="L377">			final Tuple&lt;File, String&gt; targetDirAndClassFileName = getTargetDirAndClassFileName(finalClassName);</span>
<span class="nc" id="L378">			final File targetDir = targetDirAndClassFileName.getFirst();</span>
<span class="nc" id="L379">			final String classFileName = targetDirAndClassFileName.getSecond();</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">			if (!targetDir.exists()) {</span>
<span class="nc" id="L381">				targetDir.mkdirs();</span>
			}
<span class="nc" id="L383">			final File classFile = new File(targetDir.getAbsolutePath() + File.separatorChar + classFileName);</span>
			// Update with the new one (e.g. when enriching)
<span class="nc bnc" id="L385" title="All 2 branches missed.">			if (classFile.exists()) {</span>
<span class="nc" id="L386">				classFile.delete();</span>
			}

			// Create temporary directories
<span class="nc" id="L390">			final String namespaceDir = Configuration.Flags.EXECUTION_CLASSES_PATH.getStringValue();</span>

<span class="nc" id="L392">			FileAndAspectsUtils.storeClass(namespaceDir, finalClassName + &quot;.class&quot;, classToDeploy);</span>

			// Replace YAML
			try {
<span class="nc" id="L396">				FileAndAspectsUtils.storeClass(namespaceDir, finalClassName + &quot;Yaml.yaml&quot;, stubYaml);</span>
<span class="nc" id="L397">			} catch (final Exception ex) {</span>
<span class="nc" id="L398">				LOGGER.debug(&quot;enrichClass error (while storing .yaml file)&quot;, ex);</span>
<span class="nc" id="L399">				throw new ClassDeploymentException(namespaceName, className, ex.getMessage());</span>
<span class="nc" id="L400">			}</span>

			// Reload all class loaders containing the class
<span class="nc" id="L403">			DataClayClassLoaderSrv.reloadClassLoader(namespaceName);</span>

<span class="nc" id="L405">		} catch (final Exception ex) {</span>
<span class="nc" id="L406">			LOGGER.debug(&quot;deployClasses error&quot;, ex);</span>
<span class="nc" id="L407">			throw new ClassDeploymentException(namespaceName, className, ex.getMessage());</span>
<span class="nc" id="L408">		}</span>
<span class="nc" id="L409">	}</span>

	/**
	 * Returns the targetdir and the file name of the given class
	 * 
	 * @param className
	 *            name of the class
	 * @return A tuple with the directory where the class resides and the actual
	 *         file name.
	 */
	private Tuple&lt;File, String&gt; getTargetDirAndClassFileName(final String className) {
<span class="nc" id="L420">		String packageName = &quot;&quot;;</span>
		String classFileName;
<span class="nc bnc" id="L422" title="All 2 branches missed.">		if (className.contains(&quot;.&quot;)) {</span>
<span class="nc" id="L423">			packageName = className.substring(0, className.lastIndexOf(&quot;.&quot;));</span>
<span class="nc" id="L424">			classFileName = className.substring(className.lastIndexOf(&quot;.&quot;) + 1, className.length());</span>
		} else {
<span class="nc" id="L426">			classFileName = className;</span>
		}
<span class="nc" id="L428">		classFileName += &quot;.class&quot;;</span>

<span class="nc" id="L430">		final String dirs = packageName.replace('.', File.separatorChar);</span>
<span class="nc" id="L431">		final String execDir = Configuration.Flags.EXECUTION_CLASSES_PATH.getStringValue();</span>
<span class="nc" id="L432">		final File targetDir = new File(execDir + File.separatorChar + dirs);</span>
<span class="nc" id="L433">		return new Tuple&lt;&gt;(targetDir, classFileName);</span>
	}

	@Override
	public ObjectID newPersistentInstance(final SessionID sessionID, final MetaClassID classID,
			final ImplementationID implementationID, final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps,
			final SerializedParametersOrReturn params) {

<span class="nc" id="L441">		runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">		if (Configuration.mockTesting) {</span>
<span class="nc" id="L443">			DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
		}
<span class="nc" id="L445">		final Class&lt;?&gt; clazz = DataClayClassLoaderSrv.getClass(classID);</span>

<span class="nc" id="L447">		final StubInfo stubInfo = DataClayObject.getStubInfoFromClass(clazz.getName());</span>
<span class="nc" id="L448">		final ImplementationStubInfo execInfo = stubInfo.getImplementationByID(implementationID.toString());</span>
<span class="nc" id="L449">		final Map&lt;String, Type&gt; argTypes = execInfo.getParams();</span>
<span class="nc" id="L450">		final List&lt;String&gt; argOrders = execInfo.getParamsOrder();</span>

		// Get class from signatures.
<span class="nc" id="L453">		Thread.currentThread().setContextClassLoader(DataClayClassLoaderSrv.execEnvironmentClassLoader);</span>
<span class="nc" id="L454">		final Class&lt;?&gt;[] parameterTypes = new Class&lt;?&gt;[argTypes.size()];</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">		for (int i = 0; i &lt; argTypes.size(); ++i) {</span>
<span class="nc" id="L456">			final String typeSignature = argTypes.get(argOrders.get(i)).getSignatureOrDescriptor();</span>
<span class="nc" id="L457">			parameterTypes[i] = Reflector.getClassFromSignatureAndArray(typeSignature,</span>
					DataClayClassLoaderSrv.execEnvironmentClassLoader);
		}

		// ============================ DESERIALIZE PARAMETERS
		// ============================ //
		// Since wrappers of parameters depend on the instance of the class and
		// the method cannot be static (or yes?) so we create a foo instance.
<span class="nc" id="L465">		final DataClayObject fooInstance = DataClayClassLoaderSrv.newInstance(classID, new ObjectID()); // just for</span>
		// deser.
<span class="nc" id="L467">		final Object[] loadedparams = this.runtime.deserializeParams(fooInstance, ifaceBitMaps, implementationID,</span>
				params);

		// ============================ NEW INSTANCE ============================ //
<span class="nc" id="L471">		DataClayObject instance = null;</span>
		try {
<span class="nc" id="L473">			instance = (DataClayObject) clazz.getConstructor(parameterTypes).newInstance(loadedparams);</span>
<span class="nc" id="L474">		} catch (final Exception ex) {</span>
<span class="nc" id="L475">			LOGGER.debug(&quot;newPersistentInstance -&gt; newInstance error&quot;, ex);</span>
<span class="nc" id="L476">			throw new JavaExecutionException(ex);</span>
<span class="nc" id="L477">		}</span>

		// ============================ MAKE PERSISTENT ============================ //
<span class="nc" id="L480">		instance.makePersistent(true, this.executionEnvironmentID);</span>

<span class="nc" id="L482">		runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">		if (Configuration.mockTesting) {</span>
<span class="nc" id="L484">			DataClayMockObject.removeCurrentThreadLib();</span>
		}
<span class="nc" id="L486">		return instance.getObjectID();</span>

	}

	@Override
	public void storeObjects(final SessionID sessionID, final List&lt;ObjectWithDataParamOrReturn&gt; objects,
			final boolean moving, final Set&lt;ObjectID&gt; idsWithAlias) {

<span class="nc bnc" id="L494" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L495">			LOGGER.debug(&quot;[==Store==] Storing &quot; + objects.size() + &quot; objects.&quot;);</span>
		}

<span class="nc" id="L498">		runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">		if (Configuration.mockTesting) {</span>
<span class="nc" id="L500">			DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
		}

		// notify GlobalGC about new alias references
<span class="nc bnc" id="L504" title="All 2 branches missed.">		if (idsWithAlias != null) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">			for (final ObjectID oid : idsWithAlias) {</span>
<span class="nc" id="L506">				runtime.addAliasReference(oid);</span>
<span class="nc" id="L507">			}</span>
		}

<span class="nc bnc" id="L510" title="All 2 branches missed.">		for (final ObjectWithDataParamOrReturn object : objects) {</span>
<span class="nc" id="L511">			final ObjectID objectID = object.getObjectID();</span>

			// Set object's hint to current location
<span class="nc" id="L514">			final DataClayObjectMetaData metadata = object.getMetaData();</span>
<span class="nc" id="L515">			final int tag = metadata.getOids().entrySet().stream()</span>
<span class="nc" id="L516">					.collect(Collectors.toMap(Entry::getValue, c -&gt; c.getKey())).get(objectID);</span>
<span class="nc" id="L517">			metadata.setHint(tag, this.executionEnvironmentID);</span>

			// make persistent - session references
<span class="nc" id="L520">			this.runtime.addSessionReference(objectID);</span>

<span class="nc" id="L522">			final byte[] byteArray = DataClaySerializationLib.serializeForDB(objectID, metadata,</span>
<span class="nc" id="L523">					object.getSerializedBytes(), true);</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L526">				LOGGER.debug(&quot;[==Store==] Storing object &quot; + objectID + &quot; of size = &quot; + byteArray.length + &quot; bytes &quot;);</span>
			}
<span class="nc" id="L528">			this.storageLocation.store(this.executionEnvironmentID, objectID, byteArray);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L530">				LOGGER.debug(&quot;[==Store==] Stored object &quot; + objectID + &quot; of size = &quot; + byteArray.length + &quot; bytes &quot;);</span>
			}

<span class="nc" id="L533">		}</span>

<span class="nc bnc" id="L535" title="All 2 branches missed.">		if (moving) {</span>

			// If moving and object that EXISTS in the ObjectsMap as a proxy means:
			// - The object is a Weak Proxy and we must deserialize data on it.
			// Why?
			// - If there is a proxy present in the ObjectsMap, it means it is a weak proxy,
			// and
			// we are storing an object into a DS that had the object once (and therefore it
			// turned to a
			// weak proxy).
			// A weak proxy, when is GC, it's removed and new instances pointing to the
			// moved object
			// will use the traditional mechanism of 'remote calls'. Object not in Map -&gt;
			// remote call.

<span class="nc bnc" id="L550" title="All 2 branches missed.">			for (final ObjectWithDataParamOrReturn object : objects) {</span>
<span class="nc" id="L551">				final ObjectID objectID = object.getObjectID();</span>
<span class="nc" id="L552">				DataClayExecutionObject instance = null;</span>
				try {
<span class="nc" id="L554">					instance = this.runtime.getFromHeap(objectID);</span>
					// Corner case: Client sends parameter to turn in proxy. DS1 has Proxy + Param
					// obj. but
					// param obj is actually a persistent object in DS2.
					// There is a move from DS2 to DS1, the proxy is not saved in map by default
					// (except weak)
					// but the parameter is still there. So proxy flag is false but WE CAN USE THE
					// OBJECT IN MEMORY
					// :)

					///// NORMAL WEAK PROXY
<span class="nc bnc" id="L565" title="All 4 branches missed.">					if (instance != null &amp;&amp; !instance.isLoaded()) {</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L567">							LOGGER.debug(&quot;[==Store==] Found weak proxy for &quot; + objectID</span>
									+ &quot;during a move. Loading object and turning it into normal object&quot;);
						}

<span class="nc" id="L571">						runtime.deserializeDataIntoInstance(instance, object, null);</span>
					}

<span class="nc" id="L574">				} catch (final DbObjectNotExistException ex) {</span>
<span class="nc" id="L575">					LOGGER.debug(&quot;storeObjects error, not in db anymore&quot;, ex);</span>
					// TODO: if not in DB anymore due to a delete, what to do?
				} finally {
					// Remove metadata from cache in case this dataservice has information that the
					// object is in another.
<span class="nc" id="L580">					runtime.getMetaDataCache().remove(objectID);</span>
				}

<span class="nc" id="L583">			}</span>
		}

		// FIXME: sessionID must have a counter in structure or remove entry once a
		// thread is removed (dgasull 2018)
		// clientLib.removeSessionIDForThread();
		// DataClayObject.removeLibForThread();

<span class="nc bnc" id="L591" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L592">			LOGGER.debug(&quot;[==Store==] End of Storing objects&quot;);</span>
		}
<span class="nc" id="L594">	}</span>

	@Override
	public void newMetaData(final Map&lt;ObjectID, MetaDataInfo&gt; mdInfos) {
<span class="nc bnc" id="L598" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">			for (final Entry&lt;ObjectID, MetaDataInfo&gt; entry : mdInfos.entrySet()) {</span>
<span class="nc" id="L600">				LOGGER.debug(&quot;[==MetaData Cache==] Added metadata info to MetaData Cache: &quot; + entry.getKey() + &quot; : &quot;</span>
<span class="nc" id="L601">						+ entry.getValue().getLocations().values());</span>
<span class="nc" id="L602">			}</span>
		}
<span class="nc" id="L604">		runtime.getMetaDataCache().putAll(mdInfos);</span>
<span class="nc" id="L605">	}</span>

	/**
	 * @brief Deserialize and load the data of objects provided into heap
	 * @param sessionID
	 *            ID of session
	 * @param objectsToPersist
	 *            objects to deserialize into heap
	 * @return Deserialized instances
	 */
	private Object[] storeInMemory(final SessionID sessionID, final SerializedParametersOrReturn objectsToPersist) {

<span class="nc" id="L617">		final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps = null; // TODO: get for current session</span>

		// Deserialize objects following same design as volatile but without
		// implementation ID (null) and
		// no instance to execute.
<span class="nc" id="L622">		return this.runtime.deserializeMakePersistent(ifaceBitMaps, objectsToPersist);</span>

	}

	@Override
	public void makePersistent(final SessionID sessionID, final SerializedParametersOrReturn objectsToPersist) {
		try {

<span class="nc bnc" id="L630" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L631">				LOGGER.debug(&quot;[==Serialization==] Received serialized objects: &quot; + objectsToPersist);</span>
			}

			// create lots of objects here and stash them somewhere
<span class="nc" id="L635">			runtime.setCurrentThreadSessionID(sessionID);</span>

<span class="nc bnc" id="L637" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L638">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}
<span class="nc bnc" id="L640" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L641">				LOGGER.debug(&quot;[==Make Persistent==] ** Starting make persistent **&quot;);</span>

			}
<span class="nc" id="L644">			storeInMemory(sessionID, objectsToPersist);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L646">				LOGGER.debug(&quot;[==Make Persistent==] ** End of make persistent **&quot;);</span>
			}
<span class="nc" id="L648">		} catch (final Exception ex) {</span>
<span class="nc" id="L649">			ex.printStackTrace();</span>
<span class="nc" id="L650">			LOGGER.debug(&quot; Make persistent got exception&quot;, ex);</span>
<span class="nc" id="L651">			throw ex;</span>
		} finally {
<span class="nc bnc" id="L653" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L654">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
<span class="nc" id="L656">			runtime.removeCurrentThreadSessionID();</span>

		}

<span class="nc" id="L660">	}</span>

	@Override
	public void federate(final SessionID sessionID, final SerializedParametersOrReturn objectsToPersist) {

		try {

			// create lots of objects here and stash them somewhere
<span class="nc" id="L668">			runtime.setCurrentThreadSessionID(sessionID);</span>

<span class="nc bnc" id="L670" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L671">				DataClayMockObject.setCurrentThreadLib(runtime);</span>
			}

<span class="nc bnc" id="L674" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L675">				LOGGER.debug(&quot;[==Federate==] ** Starting Federate **&quot;);</span>

			}

<span class="nc" id="L679">			final Object[] federatedInstances = storeInMemory(sessionID, objectsToPersist);</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">			for (final Object federatedInstance : federatedInstances) {</span>
<span class="nc" id="L681">				final DataClayObject federatedDataClayObj = (DataClayObject) federatedInstance;</span>
				try {
<span class="nc" id="L683">					federatedDataClayObj.whenFederated();</span>
<span class="nc" id="L684">				} catch (final Exception e) {</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L686">						LOGGER.debug(&quot;[==Federate==] Caugh exception during whenFederated: &quot;, e);</span>
					}
<span class="nc" id="L688">				}</span>
			}
<span class="nc bnc" id="L690" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L691">				LOGGER.debug(&quot;[==Federate==] ** End of Federate **&quot;);</span>
			}

<span class="nc" id="L694">		} catch (final Exception ex) {</span>
<span class="nc" id="L695">			LOGGER.debug(&quot; Federate got exception&quot;, ex);</span>
<span class="nc" id="L696">			throw ex;</span>
		} finally {
<span class="nc bnc" id="L698" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L699">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
<span class="nc" id="L701">			runtime.removeCurrentThreadSessionID();</span>

		}

<span class="nc" id="L705">	}</span>

	@Override
	public void unfederate(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs) {
		try {
			// create lots of objects here and stash them somewhere
<span class="nc bnc" id="L711" title="All 2 branches missed.">			if (sessionID != null) {</span>
<span class="nc" id="L712">				runtime.setCurrentThreadSessionID(sessionID);</span>
			}

<span class="nc bnc" id="L715" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L716">				DataClayMockObject.setCurrentThreadLib(runtime);</span>
			}

<span class="nc bnc" id="L719" title="All 2 branches missed.">			for (final ObjectID objectID : objectIDs) {</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L721">					LOGGER.debug(&quot;[==Unfederate==] ** Starting unfederate &quot;);</span>
				}
<span class="nc" id="L723">				final DataClayObject instance = runtime.getOrNewInstanceFromDB(objectID, true);</span>
<span class="nc" id="L724">				instance.whenUnfederated();</span>
<span class="nc" id="L725">			}</span>
<span class="nc" id="L726">		} catch (final Exception ex) {</span>
<span class="nc" id="L727">			LOGGER.debug(&quot;[==Unfederate==] Unfederate got exception&quot;, ex);</span>
<span class="nc" id="L728">			throw ex;</span>
		} finally {
<span class="nc bnc" id="L730" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L731">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
<span class="nc" id="L733">			runtime.removeCurrentThreadSessionID();</span>

		}
<span class="nc" id="L736">	}</span>

	@Override
	public SerializedParametersOrReturn executeImplementation(final ObjectID objectID, final ImplementationID implID,
			final SerializedParametersOrReturn params, final SessionID sessionID) {

		try {
			// create lots of objects here and stash them somewhere
<span class="nc bnc" id="L744" title="All 2 branches missed.">			if (sessionID != null) {</span>
<span class="nc" id="L745">				runtime.setCurrentThreadSessionID(sessionID);</span>
			}

<span class="nc bnc" id="L748" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L749">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}

<span class="nc bnc" id="L752" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L753">				LOGGER.debug(&quot;[==Execution==] ** New execution! ** Executing in object &quot; + objectID</span>
						+ &quot; the implementation &quot; + implID);

			}

			// =================================== GET INSTANCE
			// ===================================//
			// We must instantiate an object of the execution class

<span class="nc bnc" id="L762" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L763">				LOGGER.debug(&quot;[==Execution==] Going to get or create instance for object with id &quot; + objectID);</span>
			}
<span class="nc" id="L765">			final DataClayObject instance = runtime.getOrNewInstanceFromDB(objectID, true);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L767">				this.runtime.checkSession(instance.getDataSetID(), sessionID);</span>
			}

<span class="nc bnc" id="L770" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L771">				LOGGER.debug(&quot;[==Execution==] Deserializing parameters for execution of object with id &quot; + objectID</span>
						+ &quot; and implementation &quot; + implID);
			}

<span class="nc" id="L775">			final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps = null; // TODO: get for current session</span>

			// ============================ DESERIALIZE PARAMETERS
			// ============================ //
<span class="nc" id="L779">			final Object[] loadedparams = this.runtime.deserializeParams(instance, ifaceBitMaps, implID, params);</span>

<span class="nc bnc" id="L781" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L782">				LOGGER.debug(&quot;[==Execution==] Running method for object with id &quot; + objectID + &quot; and implementation &quot;</span>
						+ implID);
			}

			// ============================= EXECUTE =========================== //
<span class="nc" id="L787">			final Object result = this.runImplementation(instance, implID, loadedparams);</span>

<span class="nc bnc" id="L789" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L790">				LOGGER.debug(&quot;[==Execution==] End of running method for object with id &quot; + objectID</span>
						+ &quot; and implementation &quot; + implID);
			}

			// =================== SERIALIZE RESULT ===================//
<span class="nc bnc" id="L795" title="All 2 branches missed.">			if (result == null) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L797">					LOGGER.debug(&quot;[==Execution==] Returning NULL or nothing for execution of object with id &quot; + objectID</span>
							+ &quot; and implementation &quot; + implID);
				}
<span class="nc" id="L800">				return null;</span>
			} else {
<span class="nc bnc" id="L802" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L803">					LOGGER.debug(&quot;[==Execution==] Serializing return for execution of object with id &quot; + objectID</span>
							+ &quot; and implementation &quot; + implID);
				}
<span class="nc" id="L806">				return this.runtime.serializeReturn(instance, ifaceBitMaps, implID, result);</span>
			}
<span class="nc" id="L808">		} catch (final StatusRuntimeException sterr) {</span>
<span class="nc" id="L809">			LOGGER.debug(&quot;[==Execution==] Error at execution of object with id {} and implementation {}&quot;, objectID,</span>
					implID);
<span class="nc" id="L811">			LOGGER.debug(&quot;executeImplementation got a StatusRuntimeException&quot;, sterr);</span>
<span class="nc" id="L812">			throw sterr;</span>
<span class="nc" id="L813">		} catch (final DataClayException dbe) {</span>
<span class="nc" id="L814">			LOGGER.debug(&quot;[==Execution==] Error at execution of object with id {} and implementation {}&quot;, objectID,</span>
					implID);
<span class="nc" id="L816">			LOGGER.debug(&quot;executeImplementation got a native DataClayException&quot;, dbe);</span>
<span class="nc" id="L817">			dbe.printStackTrace();</span>
<span class="nc" id="L818">			throw dbe;</span>
<span class="nc" id="L819">		} catch (final Exception ex) {</span>
<span class="nc" id="L820">			LOGGER.debug(&quot;[==Execution==] Error at execution of object with id {} and implementation {}&quot;, objectID,</span>
					implID);
<span class="nc" id="L822">			LOGGER.debug(&quot;executeImplementation got a native DataClayException&quot;, ex);</span>
<span class="nc" id="L823">			throw new JavaExecutionException(ex);</span>
<span class="nc" id="L824">		} catch (final Error err) {</span>
<span class="nc" id="L825">			LOGGER.debug(&quot;executeImplementation ``true'' error&quot;, err);</span>
<span class="nc" id="L826">			throw new JavaExecutionException(err);</span>
		} finally {
<span class="nc bnc" id="L828" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L829">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
<span class="nc" id="L831">			runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L833">				LOGGER.debug(&quot;[==Execution==] ** End of execution ** End of execution of object with id &quot; + objectID</span>
						+ &quot; and implementation &quot; + implID);
			}
		}

	}

	/**
	 * This function executes the method specified
	 * 
	 * @param instance
	 *            Instance in which to execute
	 * @param implID
	 *            Information about the operation to execute
	 * @param params
	 *            Parameter values used while invoking the operation
	 * @return Serialized operation result.
	 */
	public Object runImplementation(final DataClayObject instance, final ImplementationID implID,
			final Object[] params) {
		// =================== EXECUTION ===================//
		// In case we change namespace (executeInternal called from commonlib)
<span class="nc" id="L855">		final Object result = instance.run(implID, params);</span>
<span class="nc" id="L856">		return result;</span>

	}

	/**
	 * Update all objects in memory (or store them if new). Function called at
	 * shutdown.
	 */
	public void shutdownUpdate() {
		try {
			// =========== Close DataClayGC service ================ //
<span class="nc bnc" id="L867" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L868">				LOGGER.debug(&quot;[==Shutdown==] Shutdown DataClayGC (it can take a while)... &quot;);</span>
			}

<span class="nc bnc" id="L871" title="All 2 branches missed.">			if (Configuration.Flags.PREFETCHING_ENABLED.getBooleanValue()) {</span>
				// Lazy tasks shutdown
<span class="nc" id="L873">				this.lazyTasksTimer.cancel();</span>
			}

			// =========== Update objects ================ //

<span class="nc bnc" id="L878" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L879">				LOGGER.debug(&quot;[==Shutdown==] Wait pending asynchronous (it can take a while)... &quot;);</span>
			}

<span class="nc bnc" id="L882" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L883">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}

			// Wait for all async requests.
<span class="nc" id="L887">			runtime.waitForAsyncRequestToFinish();</span>

			// FLUSH all objects
<span class="nc" id="L890">			runtime.flushAll();</span>

			// shutdown GC threads
<span class="nc" id="L893">			this.storageLocation.shutDownGarbageCollector();</span>

			// shutdown storage location
<span class="nc" id="L896">			this.storageLocation.closeDbHandler(this.executionEnvironmentID);</span>

<span class="nc bnc" id="L898" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L899">				DataClayMockObject.removeCurrentThreadLib();</span>
			}

<span class="nc" id="L902">		} catch (final Exception ex) {</span>
<span class="nc" id="L903">			LOGGER.debug(&quot;shutdownUpdate error&quot;, ex);</span>
<span class="nc" id="L904">		}</span>
<span class="nc" id="L905">	}</span>

	@Override
	public void upsertObjects(final SessionID sessionID, final List&lt;ObjectWithDataParamOrReturn&gt; objectIDsAndBytes) {

<span class="nc" id="L910">		runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">		if (Configuration.mockTesting) {</span>
<span class="nc" id="L912">			DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
		}
		try {
<span class="nc" id="L915">			final List&lt;ObjectWithDataParamOrReturn&gt; objectsInOtherBackend = new ArrayList&lt;&gt;();</span>
			// To check for replicas
<span class="nc bnc" id="L917" title="All 2 branches missed.">			for (final ObjectWithDataParamOrReturn curEntry : objectIDsAndBytes) {</span>

<span class="nc" id="L919">				final ObjectID objectID = curEntry.getObjectID();</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L921">					LOGGER.debug(&quot;[==Upsert==] Updated or inserted object &quot; + objectID);</span>
				}
				try {
					// Update bytes at memory object
<span class="nc bnc" id="L925" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L926">						LOGGER.debug(&quot;[==Upsert==] Getting/Creating instance from upsert with id &quot; + objectID);</span>
					}
<span class="nc" id="L928">					final DataClayExecutionObject instance = runtime.getOrNewInstanceFromDB(objectID, false);</span>
<span class="nc" id="L929">					runtime.deserializeDataIntoInstance(instance, curEntry, null);</span>
<span class="nc" id="L930">					instance.setDirty(true); // IMPORTANT: instance now is dirty due to update!</span>

<span class="nc" id="L932">				} catch (final DbObjectNotExistException e) {</span>
					// GET IN OTHER BACKEND
<span class="nc" id="L934">					objectsInOtherBackend.add(curEntry);</span>
<span class="nc" id="L935">				}</span>
<span class="nc" id="L936">			}</span>
<span class="nc" id="L937">			upsertObjectsInOtherBackend(sessionID, objectsInOtherBackend);</span>
		} finally {
			// Do not remove it since it might be called from inside
			/*
			 * clientLib.removeSessionIDForThread(threadID); if (Configuration.MOCK_TESTING)
			 * { DataClayMockObject.removeCurrentThreadLib(); }
			 */
		}
<span class="nc" id="L945">	}</span>

	/**
	 * Update object in another backend.
	 * 
	 * @param sessionID
	 *            ID of session
	 * @param objectsInOtherNodes
	 *            List of metadata of objects to update and its bytes. It is useful
	 *            to avoid multiple trips.
	 * @throws RemoteException
	 *             if some exception occurs
	 */
	private void upsertObjectsInOtherBackend(final SessionID sessionID,
			final List&lt;ObjectWithDataParamOrReturn&gt; objectsInOtherNodes) {
		// Prepare to unify calls (only one call for DS)
<span class="nc" id="L961">		final Map&lt;ExecutionEnvironment, List&lt;ObjectWithDataParamOrReturn&gt;&gt; objectsPerBackend = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L963" title="All 2 branches missed.">		for (final ObjectWithDataParamOrReturn curEntry : objectsInOtherNodes) {</span>
<span class="nc" id="L964">			final ObjectID curObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L965">			final MetaDataInfo mdInfo = runtime.getObjectMetadata(curObjectID);</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">			if (mdInfo == null) {</span>
				// TODO: review exception design, getObjectMetadata is returning null in case
				// object not registered.
				// WARNING: This exception should not happen here
				// NOTE: if it is a volatile and hint failed, it means that object is actually
				// not registered
<span class="nc" id="L972">				throw new ObjectNotRegisteredException(curObjectID);</span>
			}
<span class="nc" id="L974">			final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locations = mdInfo.getLocations();</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L976">				LOGGER.debug(</span>
<span class="nc" id="L977">						&quot;[==Upsert==] Updating objects in other backends. Locations of objects: &quot; + locations.keySet());</span>
			}
			// Update object at first location (NOT UPDATING REPLICAS!!!)
<span class="nc" id="L980">			final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; curLoc = locations.entrySet().iterator().next();</span>
<span class="nc" id="L981">			List&lt;ObjectWithDataParamOrReturn&gt; objectsInBackend = objectsPerBackend.get(curLoc.getValue());</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">			if (objectsInBackend == null) {</span>
<span class="nc" id="L983">				objectsInBackend = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L984">				objectsPerBackend.put(curLoc.getValue(), objectsInBackend);</span>
			}
<span class="nc" id="L986">			objectsInBackend.add(curEntry);</span>
<span class="nc" id="L987">		}</span>

		// Now call
<span class="nc bnc" id="L990" title="All 2 branches missed.">		for (final Entry&lt;ExecutionEnvironment, List&lt;ObjectWithDataParamOrReturn&gt;&gt; curEntry : objectsPerBackend</span>
<span class="nc" id="L991">				.entrySet()) {</span>

<span class="nc" id="L993">			final ExecutionEnvironment backend = curEntry.getKey();</span>
<span class="nc" id="L994">			final List&lt;ObjectWithDataParamOrReturn&gt; objectsToUpdate = curEntry.getValue();</span>
<span class="nc" id="L995">			final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(backend.getDataClayID());</span>
<span class="nc" id="L996">			dataServiceApi.upsertObjects(sessionID, objectsToUpdate);</span>

<span class="nc" id="L998">		}</span>
<span class="nc" id="L999">	}</span>

	@Override
	public SerializedParametersOrReturn getCopyOfObject(final SessionID sessionID, final ObjectID objectID,
			final boolean recursive) {
<span class="nc bnc" id="L1004" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1005">			LOGGER.debug(&quot;[==GetCopyOfObject==] Retrieving copy of &quot; + objectID);</span>
		}

		// Get the data service of one of the backends that contains the original
		// object.
<span class="nc" id="L1010">		final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1011">		objectIDs.add(objectID);</span>

<span class="nc" id="L1013">		final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs, recursive, false);</span>
		// Prepare OIDs
<span class="nc bnc" id="L1015" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1016">			LOGGER.debug(&quot;[==GetCopyOfObject==] Objects obtained to return a copy of &quot; + objectID);</span>
		}

<span class="nc" id="L1019">		final Map&lt;ObjectID, ObjectID&gt; originalToVersion = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L1020">		final Map&lt;ObjectID, ExecutionEnvironmentID&gt; versionsHints = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1022" title="All 2 branches missed.">		for (final ObjectWithDataParamOrReturn curEntry : serializedObjs) {</span>
<span class="nc" id="L1023">			final ObjectID origObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1024">			final ObjectID versionObjectID = new ObjectID();</span>
<span class="nc" id="L1025">			originalToVersion.put(origObjectID, versionObjectID);</span>
<span class="nc" id="L1026">			versionsHints.put(versionObjectID, this.runtime.getHint());</span>
<span class="nc" id="L1027">		}</span>

<span class="nc bnc" id="L1029" title="All 2 branches missed.">		for (final ObjectWithDataParamOrReturn curEntry : serializedObjs) {</span>
			// Store version in this backend (if already stored, just skip it)
<span class="nc" id="L1031">			final ObjectID origObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1032">			final ObjectID versionObjectID = originalToVersion.get(origObjectID);</span>
<span class="nc" id="L1033">			DataClaySerializationLib.modifyMetadataOIDs(curEntry, originalToVersion, versionsHints);</span>
<span class="nc" id="L1034">			curEntry.setObjectID(versionObjectID);</span>
<span class="nc" id="L1035">		}</span>

<span class="nc bnc" id="L1037" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1038">			LOGGER.debug(&quot;[==GetCopyOfObject==] Updated OIDs and references to return a copy of &quot; + objectID);</span>
		}

<span class="nc" id="L1041">		final SerializedParametersOrReturn serParamReturn = new SerializedParametersOrReturn(serializedObjs);</span>

<span class="nc" id="L1043">		return serParamReturn;</span>
	}

	@Override
	public void updateObject(final SessionID sessionID, final ObjectID intoObjectID,
			final SerializedParametersOrReturn fromObject) {
		try {
			// create lots of objects here and stash them somewhere
<span class="nc bnc" id="L1051" title="All 2 branches missed.">			if (sessionID != null) {</span>
<span class="nc" id="L1052">				runtime.setCurrentThreadSessionID(sessionID);</span>
			}

<span class="nc bnc" id="L1055" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1056">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}

<span class="nc bnc" id="L1059" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1060">				LOGGER.debug(&quot;[==UpdateObject==] ** Updating object &quot; + intoObjectID);</span>
			}

<span class="nc" id="L1063">			final DataClayObject instanceInto = runtime.getOrNewInstanceFromDB(intoObjectID, true);</span>
<span class="nc" id="L1064">			final Object[] aux = DataClayDeserializationLib.deserializeParamsOrReturn(fromObject, null, runtime);</span>
<span class="nc" id="L1065">			final DataClayObject instanceFrom = (DataClayObject) aux[0];</span>

<span class="nc bnc" id="L1067" title="All 2 branches missed.">			if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L1068">				this.runtime.checkSession(instanceInto.getDataSetID(), sessionID);</span>
			}

			// ============================= EXECUTE =========================== //
<span class="nc bnc" id="L1072" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1073">				LOGGER.debug(&quot;[==UpdateObject==] ** Updating object &quot; + intoObjectID + &quot; from object &quot;</span>
<span class="nc" id="L1074">						+ instanceFrom.getID());</span>
			}

<span class="nc" id="L1077">			instanceInto.setAll(instanceFrom);</span>

<span class="nc bnc" id="L1079" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1080">				LOGGER.debug(&quot;[==UpdateObject==] ** Updated object &quot; + intoObjectID + &quot; from object &quot;</span>
<span class="nc" id="L1081">						+ instanceFrom.getID());</span>
			}

<span class="nc" id="L1084">		} catch (final Exception e) {</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1086">				LOGGER.debug(&quot;[==UpdateObject==] Caugh exception during putObject: &quot;, e);</span>
			}
		} finally {
<span class="nc bnc" id="L1089" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1090">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
<span class="nc" id="L1092">			runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1094">				LOGGER.debug(&quot;[==UpdateObject==] ** End of updating object &quot; + intoObjectID);</span>
			}
		}
<span class="nc" id="L1097">	}</span>

	@Override
	public List&lt;ObjectWithDataParamOrReturn&gt; getObjects(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs,
			final boolean recursive, final boolean moving) {
<span class="nc bnc" id="L1102" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1103">			LOGGER.debug(&quot;[==Get==] Getting objects &quot; + objectIDs);</span>
		}
<span class="nc" id="L1105">		final List&lt;ObjectWithDataParamOrReturn&gt; result = new ArrayList&lt;&gt;();</span>
		try {
<span class="nc" id="L1107">			runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1109">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}

<span class="nc" id="L1112">			final Map&lt;ObjectID, StorageLocationID&gt; obtainedObjects = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L1113">			final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; objectsInOtherBackend = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">			for (final ObjectID objectID : objectIDs) {</span>

<span class="nc bnc" id="L1116" title="All 2 branches missed.">				if (recursive) {</span>
<span class="nc" id="L1117">					final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; pendingObjs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1118">					pendingObjs.add(new Tuple&lt;&gt;(objectID, null));</span>
<span class="nc" id="L1119">					final ListIterator&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; it = pendingObjs</span>
<span class="nc" id="L1120">							.listIterator(pendingObjs.size());</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">					while (it.hasPrevious()) {</span>
<span class="nc" id="L1122">						final Tuple&lt;ObjectID, ExecutionEnvironmentID&gt; idAndHint = it.previous();</span>
<span class="nc" id="L1123">						final ObjectID curObID = idAndHint.getFirst();</span>
<span class="nc" id="L1124">						final ExecutionEnvironmentID hint = idAndHint.getSecond();</span>

<span class="nc bnc" id="L1126" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1127">							LOGGER.debug(&quot;[==Get==] Getting &quot; + curObID);</span>
						}
<span class="nc" id="L1129">						it.remove();</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">						if (obtainedObjects.get(curObID) != null) {</span>
							// Already read
<span class="nc" id="L1132">							continue;</span>
						}
						try {
<span class="nc" id="L1135">							final ObjectWithDataParamOrReturn objWithData = getObjectInternal(curObID, moving);</span>
<span class="nc" id="L1136">							result.add(objWithData);</span>

<span class="nc" id="L1138">							obtainedObjects.put(curObID, storageLocationID);</span>
							// Get associated objects (recursive)
<span class="nc" id="L1140">							final DataClayObjectMetaData metadata = objWithData.getMetaData();</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">							for (final Entry&lt;Integer, ObjectID&gt; associatedOIDEntry : metadata.getOids().entrySet()) {</span>
<span class="nc" id="L1142">								final Integer tag = associatedOIDEntry.getKey();</span>
<span class="nc" id="L1143">								final ObjectID associatedOID = associatedOIDEntry.getValue();</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">								if (obtainedObjects.get(associatedOID) == null) {</span>
<span class="nc" id="L1145">									it.add(new Tuple&lt;&gt;(associatedOID, metadata.getHint(tag)));</span>
								}
<span class="nc" id="L1147">							}</span>
<span class="nc" id="L1148">						} catch (final DbObjectNotExistException e) {</span>
							// GET IN OTHER BACKEND
<span class="nc" id="L1150">							objectsInOtherBackend.add(new Tuple&lt;&gt;(curObID, hint));</span>
<span class="nc" id="L1151">						}</span>
<span class="nc" id="L1152">					}</span>
<span class="nc" id="L1153">				} else {</span>
<span class="nc" id="L1154">					final ObjectWithDataParamOrReturn objWithData = getObjectInternal(objectID, moving);</span>
<span class="nc" id="L1155">					result.add(objWithData);</span>
				}
<span class="nc" id="L1157">			}</span>

<span class="nc bnc" id="L1159" title="All 2 branches missed.">			if (recursive) {</span>
<span class="nc" id="L1160">				result.addAll(getObjectsInOtherBackend(sessionID, objectsInOtherBackend, true, moving));</span>
			}

		} finally {
			/*
			 * clientLib.removeSessionIDForThread(threadID); if (Configuration.MOCK_TESTING)
			 * { DataClayMockObject.removeCurrentThreadLib(); }
			 */
			// Don't remove since it might be called from inside function
		}
<span class="nc" id="L1170">		return result;</span>
	}

	@Override
	public Set&lt;ObjectID&gt; getReferencedObjectsIDs(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs) {
<span class="nc bnc" id="L1175" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1176">			LOGGER.debug(&quot;[==Get==] Getting objects &quot; + objectIDs);</span>
		}
<span class="nc" id="L1178">		final Set&lt;ObjectID&gt; result = new HashSet&lt;&gt;();</span>

<span class="nc" id="L1180">		runtime.setCurrentThreadSessionID(sessionID);</span>

<span class="nc bnc" id="L1182" title="All 2 branches missed.">		if (Configuration.mockTesting) {</span>
<span class="nc" id="L1183">			DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
		}

<span class="nc" id="L1186">		final Set&lt;ObjectID&gt; obtainedObjects = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1187">		final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; objectsInOtherBackend = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">		for (final ObjectID objectID : objectIDs) {</span>

<span class="nc" id="L1190">			final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; pendingObjs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1191">			pendingObjs.add(new Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;(objectID, null));</span>
<span class="nc" id="L1192">			final ListIterator&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; it = pendingObjs</span>
<span class="nc" id="L1193">					.listIterator(pendingObjs.size());</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">			while (it.hasPrevious()) {</span>
<span class="nc" id="L1195">				final Tuple&lt;ObjectID, ExecutionEnvironmentID&gt; idAndHint = it.previous();</span>
<span class="nc" id="L1196">				final ObjectID curObID = idAndHint.getFirst();</span>
<span class="nc" id="L1197">				final ExecutionEnvironmentID hint = idAndHint.getSecond();</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1199">					LOGGER.debug(&quot;[==Get==] Getting &quot; + curObID);</span>
				}
<span class="nc" id="L1201">				it.remove();</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">				if (obtainedObjects.contains(curObID)) {</span>
					// Already read
<span class="nc" id="L1204">					continue;</span>
				}
				try {
<span class="nc" id="L1207">					final ObjectWithDataParamOrReturn objWithData = getObjectInternal(curObID, false);</span>

<span class="nc" id="L1209">					obtainedObjects.add(curObID);</span>

					// Get associated objects (recursive)
<span class="nc" id="L1212">					final DataClayObjectMetaData metadata = objWithData.getMetaData();</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">					for (final Entry&lt;Integer, ObjectID&gt; associatedOIDEntry : metadata.getOids().entrySet()) {</span>
<span class="nc" id="L1214">						final Integer tag = associatedOIDEntry.getKey();</span>
<span class="nc" id="L1215">						final ObjectID associatedOID = associatedOIDEntry.getValue();</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">						if (!obtainedObjects.contains(associatedOID)) {</span>
							// add to iterator to also traverse from this point
<span class="nc" id="L1218">							it.add(new Tuple&lt;&gt;(associatedOID, metadata.getHint(tag)));</span>

							// add to results
<span class="nc" id="L1221">							result.add(associatedOID);</span>
						}
<span class="nc" id="L1223">					}</span>
<span class="nc" id="L1224">				} catch (final DbObjectNotExistException e) {</span>
					// TO BE RETRIEVED FROM OTHER BACKEND
<span class="nc" id="L1226">					objectsInOtherBackend.add(new Tuple&lt;&gt;(curObID, hint));</span>
<span class="nc" id="L1227">				}</span>
<span class="nc" id="L1228">			}</span>
<span class="nc" id="L1229">		}</span>

<span class="nc" id="L1231">		result.addAll(getObjectsIDsInOtherBackend(sessionID, objectsInOtherBackend));</span>

<span class="nc" id="L1233">		return result;</span>
	}

	/**
	 * Method that traverses remote objects from given information and looks them up
	 * 
	 * @param sessionID
	 *            id of the current session
	 * @param objectsInOtherBackend
	 *            objects to be found
	 * @return set of found objects with given info
	 */
	private Collection&lt;? extends ObjectID&gt; getObjectsIDsInOtherBackend(final SessionID sessionID,
			final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; objectsInOtherBackend) {
<span class="nc" id="L1247">		final Set&lt;ObjectID&gt; result = new HashSet&lt;&gt;();</span>

		// Prepare to unify calls (only one call for DS)
<span class="nc" id="L1250">		final Map&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; objectsPerBackend = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1252" title="All 2 branches missed.">		for (final Tuple&lt;ObjectID, ExecutionEnvironmentID&gt; curObjectIDEntry : objectsInOtherBackend) {</span>
<span class="nc" id="L1253">			final ObjectID curObjectID = curObjectIDEntry.getFirst();</span>
<span class="nc" id="L1254">			final ExecutionEnvironmentID hint = curObjectIDEntry.getSecond();</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1256">				LOGGER.debug(&quot;[==GetObjectsInOtherBackend==] Looking for metadata of &quot; + curObjectID);</span>
			}
<span class="nc" id="L1258">			final MetaDataInfo mdInfo = runtime.getObjectMetadata(curObjectID);</span>
<span class="nc" id="L1259">			Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locations = null;</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">			if (mdInfo == null) {</span>

				// Object is not registered yet, use Hint
<span class="nc bnc" id="L1263" title="All 2 branches missed.">				if (hint != null) {</span>
<span class="nc" id="L1264">					locations = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1265">					locations.put(hint, this.runtime.getExecutionEnvironmentInfo(hint));</span>
				} else {
					// TODO: review exception design, getObjectMetadata is returning null in case
					// object not registered.
					// WARNING: This exception should not happen here
					// NOTE: if it is a volatile and hint failed, it means that object is actually
					// not registered
<span class="nc" id="L1272">					throw new ObjectNotRegisteredException(curObjectID);</span>
				}
			} else {
<span class="nc" id="L1275">				locations = mdInfo.getLocations();</span>
			}
			// Always obtain from the first location
<span class="nc" id="L1278">			final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; backendSrc = locations.entrySet().iterator()</span>
<span class="nc" id="L1279">					.next();</span>
<span class="nc" id="L1280">			Set&lt;ObjectID&gt; objectsInBackend = objectsPerBackend.get(backendSrc.getValue());</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">			if (objectsInBackend == null) {</span>
<span class="nc" id="L1282">				objectsInBackend = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1283">				objectsPerBackend.put(backendSrc.getValue(), objectsInBackend);</span>
			}
<span class="nc" id="L1285">			objectsInBackend.add(curObjectID);</span>
<span class="nc" id="L1286">		}</span>

		// Now call
<span class="nc bnc" id="L1289" title="All 2 branches missed.">		for (final Entry&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; curEntry : objectsPerBackend.entrySet()) {</span>

<span class="nc" id="L1291">			final ExecutionEnvironment backend = curEntry.getKey();</span>
<span class="nc" id="L1292">			final Set&lt;ObjectID&gt; objectsToGet = curEntry.getValue();</span>
<span class="nc" id="L1293">			final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(backend.getDataClayID());</span>

<span class="nc bnc" id="L1295" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1296">				LOGGER.debug(&quot;[==GetObjectsInOtherBackend==] Get from other location, objects: &quot; + objectsToGet);</span>
			}

<span class="nc" id="L1299">			final Set&lt;ObjectID&gt; curResult = dataServiceApi.getReferencedObjectsIDs(sessionID, objectsToGet);</span>
<span class="nc" id="L1300">			result.addAll(curResult);</span>

<span class="nc" id="L1302">		}</span>
<span class="nc" id="L1303">		return result;</span>
	}

	@Override
	public List&lt;ObjectWithDataParamOrReturn&gt; getFederatedObjects(final DataClayInstanceID extDataClayID,
			final Set&lt;ObjectID&gt; objectIDs) {
<span class="nc bnc" id="L1309" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1310">			LOGGER.debug(&quot;[==Get==] Getting objects &quot; + objectIDs);</span>
		}
<span class="nc" id="L1312">		final List&lt;ObjectWithDataParamOrReturn&gt; result = new ArrayList&lt;&gt;();</span>
		try {
<span class="nc bnc" id="L1314" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1315">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}

			// Check object accessibility
<span class="nc bnc" id="L1319" title="All 2 branches missed.">			for (final ObjectID objectID : objectIDs) {</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">				if (!runtime.getLogicModuleAPI().checkObjectIsFederatedWithDataClayInstance(objectID, extDataClayID)) {</span>
<span class="nc" id="L1321">					return null;</span>
				}
<span class="nc" id="L1323">			}</span>

<span class="nc bnc" id="L1325" title="All 2 branches missed.">			for (final ObjectID objectID : objectIDs) {</span>
<span class="nc" id="L1326">				final ObjectWithDataParamOrReturn objWithData = getObjectInternal(objectID, false);</span>
<span class="nc" id="L1327">				result.add(objWithData);</span>
<span class="nc" id="L1328">			}</span>

		} finally {
			/*
			 * clientLib.removeSessionIDForThread(threadID); if (Configuration.MOCK_TESTING)
			 * { DataClayMockObject.removeCurrentThreadLib(); }
			 */
			// Don't remove since it might be called from inside function
		}
<span class="nc" id="L1337">		return result;</span>

	}

	@Override
	public SerializedParametersOrReturn filterObject(final SessionID sessionID, final ObjectID objectID,
			final String conditions) {
<span class="nc" id="L1344">		final ObjectWithDataParamOrReturn objData = getObjectInternal(objectID, false);</span>
<span class="nc" id="L1345">		final DataClayExecutionObject objectToFilter = (DataClayExecutionObject) objData.getDataClayObject();</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">		if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L1347">			this.runtime.checkSession(objectToFilter.getDataSetID(), sessionID);</span>
		}
<span class="nc" id="L1349">		final List&lt;Object&gt; filtered = objectToFilter.filter(conditions);</span>
<span class="nc" id="L1350">		final List&lt;DataClaySerializable&gt; returns = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1351">		returns.add(new CollectionWrapper(filtered));</span>
<span class="nc" id="L1352">		return DataClaySerializationLib.serializeParamsOrReturn(returns, null, runtime, false, null, false);</span>
	}

	/**
	 * Get object internal function
	 * 
	 * @param objectID
	 *            ID of the object ot get
	 * @param moving
	 *            Indicates we are getting object for a move
	 * @return Object with data
	 */
	private ObjectWithDataParamOrReturn getObjectInternal(final ObjectID objectID, final boolean moving) {
<span class="nc bnc" id="L1365" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1366">			LOGGER.debug(&quot;[==Get==] Getting/Creating instance for &quot; + objectID);</span>
		}
<span class="nc" id="L1368">		ObjectWithDataParamOrReturn objWithData = null;</span>
<span class="nc" id="L1369">		runtime.lock(objectID); // Race condition with gc: make sure GC does not clean the instance while you</span>
		// get it and serialize it.
		try {
<span class="nc" id="L1372">			final DataClayExecutionObject instance = runtime.getOrNewInstanceFromDB(objectID, false);</span>

<span class="nc bnc" id="L1374" title="All 2 branches missed.">			if (moving) {</span>
				// Remove hint in order to avoid hints to be also moved.
<span class="nc" id="L1376">				instance.setHint(null);</span>
			}

<span class="nc" id="L1379">			final List&lt;DataClayObject&gt; pendingObjs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1380">			final ListIterator&lt;DataClayObject&gt; it = pendingObjs.listIterator(pendingObjs.size());</span>
<span class="nc" id="L1381">			objWithData = DataClaySerializationLib.serializeDataClayObjectWithData(instance, runtime, false, null, it,</span>
<span class="nc" id="L1382">					false, instance.getHint(), false);</span>

<span class="nc bnc" id="L1384" title="All 2 branches missed.">			if (instance.isPendingToRegister()) {</span>
				//// FORCE VOLATILE TO BE REGISTERED: why?
<span class="nc" id="L1386">				final byte[] arrBytes = DataClaySerializationLib.serializeForDBGarbageCollection(instance, false, null,</span>
						false);
				// Register object pending to register now in order to be consistent
				// with any process (metadatas...)
<span class="nc" id="L1390">				this.registerAndStorePendingObject(instance, arrBytes, true);</span>
<span class="nc" id="L1391">				instance.setPendingToRegister(false);</span>
			}
<span class="nc" id="L1393">		} catch (final DataClayClassNotFoundException classNotFoundEx) {</span>

			///// COMMENTED: PYTHON SHOULD NOT USE IT ANYMORE. TODO: REMOVE THIS.
			// final byte[] objBytes = this.objectDB.get(objectID);
			// objWithData =
			///// DataClayDeserializationLib.deserializeObjectFromDBBytesIntoObjectData(objectID,
			///// objBytes, runtime);
		} finally {
<span class="nc" id="L1401">			runtime.unlock(objectID);</span>
		}
<span class="nc" id="L1403">		return objWithData;</span>
	}

	/**
	 * Get object in another backend. This function is called from DbHandler in a
	 * recursive get.
	 * 
	 * @param sessionID
	 *            ID of session
	 * @param objectsInOtherNodes
	 *            List of metadata of objects to read. It is useful to avoid
	 *            multiple trips.
	 * @param recursive
	 *            Indicates is recursive
	 * @param moving
	 *            Indicates if moving
	 * @return ID of objects and for each object, its bytes.
	 */
	private List&lt;ObjectWithDataParamOrReturn&gt; getObjectsInOtherBackend(final SessionID sessionID,
			final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; objectsInOtherNodes, final boolean recursive,
			final boolean moving) {

<span class="nc" id="L1425">		final List&lt;ObjectWithDataParamOrReturn&gt; result = new ArrayList&lt;&gt;();</span>

		// Prepare to unify calls (only one call for DS)
<span class="nc" id="L1428">		final Map&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; objectsPerBackend = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1430" title="All 2 branches missed.">		for (final Tuple&lt;ObjectID, ExecutionEnvironmentID&gt; curObjectIDEntry : objectsInOtherNodes) {</span>
<span class="nc" id="L1431">			final ObjectID curObjectID = curObjectIDEntry.getFirst();</span>
<span class="nc" id="L1432">			final ExecutionEnvironmentID hint = curObjectIDEntry.getSecond();</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1434">				LOGGER.debug(&quot;[==GetObjectsInOtherBackend==] Looking for metadata of &quot; + curObjectID);</span>
			}
<span class="nc" id="L1436">			final MetaDataInfo mdInfo = runtime.getObjectMetadata(curObjectID);</span>
<span class="nc" id="L1437">			Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locations = null;</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">			if (mdInfo == null) {</span>

				// Object is not registered yet, use Hint
<span class="nc bnc" id="L1441" title="All 2 branches missed.">				if (hint != null) {</span>
<span class="nc" id="L1442">					locations = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1443">					locations.put(hint, this.runtime.getExecutionEnvironmentInfo(hint));</span>
				} else {
					// TODO: review exception design, getObjectMetadata is returning null in case
					// object not registered.
					// WARNING: This exception should not happen here
					// NOTE: if it is a volatile and hint failed, it means that object is actually
					// not registered
<span class="nc" id="L1450">					throw new ObjectNotRegisteredException(curObjectID);</span>
				}
			} else {
<span class="nc" id="L1453">				locations = mdInfo.getLocations();</span>
			}
			// Always obtain from the first location
<span class="nc" id="L1456">			final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; backendSrc = locations.entrySet().iterator()</span>
<span class="nc" id="L1457">					.next();</span>
<span class="nc" id="L1458">			Set&lt;ObjectID&gt; objectsInBackend = objectsPerBackend.get(backendSrc.getValue());</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">			if (objectsInBackend == null) {</span>
<span class="nc" id="L1460">				objectsInBackend = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1461">				objectsPerBackend.put(backendSrc.getValue(), objectsInBackend);</span>
			}
<span class="nc" id="L1463">			objectsInBackend.add(curObjectID);</span>
<span class="nc" id="L1464">		}</span>

		// Now call
<span class="nc bnc" id="L1467" title="All 2 branches missed.">		for (final Entry&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; curEntry : objectsPerBackend.entrySet()) {</span>

<span class="nc" id="L1469">			final ExecutionEnvironment backend = curEntry.getKey();</span>
<span class="nc" id="L1470">			final Set&lt;ObjectID&gt; objectsToGet = curEntry.getValue();</span>
<span class="nc" id="L1471">			final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(backend.getDataClayID());</span>

<span class="nc bnc" id="L1473" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1474">				LOGGER.debug(&quot;[==Get==] Get from other location, objects: &quot; + objectsToGet);</span>
			}

<span class="nc" id="L1477">			final List&lt;ObjectWithDataParamOrReturn&gt; curResult = dataServiceApi.getObjects(sessionID, objectsToGet,</span>
					recursive, moving);
<span class="nc" id="L1479">			result.addAll(curResult);</span>

<span class="nc" id="L1481">		}</span>
<span class="nc" id="L1482">		return result;</span>
	}

	@Override
	public Map&lt;ObjectID, ExecutionEnvironmentID&gt; removeObjects(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs,
			final boolean recursive, final boolean moving, final ExecutionEnvironmentID newHint) {

<span class="nc" id="L1489">		final Map&lt;ObjectID, ExecutionEnvironmentID&gt; removedObjs = new ConcurrentHashMap&lt;&gt;();</span>
		try {
<span class="nc" id="L1491">			runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1493">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}

<span class="nc" id="L1496">			final List&lt;ObjectID&gt; objectsInOtherBackend = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">			for (final ObjectID objectID : objectIDs) {</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">				if (recursive) {</span>
<span class="nc" id="L1499">					final List&lt;ObjectID&gt; pendingObjs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1500">					pendingObjs.add(objectID);</span>
<span class="nc" id="L1501">					final ListIterator&lt;ObjectID&gt; it = pendingObjs.listIterator(pendingObjs.size());</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">					while (it.hasPrevious()) {</span>
<span class="nc" id="L1503">						final ObjectID curObID = it.previous();</span>
<span class="nc bnc" id="L1504" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1505">							LOGGER.debug(&quot;[==Remove==] Removing &quot; + curObID);</span>
						}

<span class="nc" id="L1508">						it.remove();</span>

<span class="nc bnc" id="L1510" title="All 2 branches missed.">						if (removedObjs.get(curObID) != null) {</span>
							// Already removed
<span class="nc" id="L1512">							continue;</span>
						}
						// If is in this DS, remove it.
<span class="nc" id="L1515">						removedObjs.put(curObID, executionEnvironmentID);</span>
						try {

							// Get bytes from DB first
<span class="nc" id="L1519">							final byte[] objBytes = get(this.executionEnvironmentID, curObID);</span>
							// Remove and check if in memory
<span class="nc" id="L1521">							removeObjectInternal(sessionID, curObID, moving, newHint);</span>
<span class="nc" id="L1522">							final DataClayObjectMetaData metadata = DataClayDeserializationLib</span>
<span class="nc" id="L1523">									.deserializeMetaDataFromDB(objBytes);</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">							for (final ObjectID associatedOID : metadata.getOids().values()) {</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">								if (removedObjs.get(associatedOID) == null) {</span>
<span class="nc" id="L1526">									it.add(associatedOID);</span>
								}
<span class="nc" id="L1528">							}</span>

<span class="nc" id="L1530">						} catch (final DbObjectNotExistException ex) {</span>
<span class="nc" id="L1531">							LOGGER.debug(&quot;Object {} not found in this node, adding to remove in another.&quot;, curObID);</span>
<span class="nc" id="L1532">							LOGGER.debug(&quot;removeObjects error&quot;, ex);</span>
							// REMOVE IN OTHER BACKEND
<span class="nc" id="L1534">							objectsInOtherBackend.add(curObID);</span>
<span class="nc" id="L1535">						}</span>
<span class="nc" id="L1536">					}</span>

<span class="nc" id="L1538">				} else {</span>
<span class="nc" id="L1539">					removeObjectInternal(sessionID, objectID, moving, newHint);</span>
				}
<span class="nc" id="L1541">			}</span>

<span class="nc bnc" id="L1543" title="All 2 branches missed.">			if (recursive) {</span>
<span class="nc" id="L1544">				removedObjs</span>
<span class="nc" id="L1545">				.putAll(removeObjectsInOtherBackend(sessionID, objectsInOtherBackend, true, moving, newHint));</span>
			}

		} finally {
<span class="nc" id="L1549">			runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1551">				DataClayMockObject.removeCurrentThreadLib();</span>
			}

		}
<span class="nc" id="L1555">		return removedObjs;</span>

	}

	/**
	 * Remove object internal function
	 * 
	 * @param sessionID
	 *            ID of session removing
	 * @param objectID
	 *            ID of the object to remove
	 * @param moving
	 *            Indicates remove was done by a movement.
	 * @param newHint
	 *            New hint in case of movement
	 * @throws DbObjectNotExistException
	 *             if object is not in database
	 */
	private void removeObjectInternal(final SessionID sessionID, final ObjectID objectID, final boolean moving,
			final ExecutionEnvironmentID newHint) {
<span class="nc bnc" id="L1575" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1576">			LOGGER.debug(&quot;[==Remove==] Removing object &quot; + objectID);</span>
		}
<span class="nc" id="L1578">		final DataClayExecutionObject instance = runtime.getOrNewInstanceFromDB(objectID, true);</span>
<span class="nc" id="L1579">		runtime.lock(objectID);</span>
		try {
<span class="nc bnc" id="L1581" title="All 2 branches missed.">			if (moving) {</span>
<span class="nc" id="L1582">				this.runtime.setWeakProxy(instance, newHint);</span>
			} else {

<span class="nc" id="L1585">				instance.setPendingToRegister(true);</span>
<span class="nc" id="L1586">				instance.setOwnerSessionIDforVolatiles(sessionID);</span>
<span class="nc" id="L1587">				runtime.removeFromHeap(objectID); // remove old</span>

<span class="nc bnc" id="L1589" title="All 2 branches missed.">				if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>

					// === NOTIFY NOTIFICATION MANAGER === //
					// Removed instance is send as a volatile object!
<span class="nc" id="L1593">					final List&lt;DataClaySerializable&gt; wrappedParams = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L1595">					wrappedParams.add(instance);</span>
<span class="nc" id="L1596">					final SerializedParametersOrReturn serParams = DataClaySerializationLib.serializeParamsOrReturn(</span>
							wrappedParams, null, runtime, false, executionEnvironmentID, false);
<span class="nc" id="L1598">					serParams.removeReferencesForYaml();</span>
<span class="nc" id="L1599">					final MetaDataInfo metadata = runtime.getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L1600" title="All 2 branches missed.">					if (metadata == null) {</span>
						// TODO: review exception design, getObjectMetadata is returning null in case
						// object not registered.
						// WARNING: This exception should not happen here
						// NOTE: if it is a volatile and hint failed, it means that object is actually
						// not registered
<span class="nc" id="L1606">						throw new ObjectNotRegisteredException(objectID);</span>
					}
<span class="nc" id="L1608">					final MetaClassID classID = metadata.getMetaclassID();</span>
<span class="nc" id="L1609">					final EventType eventType = new DeletedObjEventType(classID);</span>
<span class="nc" id="L1610">					final EventMessage eventMsg = new EventMessage(objectID, eventType, serParams);</span>
<span class="nc" id="L1611">					this.runtime.getLogicModuleAPI().adviseEvent(eventMsg);</span>
				}

				// Set object to volatile
<span class="nc" id="L1615">				instance.setNewObjectID();</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1617">					LOGGER.debug(&quot;[==Cache==] Added to objectsMap due to remove &quot; + instance.getObjectID()</span>
<span class="nc" id="L1618">					+ &quot; of class &quot; + instance.getClass().getName() + &quot;. System.id = &quot;</span>
<span class="nc" id="L1619">					+ System.identityHashCode(instance));</span>
				}
<span class="nc" id="L1621">				runtime.addToHeap(instance);</span>
			}

			// ==== REMOVE ==== //
			// Remove object from MD cache and Database
<span class="nc bnc" id="L1626" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1627">				LOGGER.debug(&quot;[==Remove==] Removing metadata info from MetaData Cache: &quot; + objectID);</span>
			}
<span class="nc" id="L1629">			runtime.getMetaDataCache().remove(objectID);</span>
<span class="nc" id="L1630">			this.storageLocation.delete(this.executionEnvironmentID, objectID);</span>

		} finally {
<span class="nc" id="L1633">			runtime.unlock(objectID);</span>
		}

<span class="nc" id="L1636">	}</span>

	/**
	 * Remove objects in another backend.
	 * 
	 * @param sessionID
	 *            ID of session removing
	 * @param objectsInOtherNodes
	 *            List of objects to remove in other backends
	 * @param recursive
	 *            Indicates is recursive
	 * @param moving
	 *            Indicates objects are being removed due to a movement.
	 * @param newHint
	 *            New hint to be set
	 * @return ID of objects and for each object, its BackendID.
	 */
	private Map&lt;ObjectID, ExecutionEnvironmentID&gt; removeObjectsInOtherBackend(final SessionID sessionID,
			final List&lt;ObjectID&gt; objectsInOtherNodes, final boolean recursive, final boolean moving,
			final ExecutionEnvironmentID newHint) {
<span class="nc" id="L1656">		final Map&lt;ObjectID, ExecutionEnvironmentID&gt; result = new ConcurrentHashMap&lt;&gt;();</span>

		// Prepare to unify calls (only one call for DS)
<span class="nc" id="L1659">		final Map&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; objectsPerBackend = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1660" title="All 2 branches missed.">		for (final ObjectID curObjectID : objectsInOtherNodes) {</span>
<span class="nc" id="L1661">			final MetaDataInfo mdInfo = runtime.getObjectMetadata(curObjectID);</span>
<span class="nc bnc" id="L1662" title="All 2 branches missed.">			if (mdInfo == null) {</span>
				// TODO: review exception design, getObjectMetadata is returning null in case
				// object not registered.
				// WARNING: This exception should not happen here
				// NOTE: if it is a volatile and hint failed, it means that object is actually
				// not registered
<span class="nc" id="L1668">				throw new ObjectNotRegisteredException(curObjectID);</span>
			}
<span class="nc" id="L1670">			final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locations = mdInfo.getLocations();</span>
			// Always obtain from the first location
<span class="nc" id="L1672">			final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; backendSrc = locations.entrySet().iterator()</span>
<span class="nc" id="L1673">					.next();</span>
<span class="nc" id="L1674">			Set&lt;ObjectID&gt; objectsInBackend = objectsPerBackend.get(backendSrc.getValue());</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">			if (objectsInBackend == null) {</span>
<span class="nc" id="L1676">				objectsInBackend = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1677">				objectsPerBackend.put(backendSrc.getValue(), objectsInBackend);</span>
			}
<span class="nc" id="L1679">			objectsInBackend.add(curObjectID);</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1681">				LOGGER.debug(&quot;[==Remove==] Removing metadata info from MetaData Cache: &quot; + curObjectID);</span>
			}
<span class="nc" id="L1683">			runtime.getMetaDataCache().remove(curObjectID);</span>
<span class="nc" id="L1684">			result.put(curObjectID, backendSrc.getKey());</span>
<span class="nc" id="L1685">		}</span>

		// Now call
<span class="nc bnc" id="L1688" title="All 2 branches missed.">		for (final Entry&lt;ExecutionEnvironment, Set&lt;ObjectID&gt;&gt; curEntry : objectsPerBackend.entrySet()) {</span>
<span class="nc" id="L1689">			final ExecutionEnvironment backend = curEntry.getKey();</span>
<span class="nc" id="L1690">			final Set&lt;ObjectID&gt; objectsToRemove = curEntry.getValue();</span>
<span class="nc bnc" id="L1691" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1692">				LOGGER.debug(&quot;[==Remove==] Calling remove in other backend for: &quot; + objectsToRemove);</span>
			}
<span class="nc" id="L1694">			final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(backend.getDataClayID());</span>
<span class="nc" id="L1695">			dataServiceApi.removeObjects(sessionID, objectsToRemove, recursive, moving, newHint);</span>

<span class="nc" id="L1697">		}</span>
<span class="nc" id="L1698">		return result;</span>
	}

	@Override
	public Set&lt;ObjectID&gt; newReplica(final SessionID sessionID, final ObjectID objectID, final boolean recursive) {
<span class="nc bnc" id="L1703" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1704">			LOGGER.debug(&quot;[==Replica==] New replica for &quot; + objectID);</span>
		}

		// Get the original object.
<span class="nc" id="L1708">		final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1709">		objectIDs.add(objectID);</span>
<span class="nc" id="L1710">		final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs, recursive, false);</span>

<span class="nc bnc" id="L1712" title="All 2 branches missed.">		for (final ObjectWithDataParamOrReturn objFound : serializedObjs) {</span>
<span class="nc" id="L1713">			objectIDs.add(objFound.getObjectID());</span>
<span class="nc" id="L1714">		}</span>

<span class="nc" id="L1716">		storeObjects(sessionID, serializedObjs, false, null);</span>
<span class="nc" id="L1717">		return objectIDs;</span>

	}

	@Override
	public Tuple&lt;ObjectID, Map&lt;ObjectID, ObjectID&gt;&gt; newVersion(final SessionID sessionID, final ObjectID objectID,
			final MetaDataInfo metadataInfo) {
<span class="nc bnc" id="L1724" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1725">			LOGGER.debug(&quot;[==Version==] New version for &quot; + objectID);</span>
		}

		// Get the data service of one of the backends that contains the original
		// object.
<span class="nc" id="L1730">		final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1731">		objectIDs.add(objectID);</span>

<span class="nc" id="L1733">		final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs, true, false);</span>
		// Prepare OIDs
<span class="nc bnc" id="L1735" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1736">			LOGGER.debug(&quot;[==Version==] Objects obtained to create version for &quot; + objectID);</span>
		}

<span class="nc" id="L1739">		final Map&lt;ObjectID, ObjectID&gt; versionToOriginal = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L1740">		final Map&lt;ObjectID, ObjectID&gt; originalToVersion = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L1741">		final Map&lt;ObjectID, ExecutionEnvironmentID&gt; versionsHints = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1743" title="All 2 branches missed.">		for (final ObjectWithDataParamOrReturn curEntry : serializedObjs) {</span>
			// Store version in this backend (if already stored, just skip it)
<span class="nc" id="L1745">			final ObjectID origObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1746">			final ObjectID versionObjectID = new ObjectID();</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1748">				LOGGER.debug(&quot;[==Version==] Creating version {} -&gt; {} &quot;, origObjectID, versionObjectID);</span>
			}
<span class="nc" id="L1750">			versionToOriginal.put(versionObjectID, origObjectID);</span>
<span class="nc" id="L1751">			originalToVersion.put(origObjectID, versionObjectID);</span>
<span class="nc" id="L1752">			versionsHints.put(versionObjectID, this.runtime.getHint());</span>
<span class="nc" id="L1753">		}</span>

<span class="nc bnc" id="L1755" title="All 2 branches missed.">		for (final ObjectWithDataParamOrReturn curEntry : serializedObjs) {</span>
			// Store version in this backend (if already stored, just skip it)
<span class="nc" id="L1757">			final ObjectID origObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1758">			final ObjectID versionObjectID = originalToVersion.get(origObjectID);</span>
<span class="nc" id="L1759">			DataClaySerializationLib.modifyMetadataOIDs(curEntry, originalToVersion, versionsHints);</span>
<span class="nc" id="L1760">			curEntry.setObjectID(versionObjectID);</span>
<span class="nc" id="L1761">		}</span>

		// Store versions
<span class="nc bnc" id="L1764" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1765">			LOGGER.debug(&quot;[==Version==] Storing version for &quot; + objectID);</span>
		}
<span class="nc" id="L1767">		this.storeObjects(sessionID, serializedObjs, false, null);</span>

		// Store version metadata in the cache of this dataservice
		// NOTE: MD of subobjects is also stored in cache while 'getting bytes' from
		// other backends.
<span class="nc" id="L1772">		final ObjectID versionID = originalToVersion.get(objectID);</span>
<span class="nc" id="L1773">		final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; environments = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L1774">		environments.put(executionEnvironmentID, runtime.getExecutionEnvironmentInfo(executionEnvironmentID));</span>

<span class="nc" id="L1776">		final MetaDataInfo versionMD = new MetaDataInfo(metadataInfo.getDataClayID(), metadataInfo.getDatasetID(),</span>
<span class="nc" id="L1777">				metadataInfo.getMetaclassID(), false, environments, null, metadataInfo.getOwnerID());</span>
<span class="nc bnc" id="L1778" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1779">			LOGGER.debug(&quot;[==Version==] Added metadata info to MetaData Cache: &quot; + versionID + &quot; : &quot;</span>
<span class="nc" id="L1780">					+ versionMD.getLocations().values());</span>
		}
<span class="nc" id="L1782">		runtime.getMetaDataCache().put(versionID, versionMD);</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1784">			LOGGER.debug(&quot;[==Version==] Version finished for &quot; + objectID + &quot; with id &quot; + versionID);</span>
		}
<span class="nc" id="L1786">		return new Tuple&lt;&gt;(versionID, versionToOriginal);</span>
	}

	@Override
	public void consolidateVersion(final SessionID sessionID, final VersionInfo version) {

<span class="nc bnc" id="L1792" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1793">			LOGGER.debug(&quot;[==Consolidate==] Consolidating &quot; + version.getVersionOID() + &quot; to &quot;</span>
<span class="nc" id="L1794">					+ version.getVersionsMapping().get(version.getVersionOID()));</span>
		}

		// Consolidate in this backend - the complete version is here
<span class="nc" id="L1798">		final Map&lt;ObjectID, ObjectID&gt; versionToOriginal = version.getVersionsMapping();</span>
<span class="nc" id="L1799">		final Map&lt;ObjectID, ExecutionEnvironmentID&gt; originalHints = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">		for (final ObjectID originalOID : versionToOriginal.values()) {</span>
<span class="nc" id="L1801">			final MetaDataInfo originalMD = version.getOriginalMD().get(originalOID);</span>
<span class="nc" id="L1802">			originalHints.put(originalOID, originalMD.getLocations().keySet().iterator().next());</span>
<span class="nc" id="L1803">		}</span>

		// Get bytes of all version objects
<span class="nc" id="L1806">		final Set&lt;ObjectID&gt; versionObjectIDs = versionToOriginal.keySet();</span>
<span class="nc" id="L1807">		final List&lt;ObjectWithDataParamOrReturn&gt; versionsBytes = getObjects(sessionID, versionObjectIDs, true, false);</span>

		// Update original objects
<span class="nc bnc" id="L1810" title="All 2 branches missed.">		for (final ObjectWithDataParamOrReturn versionBytesEntry : versionsBytes) {</span>
<span class="nc" id="L1811">			final ObjectID versionID = versionBytesEntry.getObjectID();</span>
<span class="nc" id="L1812">			final ObjectID originalObjectID = versionToOriginal.get(versionID);</span>
			// Modify metadata to use new Object IDs
<span class="nc bnc" id="L1814" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1815">				LOGGER.debug(</span>
						&quot;[==Consolidate==] Modify oids of version &quot; + versionID + &quot; to original &quot; + originalObjectID);
			}
<span class="nc" id="L1818">			DataClaySerializationLib.modifyMetadataOIDs(versionBytesEntry, versionToOriginal, originalHints);</span>
<span class="nc" id="L1819">			versionBytesEntry.setObjectID(originalObjectID);</span>
<span class="nc" id="L1820">		}</span>
<span class="nc" id="L1821">		ExecutionEnvironmentID destLoc = null;</span>
		try {
<span class="nc" id="L1823">			runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1825">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}

			// Update original objects (here and in other DSs - replicas)
<span class="nc" id="L1829">			final ObjectID origOID = versionToOriginal.get(version.getVersionOID());</span>
<span class="nc" id="L1830">			final MetaDataInfo mdInfo = version.getOriginalMD().get(origOID);</span>
<span class="nc" id="L1831">			final Map&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; locs = mdInfo.getLocations();</span>
<span class="nc bnc" id="L1832" title="All 2 branches missed.">			for (final Entry&lt;ExecutionEnvironmentID, ExecutionEnvironment&gt; loc : locs.entrySet()) {</span>
<span class="nc" id="L1833">				destLoc = loc.getKey();</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">				if (destLoc.equals(this.executionEnvironmentID)) {</span>
<span class="nc" id="L1835">					this.upsertObjects(sessionID, versionsBytes);</span>
				} else {
<span class="nc" id="L1837">					final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(destLoc);</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1839">						LOGGER.debug(&quot;[==Consolidate==] Going to other DS to upsert &quot;</span>
<span class="nc" id="L1840">								+ versionToOriginal.get(version.getVersionOID()));</span>
					}
<span class="nc" id="L1842">					dataServiceApi.upsertObjects(sessionID, versionsBytes);</span>
				}
<span class="nc" id="L1844">			}</span>

			// Delete versions here
<span class="nc" id="L1847">			this.removeObjects(sessionID, versionObjectIDs, true, false, destLoc);</span>

		} finally {
<span class="nc" id="L1850">			runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L1851" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1852">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
		}

<span class="nc" id="L1856">	}</span>

	@Override
	public Tuple&lt;Map&lt;StorageLocationID, Set&lt;ObjectID&gt;&gt;, Set&lt;ObjectID&gt;&gt; migrateObjectsToBackends(
			final Map&lt;StorageLocationID, StorageLocation&gt; backends) {
<span class="nc" id="L1861">		throw new UnsupportedOperationException();</span>
	}

	@Override
	public Set&lt;ObjectID&gt; moveObjects(final SessionID sessionID, final ObjectID objectID,
			final ExecutionEnvironmentID destLocation, final boolean recursive) {
<span class="nc" id="L1867">		final Set&lt;ObjectID&gt; updateMetadataof = new HashSet&lt;&gt;();</span>

		try {
<span class="nc" id="L1870">			runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1872">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}
<span class="nc bnc" id="L1874" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1875">				LOGGER.debug(&quot;[==MOVE==] Moving object &quot; + objectID + &quot; to storage location: &quot; + destLocation);</span>
			}
<span class="nc" id="L1877">			final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
			// Get the the original object.
<span class="nc" id="L1879">			objectIDs.add(objectID);</span>

<span class="nc" id="L1881">			final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs, recursive, true);</span>

<span class="nc" id="L1883">			final Set&lt;ObjectID&gt; objectsToRemove = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1884">			final List&lt;ObjectWithDataParamOrReturn&gt; objectsToMove = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1886" title="All 2 branches missed.">			for (final ObjectWithDataParamOrReturn objFound : serializedObjs) {</span>

				// The object is not here (it comes from another node due to GET) but
				// it must be stored here
<span class="nc bnc" id="L1890" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1891">					LOGGER.debug(&quot;[==MOVE==] Looking for metadata of &quot; + objFound.getObjectID());</span>
				}
<span class="nc" id="L1893">				final MetaDataInfo metadata = runtime.getObjectMetadata(objFound.getObjectID());</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">				if (metadata == null) {</span>
					// TODO: review exception design, getObjectMetadata is returning null in case
					// object not registered.
					// WARNING: This exception should not happen here
					// NOTE: if it is a volatile and hint failed, it means that object is actually
					// not registered
<span class="nc" id="L1900">					throw new ObjectNotRegisteredException(objFound.getObjectID());</span>
				}
<span class="nc" id="L1902">				final ExecutionEnvironmentID objLocation = metadata.getLocations().keySet().iterator().next();</span>

<span class="nc bnc" id="L1904" title="All 2 branches missed.">				if (objLocation.equals(destLocation)) {</span>
<span class="nc bnc" id="L1905" title="All 2 branches missed.">					if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1906">						LOGGER.debug(&quot;[==MOVE==] Ignoring move of object  &quot; + objFound.getObjectID()</span>
						+ &quot; since it is already where it should be. ObjLoc = &quot; + objLocation + &quot; and DestLoc = &quot;
						+ destLocation);
					}
					// object already in dest
					continue;
				} else {
<span class="nc bnc" id="L1913" title="All 2 branches missed.">					if (this.executionEnvironmentID.equals(destLocation)) {</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1915">							LOGGER.debug(&quot;[==MOVE==] Ignoring move of object  &quot; + objFound.getObjectID()</span>
							+ &quot; since it is already where it should be&quot; + &quot; ObjLoc = &quot; + objLocation
							+ &quot; and DestLoc = &quot; + destLocation);
						}
					} else {
<span class="nc bnc" id="L1920" title="All 2 branches missed.">						if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1921">							LOGGER.debug(&quot;[==MOVE==] Moving object  &quot; + objFound.getObjectID()</span>
							+ &quot; since dest.location is different to src.location and object is not in dest.location &quot;
							+ &quot; ObjLoc = &quot; + objLocation + &quot; and DestLoc = &quot; + destLocation);
						}
						// THE DESTINATION IS ANOTHER NODE: move.
<span class="nc" id="L1926">						objectsToMove.add(objFound);</span>
<span class="nc" id="L1927">						objectsToRemove.add(objFound.getObjectID());</span>
<span class="nc" id="L1928">						updateMetadataof.add(objFound.getObjectID());</span>
					}
				}

<span class="nc" id="L1932">			}</span>

<span class="nc bnc" id="L1934" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1935">				LOGGER.debug(&quot;[==MOVE==] Finally moving OBJECTS:  &quot; + objectsToRemove);</span>
			}

			// REMOVE IN OTHER BACKEND
<span class="nc" id="L1939">			final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(destLocation);</span>
			// Now move all objects to the destination location.
<span class="nc" id="L1941">			dataServiceApi.storeObjects(sessionID, objectsToMove, true, null);</span>

			// TODO: lock any execution in remove before storing objects in remote
			// dataservice
			// so anyone can modify it.

			// Remove after store in order to avoid wrong executions during the movement :)
			// Remove all objects in all source locations different to dest. location
<span class="nc" id="L1949">			this.removeObjects(sessionID, objectIDs, recursive, true, destLocation);</span>

			// Remove entries
<span class="nc bnc" id="L1952" title="All 2 branches missed.">			for (final ObjectID oid : objectsToRemove) {</span>
<span class="nc" id="L1953">				runtime.getMetaDataCache().remove(oid);</span>
<span class="nc" id="L1954">			}</span>

<span class="nc bnc" id="L1956" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1957">				LOGGER.debug(&quot;[==MOVE==] Move finalized &quot;);</span>
			}

<span class="nc" id="L1960">		} catch (</span>

				final Exception ex) {
<span class="nc" id="L1963">			LOGGER.debug(&quot;moveObjects error&quot;, ex);</span>

		} finally {
<span class="nc" id="L1966">			runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1968">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
		}

<span class="nc" id="L1972">		return updateMetadataof;</span>

	}

	@Override
	public MetaClassID getClassIDFromObjectInMemory(final ObjectID objectID) {
		try {
<span class="nc bnc" id="L1979" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1980">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}
<span class="nc" id="L1982">			final DataClayObject dcObject = runtime.getFromHeap(objectID);</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">			if (dcObject != null) {</span>
<span class="nc" id="L1984">				return dcObject.getMetaClassID();</span>
			}
		} finally {
<span class="nc bnc" id="L1987" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L1988">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
		}
<span class="nc" id="L1991">		return null;</span>
	}

	/**
	 * Update or store object.
	 * 
	 * @param instance
	 *            Object to update in DB.
	 */
	public void gcCollectObjectInternal(final DataClayExecutionObject instance) {
		// =================== UPDATE DATABASE ===================//
		// We update the set of associated objects if new objects were associated or
		// deleted.
<span class="nc bnc" id="L2004" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2005">			LOGGER.debug(&quot;[==GC==] Collecting object &quot; + instance.getObjectID());</span>
		}

<span class="nc bnc" id="L2008" title="All 2 branches missed.">		if (instance.isPendingToRegister()) {</span>
<span class="nc bnc" id="L2009" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2010">				LOGGER.debug(&quot;[==GC==] Serializing pending instance &quot;);</span>
			}
		}

<span class="nc bnc" id="L2014" title="All 2 branches missed.">		if (instance.isPendingToRegister()) {</span>
<span class="nc" id="L2015">			final byte[] arrBytes = DataClaySerializationLib.serializeForDBGarbageCollection(instance, false, null,</span>
					false);
<span class="nc" id="L2017">			registerAndStorePendingObject(instance, arrBytes, false);</span>
<span class="nc" id="L2018">			instance.setPendingToRegister(false);</span>

<span class="nc bnc" id="L2020" title="All 2 branches missed.">		} else if (instance.isDirty()) {</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2022">				LOGGER.debug(</span>
<span class="nc" id="L2023">						&quot;[==GC==] Going to update dirty object in database object with ID &quot; + instance.getObjectID());</span>
			}
<span class="nc" id="L2025">			final byte[] arrBytes = DataClaySerializationLib.serializeForDBGarbageCollection(instance, false, null,</span>
					false);
<span class="nc" id="L2027">			this.storageLocation.update(this.executionEnvironmentID, instance.getObjectID(), arrBytes, true);</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2029">				final StringBuilder strBuilder = new StringBuilder();</span>
<span class="nc" id="L2030">				strBuilder.append(&quot;Updated object of class &quot;);</span>
<span class="nc" id="L2031">				strBuilder.append(instance.getClass().getName());</span>
<span class="nc" id="L2032">				strBuilder.append(&quot; with Object ID &quot; + instance.getObjectID());</span>
<span class="nc" id="L2033">				strBuilder.append(&quot; with size = &quot; + arrBytes.length + &quot; bytes&quot;);</span>
<span class="nc" id="L2034">				LOGGER.debug(&quot;[==GC==]&quot; + strBuilder.toString());</span>
			}

			// TODO: Think which DataSet should be assigned to object (dgasull 2017)
			/*
			 * if (instance.getDataSetID() != null) {
			 * this.runtime.getLogicModuleAPI().setDataSetIDFromGarbageCollector(instance.
			 * getObjectID(), instance.getDataSetID()); }
			 */

<span class="nc" id="L2044">		} else {</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">			if (Configuration.Flags.GLOBAL_GC_ENABLED.getBooleanValue()) {</span>
<span class="nc bnc" id="L2046" title="All 2 branches missed.">				if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2047">					LOGGER.debug(</span>
<span class="nc" id="L2048">							&quot;[==GC==] Going to notify not dirty object to GlobalGC with ID &quot; + instance.getObjectID());</span>
				}
<span class="nc" id="L2050">				final byte[] arrBytes = DataClaySerializationLib.serializeForDBGarbageCollection(instance, false, null,</span>
						true);
<span class="nc bnc" id="L2052" title="All 2 branches missed.">				if (arrBytes != null) {</span>
<span class="nc" id="L2053">					final byte[] refCountingBytes = DataClayDeserializationLib.extractReferenceCounting(arrBytes);</span>
<span class="nc" id="L2054">					this.storageLocation.update(this.executionEnvironmentID, instance.getObjectID(), refCountingBytes,</span>
							false);

<span class="nc" id="L2057">				} else {</span>
<span class="nc" id="L2058">					LOGGER.debug(&quot;[==GC==] Found very volatile not modified (not sending to Disk) with ID &quot;</span>
<span class="nc" id="L2059">							+ instance.getObjectID());</span>
				}
			}
		}

<span class="nc" id="L2064">	}</span>

	/**
	 * Register and store pending object
	 * 
	 * @param instance
	 *            Instance to register
	 * @param arrBytes
	 *            Persistent object
	 * @param sync
	 *            Indicates if register is synchronous or asynchronous
	 */
	private void registerAndStorePendingObject(final DataClayExecutionObject instance, final byte[] arrBytes,
			final boolean sync) {

<span class="nc bnc" id="L2079" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2080">			LOGGER.debug(</span>
<span class="nc" id="L2081">					&quot;[==RegisterPending==] Registering pending object with ID &quot; + instance.getObjectID() + &quot; of class &quot;</span>
<span class="nc" id="L2082">							+ instance.getClass().getName() + &quot;. System.id = &quot; + System.identityHashCode(instance));</span>
		}

<span class="nc" id="L2085">		this.storageLocation.store(this.executionEnvironmentID, instance.getObjectID(), arrBytes);</span>

		// Inform MDS about new object !
<span class="nc" id="L2088">		final Map&lt;ObjectID, MetaClassID&gt; storedObjs = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L2089">		storedObjs.put(instance.getObjectID(), instance.getMetaClassID());</span>

<span class="nc" id="L2091">		final RegistrationInfo regInfo = new RegistrationInfo(instance.getObjectID(), instance.getMetaClassID(),</span>
<span class="nc" id="L2092">				instance.getOwnerSessionIDforVolatiles(), instance.getDataSetID());</span>

<span class="nc bnc" id="L2094" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2095">			LOGGER.debug(&quot;[==RegisterPending==] Going to register &quot; + regInfo + &quot; for instance &quot;</span>
<span class="nc" id="L2096">					+ System.identityHashCode(instance));</span>
		}
		try {
<span class="nc bnc" id="L2099" title="All 2 branches missed.">			if (sync) {</span>
<span class="nc" id="L2100">				this.runtime.getLogicModuleAPI().registerObject(regInfo, executionEnvironmentID, null, Langs.LANG_JAVA);</span>
			} else {
<span class="nc" id="L2102">				this.runtime.getLogicModuleAPI().registerObjectFromGC(regInfo, executionEnvironmentID, this.runtime);</span>
			}
<span class="nc" id="L2104">		} catch (final Exception e) {</span>
			// object already registered due to add alias

<span class="nc" id="L2107">		}</span>

<span class="nc" id="L2109">	}</span>

	/**
	 * Register all pending objects
	 */
	@Override
	public void registerPendingObjects() {
<span class="nc" id="L2116">		throw new UnsupportedOperationException();</span>
	}

	// ============================== LAZY TASKS ==================== //

	/**
	 * Add lazy task
	 * 
	 * @param objectID
	 *            ID of the object
	 * @param lazyTask
	 *            Lazy task
	 */
	public void addLazyTask(final ObjectID objectID, final LazyTask lazyTask) {
<span class="nc" id="L2130">		this.lazyTasksRunner.addLazyTask(objectID, lazyTask);</span>
<span class="nc" id="L2131">	}</span>

	// ============================== GLOBAL DISK GC ==================== //

	/**
	 * Execute lazy task
	 * 
	 * @param implID
	 *            ID of the task to execute
	 * @param paramObjectID
	 *            ID of the parameter
	 * @param sessionID
	 *            ID of the session
	 * @param classID
	 *            ID of the class
	 */
	public void executeLazyTask(final ImplementationID implID, final ObjectID paramObjectID, final SessionID sessionID,
			final MetaClassID classID) {
		// TODO: check session?
		try {
			// create lots of objects here and stash them somewhere
<span class="nc bnc" id="L2152" title="All 2 branches missed.">			if (sessionID != null) {</span>
<span class="nc" id="L2153">				runtime.setCurrentThreadSessionID(sessionID);</span>
			}
<span class="nc bnc" id="L2155" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L2156">				DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
			}

<span class="nc bnc" id="L2159" title="All 2 branches missed.">			if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2160">				LOGGER.debug(&quot;[==Execution==] ** New execution ** Executing task &quot; + implID);</span>

			}

			// ============================ DESERIALIZE PARAMETERS
			// ============================ //
<span class="nc" id="L2166">			final DataClayObject paramInstance = runtime.getOrNewInstanceFromDB(paramObjectID, true);</span>
<span class="nc" id="L2167">			final Object[] loadedparams = new Object[] { paramInstance };</span>

			// =================================== GET INSTANCE
			// ===================================//
			// We must instantiate an object of the execution class

			// SIMILAR TO NEW PERSISTENT INSTANCE

			// final DataClayObject instance = DataClayClassLoaderSrv.newInstance(classID,
			// new ObjectID(),
			// DataClayObjectState.VOLATILE_SERVER);
			// this.runImplementation(instance, implID, loadedparams);

<span class="nc" id="L2180">			final Class&lt;?&gt; clazz = DataClayClassLoaderSrv.getClass(classID);</span>
<span class="nc" id="L2181">			final StubInfo stubInfo = DataClayObject.getStubInfoFromClass(clazz.getName());</span>

<span class="nc" id="L2183">			final ImplementationStubInfo implStubInfo = stubInfo.getImplementationByID(implID.toString());</span>
<span class="nc" id="L2184">			final String signature = implStubInfo.getSignature();</span>

			/*
			 * final UserType paramType = (UserType) implStubInfo.getParameters().get(0);
			 * final Class&lt;?&gt; paramClass =
			 * DataClayClassLoaderSrv.getClass(paramType.getClassID());
			 */

			// ============================= EXECUTE =========================== //

<span class="nc" id="L2194">			final String methodName = signature.split(&quot;\\(&quot;)[0];</span>

<span class="nc" id="L2196">			Class&lt;?&gt; paramClass = paramInstance.getClass();</span>
<span class="nc" id="L2197">			boolean notExecuted = true;</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">			while (notExecuted) {</span>
				try {
<span class="nc" id="L2200">					clazz.getMethod(methodName, paramClass).invoke(null, loadedparams);</span>
<span class="nc" id="L2201">					notExecuted = false;</span>
<span class="nc" id="L2202">				} catch (final java.lang.NoSuchMethodException err) {</span>
<span class="nc" id="L2203">					paramClass = paramClass.getSuperclass();</span>
<span class="nc" id="L2204">				}</span>
			}

			// clazz.getMethod(methodName, paramClass).invoke(null, loadedparams);

<span class="nc" id="L2209">		} catch (final StatusRuntimeException sterr) {</span>
<span class="nc" id="L2210">			LOGGER.debug(&quot;[==Execution==] Error at task of parameter object {} and implementation {}&quot;, paramObjectID,</span>
					implID);
<span class="nc" id="L2212">			LOGGER.debug(&quot;executeLazyTask got a StatusRuntimeException&quot;, sterr);</span>
<span class="nc" id="L2213">			throw sterr;</span>
<span class="nc" id="L2214">		} catch (final DataClayException de) {</span>
<span class="nc" id="L2215">			LOGGER.debug(&quot;[==Execution==] Error at task of parameter object {} and implementation {}&quot;, paramObjectID,</span>
					implID);
<span class="nc" id="L2217">			LOGGER.debug(&quot;executeLazyTask got a native DataClayException&quot;, de);</span>
<span class="nc" id="L2218">			throw de;</span>
<span class="nc" id="L2219">		} catch (final Exception ex) {</span>
<span class="nc" id="L2220">			LOGGER.debug(&quot;[==Execution==] Error at task of parameter object {} and implementation {}&quot;, paramObjectID,</span>
					implID);
<span class="nc" id="L2222">			LOGGER.debug(&quot;executeLazyTask got an error&quot;, ex);</span>
<span class="nc" id="L2223">			throw new JavaExecutionException(ex);</span>
<span class="nc" id="L2224">		} catch (final Error err) {</span>
<span class="nc" id="L2225">			LOGGER.debug(&quot;executeLazyTask got a ``true'' error&quot;, err);</span>
<span class="nc" id="L2226">			throw new JavaExecutionException(err);</span>
		} finally {
<span class="nc bnc" id="L2228" title="All 2 branches missed.">			if (Configuration.mockTesting) {</span>
<span class="nc" id="L2229">				DataClayMockObject.removeCurrentThreadLib();</span>
			}
<span class="nc" id="L2231">			runtime.removeCurrentThreadSessionID();</span>
		}

<span class="nc" id="L2234">	}</span>

	@Override
	public boolean existsInEE(final ObjectID objectID) {
<span class="nc bnc" id="L2238" title="All 2 branches missed.">		if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2239">			LOGGER.debug(&quot;[==Exists==] Checking if object {} exists in current EE&quot;, objectID);</span>
		}
<span class="nc" id="L2241">		final boolean inheap = this.runtime.existsInHeap(objectID);</span>
<span class="nc bnc" id="L2242" title="All 2 branches missed.">		if (inheap) {</span>
<span class="nc" id="L2243">			final DataClayExecutionObject obj = this.runtime.getFromHeap(objectID);</span>
			// object might be in heap but as a &quot;proxy&quot;
			// since this function is used from SL after checking if the object is in
			// database,
			// we return false if the object is not loaded so the combination of SL exists
			// and EE exists
			// can tell if the object actually exists
			// summary: the object only exist in EE if it is loaded.
<span class="nc" id="L2251">			return obj.isLoaded();</span>

		} else {
<span class="nc" id="L2254">			return false;</span>
		}
	}

	@Override
	public boolean exists(final ObjectID objectID) {
<span class="nc" id="L2260">		return this.storageLocation.exists(objectID);</span>
	}

	@Override
	public void closeSessionInDS(final SessionID sessionID) {
<span class="nc" id="L2265">		this.runtime.closeSessionInEE(sessionID);</span>
<span class="nc" id="L2266">	}</span>

	@Override
	public void store(final ExecutionEnvironmentID eeID, final ObjectID objectID, final byte[] bytes) {
<span class="nc" id="L2270">		this.storageLocation.store(eeID, objectID, bytes);</span>
<span class="nc" id="L2271">	}</span>

	/**
	 * Get from this DB
	 * 
	 * @param objectID
	 *            ID of the object
	 * @return Bytes of object
	 */
	public byte[] getLocal(final ObjectID objectID) {
<span class="nc" id="L2281">		return this.storageLocation.get(this.executionEnvironmentID, objectID);</span>
	}

	@Override
	public byte[] get(final ExecutionEnvironmentID eeID, final ObjectID objectID) {
<span class="nc" id="L2286">		return this.storageLocation.get(eeID, objectID);</span>
	}

	@Override
	public void update(final ExecutionEnvironmentID eeID, final ObjectID objectID, final byte[] newbytes,
			final boolean dirty) {
<span class="nc" id="L2292">		this.storageLocation.update(eeID, objectID, newbytes, dirty);</span>
<span class="nc" id="L2293">	}</span>

	@Override
	public void delete(final ExecutionEnvironmentID eeID, final ObjectID objectID) {
<span class="nc" id="L2297">		this.storageLocation.delete(eeID, objectID);</span>
<span class="nc" id="L2298">	}</span>

	@Override
	public void updateRefs(final Map&lt;ObjectID, Integer&gt; updateCounterRefs) {
<span class="nc" id="L2302">		this.storageLocation.updateRefs(updateCounterRefs);</span>
<span class="nc" id="L2303">	}</span>

	@Override
	public Set&lt;ObjectID&gt; getRetainedReferences() {
<span class="nc" id="L2307">		return runtime.getRetainedReferences();</span>
	}



	// ============= OTHER =========== //

	@Override
	public void cleanExecutionClassDirectory() {
<span class="nc" id="L2316">		cleanExecutionClasses();</span>
<span class="nc" id="L2317">	}</span>

	/**
	 * Static function for cleaning paths. Static so can be called even if DS is not
	 * running.
	 */
	public static void cleanExecutionClasses() {
		try {

<span class="nc" id="L2326">			DataClayClassLoaderSrv.cleanCaches();</span>
<span class="nc" id="L2327">			File f = new File(Configuration.Flags.EXECUTION_CLASSES_PATH.getStringValue());</span>
<span class="nc bnc" id="L2328" title="All 2 branches missed.">			if (f.exists()) {</span>
<span class="nc" id="L2329">				FileAndAspectsUtils.deleteFolderContent(f);</span>
			}
<span class="nc" id="L2331">		} catch (final Exception ex) {</span>
<span class="nc" id="L2332">			LOGGER.debug(&quot;cleanExecutionClasses error&quot;, ex);</span>
<span class="nc" id="L2333">			throw new CleanExecutionClassesDirException(ex.getLocalizedMessage());</span>
<span class="nc" id="L2334">		}</span>
<span class="nc" id="L2335">	}</span>

	@Override
	public void cleanCaches() {
<span class="nc" id="L2339">		runtime.cleanCaches();</span>
<span class="nc" id="L2340">	}</span>

	/**
	 * Get DbHandler. Used for testing purposes.
	 * 
	 * @return DbHandler.
	 */
	public DBHandler getDbHandler() {
<span class="nc" id="L2348">		return this.storageLocation.getDbHandler(this.executionEnvironmentID);</span>
	}

	@Override
	public void closeDbHandler() {
<span class="nc" id="L2353">		this.storageLocation.closeDbHandler(this.executionEnvironmentID);</span>
<span class="nc" id="L2354">	}</span>

	@Override
	public void activateTracing(final int currentAvailableTaskID) {
<span class="nc" id="L2358">		DataClayExtrae.setCurrentAvailableTaskID(currentAvailableTaskID);</span>
<span class="nc" id="L2359">		DataClayExtrae.initializeExtrae(true);</span>

<span class="nc" id="L2361">	}</span>

	@Override
	public void deactivateTracing() {
<span class="nc" id="L2365">		DataClayExtrae.finishTracing(true);</span>
<span class="nc" id="L2366">	}</span>

	@Override
	public Map&lt;String, byte[]&gt; getTraces() { 
<span class="nc" id="L2370">		return DataClayExtrae.getTraces();</span>
	}

	/**
	 * Finish cache threads.
	 * 
	 * @if some exception occurs
	 */
	public void finishCacheThreads() {
<span class="nc" id="L2379">		this.runtime.finishCacheThreads();</span>
<span class="nc" id="L2380">	}</span>

	/**
	 * Finish connections in DS.
	 * 
	 * @throws Exception
	 *             if some exception occurs
	 */
	public void finishClientConnections() {
<span class="nc bnc" id="L2389" title="All 2 branches missed.">		if (this.runtime != null) {</span>
<span class="nc" id="L2390">			this.runtime.finishConnections();</span>
		}

<span class="nc" id="L2393">	}</span>

	/**
	 * Unregister the data service from the logic module.
	 */
	public void unregisterFromLogicModule() {
<span class="nc" id="L2399">		runtime.getLogicModuleAPI().unregisterExecutionEnvironment(executionEnvironmentID);</span>
<span class="nc" id="L2400">		runtime.getLogicModuleAPI().unregisterStorageLocation(storageLocationID);</span>
<span class="nc" id="L2401">	}</span>

	@Override
	public void shutDown() {
<span class="nc" id="L2405">		ownServer.stopService();</span>
<span class="nc" id="L2406">	}</span>

	@Override
	public void disconnectFromOthers() {
<span class="nc" id="L2410">		ownServer.disconnectFromOthers();</span>
<span class="nc" id="L2411">	}</span>

	/**
	 * Return number of references pointing to object.
	 * 
	 * @param objectID
	 *            ID of object
	 * @return Number of references pointing to object
	 */
	public int getNumReferencesTo(final ObjectID objectID) {
<span class="nc" id="L2421">		return this.storageLocation.getNumReferencesTo(objectID);</span>
	}

	/**
	 * Only for testing and SL representing a storage location, get storage location
	 * service.
	 * 
	 * @return storageLocation service
	 */
	public StorageLocationService getStorageLocationService() {
<span class="nc" id="L2431">		return this.storageLocation;</span>
	}

	/**
	 * Notify LM current execution environment left
	 */
	public void notifyExecutionEnvironmentShutdown() {
<span class="nc" id="L2438">		final LogicModuleAPI lmAPI = this.runtime.getLogicModuleAPI();</span>
<span class="nc" id="L2439">		lmAPI.notifyExecutionEnvironmentShutdown(this.executionEnvironmentID);</span>
<span class="nc" id="L2440">	}</span>

	/**
	 * Notify LM current storage location left
	 */
	public void notifyStorageLocationShutdown() {
<span class="nc" id="L2446">		final LogicModuleAPI lmAPI = this.runtime.getLogicModuleAPI();</span>
<span class="nc" id="L2447">		lmAPI.notifyStorageLocationShutdown(this.storageLocationID);</span>
<span class="nc" id="L2448">	}</span>

	
	/**
	 * Wait for all execution environments associated to current data service to finish and return
	 */
	public void waitForExecutionEnvironmentsToFinish() {
<span class="nc" id="L2455">		final LogicModuleAPI lmAPI = this.runtime.getLogicModuleAPI();</span>
		while (true) {
<span class="nc bnc" id="L2457" title="All 2 branches missed.">			if (!lmAPI.existsActiveEnvironmentsForSL(this.storageLocationID)) {</span>
<span class="nc" id="L2458">				break;</span>
			}
			try {
<span class="nc" id="L2461">				LOGGER.info(&quot;Waiting for EEs associated to current SL to finish ...&quot;);</span>
<span class="nc" id="L2462">				Thread.sleep(Configuration.Flags.SLEEP_WAIT_SHUTDOWN.getLongValue());</span>
<span class="nc" id="L2463">			} catch (final InterruptedException ie) {</span>
<span class="nc" id="L2464">				LOGGER.warn(&quot;Connection to LM interrupted. Shutting down DS&quot;);</span>
<span class="nc" id="L2465">				break;</span>
<span class="nc" id="L2466">			}</span>
		}
<span class="nc" id="L2468">	}</span>
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>