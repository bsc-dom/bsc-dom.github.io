<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dataclay</a> &gt; <a href="index.source.html" class="el_package">es.bsc.dataclay.dataservice</a> &gt; <span class="el_source">DataService.java</span></div><h1>DataService.java</h1><pre class="source lang-java linenums">
/**
 * @file DataService.java
 * @date Oct 23, 2012
 */
package es.bsc.dataclay.dataservice;

// CHECKSTYLE:OFF

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Timer;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.objectweb.asm.util.CheckClassAdapter;

import org.objectweb.asm.ClassReader;

import es.bsc.dataclay.DataClayExecutionObject;
import es.bsc.dataclay.DataClayMockObject;
import es.bsc.dataclay.DataClayObject;
import es.bsc.dataclay.commonruntime.DataServiceRuntime;
import es.bsc.dataclay.communication.grpc.messages.common.CommonMessages.Langs;
import es.bsc.dataclay.dataservice.api.DataServiceAPI;
import es.bsc.dataclay.dataservice.server.DataServiceSrv;
import es.bsc.dataclay.dbhandler.DBHandler;
import es.bsc.dataclay.dbhandler.DBHandlerConf;
import es.bsc.dataclay.exceptions.DataClayClassNotFoundException;
import es.bsc.dataclay.exceptions.DataClayException;
import es.bsc.dataclay.exceptions.JavaExecutionException;
import es.bsc.dataclay.exceptions.dataservice.ClassDeploymentException;
import es.bsc.dataclay.exceptions.dataservice.CleanExecutionClassesDirException;
import es.bsc.dataclay.exceptions.dbhandler.DbObjectNotExistException;
import es.bsc.dataclay.exceptions.metadataservice.ObjectNotRegisteredException;
import es.bsc.dataclay.extrae.DataClayExtrae;
import es.bsc.dataclay.logic.api.LogicModuleAPI;
import es.bsc.dataclay.serialization.DataClaySerializable;
import es.bsc.dataclay.serialization.java.util.CollectionWrapper;
import es.bsc.dataclay.serialization.lib.DataClayDeserializationLib;
import es.bsc.dataclay.serialization.lib.DataClaySerializationLib;
import es.bsc.dataclay.serialization.lib.ObjectWithDataParamOrReturn;
import es.bsc.dataclay.serialization.lib.SerializedParametersOrReturn;
import es.bsc.dataclay.storagelocation.StorageLocationService;
import es.bsc.dataclay.util.Configuration;
import es.bsc.dataclay.util.DataClayObjectMetaData;
import es.bsc.dataclay.util.FileAndAspectsUtils;
import es.bsc.dataclay.util.classloaders.DataClayClassLoaderSrv;
import es.bsc.dataclay.util.events.message.EventMessage;
import es.bsc.dataclay.util.events.type.DeletedObjEventType;
import es.bsc.dataclay.util.events.type.EventType;
import es.bsc.dataclay.util.ids.DataClayInstanceID;
import es.bsc.dataclay.util.ids.ExecutionEnvironmentID;
import es.bsc.dataclay.util.ids.ImplementationID;
import es.bsc.dataclay.util.ids.MetaClassID;
import es.bsc.dataclay.util.ids.ObjectID;
import es.bsc.dataclay.util.ids.SessionID;
import es.bsc.dataclay.util.ids.StorageLocationID;
import es.bsc.dataclay.util.info.VersionInfo;
import es.bsc.dataclay.util.management.classmgr.MetaClass;
import es.bsc.dataclay.util.management.classmgr.Type;
import es.bsc.dataclay.util.management.metadataservice.ExecutionEnvironment;
import es.bsc.dataclay.util.management.metadataservice.MetaDataInfo;
import es.bsc.dataclay.util.management.metadataservice.RegistrationInfo;
import es.bsc.dataclay.util.management.metadataservice.StorageLocation;
import es.bsc.dataclay.util.management.stubs.ImplementationStubInfo;
import es.bsc.dataclay.util.management.stubs.StubInfo;
import es.bsc.dataclay.util.reflection.Reflector;
import es.bsc.dataclay.util.structs.Tuple;
import io.grpc.StatusRuntimeException;

// CHECKSTYLE:ON

/**
 * This class is responsible to manage data of the objects stored in the system.
 */
public final class DataService implements DataServiceAPI {

    /**
     * DatService name.
     */
    public final String dsName;

    /**
     * DataService hostname.
     */
    private final String dsHostname;

    /**
     * DataService port.
     */
    private final int dsPort;

    // CHECKSTYLE:OFF
    /**
     * Logger.
     */
<span class="nc" id="L117">    private static final Logger LOGGER = LogManager.getLogger(&quot;DataService&quot;);</span>

    /**
     * Indicates if debug is enabled.
     */
<span class="nc" id="L122">    private static final boolean DEBUG_ENABLED = Configuration.isDebugEnabled();</span>

    /**
     * Server instance.
     */
    private final DataServiceSrv ownServer;

    /**
     * DataService StorageLocationID.
     */
    private StorageLocationID storageLocationID;

    /**
     * DataService StorageLocationID.
     */
    private ExecutionEnvironmentID executionEnvironmentID;

    /**
     * Runtime.
     */
    public DataServiceRuntime runtime;

    /**
     * Storage location associated to this service.
     */
    private final StorageLocationService storageLocation;

    /**
     * Lazy task runner.
     */
    private LazyTasksRunner lazyTasksRunner;

    /**
     * Timer.
     */
    private Timer lazyTasksTimer;

    /**
     * Timer to activate paraver.
     */
    private Timer activatePrvTimer;

    /**
     * Instantiates an DataService that uses the DB in the provided path.
     *
     * @param newdsName     DataService name
     * @param newdsHostname DataService host name
     * @param newdsTCPPort  DataService tcp port
     * @param dbHandlerconf Configuration of the DbHandler to use by the manager.
     * @param theownServer  Reference to server instance using this DataService
     *                      implementation.
     * @post Creates a Data Service and initializes the objectDB in the path
     * provided.
     */
    public DataService(final String newdsName, final String newdsHostname, final int newdsTCPPort,
<span class="nc" id="L177">                       final DBHandlerConf dbHandlerconf, final DataServiceSrv theownServer) {</span>
<span class="nc" id="L178">        dsName = newdsName;</span>
<span class="nc" id="L179">        dsHostname = newdsHostname;</span>
<span class="nc" id="L180">        dsPort = newdsTCPPort;</span>
<span class="nc" id="L181">        ownServer = theownServer;</span>
<span class="nc" id="L182">        this.storageLocation = new StorageLocationService(dbHandlerconf);</span>
<span class="nc" id="L183">        this.runtime = new DataServiceRuntime(this);</span>
<span class="nc" id="L184">        initEEInfo();</span>


<span class="nc" id="L187">    }</span>

    /**
     * Initialize caches from persistent files
     */
    private void initEEInfo() {
        try {
<span class="nc" id="L194">            final FileInputStream fis = new FileInputStream(Configuration.Flags.STORAGE_METADATA_PATH.getStringValue()</span>
                    + File.separatorChar + &quot;java_ds_&quot; + this.dsName + &quot;.info&quot;);
<span class="nc" id="L196">            final ObjectInputStream ois = new ObjectInputStream(fis);</span>
<span class="nc" id="L197">            final ExecutionEnvironmentPersistentInfo persInfo = (ExecutionEnvironmentPersistentInfo) ois.readObject();</span>
<span class="nc" id="L198">            this.executionEnvironmentID = persInfo.getExecutionEnvironmentID();</span>
<span class="nc" id="L199">            this.storageLocationID = persInfo.getStorageLocationID();</span>
<span class="nc" id="L200">            LOGGER.info(&quot;Initialized from file execution environment ID :&quot; + this.executionEnvironmentID);</span>
<span class="nc" id="L201">            LOGGER.info(&quot;Initialized from file storage location ID :&quot; + this.storageLocationID);</span>
<span class="nc" id="L202">            ois.close();</span>
<span class="nc" id="L203">            fis.close();</span>
<span class="nc" id="L204">        } catch (final IOException ioe) {</span>
<span class="nc" id="L205">            this.executionEnvironmentID = new ExecutionEnvironmentID();</span>
<span class="nc" id="L206">            this.storageLocationID = new StorageLocationID();</span>
<span class="nc" id="L207">            LOGGER.info(&quot;Initialized execution environment ID :&quot; + this.executionEnvironmentID);</span>
<span class="nc" id="L208">            LOGGER.info(&quot;Initialized storage location ID :&quot; + this.storageLocationID);</span>
<span class="nc" id="L209">        } catch (final Exception ex) {</span>
<span class="nc" id="L210">            LOGGER.debug(&quot;init EE information error&quot;, ex);</span>
<span class="nc" id="L211">            return;</span>
<span class="nc" id="L212">        }</span>

<span class="nc" id="L214">    }</span>

    /**
     * Store EE information.
     */
    public void persistEEInfo() {
        try {
<span class="nc" id="L221">            final FileOutputStream fos = new FileOutputStream(Configuration.Flags.STORAGE_METADATA_PATH.getStringValue()</span>
                    + File.separatorChar + &quot;java_ds_&quot; + this.dsName + &quot;.info&quot;);
<span class="nc" id="L223">            final ObjectOutputStream oos = new ObjectOutputStream(fos);</span>
<span class="nc" id="L224">            final ExecutionEnvironmentPersistentInfo eeInfo = new ExecutionEnvironmentPersistentInfo(</span>
                    this.executionEnvironmentID, this.storageLocationID);
<span class="nc" id="L226">            oos.writeObject(eeInfo);</span>
<span class="nc" id="L227">            oos.close();</span>
<span class="nc" id="L228">            fos.close();</span>
<span class="nc" id="L229">        } catch (final IOException ioe) {</span>
<span class="nc" id="L230">            LOGGER.debug(&quot;persist EE info IO error&quot;, ioe);</span>
<span class="nc" id="L231">        }</span>

<span class="nc" id="L233">    }</span>

    /**
     * Perform a local initialization, and perform the autoregisterDataService to
     * the LogicModule
     *
     * @param logicModuleHost    Logic Module host
     * @param tcpLogicModulePort Logic Module port
     * @param dataServiceName    DS name
     * @throws Exception If an error occurs during this process
     */
    public void initLocalWithAutoregistration(final String logicModuleHost, final int tcpLogicModulePort,
                                              final String dataServiceName) throws Exception {

<span class="nc" id="L247">        this.runtime.initialize(logicModuleHost, tcpLogicModulePort, dataServiceName);</span>
<span class="nc" id="L248">        DataClayObject.setLib(runtime);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (Configuration.Flags.PREFETCHING_ENABLED.getBooleanValue()) {</span>
<span class="nc" id="L250">            lazyTasksRunner = new LazyTasksRunner(this);</span>
<span class="nc" id="L251">            lazyTasksTimer = new Timer();</span>
<span class="nc" id="L252">            lazyTasksTimer.schedule(lazyTasksRunner, 0, Configuration.Flags.PREFETCHING_TASKS_INTERVAL.getLongValue());</span>
        }

<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (activatePrvTimer != null) {</span>
<span class="nc" id="L256">            activatePrvTimer.cancel();</span>
        }

<span class="nc" id="L259">        final LogicModuleAPI lmAPI = this.runtime.getLogicModuleAPI();</span>
<span class="nc" id="L260">        lmAPI.autoregisterSL(this.storageLocationID, dsName, dsHostname, dsPort);</span>
<span class="nc" id="L261">        lmAPI.autoregisterEE(executionEnvironmentID, dsName, dsHostname, dsPort, Langs.LANG_JAVA);</span>
<span class="nc" id="L262">        this.storageLocation.initialize(runtime, this.executionEnvironmentID);</span>
<span class="nc" id="L263">    }</span>

    /**
     * Returns the backendID of this DS.
     *
     * @return ID of the backend assigned to this DS.
     */
    public StorageLocationID getStorageLocationID() {
<span class="nc" id="L271">        return storageLocationID;</span>
    }

    /**
     * Returns the backendID of this DS.
     *
     * @return ID of the backend assigned to this DS.
     */
    public ExecutionEnvironmentID getExecutionEnvironmentID() {
<span class="nc" id="L280">        return executionEnvironmentID;</span>
    }


    @Override
    public void initBackendID(final StorageLocationID newbackendID) {
<span class="nc" id="L286">        this.storageLocationID = newbackendID;</span>
<span class="nc" id="L287">    }</span>

    @Override
    public void associateExecutionEnvironment(final ExecutionEnvironmentID newexecutionEnvironmentID) {
<span class="nc" id="L291">        LOGGER.debug(&quot;Associating &quot; + newexecutionEnvironmentID + &quot; to &quot; + this.dsName);</span>
<span class="nc" id="L292">        this.storageLocation.associateExecutionEnvironment(newexecutionEnvironmentID);</span>

<span class="nc" id="L294">    }</span>

    @Override
    public void deployMetaClasses(final String namespaceName, final Map&lt;String, MetaClass&gt; deploymentPack) {
<span class="nc" id="L298">        throw new UnsupportedOperationException(&quot;Deploy MetaClass not supported for Java DataService&quot;);</span>
    }

    public static byte[] checkGeneratedClass(byte[] classBytes) {
<span class="nc" id="L302">        ClassReader cr = new ClassReader(classBytes);</span>
<span class="nc" id="L303">        StringWriter sw = new StringWriter();</span>
<span class="nc" id="L304">        PrintWriter pw = new PrintWriter(sw);</span>
<span class="nc" id="L305">        CheckClassAdapter.verify(cr, true, pw);</span>

<span class="nc" id="L307">        return classBytes;</span>
    }

    public static void validateClass(ClassReader reader, ClassLoader loader) {
<span class="nc" id="L311">        StringWriter writer = new StringWriter();</span>
<span class="nc" id="L312">        PrintWriter printWriter = new PrintWriter(writer);</span>

<span class="nc" id="L314">        Exception error = null;</span>
        try {
<span class="nc" id="L316">            CheckClassAdapter.verify(reader, loader, true, printWriter);</span>
<span class="nc" id="L317">        } catch (Exception e) {</span>
<span class="nc" id="L318">            error = e;</span>
<span class="nc" id="L319">        }</span>

<span class="nc" id="L321">        String contents = writer.toString();</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">        if (error != null || contents.length() &gt; 0) {</span>
<span class="nc" id="L323">            throw new IllegalStateException(writer.toString(), error);</span>
        }
<span class="nc" id="L325">    }</span>


    @Override
    public void deployClasses(final String namespaceName, final Map&lt;Tuple&lt;String, MetaClassID&gt;, byte[]&gt; classesToDeploy,
                              final Map&lt;String, byte[]&gt; classesAspects, final Map&lt;String, byte[]&gt; stubYamls) {
<span class="nc" id="L331">        runtime.setCurrentThreadSessionID(new SessionID());</span>

        // Create temporary directories
<span class="nc" id="L334">        final String namespaceDir = Configuration.Flags.EXECUTION_CLASSES_PATH.getStringValue();</span>

		// Create directories if needed
<span class="nc" id="L337">		FileAndAspectsUtils.createDirectory(namespaceDir);</span>
<span class="nc" id="L338">		LOGGER.debug(&quot;Received &quot; + classesToDeploy.size() + &quot; classes &quot;);</span>

<span class="nc bnc" id="L340" title="All 2 branches missed.">		for (final Entry&lt;Tuple&lt;String, MetaClassID&gt;, byte[]&gt; curEntry : classesToDeploy.entrySet()) {</span>
<span class="nc" id="L341">			final String className = curEntry.getKey().getFirst();</span>
<span class="nc" id="L342">			final String finalClassName = namespaceName + &quot;.&quot; + className;</span>
<span class="nc" id="L343">			LOGGER.debug(&quot;Storing class &quot; + finalClassName);</span>
<span class="nc" id="L344">			final byte[] classToDeploy = curEntry.getValue();</span>
			try {
<span class="nc" id="L346">				FileAndAspectsUtils.storeClass(namespaceDir, finalClassName + &quot;.class&quot;, classToDeploy);</span>

<span class="nc" id="L348">            } catch (final Exception ex) {</span>
<span class="nc" id="L349">                ex.printStackTrace();</span>
<span class="nc" id="L350">                LOGGER.debug(&quot;deployClasses error (while storing .class files)&quot;, ex);</span>
<span class="nc" id="L351">                throw new ClassDeploymentException(namespaceName, className, ex.getMessage());</span>
<span class="nc" id="L352">            }</span>
<span class="nc" id="L353">        }</span>



<span class="nc bnc" id="L357" title="All 2 branches missed.">		for (final Entry&lt;Tuple&lt;String, MetaClassID&gt;, byte[]&gt; curEntry : classesToDeploy.entrySet()) {</span>
<span class="nc" id="L358">			final String className = curEntry.getKey().getFirst();</span>
<span class="nc" id="L359">			final String finalClassName = namespaceName + &quot;.&quot; + className;</span>
<span class="nc" id="L360">			final byte[] classToDeploy = curEntry.getValue();</span>
			//  Verify class
<span class="nc" id="L362">			LOGGER.debug(&quot;Checking class &quot; + finalClassName);</span>
<span class="nc" id="L363">			checkGeneratedClass(classToDeploy);</span>
<span class="nc" id="L364">			DataClayClassLoaderSrv.getClass(finalClassName);</span>
<span class="nc" id="L365">		}</span>

        // Store yamls into final path
<span class="nc bnc" id="L368" title="All 2 branches missed.">        for (final Entry&lt;String, byte[]&gt; curEntry : stubYamls.entrySet()) {</span>
<span class="nc" id="L369">            final String className = curEntry.getKey();</span>
<span class="nc" id="L370">            final String finalClassName = namespaceName + &quot;.&quot; + className;</span>
<span class="nc" id="L371">            final byte[] yamlToStore = curEntry.getValue();</span>
            try {
<span class="nc" id="L373">                FileAndAspectsUtils.storeClass(namespaceDir, finalClassName + &quot;Yaml.yaml&quot;, yamlToStore);</span>
<span class="nc" id="L374">            } catch (final Exception ex) {</span>
<span class="nc" id="L375">                LOGGER.debug(&quot;deployClasses error (while storing .yaml files)&quot;, ex);</span>
<span class="nc" id="L376">                throw new ClassDeploymentException(namespaceName, className, ex.getMessage());</span>
<span class="nc" id="L377">            }</span>
<span class="nc" id="L378">        }</span>
<span class="nc" id="L379">    }</span>

    @Override
    public void enrichClass(final String namespaceName, final String className, final byte[] classToDeploy,
                            final byte[] classAspects, final byte[] stubYaml) {

        try {

<span class="nc" id="L387">            final String finalClassName = namespaceName + &quot;.&quot; + className;</span>

<span class="nc" id="L389">            final Tuple&lt;File, String&gt; targetDirAndClassFileName = getTargetDirAndClassFileName(finalClassName);</span>
<span class="nc" id="L390">            final File targetDir = targetDirAndClassFileName.getFirst();</span>
<span class="nc" id="L391">            final String classFileName = targetDirAndClassFileName.getSecond();</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (!targetDir.exists()) {</span>
<span class="nc" id="L393">                targetDir.mkdirs();</span>
            }
<span class="nc" id="L395">            final File classFile = new File(targetDir.getAbsolutePath() + File.separatorChar + classFileName);</span>
            // Update with the new one (e.g. when enriching)
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (classFile.exists()) {</span>
<span class="nc" id="L398">                classFile.delete();</span>
            }

            // Create temporary directories
<span class="nc" id="L402">            final String namespaceDir = Configuration.Flags.EXECUTION_CLASSES_PATH.getStringValue();</span>

<span class="nc" id="L404">            FileAndAspectsUtils.storeClass(namespaceDir, finalClassName + &quot;.class&quot;, classToDeploy);</span>

            // Replace YAML
            try {
<span class="nc" id="L408">                FileAndAspectsUtils.storeClass(namespaceDir, finalClassName + &quot;Yaml.yaml&quot;, stubYaml);</span>
<span class="nc" id="L409">            } catch (final Exception ex) {</span>
<span class="nc" id="L410">                LOGGER.debug(&quot;enrichClass error (while storing .yaml file)&quot;, ex);</span>
<span class="nc" id="L411">                throw new ClassDeploymentException(namespaceName, className, ex.getMessage());</span>
<span class="nc" id="L412">            }</span>

            // Reload all class loaders containing the class
<span class="nc" id="L415">            DataClayClassLoaderSrv.reloadClassLoader(namespaceName);</span>

<span class="nc" id="L417">        } catch (final Exception ex) {</span>
<span class="nc" id="L418">            LOGGER.debug(&quot;deployClasses error&quot;, ex);</span>
<span class="nc" id="L419">            throw new ClassDeploymentException(namespaceName, className, ex.getMessage());</span>
<span class="nc" id="L420">        }</span>
<span class="nc" id="L421">    }</span>

    /**
     * Returns the targetdir and the file name of the given class
     *
     * @param className name of the class
     * @return A tuple with the directory where the class resides and the actual
     * file name.
     */
    private Tuple&lt;File, String&gt; getTargetDirAndClassFileName(final String className) {
<span class="nc" id="L431">        String packageName = &quot;&quot;;</span>
        String classFileName;
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (className.contains(&quot;.&quot;)) {</span>
<span class="nc" id="L434">            packageName = className.substring(0, className.lastIndexOf(&quot;.&quot;));</span>
<span class="nc" id="L435">            classFileName = className.substring(className.lastIndexOf(&quot;.&quot;) + 1, className.length());</span>
        } else {
<span class="nc" id="L437">            classFileName = className;</span>
        }
<span class="nc" id="L439">        classFileName += &quot;.class&quot;;</span>

<span class="nc" id="L441">        final String dirs = packageName.replace('.', File.separatorChar);</span>
<span class="nc" id="L442">        final String execDir = Configuration.Flags.EXECUTION_CLASSES_PATH.getStringValue();</span>
<span class="nc" id="L443">        final File targetDir = new File(execDir + File.separatorChar + dirs);</span>
<span class="nc" id="L444">        return new Tuple&lt;&gt;(targetDir, classFileName);</span>
    }

    @Override
    public ObjectID newPersistentInstance(final SessionID sessionID, final MetaClassID classID,
                                          final ImplementationID implementationID, final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps,
                                          final SerializedParametersOrReturn params) {

<span class="nc" id="L452">        runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (Configuration.mockTesting) {</span>
<span class="nc" id="L454">            DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
        }
<span class="nc" id="L456">        final Class&lt;?&gt; clazz = DataClayClassLoaderSrv.getClass(classID);</span>

<span class="nc" id="L458">        final StubInfo stubInfo = DataClayObject.getStubInfoFromClass(clazz.getName());</span>
<span class="nc" id="L459">        final ImplementationStubInfo execInfo = stubInfo.getImplementationByID(implementationID.toString());</span>
<span class="nc" id="L460">        final Map&lt;String, Type&gt; argTypes = execInfo.getParams();</span>
<span class="nc" id="L461">        final List&lt;String&gt; argOrders = execInfo.getParamsOrder();</span>

        // Get class from signatures.
<span class="nc" id="L464">        Thread.currentThread().setContextClassLoader(DataClayClassLoaderSrv.execEnvironmentClassLoader);</span>
<span class="nc" id="L465">        final Class&lt;?&gt;[] parameterTypes = new Class&lt;?&gt;[argTypes.size()];</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        for (int i = 0; i &lt; argTypes.size(); ++i) {</span>
<span class="nc" id="L467">            final String typeSignature = argTypes.get(argOrders.get(i)).getSignatureOrDescriptor();</span>
<span class="nc" id="L468">            parameterTypes[i] = Reflector.getClassFromSignatureAndArray(typeSignature,</span>
                    DataClayClassLoaderSrv.execEnvironmentClassLoader);
        }

        // ============================ DESERIALIZE PARAMETERS
        // ============================ //
        // Since wrappers of parameters depend on the instance of the class and
        // the method cannot be static (or yes?) so we create a foo instance.
<span class="nc" id="L476">        final DataClayObject fooInstance = DataClayClassLoaderSrv.newInstance(classID, new ObjectID()); // just for</span>
        // deser.
<span class="nc" id="L478">        final Object[] loadedparams = this.runtime.deserializeParams(fooInstance, ifaceBitMaps, implementationID,</span>
                params);

        // ============================ NEW INSTANCE ============================ //
<span class="nc" id="L482">        DataClayObject instance = null;</span>
        try {
<span class="nc" id="L484">            instance = (DataClayObject) clazz.getConstructor(parameterTypes).newInstance(loadedparams);</span>
<span class="nc" id="L485">        } catch (final Exception ex) {</span>
<span class="nc" id="L486">            LOGGER.debug(&quot;newPersistentInstance -&gt; newInstance error&quot;, ex);</span>
<span class="nc" id="L487">            throw new JavaExecutionException(ex);</span>
<span class="nc" id="L488">        }</span>

        // ============================ MAKE PERSISTENT ============================ //
<span class="nc" id="L491">        instance.makePersistent(true, this.executionEnvironmentID);</span>

<span class="nc" id="L493">        runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (Configuration.mockTesting) {</span>
<span class="nc" id="L495">            DataClayMockObject.removeCurrentThreadLib();</span>
        }
<span class="nc" id="L497">        return instance.getObjectID();</span>

    }

    /**
     * Update hints in serialized objects provided to use current backend id
     * @param objects serialized objects to update
     */
    private void updateHintsToCurrentExecEnv(List&lt;ObjectWithDataParamOrReturn&gt; objects) {
        // NOTE: update hints of objects since they come from other backends in this call
        // Prepare hints to update
<span class="nc" id="L508">        Map&lt;ObjectID, ExecutionEnvironmentID&gt; hintsMapping = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn object : objects) {</span>
<span class="nc" id="L510">            final ObjectID objectID = object.getObjectID();</span>
<span class="nc" id="L511">            hintsMapping.put(objectID, this.executionEnvironmentID);</span>
<span class="nc" id="L512">        }</span>
        // Update hints
<span class="nc bnc" id="L514" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn object : objects) {</span>
<span class="nc" id="L515">            final ObjectID objectID = object.getObjectID();</span>
            // Set object's hint to current location
<span class="nc" id="L517">            final DataClayObjectMetaData metadata = object.getMetaData();</span>
<span class="nc" id="L518">            metadata.modifyHints(hintsMapping);</span>
            // make persistent - session references
<span class="nc" id="L520">            this.runtime.addSessionReference(objectID);</span>
<span class="nc" id="L521">        }</span>
<span class="nc" id="L522">    }</span>

    @Override
    public void storeObjects(final SessionID sessionID,
                             final List&lt;ObjectWithDataParamOrReturn&gt; objects,
                             final boolean moving, final Set&lt;ObjectID&gt; idsWithAlias) {
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L529">            LOGGER.debug(&quot;[==Store==] Storing &quot; + objects.size() + &quot; objects.&quot;);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">            for (ObjectWithDataParamOrReturn objectWithDataParamOrReturn : objects) {</span>
<span class="nc" id="L531">                LOGGER.debug(&quot;[==Store==] Storing: &quot; + objectWithDataParamOrReturn);</span>
<span class="nc" id="L532">            }</span>
        }
<span class="nc" id="L534">        runtime.setCurrentThreadSessionID(sessionID);</span>
        // NOTE: update hints of objects since they come from other backends in this call
        // Prepare hints to update
<span class="nc" id="L537">        this.updateHintsToCurrentExecEnv(objects);</span>

<span class="nc" id="L539">        storeInMemory(sessionID, objects);</span>

<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (moving) {</span>

            // If moving and object that EXISTS in the ObjectsMap as a proxy means:
            // - The object is a Weak Proxy and we must deserialize data on it.
            // Why?
            // - If there is a proxy present in the ObjectsMap, it means it is a weak proxy,
            // and
            // we are storing an object into a DS that had the object once (and therefore it
            // turned to a
            // weak proxy).
            // A weak proxy, when is GC, it's removed and new instances pointing to the
            // moved object
            // will use the traditional mechanism of 'remote calls'. Object not in Map -&gt;
            // remote call.

<span class="nc bnc" id="L556" title="All 2 branches missed.">            for (final ObjectWithDataParamOrReturn object : objects) {</span>
<span class="nc" id="L557">                final ObjectID objectID = object.getObjectID();</span>
<span class="nc" id="L558">                DataClayExecutionObject instance = null;</span>
                try {
<span class="nc" id="L560">                    instance = this.runtime.getFromHeap(objectID);</span>
                    // Corner case: Client sends parameter to turn in proxy. DS1 has Proxy + Param
                    // obj. but
                    // param obj is actually a persistent object in DS2.
                    // There is a move from DS2 to DS1, the proxy is not saved in map by default
                    // (except weak)
                    // but the parameter is still there. So proxy flag is false but WE CAN USE THE
                    // OBJECT IN MEMORY
                    // :)

                    ///// NORMAL WEAK PROXY
<span class="nc bnc" id="L571" title="All 4 branches missed.">                    if (instance != null &amp;&amp; !instance.isLoaded()) {</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L573">                            LOGGER.debug(&quot;[==Store==] Found weak proxy for &quot; + objectID</span>
                                    + &quot;during a move. Loading object and turning it into normal object&quot;);
                        }

<span class="nc" id="L577">                        runtime.deserializeDataIntoInstance(instance, object, null);</span>
                    }

<span class="nc" id="L580">                } catch (final DbObjectNotExistException ex) {</span>
<span class="nc" id="L581">                    LOGGER.debug(&quot;storeObjects error, not in db anymore&quot;, ex);</span>
                    // TODO: if not in DB anymore due to a delete, what to do?
                } finally {
                    // Remove metadata from cache in case this dataservice has information that the
                    // object is in another.
<span class="nc" id="L586">                    runtime.removeObjectMetadataFromCache(objectID);</span>
                }

<span class="nc" id="L589">            }</span>
        }

        // FIXME: sessionID must have a counter in structure or remove entry once a
        // thread is removed (dgasull 2018)
        // clientLib.removeSessionIDForThread();
        // DataClayObject.removeLibForThread();

<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L598">            LOGGER.debug(&quot;[==Store==] End of Storing objects&quot;);</span>
        }
<span class="nc" id="L600">    }</span>

    /**
     * @param sessionID        ID of session
     * @param objectsToPersist objects to deserialize into heap
     * @return Deserialized instances
     * @brief Deserialize and load the data of objects provided into heap
     */
    private Object[] storeInMemory(final SessionID sessionID, final List&lt;ObjectWithDataParamOrReturn&gt; objectsToPersist) {

<span class="nc" id="L610">        final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps = null; // TODO: get for current session</span>

        // Deserialize objects following same design as volatile but without
        // implementation ID (null) and
        // no instance to execute.
<span class="nc" id="L615">        return this.runtime.deserializeIntoHeap(ifaceBitMaps, objectsToPersist);</span>

    }

    @Override
    public void makePersistent(final SessionID sessionID, final List&lt;ObjectWithDataParamOrReturn&gt; objectsToPersist) {
        try {

<span class="nc bnc" id="L623" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L624">                LOGGER.debug(&quot;[==Serialization==] Received serialized objects: &quot; + objectsToPersist);</span>
            }

            // create lots of objects here and stash them somewhere
<span class="nc" id="L628">            runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L630">                LOGGER.debug(&quot;[==Make Persistent==] ** Starting make persistent **&quot;);</span>

            }
<span class="nc" id="L633">            storeInMemory(sessionID, objectsToPersist);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L635">                LOGGER.debug(&quot;[==Make Persistent==] ** End of make persistent **&quot;);</span>
            }
<span class="nc" id="L637">        } catch (final Exception ex) {</span>
<span class="nc" id="L638">            ex.printStackTrace();</span>
<span class="nc" id="L639">            LOGGER.debug(&quot; Make persistent got exception&quot;, ex);</span>
<span class="nc" id="L640">            throw ex;</span>
        } finally {
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L643">                DataClayMockObject.removeCurrentThreadLib();</span>
            }
<span class="nc" id="L645">            runtime.removeCurrentThreadSessionID();</span>

        }

<span class="nc" id="L649">    }</span>

    @Override
    public void federate(final SessionID sessionID, final ObjectID objectID,
                  final ExecutionEnvironmentID externalExecutionEnvironmentID,
                  final boolean recursive) {
        try {

            // create lots of objects here and stash them somewhere
<span class="nc" id="L658">            runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc" id="L659">            LOGGER.debug(&quot;----&gt; Starting federation of &quot; + objectID);</span>

            // Get the original object.
<span class="nc" id="L662">            final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L663">            objectIDs.add(objectID);</span>
<span class="nc" id="L664">            final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs, new HashSet&lt;ObjectID&gt;(), recursive, externalExecutionEnvironmentID,</span>
                    1);

            // Store it in destination backend
            // TODO: check that current dataClay/EE has permission to federate the object (refederation use-case)
            // delegation mechanism?
<span class="nc" id="L670">            final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(externalExecutionEnvironmentID);</span>
<span class="nc" id="L671">            dataServiceApi.notifyFederation(sessionID, serializedObjs);</span>

<span class="nc" id="L673">        } catch (final Exception ex) {</span>
<span class="nc" id="L674">            LOGGER.debug(&quot; Federate got exception&quot;, ex);</span>
<span class="nc" id="L675">            throw ex;</span>
<span class="nc" id="L676">        } finally {</span>
            //Do not remove for function called inside methods
            //runtime.removeCurrentThreadSessionID();
<span class="nc" id="L679">        }</span>
<span class="nc" id="L680">        LOGGER.debug(&quot;&lt;---- Finished federation of &quot; + objectID);</span>
<span class="nc" id="L681">    }</span>

    @Override
    public void notifyFederation(final SessionID sessionID, final List&lt;ObjectWithDataParamOrReturn&gt; objectsToPersist) {

        try {

            // create lots of objects here and stash them somewhere
            //runtime.setCurrentThreadSessionID(sessionID);
<span class="nc" id="L690">            LOGGER.debug(&quot;----&gt; Notified federation&quot;);</span>


            // if objects received have alias, they must be registered
<span class="nc" id="L694">            List&lt;RegistrationInfo&gt; regInfos = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            for (ObjectWithDataParamOrReturn objectWithDataParamOrReturn: objectsToPersist) {</span>
<span class="nc" id="L696">                ObjectID objectID = objectWithDataParamOrReturn.getObjectID();</span>
<span class="nc" id="L697">                DataClayObjectMetaData metaData = objectWithDataParamOrReturn.getMetaData();</span>
<span class="nc bnc" id="L698" title="All 4 branches missed.">                if (metaData.getAlias() != null &amp;&amp; !metaData.getAlias().isEmpty()) {</span>
<span class="nc" id="L699">                    MetaClassID classID = objectWithDataParamOrReturn.getClassID();</span>
                    // FIXME: session must be null since it does not exist in current dataClay
<span class="nc" id="L701">                    final RegistrationInfo regInfo = new RegistrationInfo(objectID, classID,</span>
<span class="nc" id="L702">                            null, null, metaData.getAlias());</span>
                    // TODO objectID must not be replaced here by new one created?
<span class="nc" id="L704">                    regInfos.add(regInfo);</span>
                }
<span class="nc" id="L706">            }</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">            if (!regInfos.isEmpty()) {</span>
                // LogicModule notify GCs about new alias
<span class="nc" id="L709">                this.runtime.getLogicModuleAPI().registerObjects(regInfos,</span>
                        (ExecutionEnvironmentID) this.executionEnvironmentID, Langs.LANG_JAVA);
            }


<span class="nc" id="L714">            final Object[] federatedInstances = storeInMemory(null, objectsToPersist);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            for (final Object federatedInstance : federatedInstances) {</span>
<span class="nc" id="L716">                final DataClayObject federatedDataClayObj = (DataClayObject) federatedInstance;</span>
                try {
<span class="nc" id="L718">                    federatedDataClayObj.whenFederated();</span>
<span class="nc" id="L719">                } catch (final Exception e) {</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                    if (DEBUG_ENABLED) {</span>
<span class="nc" id="L721">                        LOGGER.debug(&quot;[==Federate==] Caugh exception during whenFederated: &quot;, e);</span>
                    }
<span class="nc" id="L723">                }</span>
            }
<span class="nc" id="L725">            LOGGER.debug(&quot;&lt;---- Finished notification of federation&quot;);</span>


<span class="nc" id="L728">        } catch (final Exception ex) {</span>
<span class="nc" id="L729">            LOGGER.debug(&quot; Notify federation got exception&quot;, ex);</span>
<span class="nc" id="L730">            throw ex;</span>
<span class="nc" id="L731">        } finally {</span>
            //runtime.removeCurrentThreadSessionID();
<span class="nc" id="L733">        }</span>

<span class="nc" id="L735">    }</span>

    @Override
    public void unfederate(final SessionID sessionID, final ObjectID objectID,
                         final ExecutionEnvironmentID externalExecutionEnvironmentID,
                         final boolean recursive) {

        // TODO: redirect unfederation to owner if current dataClay is not the owner, check origLoc belongs to current dataClay
        try {
<span class="nc" id="L744">            LOGGER.debug(&quot;----&gt; Starting unfederation of {} from {}&quot;, objectID, externalExecutionEnvironmentID);</span>
<span class="nc" id="L745">            runtime.setCurrentThreadSessionID(sessionID);</span>

            // Get the original object.
<span class="nc" id="L748">            final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L749">            objectIDs.add(objectID);</span>
<span class="nc" id="L750">            final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs,</span>
                    new HashSet&lt;ObjectID&gt;(), recursive, externalExecutionEnvironmentID, 2);

<span class="nc" id="L753">            Map&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; unfederatePerBackend = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">            for (ObjectWithDataParamOrReturn objectWithDataParamOrReturn : serializedObjs) {</span>
<span class="nc" id="L755">                Set&lt;ExecutionEnvironmentID&gt; replicaLocs = objectWithDataParamOrReturn.getMetaData().getReplicaLocations();</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">                for (ExecutionEnvironmentID replicaLoc : replicaLocs) {</span>
<span class="nc" id="L757">                    ExecutionEnvironment execEnv = this.runtime.getExecutionEnvironmentInfo(replicaLoc);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                    if (!execEnv.getDataClayInstanceID().equals(this.runtime.getDataClayID())) {</span>
<span class="nc bnc" id="L759" title="All 4 branches missed.">                        if (externalExecutionEnvironmentID != null &amp;&amp; !replicaLoc.equals(externalExecutionEnvironmentID)) {</span>
<span class="nc" id="L760">                            continue;</span>
                        }
<span class="nc" id="L762">                        Set&lt;ObjectID&gt; objsInBackend = unfederatePerBackend.get(replicaLoc);</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                        if (objsInBackend == null) {</span>
<span class="nc" id="L764">                            objsInBackend = new HashSet&lt;&gt;();</span>
<span class="nc" id="L765">                            unfederatePerBackend.put(replicaLoc, objsInBackend);</span>
                        }
<span class="nc" id="L767">                        objsInBackend.add(objectWithDataParamOrReturn.getObjectID());</span>
                    }
<span class="nc" id="L769">                }</span>
<span class="nc" id="L770">            }</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">            for (Entry&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; curEntry : unfederatePerBackend.entrySet()) {</span>
<span class="nc" id="L772">                final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(curEntry.getKey());</span>
<span class="nc" id="L773">                dataServiceApi.notifyUnfederation(sessionID, curEntry.getValue());</span>
<span class="nc" id="L774">            }</span>

<span class="nc" id="L776">        } catch (final Exception ex) {</span>
<span class="nc" id="L777">            LOGGER.debug(&quot; Unfederate got exception&quot;, ex);</span>
<span class="nc" id="L778">            throw ex;</span>
<span class="nc" id="L779">        } finally {</span>
            //Do not remove for function called inside methods
            //runtime.removeCurrentThreadSessionID();
<span class="nc" id="L782">        }</span>
<span class="nc" id="L783">        LOGGER.debug(&quot;&lt;---- Finished unfederation of &quot; + objectID);</span>
<span class="nc" id="L784">    }</span>

    @Override
    public void notifyUnfederation(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs) {
        try {
            // create lots of objects here and stash them somewhere
            //if (sessionID != null) {
            //    runtime.setCurrentThreadSessionID(sessionID);
            //}
<span class="nc" id="L793">            LOGGER.debug(&quot;----&gt; Starting notification of unfederation of &quot; + objectIDs);</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">            for (final ObjectID objectID : objectIDs) {</span>
<span class="nc" id="L795">                final DataClayObject instance = runtime.getOrNewInstanceFromDB(objectID, true);</span>
<span class="nc" id="L796">                instance.whenUnfederated();</span>
<span class="nc" id="L797">                instance.setOriginLocation(null);</span>
<span class="nc bnc" id="L798" title="All 4 branches missed.">                if (instance.getAlias() != null &amp;&amp; !instance.getAlias().isEmpty()) {</span>
                    try {
<span class="nc" id="L800">                        runtime.deleteAlias(instance);</span>
<span class="nc" id="L801">                    } catch (final Exception aliasNotExists) {</span>
                        // ignore if still not registered
<span class="nc" id="L803">                    }</span>
                }

<span class="nc" id="L806">            }</span>
<span class="nc" id="L807">        } catch (final DbObjectNotExistException ex) {</span>
            // ignore
<span class="nc" id="L809">        } catch (final Exception ex) {</span>
<span class="nc" id="L810">            LOGGER.debug(&quot;Notify unfederate got exception&quot;, ex);</span>
<span class="nc" id="L811">            throw ex;</span>
<span class="nc" id="L812">        } finally {</span>
            //runtime.removeCurrentThreadSessionID();

<span class="nc" id="L815">        }</span>
<span class="nc" id="L816">        LOGGER.debug(&quot;&lt;---- Finished notification of unfederation of &quot; + objectIDs);</span>

<span class="nc" id="L818">    }</span>

    @Override
    public SerializedParametersOrReturn executeImplementation(final ObjectID objectID, final ImplementationID implID,
                                                              final SerializedParametersOrReturn params, final SessionID sessionID) {

        try {
            // create lots of objects here and stash them somewhere
<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (sessionID != null) {</span>
<span class="nc" id="L827">                runtime.setCurrentThreadSessionID(sessionID);</span>
            }
<span class="nc bnc" id="L829" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L830">                LOGGER.debug(&quot;[==Execution==] ** New execution! ** Executing in object &quot; + objectID</span>
                        + &quot; the implementation &quot; + implID);

            }

            // =================================== GET INSTANCE
            // ===================================//
            // We must instantiate an object of the execution class

<span class="nc bnc" id="L839" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L840">                LOGGER.debug(&quot;[==Execution==] Going to get or create instance for object with id &quot; + objectID);</span>
            }
<span class="nc" id="L842">            final DataClayObject instance = runtime.getOrNewInstanceFromDB(objectID, true);</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">            if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L844">                this.runtime.checkSession(instance.getDataSetID(), sessionID);</span>
            }

<span class="nc bnc" id="L847" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L848">                LOGGER.debug(&quot;[==Execution==] Deserializing parameters for execution of object with id &quot; + objectID</span>
                        + &quot; and implementation &quot; + implID);
            }

<span class="nc" id="L852">            final Map&lt;MetaClassID, byte[]&gt; ifaceBitMaps = null; // TODO: get for current session</span>

            // ============================ DESERIALIZE PARAMETERS
            // ============================ //
<span class="nc" id="L856">            final Object[] loadedparams = this.runtime.deserializeParams(instance, ifaceBitMaps, implID, params);</span>

<span class="nc bnc" id="L858" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L859">                LOGGER.debug(&quot;[==Execution==] Running method for object with id &quot; + objectID + &quot; and implementation &quot;</span>
                        + implID);
            }

            // ============================= EXECUTE =========================== //
<span class="nc" id="L864">            final Object result = this.runImplementation(instance, implID, loadedparams);</span>

<span class="nc bnc" id="L866" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L867">                LOGGER.debug(&quot;[==Execution==] End of running method for object with id &quot; + objectID</span>
                        + &quot; and implementation &quot; + implID);
            }

            // =================== SERIALIZE RESULT ===================//
<span class="nc bnc" id="L872" title="All 2 branches missed.">            if (result == null) {</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L874">                    LOGGER.debug(&quot;[==Execution==] Returning NULL or nothing for execution of object with id &quot; + objectID</span>
                            + &quot; and implementation &quot; + implID);
                }
<span class="nc" id="L877">                return null;</span>
            } else {
<span class="nc bnc" id="L879" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L880">                    LOGGER.debug(&quot;[==Execution==] Serializing return for execution of object with id &quot; + objectID</span>
                            + &quot; and implementation &quot; + implID);
                }
<span class="nc" id="L883">                return this.runtime.serializeReturn(instance, ifaceBitMaps, implID, result);</span>
            }
<span class="nc" id="L885">        } catch (final StatusRuntimeException sterr) {</span>
<span class="nc" id="L886">            LOGGER.debug(&quot;[==Execution==] Error at execution of object with id {} and implementation {}&quot;, objectID,</span>
                    implID);
<span class="nc" id="L888">            LOGGER.debug(&quot;executeImplementation got a StatusRuntimeException&quot;, sterr);</span>
<span class="nc" id="L889">            throw sterr;</span>
<span class="nc" id="L890">        } catch (final DataClayException dbe) {</span>
<span class="nc" id="L891">            LOGGER.debug(&quot;[==Execution==] Error at execution of object with id {} and implementation {}&quot;, objectID,</span>
                    implID);
<span class="nc" id="L893">            LOGGER.debug(&quot;executeImplementation got a native DataClayException&quot;, dbe);</span>
<span class="nc" id="L894">            dbe.printStackTrace();</span>
<span class="nc" id="L895">            throw dbe;</span>
<span class="nc" id="L896">        } catch (final Exception ex) {</span>
<span class="nc" id="L897">            LOGGER.debug(&quot;[==Execution==] Error at execution of object with id {} and implementation {}&quot;, objectID,</span>
                    implID);
<span class="nc" id="L899">            LOGGER.debug(&quot;executeImplementation got a native DataClayException&quot;, ex);</span>
<span class="nc" id="L900">            throw new JavaExecutionException(ex);</span>
<span class="nc" id="L901">        } catch (final Error err) {</span>
<span class="nc" id="L902">            LOGGER.debug(&quot;executeImplementation ``true'' error&quot;, err);</span>
<span class="nc" id="L903">            throw new JavaExecutionException(err);</span>
        } finally {
<span class="nc" id="L905">            runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L907">                LOGGER.debug(&quot;[==Execution==] ** End of execution ** End of execution of object with id &quot; + objectID</span>
                        + &quot; and implementation &quot; + implID);
            }
        }

    }

    /**
     * This function executes the method specified
     *
     * @param instance Instance in which to execute
     * @param implID   Information about the operation to execute
     * @param params   Parameter values used while invoking the operation
     * @return Serialized operation result.
     */
    public Object runImplementation(final DataClayObject instance, final ImplementationID implID,
                                    final Object[] params) {
        // =================== EXECUTION ===================//
        // In case we change namespace (executeInternal called from commonlib)
<span class="nc" id="L926">        final Object result = instance.run(implID, params);</span>
<span class="nc" id="L927">        return result;</span>

    }

    @Override
    public void synchronize(final SessionID sessionID, final ObjectID objectID, final ImplementationID implID,
                                    final SerializedParametersOrReturn params,
                                    final ExecutionEnvironmentID callingBackend) {
<span class="nc" id="L935">        LOGGER.debug(&quot;--&gt; Synchronize started for object {} and calling backend {}&quot;, objectID, callingBackend);</span>

        // first update field
<span class="nc" id="L938">        this.executeImplementation(objectID, implID, params, sessionID);</span>

        // update source
<span class="nc" id="L941">        final DataClayObject instance = runtime.getOrNewInstanceFromDB(objectID, true);</span>
<span class="nc" id="L942">        ExecutionEnvironmentID originalLocation = instance.getOriginLocation();</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if (originalLocation != null) {</span>
<span class="nc bnc" id="L944" title="All 4 branches missed.">            if (callingBackend == null || !originalLocation.equals(callingBackend)) {</span>
<span class="nc" id="L945">                LOGGER.debug(&quot;--&gt; Synchronize: calling object {} original location {} to synchronize&quot;, objectID, originalLocation);</span>
<span class="nc" id="L946">                final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(originalLocation);</span>
<span class="nc" id="L947">                dataServiceApi.synchronize(sessionID, objectID, implID, params, this.executionEnvironmentID);</span>
            }
        }

<span class="nc" id="L951">        Set&lt;ExecutionEnvironmentID&gt; replicaLocations = instance.getReplicaLocations();</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">        if (replicaLocations != null) {</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">            for (ExecutionEnvironmentID replicaLocation: replicaLocations) {</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                if (replicaLocation != null) {</span>
<span class="nc bnc" id="L955" title="All 4 branches missed.">                    if (callingBackend == null || !replicaLocation.equals(callingBackend)) {</span>
<span class="nc" id="L956">                        LOGGER.debug(&quot;--&gt; Synchronize: calling object {} replica location {} to synchronize&quot;, objectID, replicaLocation);</span>
<span class="nc" id="L957">                        final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(replicaLocation);</span>
<span class="nc" id="L958">                        dataServiceApi.synchronize(sessionID, objectID, implID, params, this.executionEnvironmentID);</span>
                    }
                }
<span class="nc" id="L961">            }</span>
        }
<span class="nc" id="L963">        LOGGER.debug(&quot;&lt;-- Finished synchronize for object {} and calling backend {}&quot;, objectID, callingBackend);</span>


<span class="nc" id="L966">    }</span>

    /**
     * Update all objects in memory (or store them if new). Function called at
     * shutdown.
     */
    public void shutdownUpdate() {
        try {
            // =========== Close DataClayGC service ================ //
<span class="nc bnc" id="L975" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L976">                LOGGER.debug(&quot;[==Shutdown==] Shutdown DataClayGC (it can take a while)... &quot;);</span>
            }

<span class="nc bnc" id="L979" title="All 2 branches missed.">            if (Configuration.Flags.PREFETCHING_ENABLED.getBooleanValue()) {</span>
                // Lazy tasks shutdown
<span class="nc" id="L981">                this.lazyTasksTimer.cancel();</span>
            }

            // =========== Update objects ================ //

<span class="nc bnc" id="L986" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L987">                LOGGER.debug(&quot;[==Shutdown==] Wait pending asynchronous (it can take a while)... &quot;);</span>
            }

<span class="nc bnc" id="L990" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L991">                DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
            }

            // Wait for all async requests.
<span class="nc" id="L995">            runtime.waitForAsyncRequestToFinish();</span>

            // FLUSH all objects
<span class="nc" id="L998">            runtime.flushAll();</span>

            // shutdown GC threads
<span class="nc" id="L1001">            this.storageLocation.shutDownGarbageCollector();</span>

            // shutdown storage location
<span class="nc" id="L1004">            this.storageLocation.closeDbHandler(this.executionEnvironmentID);</span>

<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L1007">                DataClayMockObject.removeCurrentThreadLib();</span>
            }

<span class="nc" id="L1010">        } catch (final Exception ex) {</span>
<span class="nc" id="L1011">            LOGGER.debug(&quot;shutdownUpdate error&quot;, ex);</span>
<span class="nc" id="L1012">        }</span>
<span class="nc" id="L1013">    }</span>

    @Override
    public void upsertObjects(final SessionID sessionID, final List&lt;ObjectWithDataParamOrReturn&gt; objectIDsAndBytes) {

<span class="nc" id="L1018">        runtime.setCurrentThreadSessionID(sessionID);</span>
        try {
<span class="nc" id="L1020">            final List&lt;ObjectWithDataParamOrReturn&gt; objectsInOtherBackend = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1021">            final List&lt;ObjectWithDataParamOrReturn&gt; updatedObjectsHere = new ArrayList&lt;&gt;();</span>

            // To check for replicas
<span class="nc bnc" id="L1024" title="All 2 branches missed.">            for (final ObjectWithDataParamOrReturn curEntry : objectIDsAndBytes) {</span>

<span class="nc" id="L1026">                final ObjectID objectID = curEntry.getObjectID();</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1028">                    LOGGER.debug(&quot;[==Upsert==] Updated or inserted object &quot; + objectID);</span>
                }
                try {
                    // Update bytes at memory object
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                    if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1033">                        LOGGER.debug(&quot;[==Upsert==] Getting/Creating instance from upsert with id &quot; + objectID);</span>
                    }
<span class="nc" id="L1035">                    final DataClayExecutionObject instance = runtime.getOrNewInstanceFromDB(objectID, false);</span>
<span class="nc" id="L1036">                    runtime.deserializeDataIntoInstance(instance, curEntry, null);</span>
<span class="nc" id="L1037">                    instance.setDirty(true); // IMPORTANT: instance now is dirty due to update!</span>
<span class="nc" id="L1038">                    updatedObjectsHere.add(curEntry);</span>
<span class="nc" id="L1039">                } catch (final DbObjectNotExistException e) {</span>
                    // GET IN OTHER BACKEND
<span class="nc" id="L1041">                    objectsInOtherBackend.add(curEntry);</span>
<span class="nc" id="L1042">                }</span>
<span class="nc" id="L1043">            }</span>

            // NOTE: update hints of objects since they come from other backends in this call
            // Prepare hints to update
<span class="nc" id="L1047">            this.updateHintsToCurrentExecEnv(updatedObjectsHere);</span>

<span class="nc" id="L1049">            upsertObjectsInOtherBackend(sessionID, objectsInOtherBackend);</span>
        } finally {
            // Do not remove it since it might be called from inside
            /*
             * clientLib.removeSessionIDForThread(threadID); if (Configuration.MOCK_TESTING)
             * { DataClayMockObject.removeCurrentThreadLib(); }
             */
        }
<span class="nc" id="L1057">    }</span>

    /**
     * Update object in another backend.
     *
     * @param sessionID           ID of session
     * @param objectsInOtherNodes List of metadata of objects to update and its bytes. It is useful
     *                            to avoid multiple trips.
     * @throws RemoteException if some exception occurs
     */
    private void upsertObjectsInOtherBackend(final SessionID sessionID,
                                             final List&lt;ObjectWithDataParamOrReturn&gt; objectsInOtherNodes) {
        // Prepare to unify calls (only one call for DS)
<span class="nc" id="L1070">        final Map&lt;ExecutionEnvironmentID, List&lt;ObjectWithDataParamOrReturn&gt;&gt; objectsPerBackend = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1072" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn curEntry : objectsInOtherNodes) {</span>
<span class="nc" id="L1073">            final ObjectID curObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1074">            final MetaDataInfo mdInfo = runtime.getObjectMetadata(curObjectID);</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">            if (mdInfo == null) {</span>
                // TODO: review exception design, getObjectMetadata is returning null in case
                // object not registered.
                // WARNING: This exception should not happen here
                // NOTE: if it is a volatile and hint failed, it means that object is actually
                // not registered
<span class="nc" id="L1081">                throw new ObjectNotRegisteredException(curObjectID);</span>
            }
<span class="nc" id="L1083">            final Set&lt;ExecutionEnvironmentID&gt; locations = mdInfo.getLocations();</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1085">                LOGGER.debug(</span>
                        &quot;[==Upsert==] Updating objects in other backends. Locations of objects: &quot; + locations);
            }
            // Update object at first location (NOT UPDATING REPLICAS!!!)
<span class="nc" id="L1089">            final ExecutionEnvironmentID curLoc = locations.iterator().next();</span>
<span class="nc" id="L1090">            List&lt;ObjectWithDataParamOrReturn&gt; objectsInBackend = objectsPerBackend.get(curLoc);</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">            if (objectsInBackend == null) {</span>
<span class="nc" id="L1092">                objectsInBackend = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1093">                objectsPerBackend.put(curLoc, objectsInBackend);</span>
            }
<span class="nc" id="L1095">            objectsInBackend.add(curEntry);</span>
<span class="nc" id="L1096">        }</span>

        // Now call
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        for (final Entry&lt;ExecutionEnvironmentID, List&lt;ObjectWithDataParamOrReturn&gt;&gt; curEntry : objectsPerBackend</span>
<span class="nc" id="L1100">                .entrySet()) {</span>
<span class="nc" id="L1101">            ExecutionEnvironmentID backendID = curEntry.getKey();</span>
<span class="nc" id="L1102">            final List&lt;ObjectWithDataParamOrReturn&gt; objectsToUpdate = curEntry.getValue();</span>
<span class="nc" id="L1103">            final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(backendID);</span>
<span class="nc" id="L1104">            dataServiceApi.upsertObjects(sessionID, objectsToUpdate);</span>

<span class="nc" id="L1106">        }</span>
<span class="nc" id="L1107">    }</span>

    @Override
    public SerializedParametersOrReturn getCopyOfObject(final SessionID sessionID, final ObjectID objectID,
                                                        final boolean recursive) {
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1113">            LOGGER.debug(&quot;[==GetCopyOfObject==] Retrieving copy of &quot; + objectID);</span>
        }

        // Get the data service of one of the backends that contains the original
        // object.
<span class="nc" id="L1118">        final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1119">        objectIDs.add(objectID);</span>

<span class="nc" id="L1121">        final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs, new HashSet&lt;ObjectID&gt;(), recursive, null, 0);</span>
        // Prepare OIDs
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1124">            LOGGER.debug(&quot;[==GetCopyOfObject==] Objects obtained to return a copy of &quot; + objectID);</span>
        }

<span class="nc" id="L1127">        final Map&lt;ObjectID, ObjectID&gt; originalToVersion = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1129" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn curEntry : serializedObjs) {</span>
<span class="nc" id="L1130">            final ObjectID origObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1131">            final ObjectID versionObjectID = new ObjectID();</span>
<span class="nc" id="L1132">            originalToVersion.put(origObjectID, versionObjectID);</span>
<span class="nc" id="L1133">        }</span>

<span class="nc bnc" id="L1135" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn curEntry : serializedObjs) {</span>
            // Store version in this backend (if already stored, just skip it)
<span class="nc" id="L1137">            final ObjectID origObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1138">            final ObjectID versionObjectID = originalToVersion.get(origObjectID);</span>
<span class="nc" id="L1139">            final DataClayObjectMetaData metadata = curEntry.getMetaData();</span>
<span class="nc" id="L1140">            metadata.modifyOids(originalToVersion);</span>
<span class="nc" id="L1141">            curEntry.setObjectID(versionObjectID);</span>
<span class="nc" id="L1142">        }</span>

<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1145">            LOGGER.debug(&quot;[==GetCopyOfObject==] Updated OIDs and references to return a copy of &quot; + objectID);</span>
        }

<span class="nc" id="L1148">        final SerializedParametersOrReturn serParamReturn = new SerializedParametersOrReturn(serializedObjs);</span>

<span class="nc" id="L1150">        return serParamReturn;</span>
    }

    @Override
    public void updateObject(final SessionID sessionID, final ObjectID intoObjectID,
                             final SerializedParametersOrReturn fromObject) {
        try {
            // create lots of objects here and stash them somewhere
<span class="nc bnc" id="L1158" title="All 2 branches missed.">            if (sessionID != null) {</span>
<span class="nc" id="L1159">                runtime.setCurrentThreadSessionID(sessionID);</span>
            }
<span class="nc bnc" id="L1161" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1162">                LOGGER.debug(&quot;[==UpdateObject==] ** Updating object &quot; + intoObjectID);</span>
            }

<span class="nc" id="L1165">            final DataClayObject instanceInto = runtime.getOrNewInstanceFromDB(intoObjectID, true);</span>
<span class="nc" id="L1166">            final Object[] aux = DataClayDeserializationLib.deserializeParamsOrReturn(fromObject, null, runtime);</span>
<span class="nc" id="L1167">            final DataClayObject instanceFrom = (DataClayObject) aux[0];</span>

<span class="nc bnc" id="L1169" title="All 2 branches missed.">            if (Configuration.Flags.CHECK_SESSION.getBooleanValue()) {</span>
<span class="nc" id="L1170">                this.runtime.checkSession(instanceInto.getDataSetID(), sessionID);</span>
            }

            // ============================= EXECUTE =========================== //
<span class="nc bnc" id="L1174" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1175">                LOGGER.debug(&quot;[==UpdateObject==] ** Updating object &quot; + intoObjectID + &quot; from object &quot;</span>
<span class="nc" id="L1176">                        + instanceFrom.getID());</span>
            }

<span class="nc" id="L1179">            instanceInto.setAll(instanceFrom);</span>

<span class="nc bnc" id="L1181" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1182">                LOGGER.debug(&quot;[==UpdateObject==] ** Updated object &quot; + intoObjectID + &quot; from object &quot;</span>
<span class="nc" id="L1183">                        + instanceFrom.getID());</span>
            }

<span class="nc" id="L1186">        } catch (final Exception e) {</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1188">                LOGGER.debug(&quot;[==UpdateObject==] Caugh exception during putObject: &quot;, e);</span>
            }
        } finally {
<span class="nc bnc" id="L1191" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L1192">                DataClayMockObject.removeCurrentThreadLib();</span>
            }
<span class="nc" id="L1194">            runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1196">                LOGGER.debug(&quot;[==UpdateObject==] ** End of updating object &quot; + intoObjectID);</span>
            }
        }
<span class="nc" id="L1199">    }</span>

    @Override
    public List&lt;ObjectWithDataParamOrReturn&gt; getObjects(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs,
                                                        final Set&lt;ObjectID&gt; alreadyObtainedObjs,
                                                        final boolean recursive, final ExecutionEnvironmentID replicaDestBackendID,
                                                        final int updateReplicaLocs) {
<span class="nc" id="L1206">        LOGGER.debug(&quot;----&gt; Starting get objects &quot; + objectIDs);</span>

<span class="nc" id="L1208">        final List&lt;ObjectWithDataParamOrReturn&gt; result = new ArrayList&lt;&gt;();</span>
        try {
<span class="nc" id="L1210">            runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc" id="L1211">            final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; objectsInOtherBackend = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">            for (final ObjectID objectID : objectIDs) {</span>

<span class="nc bnc" id="L1214" title="All 2 branches missed.">                if (recursive) {</span>
<span class="nc" id="L1215">                    final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; pendingObjs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1216">                    pendingObjs.add(new Tuple&lt;&gt;(objectID, null));</span>
<span class="nc" id="L1217">                    final ListIterator&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; it = pendingObjs</span>
<span class="nc" id="L1218">                            .listIterator(pendingObjs.size());</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                    while (it.hasPrevious()) {</span>
<span class="nc" id="L1220">                        final Tuple&lt;ObjectID, ExecutionEnvironmentID&gt; idAndHint = it.previous();</span>
<span class="nc" id="L1221">                        final ObjectID curObID = idAndHint.getFirst();</span>
<span class="nc" id="L1222">                        final ExecutionEnvironmentID hint = idAndHint.getSecond();</span>

<span class="nc bnc" id="L1224" title="All 2 branches missed.">                        if (DEBUG_ENABLED) {  LOGGER.debug(&quot;[==Get==] Getting &quot; + curObID); }</span>
<span class="nc" id="L1225">                        it.remove();</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                        if (alreadyObtainedObjs.contains(curObID)) {</span>
                            // Already read
<span class="nc bnc" id="L1228" title="All 2 branches missed.">                            if (DEBUG_ENABLED) {  LOGGER.debug(&quot;[==Get==] Object {} already obtained&quot;, curObID); }</span>
                            continue;
                        }

<span class="nc bnc" id="L1232" title="All 4 branches missed.">                        if (hint != null &amp;&amp; !hint.equals(this.executionEnvironmentID)) {</span>
                            // GET IN OTHER BACKEND
<span class="nc bnc" id="L1234" title="All 2 branches missed.">                            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1235">                                LOGGER.debug(&quot;[==Get==] {} is not in this backend obj hint {} != current loc {} &quot;, curObID, hint, this.executionEnvironmentID);</span>
                            }
<span class="nc" id="L1237">                            objectsInOtherBackend.add(new Tuple&lt;&gt;(curObID, hint));</span>
<span class="nc" id="L1238">                            continue;</span>
                        }

                        try {
<span class="nc" id="L1242">                            final ObjectWithDataParamOrReturn objWithData = getObjectInternal(curObID, replicaDestBackendID,</span>
                                    updateReplicaLocs);
<span class="nc bnc" id="L1244" title="All 2 branches missed.">                            if (objWithData != null) {</span>
<span class="nc" id="L1245">                                result.add(objWithData);</span>
<span class="nc" id="L1246">                                alreadyObtainedObjs.add(curObID);</span>
                                // Get associated objects (recursive)
<span class="nc" id="L1248">                                final DataClayObjectMetaData metadata = objWithData.getMetaData();</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                                for (final Entry&lt;Integer, ObjectID&gt; associatedOIDEntry : metadata.getOids().entrySet()) {</span>
<span class="nc" id="L1250">                                    final Integer tag = associatedOIDEntry.getKey();</span>
<span class="nc" id="L1251">                                    final ObjectID associatedOID = associatedOIDEntry.getValue();</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">                                    if (!alreadyObtainedObjs.contains(associatedOID)) {</span>
<span class="nc" id="L1253">                                        it.add(new Tuple&lt;&gt;(associatedOID, metadata.getHint(tag)));</span>
                                    }
<span class="nc" id="L1255">                                }</span>
                            }
<span class="nc" id="L1257">                        } catch (final DbObjectNotExistException e) {</span>
                            // GET IN OTHER BACKEND
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                            if (DEBUG_ENABLED) {  LOGGER.debug(&quot;[==Get==] Not in this backend (wrong or null hint): &quot; + curObID); }</span>
<span class="nc" id="L1260">                            objectsInOtherBackend.add(new Tuple&lt;&gt;(curObID, null));</span>
<span class="nc" id="L1261">                        }</span>
<span class="nc" id="L1262">                    }</span>
<span class="nc" id="L1263">                } else {</span>
<span class="nc" id="L1264">                    final ObjectWithDataParamOrReturn objWithData = getObjectInternal(objectID, replicaDestBackendID, updateReplicaLocs);</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">                    if (objWithData != null) {</span>
<span class="nc" id="L1266">                        result.add(objWithData);</span>
                    }
                }
<span class="nc" id="L1269">            }</span>

<span class="nc" id="L1271">            result.addAll(getObjectsInOtherBackend(sessionID, objectsInOtherBackend, alreadyObtainedObjs, true, replicaDestBackendID, updateReplicaLocs));</span>


        } finally {
            /*
             * clientLib.removeSessionIDForThread(threadID); if (Configuration.MOCK_TESTING)
             * { DataClayMockObject.removeCurrentThreadLib(); }
             */
            // Don't remove since it might be called from inside function
        }
<span class="nc" id="L1281">        LOGGER.debug(&quot;&lt;---- Finished get objects &quot; + objectIDs);</span>

<span class="nc" id="L1283">        return result;</span>
    }

    /**
     * Get object internal function
     *
     * @param objectID   ID of the object ot get
     * @param replicaDestBackendID Destination backend of objects being obtained for replica
     * @param updateReplicaLocs If 1, provided replica dest backend id must be added to replica locs of obtained objects
     *                          If 2, provided replica dest backend id must be removed from replica locs
     *                          If 0, replicaDestBackendID field is ignored
     * @return Object with data
     */
    private ObjectWithDataParamOrReturn getObjectInternal(final ObjectID objectID,
                                                          final ExecutionEnvironmentID replicaDestBackendID,
                                                          final int updateReplicaLocs) {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1300">            LOGGER.debug(&quot;[==Get==] Getting/Creating instance for &quot; + objectID);</span>
        }
<span class="nc" id="L1302">        ObjectWithDataParamOrReturn objWithData = null;</span>
        // lock serialization to avoid GC serializing at same time without replica locs
<span class="nc" id="L1304">        runtime.lock(objectID);</span>
        try {
<span class="nc" id="L1306">            final DataClayExecutionObject instance = runtime.getOrNewInstanceFromDB(objectID, false);</span>
<span class="nc" id="L1307">            final List&lt;DataClayObject&gt; pendingObjs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1308">            final ListIterator&lt;DataClayObject&gt; it = pendingObjs.listIterator(pendingObjs.size());</span>
<span class="nc bnc" id="L1309" title="All 4 branches missed.">            if (replicaDestBackendID != null &amp;&amp; updateReplicaLocs == 1) { // update = 1 means new replica/federation</span>
<span class="nc bnc" id="L1310" title="All 4 branches missed.">                if (instance.getReplicaLocations() != null &amp;&amp; instance.getReplicaLocations().contains(replicaDestBackendID)) {</span>
                    // already replicated
<span class="nc" id="L1312">                    LOGGER.debug(&quot;[==Get==] WARNING: Already replicated &quot; + objectID + &quot;. Skipping get&quot;);</span>
<span class="nc" id="L1313">                    return null;</span>
                }
            }
<span class="nc" id="L1316">            objWithData = DataClaySerializationLib.serializeDataClayObjectWithData(instance, runtime, false, null, it,</span>
<span class="nc" id="L1317">                    false, instance.getHint(), false);</span>
<span class="nc bnc" id="L1318" title="All 4 branches missed.">            if (replicaDestBackendID != null &amp;&amp; updateReplicaLocs == 1) {</span>
<span class="nc" id="L1319">                    LOGGER.debug(&quot;[==Get==] Setting object {} replica location {}&quot;, objectID, replicaDestBackendID);</span>
<span class="nc" id="L1320">                    instance.addReplicaLocations(replicaDestBackendID);</span>
<span class="nc" id="L1321">                    instance.setDirty(true);</span>
<span class="nc" id="L1322">                    LOGGER.debug(&quot;[==Get==] Serializing object {} with dest replica locs {}&quot;, objectID, objWithData.getMetaData().getReplicaLocations());</span>
<span class="nc" id="L1323">                    LOGGER.debug(&quot;[==Get==] Setting object {} original location {} &quot;, objectID, this.executionEnvironmentID);</span>
<span class="nc" id="L1324">                    objWithData.getMetaData().setOriginLocation(this.executionEnvironmentID);</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">            } else if (updateReplicaLocs == 2) {</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">                if (replicaDestBackendID != null) {</span>
<span class="nc" id="L1327">                    LOGGER.debug(&quot;[==Get==] Removing from object {} the replica location {}&quot;, objectID, replicaDestBackendID);</span>
<span class="nc" id="L1328">                    instance.removeReplicaLocation(replicaDestBackendID);</span>
                } else {
<span class="nc" id="L1330">                    LOGGER.debug(&quot;[==Get==] Removing from object {} all replica locations&quot;, objectID);</span>
<span class="nc" id="L1331">                    instance.clearReplicaLocations();</span>

                }
<span class="nc" id="L1334">                instance.setDirty(true);</span>
            }


        } finally {
<span class="nc" id="L1339">            runtime.unlock(objectID);</span>
        }
<span class="nc" id="L1341">        return objWithData;</span>
    }

    /**
     * Get object in another backend. This function is called from DbHandler in a
     * recursive get.
     *
     * @param sessionID           ID of session
     * @param objectsInOtherNodes List of metadata of objects to read. It is useful to avoid
     *                            multiple trips.
     * @param recursive           Indicates is recursive
     * @param replicaDestBackendID Destination backend of objects being obtained for replica
     * @param updateReplicaLocs If 1, provided replica dest backend id must be added to replica locs of obtained objects
     *                          If 2, provided replica dest backend id must be removed from replica locs
     *                          If 0, replicaDestBackendID field is ignored
     * @return Map of serialized object where key is the objectID. Object is not serialized if flag getOnlyRefs=true
     */
    private List&lt;ObjectWithDataParamOrReturn&gt; getObjectsInOtherBackend(final SessionID sessionID,
                                                                       final List&lt;Tuple&lt;ObjectID, ExecutionEnvironmentID&gt;&gt; objectsInOtherNodes,
                                                                       final Set&lt;ObjectID&gt; alreadyObtainedObjs,
                                                                       final boolean recursive,
                                                                       final ExecutionEnvironmentID replicaDestBackendID,
                                                                       final int updateReplicaLocs) {

<span class="nc" id="L1365">        final List&lt;ObjectWithDataParamOrReturn&gt; result = new ArrayList&lt;&gt;();</span>

        // Prepare to unify calls (only one call per DS)
<span class="nc" id="L1368">        final Map&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; objectsPerBackend = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1370" title="All 2 branches missed.">        for (final Tuple&lt;ObjectID, ExecutionEnvironmentID&gt; curObjectIDEntry : objectsInOtherNodes) {</span>
<span class="nc" id="L1371">            final ObjectID curObjectID = curObjectIDEntry.getFirst();</span>
<span class="nc" id="L1372">            final ExecutionEnvironmentID hint = curObjectIDEntry.getSecond();</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1374">                LOGGER.debug(&quot;[==GetObjectsInOtherBackend==] Looking for metadata of &quot; + curObjectID);</span>
            }
<span class="nc" id="L1376">            Set&lt;ExecutionEnvironmentID&gt; locations = null;</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">            if (hint != null) {</span>
<span class="nc" id="L1378">                locations = new HashSet&lt;ExecutionEnvironmentID&gt;();</span>
<span class="nc" id="L1379">                locations.add(hint);</span>
            } else {
<span class="nc" id="L1381">                final MetaDataInfo mdInfo = runtime.getObjectMetadata(curObjectID);</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">                if (mdInfo == null) {</span>
                    // TODO: review exception design, getObjectMetadata is returning null in case
                    // object not registered.
                    // WARNING: This exception should not happen here
                    // NOTE: if it is a volatile and hint failed, it means that object is actually
                    // not registered
<span class="nc" id="L1388">                    throw new ObjectNotRegisteredException(curObjectID);</span>
                } else {
<span class="nc" id="L1390">                    locations = mdInfo.getLocations();</span>
                }
            }
            // Always obtain from the first location
<span class="nc" id="L1394">            final ExecutionEnvironmentID backendSrc = locations.iterator().next();</span>
<span class="nc" id="L1395">            Set&lt;ObjectID&gt; objectsInBackend = objectsPerBackend.get(backendSrc);</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">            if (objectsInBackend == null) {</span>
<span class="nc" id="L1397">                objectsInBackend = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1398">                objectsPerBackend.put(backendSrc, objectsInBackend);</span>
            }
<span class="nc" id="L1400">            objectsInBackend.add(curObjectID);</span>
<span class="nc" id="L1401">        }</span>

        // Now call
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        for (final Entry&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; curEntry : objectsPerBackend.entrySet()) {</span>
<span class="nc" id="L1405">            final ExecutionEnvironmentID backendID = curEntry.getKey();</span>
<span class="nc" id="L1406">            final Set&lt;ObjectID&gt; objectsToGet = curEntry.getValue();</span>

<span class="nc bnc" id="L1408" title="All 4 branches missed.">            if (replicaDestBackendID == null || !replicaDestBackendID.equals(backendID)) {</span>
                // do not get objects already in destination backend
<span class="nc" id="L1410">                final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(backendID);</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1412">                    LOGGER.debug(&quot;[==Get==] Get from other location, objects: &quot; + objectsToGet);</span>
                }
<span class="nc" id="L1414">                final List&lt;ObjectWithDataParamOrReturn&gt; curResult = dataServiceApi.getObjects(sessionID, objectsToGet,</span>
                        alreadyObtainedObjs, recursive, replicaDestBackendID, updateReplicaLocs);
<span class="nc" id="L1416">                result.addAll(curResult);</span>
            }

<span class="nc" id="L1419">        }</span>
<span class="nc" id="L1420">        return result;</span>
    }

    @Override
    public Map&lt;ObjectID, ExecutionEnvironmentID&gt; removeObjects(final SessionID sessionID, final Set&lt;ObjectID&gt; objectIDs,
                                                               final boolean recursive, final boolean moving, final ExecutionEnvironmentID newHint) {

<span class="nc" id="L1427">        final Map&lt;ObjectID, ExecutionEnvironmentID&gt; removedObjs = new ConcurrentHashMap&lt;&gt;();</span>
        try {
<span class="nc" id="L1429">            runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L1431">                DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
            }

<span class="nc" id="L1434">            final List&lt;ObjectID&gt; objectsInOtherBackend = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">            for (final ObjectID objectID : objectIDs) {</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">                if (recursive) {</span>
<span class="nc" id="L1437">                    final List&lt;ObjectID&gt; pendingObjs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L1438">                    pendingObjs.add(objectID);</span>
<span class="nc" id="L1439">                    final ListIterator&lt;ObjectID&gt; it = pendingObjs.listIterator(pendingObjs.size());</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">                    while (it.hasPrevious()) {</span>
<span class="nc" id="L1441">                        final ObjectID curObID = it.previous();</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">                        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1443">                            LOGGER.debug(&quot;[==Remove==] Removing &quot; + curObID);</span>
                        }

<span class="nc" id="L1446">                        it.remove();</span>

<span class="nc bnc" id="L1448" title="All 2 branches missed.">                        if (removedObjs.get(curObID) != null) {</span>
                            // Already removed
<span class="nc" id="L1450">                            continue;</span>
                        }
                        // If is in this DS, remove it.
<span class="nc" id="L1453">                        removedObjs.put(curObID, executionEnvironmentID);</span>
                        try {

                            // Get bytes from DB first
<span class="nc" id="L1457">                            final byte[] objBytes = get(this.executionEnvironmentID, curObID);</span>
                            // Remove and check if in memory
<span class="nc" id="L1459">                            removeObjectInternal(sessionID, curObID, moving, newHint);</span>
<span class="nc" id="L1460">                            final DataClayObjectMetaData metadata = DataClayDeserializationLib</span>
<span class="nc" id="L1461">                                    .deserializeMetaDataFromDB(objBytes);</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">                            for (final ObjectID associatedOID : metadata.getOids().values()) {</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">                                if (removedObjs.get(associatedOID) == null) {</span>
<span class="nc" id="L1464">                                    it.add(associatedOID);</span>
                                }
<span class="nc" id="L1466">                            }</span>

<span class="nc" id="L1468">                        } catch (final DbObjectNotExistException ex) {</span>
<span class="nc" id="L1469">                            LOGGER.debug(&quot;Object {} not found in this node, adding to remove in another.&quot;, curObID);</span>
<span class="nc" id="L1470">                            LOGGER.debug(&quot;removeObjects error&quot;, ex);</span>
                            // REMOVE IN OTHER BACKEND
<span class="nc" id="L1472">                            objectsInOtherBackend.add(curObID);</span>
<span class="nc" id="L1473">                        }</span>
<span class="nc" id="L1474">                    }</span>

<span class="nc" id="L1476">                } else {</span>
<span class="nc" id="L1477">                    removeObjectInternal(sessionID, objectID, moving, newHint);</span>
                }
<span class="nc" id="L1479">            }</span>

<span class="nc bnc" id="L1481" title="All 2 branches missed.">            if (recursive) {</span>
<span class="nc" id="L1482">                removedObjs</span>
<span class="nc" id="L1483">                        .putAll(removeObjectsInOtherBackend(sessionID, objectsInOtherBackend, true, moving, newHint));</span>
            }

        } finally {
<span class="nc" id="L1487">            runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L1489">                DataClayMockObject.removeCurrentThreadLib();</span>
            }

        }
<span class="nc" id="L1493">        return removedObjs;</span>

    }

    /**
     * Remove object internal function
     *
     * @param sessionID ID of session removing
     * @param objectID  ID of the object to remove
     * @param moving    Indicates remove was done by a movement.
     * @param newHint   New hint in case of movement
     * @throws DbObjectNotExistException if object is not in database
     */
    private void removeObjectInternal(final SessionID sessionID, final ObjectID objectID, final boolean moving,
                                      final ExecutionEnvironmentID newHint) {
<span class="nc bnc" id="L1508" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1509">            LOGGER.debug(&quot;[==Remove==] Removing object &quot; + objectID);</span>
        }
<span class="nc" id="L1511">        final DataClayExecutionObject instance = runtime.getOrNewInstanceFromDB(objectID, true);</span>
<span class="nc" id="L1512">        runtime.lock(objectID);</span>
        try {
<span class="nc bnc" id="L1514" title="All 2 branches missed.">            if (moving) {</span>
<span class="nc" id="L1515">                this.runtime.setWeakProxy(instance, newHint);</span>
            } else {

<span class="nc" id="L1518">                instance.setPendingToRegister(true);</span>
<span class="nc" id="L1519">                instance.setOwnerSessionIDforVolatiles(sessionID);</span>
<span class="nc" id="L1520">                runtime.removeFromHeap(objectID); // remove old</span>

<span class="nc bnc" id="L1522" title="All 2 branches missed.">                if (Configuration.Flags.NOTIFICATION_MANAGER_ACTIVE.getBooleanValue()) {</span>

                    // === NOTIFY NOTIFICATION MANAGER === //
                    // Removed instance is send as a volatile object!
<span class="nc" id="L1526">                    final List&lt;DataClaySerializable&gt; wrappedParams = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L1528">                    wrappedParams.add(instance);</span>
<span class="nc" id="L1529">                    final SerializedParametersOrReturn serParams = DataClaySerializationLib.serializeParamsOrReturn(</span>
                            wrappedParams, null, runtime, false, executionEnvironmentID, false);
<span class="nc" id="L1531">                    serParams.removeReferencesForYaml();</span>
<span class="nc" id="L1532">                    final MetaDataInfo metadata = runtime.getObjectMetadata(objectID);</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">                    if (metadata == null) {</span>
                        // TODO: review exception design, getObjectMetadata is returning null in case
                        // object not registered.
                        // WARNING: This exception should not happen here
                        // NOTE: if it is a volatile and hint failed, it means that object is actually
                        // not registered
<span class="nc" id="L1539">                        throw new ObjectNotRegisteredException(objectID);</span>
                    }
<span class="nc" id="L1541">                    final MetaClassID classID = metadata.getMetaclassID();</span>
<span class="nc" id="L1542">                    final EventType eventType = new DeletedObjEventType(classID);</span>
<span class="nc" id="L1543">                    final EventMessage eventMsg = new EventMessage(objectID, eventType, serParams);</span>
<span class="nc" id="L1544">                    this.runtime.getLogicModuleAPI().adviseEvent(eventMsg);</span>
                }

                // Set object to volatile
<span class="nc" id="L1548">                instance.setNewObjectID();</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1550">                    LOGGER.debug(&quot;[==Cache==] Added to objectsMap due to remove &quot; + instance.getObjectID()</span>
<span class="nc" id="L1551">                            + &quot; of class &quot; + instance.getClass().getName() + &quot;. System.id = &quot;</span>
<span class="nc" id="L1552">                            + System.identityHashCode(instance));</span>
                }
<span class="nc" id="L1554">                runtime.addToHeap(instance);</span>
            }

            // ==== REMOVE ==== //
            // Remove object from MD cache and Database
<span class="nc bnc" id="L1559" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1560">                LOGGER.debug(&quot;[==Remove==] Removing metadata info from MetaData Cache: &quot; + objectID);</span>
            }
<span class="nc" id="L1562">            runtime.removeObjectMetadataFromCache(objectID);</span>
<span class="nc" id="L1563">            this.storageLocation.delete(this.executionEnvironmentID, objectID);</span>

        } finally {
<span class="nc" id="L1566">            runtime.unlock(objectID);</span>
        }

<span class="nc" id="L1569">    }</span>

    /**
     * Remove objects in another backend.
     *
     * @param sessionID           ID of session removing
     * @param objectsInOtherNodes List of objects to remove in other backends
     * @param recursive           Indicates is recursive
     * @param moving              Indicates objects are being removed due to a movement.
     * @param newHint             New hint to be set
     * @return ID of objects and for each object, its BackendID.
     */
    private Map&lt;ObjectID, ExecutionEnvironmentID&gt; removeObjectsInOtherBackend(final SessionID sessionID,
                                                                              final List&lt;ObjectID&gt; objectsInOtherNodes, final boolean recursive, final boolean moving,
                                                                              final ExecutionEnvironmentID newHint) {
<span class="nc" id="L1584">        final Map&lt;ObjectID, ExecutionEnvironmentID&gt; result = new ConcurrentHashMap&lt;&gt;();</span>

        // Prepare to unify calls (only one call for DS)
<span class="nc" id="L1587">        final Map&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; objectsPerBackend = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">        for (final ObjectID curObjectID : objectsInOtherNodes) {</span>
<span class="nc" id="L1589">            final MetaDataInfo mdInfo = runtime.getObjectMetadata(curObjectID);</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">            if (mdInfo == null) {</span>
                // TODO: review exception design, getObjectMetadata is returning null in case
                // object not registered.
                // WARNING: This exception should not happen here
                // NOTE: if it is a volatile and hint failed, it means that object is actually
                // not registered
<span class="nc" id="L1596">                throw new ObjectNotRegisteredException(curObjectID);</span>
            }
<span class="nc" id="L1598">            final Set&lt;ExecutionEnvironmentID&gt; locations = mdInfo.getLocations();</span>
            // Always obtain from the first location
<span class="nc" id="L1600">            final ExecutionEnvironmentID backendSrc = locations.iterator().next();</span>
<span class="nc" id="L1601">            Set&lt;ObjectID&gt; objectsInBackend = objectsPerBackend.get(backendSrc);</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">            if (objectsInBackend == null) {</span>
<span class="nc" id="L1603">                objectsInBackend = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1604">                objectsPerBackend.put(backendSrc, objectsInBackend);</span>
            }
<span class="nc" id="L1606">            objectsInBackend.add(curObjectID);</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1608">                LOGGER.debug(&quot;[==Remove==] Removing metadata info from MetaData Cache: &quot; + curObjectID);</span>
            }
<span class="nc" id="L1610">            runtime.removeObjectMetadataFromCache(curObjectID);</span>
<span class="nc" id="L1611">            result.put(curObjectID, backendSrc);</span>
<span class="nc" id="L1612">        }</span>

        // Now call
<span class="nc bnc" id="L1615" title="All 2 branches missed.">        for (final Entry&lt;ExecutionEnvironmentID, Set&lt;ObjectID&gt;&gt; curEntry : objectsPerBackend.entrySet()) {</span>
<span class="nc" id="L1616">            final ExecutionEnvironmentID backendID = curEntry.getKey();</span>
<span class="nc" id="L1617">            final Set&lt;ObjectID&gt; objectsToRemove = curEntry.getValue();</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1619">                LOGGER.debug(&quot;[==Remove==] Calling remove in other backend for: &quot; + objectsToRemove);</span>
            }
<span class="nc" id="L1621">            final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(backendID);</span>
<span class="nc" id="L1622">            dataServiceApi.removeObjects(sessionID, objectsToRemove, recursive, moving, newHint);</span>

<span class="nc" id="L1624">        }</span>
<span class="nc" id="L1625">        return result;</span>
    }

    @Override
    public Set&lt;ObjectID&gt; newReplica(final SessionID sessionID, final ObjectID objectID,
                                                      final ExecutionEnvironmentID destBackendID,
                                                      final boolean recursive) {
<span class="nc" id="L1632">        LOGGER.debug(&quot;----&gt; Starting new replica of &quot; + objectID);</span>

        // Get the original object.
<span class="nc" id="L1635">        final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1636">        objectIDs.add(objectID);</span>
<span class="nc" id="L1637">        final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID,</span>
                objectIDs, new HashSet&lt;ObjectID&gt;(), recursive, destBackendID, 1);

        // Store it in destination backend
<span class="nc" id="L1641">        final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(destBackendID);</span>
<span class="nc" id="L1642">        dataServiceApi.storeObjects(sessionID, serializedObjs, false, null);</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">        for (ObjectWithDataParamOrReturn objectWithDataParamOrReturn : serializedObjs) {</span>
<span class="nc" id="L1644">            objectIDs.add(objectWithDataParamOrReturn.getObjectID());</span>
<span class="nc" id="L1645">        }</span>
<span class="nc" id="L1646">        LOGGER.debug(&quot;&lt;---- Finished new replica of &quot; + objectID);</span>
<span class="nc" id="L1647">        return objectIDs;</span>
    }

    @Override
    public ObjectID newVersion(final SessionID sessionID, final ObjectID objectID,
                           final ExecutionEnvironmentID destBackendID) {
<span class="nc bnc" id="L1653" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1654">            LOGGER.debug(&quot;----&gt; Starting new version for {} to destination backend {}&quot;, objectID, destBackendID);</span>
        }

        // Get the original object.
<span class="nc" id="L1658">        final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1659">        objectIDs.add(objectID);</span>
<span class="nc" id="L1660">        final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs, new HashSet&lt;ObjectID&gt;(),true, null, 0);</span>

        // Prepare OIDs
<span class="nc bnc" id="L1663" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1664">            LOGGER.debug(&quot;[==Version==] Objects obtained to create version for &quot; + objectID);</span>
        }

<span class="nc" id="L1667">        final Map&lt;ObjectID, ObjectID&gt; originalToVersion = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn curEntry : serializedObjs) {</span>
            // Store version in this backend (if already stored, just skip it)
<span class="nc" id="L1670">            final ObjectID origObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1671">            final ObjectID versionObjectID = new ObjectID();</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1673">                LOGGER.debug(&quot;[==Version==] Creating version {} -&gt; {} &quot;, origObjectID, versionObjectID);</span>
            }
<span class="nc" id="L1675">            originalToVersion.put(origObjectID, versionObjectID);</span>
<span class="nc" id="L1676">        }</span>

<span class="nc bnc" id="L1678" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn curEntry : serializedObjs) {</span>
            // Store version in dest backend (if already stored, just skip it)
<span class="nc" id="L1680">            final ObjectID origObjectID = curEntry.getObjectID();</span>
<span class="nc" id="L1681">            final ObjectID versionObjectID = originalToVersion.get(origObjectID);</span>
<span class="nc" id="L1682">            final DataClayObjectMetaData metadata = curEntry.getMetaData();</span>
<span class="nc" id="L1683">            metadata.modifyOids(originalToVersion);</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">            if (metadata.getOriginalObjectID() == null) {</span>
                // IMPORTANT: only set if not already set since consolidate
                // is always applied to original one
<span class="nc" id="L1687">                metadata.setOriginalObjectID(origObjectID);</span>
<span class="nc" id="L1688">                LOGGER.debug(&quot;Setting root location of {} to {}&quot;, versionObjectID, this.executionEnvironmentID);</span>
<span class="nc" id="L1689">                metadata.setRootLocation(this.executionEnvironmentID);</span>
            }
<span class="nc" id="L1691">            curEntry.setObjectID(versionObjectID);</span>
<span class="nc" id="L1692">        }</span>

        // Store versions
<span class="nc bnc" id="L1695" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1696">            LOGGER.debug(&quot;[==Version==] Storing version for &quot; + objectID);</span>
        }
<span class="nc bnc" id="L1698" title="All 2 branches missed.">        if (destBackendID.equals(this.executionEnvironmentID)) {</span>
<span class="nc" id="L1699">            this.storeObjects(sessionID, serializedObjs, false, null);</span>
        } else {
<span class="nc" id="L1701">            final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(destBackendID);</span>
<span class="nc" id="L1702">            dataServiceApi.storeObjects(sessionID, serializedObjs, false, null);</span>
        }
<span class="nc" id="L1704">        LOGGER.debug(&quot;&lt;---- Finished new version of &quot; + objectID);</span>
<span class="nc" id="L1705">        return originalToVersion.get(objectID);</span>
    }

    @Override
    public void consolidateVersion(final SessionID sessionID, final ObjectID finalVersionObjectID) {

<span class="nc bnc" id="L1711" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1712">            LOGGER.debug(&quot;----&gt; Starting consolidate for &quot; + finalVersionObjectID);</span>
        }
        // Consolidate in this backend - the complete version is here
<span class="nc" id="L1715">        final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1716">        objectIDs.add(finalVersionObjectID);</span>
<span class="nc" id="L1717">        final List&lt;ObjectWithDataParamOrReturn&gt; versionObjects = getObjects(sessionID, objectIDs, new HashSet&lt;ObjectID&gt;(),true, null, 0);</span>

<span class="nc" id="L1719">        ExecutionEnvironmentID rootLocation = null;</span>
<span class="nc" id="L1720">        final Map&lt;ObjectID, ObjectID&gt; versionToOriginal = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn versionObject : versionObjects) {</span>
<span class="nc" id="L1722">            final ObjectID versionID = versionObject.getObjectID();</span>
<span class="nc" id="L1723">            final DataClayObjectMetaData versionMetaData = versionObject.getMetaData();</span>
<span class="nc bnc" id="L1724" title="All 2 branches missed.">            if (versionMetaData.getOriginalObjectID() != null) {</span>
<span class="nc" id="L1725">                versionToOriginal.put(versionID, versionMetaData.getOriginalObjectID());</span>
            }

<span class="nc bnc" id="L1728" title="All 2 branches missed.">            if (versionID.equals(finalVersionObjectID)) {</span>
<span class="nc" id="L1729">                rootLocation = versionObject.getMetaData().getRootLocation();</span>
<span class="nc" id="L1730">                LOGGER.debug(&quot;Root location of {} is {}&quot;, finalVersionObjectID, rootLocation);</span>
            }

<span class="nc" id="L1733">        }</span>
         // Update original objects
<span class="nc bnc" id="L1735" title="All 2 branches missed.">        for (final ObjectWithDataParamOrReturn versionObject : versionObjects) {</span>
<span class="nc" id="L1736">            final DataClayObjectMetaData versionMetaData = versionObject.getMetaData();</span>
            // Modify metadata to use new Object IDs
<span class="nc" id="L1738">            versionMetaData.modifyOids(versionToOriginal);</span>
<span class="nc" id="L1739">            final ObjectID originalObjectID = versionMetaData.getOriginalObjectID();</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">            if (originalObjectID != null) {</span>
<span class="nc" id="L1741">                versionObject.setObjectID(originalObjectID);</span>
            }
<span class="nc" id="L1743">        }</span>
        try {
<span class="nc" id="L1745">            runtime.setCurrentThreadSessionID(sessionID);</span>
            // Update original objects (here and in other DSs - replicas)
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            if (rootLocation.equals(this.executionEnvironmentID)) {</span>
<span class="nc" id="L1748">                this.upsertObjects(sessionID, versionObjects);</span>
            } else {
<span class="nc" id="L1750">                final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(rootLocation);</span>
<span class="nc" id="L1751">                dataServiceApi.upsertObjects(sessionID, versionObjects);</span>
            }
        } finally {
<span class="nc" id="L1754">            runtime.removeCurrentThreadSessionID();</span>
        }

<span class="nc" id="L1757">    }</span>

    @Override
    public Tuple&lt;Map&lt;StorageLocationID, Set&lt;ObjectID&gt;&gt;, Set&lt;ObjectID&gt;&gt; migrateObjectsToBackends(
            final Map&lt;StorageLocationID, StorageLocation&gt; backends) {
<span class="nc" id="L1762">        throw new UnsupportedOperationException();</span>
    }

    @Override
    public Set&lt;ObjectID&gt; moveObjects(final SessionID sessionID, final ObjectID objectID,
                                     final ExecutionEnvironmentID destLocation, final boolean recursive) {
<span class="nc" id="L1768">        final Set&lt;ObjectID&gt; updateMetadataof = new HashSet&lt;&gt;();</span>

        try {
<span class="nc" id="L1771">            runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L1773">                DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
            }
<span class="nc bnc" id="L1775" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1776">                LOGGER.debug(&quot;[==MOVE==] Moving object &quot; + objectID + &quot; to storage location: &quot; + destLocation);</span>
            }
<span class="nc" id="L1778">            final Set&lt;ObjectID&gt; objectIDs = new HashSet&lt;&gt;();</span>
            // Get the the original object.
<span class="nc" id="L1780">            objectIDs.add(objectID);</span>

<span class="nc" id="L1782">            final List&lt;ObjectWithDataParamOrReturn&gt; serializedObjs = getObjects(sessionID, objectIDs, new HashSet&lt;ObjectID&gt;(), recursive, null, 0);</span>

<span class="nc" id="L1784">            final Set&lt;ObjectID&gt; objectsToRemove = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1785">            final List&lt;ObjectWithDataParamOrReturn&gt; objectsToMove = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1787" title="All 2 branches missed.">            for (final ObjectWithDataParamOrReturn objFound : serializedObjs) {</span>

                // The object is not here (it comes from another node due to GET) but
                // it must be stored here
<span class="nc bnc" id="L1791" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1792">                    LOGGER.debug(&quot;[==MOVE==] Looking for metadata of &quot; + objFound.getObjectID());</span>
                }
<span class="nc" id="L1794">                final MetaDataInfo metadata = runtime.getObjectMetadata(objFound.getObjectID());</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">                if (metadata == null) {</span>
                    // TODO: review exception design, getObjectMetadata is returning null in case
                    // object not registered.
                    // WARNING: This exception should not happen here
                    // NOTE: if it is a volatile and hint failed, it means that object is actually
                    // not registered
<span class="nc" id="L1801">                    throw new ObjectNotRegisteredException(objFound.getObjectID());</span>
                }
<span class="nc" id="L1803">                final ExecutionEnvironmentID objLocation = metadata.getLocations().iterator().next();</span>

<span class="nc bnc" id="L1805" title="All 2 branches missed.">                if (objLocation.equals(destLocation)) {</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">                    if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1807">                        LOGGER.debug(&quot;[==MOVE==] Ignoring move of object  &quot; + objFound.getObjectID()</span>
                                + &quot; since it is already where it should be. ObjLoc = &quot; + objLocation + &quot; and DestLoc = &quot;
                                + destLocation);
                    }
                    // object already in dest
                    continue;
                } else {
<span class="nc bnc" id="L1814" title="All 2 branches missed.">                    if (this.executionEnvironmentID.equals(destLocation)) {</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">                        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1816">                            LOGGER.debug(&quot;[==MOVE==] Ignoring move of object  &quot; + objFound.getObjectID()</span>
                                    + &quot; since it is already where it should be&quot; + &quot; ObjLoc = &quot; + objLocation
                                    + &quot; and DestLoc = &quot; + destLocation);
                        }
                    } else {
<span class="nc bnc" id="L1821" title="All 2 branches missed.">                        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1822">                            LOGGER.debug(&quot;[==MOVE==] Moving object  &quot; + objFound.getObjectID()</span>
                                    + &quot; since dest.location is different to src.location and object is not in dest.location &quot;
                                    + &quot; ObjLoc = &quot; + objLocation + &quot; and DestLoc = &quot; + destLocation);
                        }
                        // THE DESTINATION IS ANOTHER NODE: move.
<span class="nc" id="L1827">                        objectsToMove.add(objFound);</span>
<span class="nc" id="L1828">                        objectsToRemove.add(objFound.getObjectID());</span>
<span class="nc" id="L1829">                        updateMetadataof.add(objFound.getObjectID());</span>
                    }
                }

<span class="nc" id="L1833">            }</span>

<span class="nc bnc" id="L1835" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1836">                LOGGER.debug(&quot;[==MOVE==] Finally moving OBJECTS:  &quot; + objectsToRemove);</span>
            }

            // REMOVE IN OTHER BACKEND
<span class="nc" id="L1840">            final DataServiceAPI dataServiceApi = runtime.getRemoteExecutionEnvironment(destLocation);</span>
            // Now move all objects to the destination location.
<span class="nc" id="L1842">            dataServiceApi.storeObjects(sessionID, objectsToMove, true, null);</span>

            // TODO: lock any execution in remove before storing objects in remote
            // dataservice
            // so anyone can modify it.

            // Remove after store in order to avoid wrong executions during the movement :)
            // Remove all objects in all source locations different to dest. location
<span class="nc" id="L1850">            this.removeObjects(sessionID, objectIDs, recursive, true, destLocation);</span>

            // Remove entries
<span class="nc bnc" id="L1853" title="All 2 branches missed.">            for (final ObjectID oid : objectsToRemove) {</span>
<span class="nc" id="L1854">                runtime.removeObjectMetadataFromCache(oid);</span>
<span class="nc" id="L1855">            }</span>

<span class="nc bnc" id="L1857" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1858">                LOGGER.debug(&quot;[==MOVE==] Move finalized &quot;);</span>
            }

<span class="nc" id="L1861">        } catch (</span>

                final Exception ex) {
<span class="nc" id="L1864">            LOGGER.debug(&quot;moveObjects error&quot;, ex);</span>

        } finally {
<span class="nc" id="L1867">            runtime.removeCurrentThreadSessionID();</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L1869">                DataClayMockObject.removeCurrentThreadLib();</span>
            }
        }

<span class="nc" id="L1873">        return updateMetadataof;</span>

    }

    @Override
    public MetaClassID getClassIDFromObjectInMemory(final ObjectID objectID) {
        try {
<span class="nc bnc" id="L1880" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L1881">                DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
            }
<span class="nc" id="L1883">            final DataClayObject dcObject = runtime.getFromHeap(objectID);</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">            if (dcObject != null) {</span>
<span class="nc" id="L1885">                return dcObject.getMetaClassID();</span>
            }
        } finally {
<span class="nc bnc" id="L1888" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L1889">                DataClayMockObject.removeCurrentThreadLib();</span>
            }
        }
<span class="nc" id="L1892">        return null;</span>
    }

    /**
     * Update or store object.
     *
     * @param instance Object to update in DB.
     */
    public void gcCollectObjectInternal(final DataClayExecutionObject instance) {
        // =================== UPDATE DATABASE ===================//
        // We update the set of associated objects if new objects were associated or
        // deleted.
<span class="nc bnc" id="L1904" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1905">            LOGGER.debug(&quot;[==GC==] Collecting object &quot; + instance.getObjectID());</span>
        }

<span class="nc bnc" id="L1908" title="All 2 branches missed.">        if (instance.isPendingToRegister()) {</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1910">                LOGGER.debug(&quot;[==GC==] Serializing pending instance &quot;);</span>
            }
        }

<span class="nc bnc" id="L1914" title="All 2 branches missed.">        if (instance.isPendingToRegister()) {</span>
<span class="nc" id="L1915">            final byte[] arrBytes = DataClaySerializationLib.serializeForDBGarbageCollection(instance, false, null,</span>
                    false);
<span class="nc" id="L1917">            registerAndStorePendingObject(instance, arrBytes, true);</span>
<span class="nc" id="L1918">            instance.setPendingToRegister(false);</span>

<span class="nc bnc" id="L1920" title="All 2 branches missed.">        } else if (instance.isDirty()) {</span>
<span class="nc bnc" id="L1921" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1922">                LOGGER.debug(</span>
<span class="nc" id="L1923">                        &quot;[==GC==] Going to update dirty object in database object with ID &quot; + instance.getObjectID());</span>
            }
<span class="nc" id="L1925">            final byte[] arrBytes = DataClaySerializationLib.serializeForDBGarbageCollection(instance, false, null,</span>
                    false);
<span class="nc" id="L1927">            this.storageLocation.update(this.executionEnvironmentID, instance.getObjectID(), arrBytes, true);</span>
<span class="nc bnc" id="L1928" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1929">                final StringBuilder strBuilder = new StringBuilder();</span>
<span class="nc" id="L1930">                strBuilder.append(&quot;Updated object of class &quot;);</span>
<span class="nc" id="L1931">                strBuilder.append(instance.getClass().getName());</span>
<span class="nc" id="L1932">                strBuilder.append(&quot; with Object ID &quot; + instance.getObjectID());</span>
<span class="nc" id="L1933">                strBuilder.append(&quot; with size = &quot; + arrBytes.length + &quot; bytes&quot;);</span>
<span class="nc" id="L1934">                LOGGER.debug(&quot;[==GC==]&quot; + strBuilder.toString());</span>
            }

            // TODO: Think which DataSet should be assigned to object (dgasull 2017)
            /*
             * if (instance.getDataSetID() != null) {
             * this.runtime.getLogicModuleAPI().setDataSetIDFromGarbageCollector(instance.
             * getObjectID(), instance.getDataSetID()); }
             */

<span class="nc" id="L1944">        } else {</span>
<span class="nc bnc" id="L1945" title="All 2 branches missed.">            if (Configuration.Flags.GLOBAL_GC_ENABLED.getBooleanValue()) {</span>
<span class="nc bnc" id="L1946" title="All 2 branches missed.">                if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1947">                    LOGGER.debug(</span>
<span class="nc" id="L1948">                            &quot;[==GC==] Going to notify not dirty object to GlobalGC with ID &quot; + instance.getObjectID());</span>
                }
<span class="nc" id="L1950">                final byte[] arrBytes = DataClaySerializationLib.serializeForDBGarbageCollection(instance, false, null,</span>
                        true);
<span class="nc bnc" id="L1952" title="All 2 branches missed.">                if (arrBytes != null) {</span>
<span class="nc" id="L1953">                    final byte[] refCountingBytes = DataClayDeserializationLib.extractReferenceCounting(arrBytes);</span>
<span class="nc" id="L1954">                    this.storageLocation.update(this.executionEnvironmentID, instance.getObjectID(), refCountingBytes,</span>
                            false);

<span class="nc" id="L1957">                } else {</span>
<span class="nc" id="L1958">                    LOGGER.debug(&quot;[==GC==] Found very volatile not modified (not sending to Disk) with ID &quot;</span>
<span class="nc" id="L1959">                            + instance.getObjectID());</span>
                }
            }
        }

<span class="nc" id="L1964">    }</span>

    /**
     * Register pending object
     *
     * @param instance Instance to register
     * @param sync     Indicates if register is synchronous or asynchronous
     */
    private void registerObject(final DataClayExecutionObject instance,
                                               final boolean sync) {
        // Inform MDS about new object !
<span class="nc" id="L1975">        final Map&lt;ObjectID, MetaClassID&gt; storedObjs = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L1976">        storedObjs.put(instance.getObjectID(), instance.getMetaClassID());</span>

<span class="nc" id="L1978">        final RegistrationInfo regInfo = new RegistrationInfo(instance.getObjectID(), instance.getMetaClassID(),</span>
<span class="nc" id="L1979">                instance.getOwnerSessionIDforVolatiles(), instance.getDataSetID(), null);</span>

<span class="nc bnc" id="L1981" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L1982">            LOGGER.debug(&quot;[==RegisterPending==] Going to register &quot; + regInfo + &quot; for instance &quot;</span>
<span class="nc" id="L1983">                    + System.identityHashCode(instance));</span>
        }
        try {
<span class="nc bnc" id="L1986" title="All 2 branches missed.">            if (sync) {</span>
<span class="nc" id="L1987">                List&lt;RegistrationInfo&gt; regInfos = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1988">                regInfos.add(regInfo);</span>
<span class="nc" id="L1989">                this.runtime.getLogicModuleAPI().registerObjects(regInfos, executionEnvironmentID, Langs.LANG_JAVA);</span>
<span class="nc" id="L1990">            } else {</span>
<span class="nc" id="L1991">                this.runtime.getLogicModuleAPI().registerObjectFromGC(regInfo, executionEnvironmentID, this.runtime);</span>
            }
<span class="nc" id="L1993">        } catch (final Exception e) {</span>
            // object already registered due to add alias / it's a replica
<span class="nc" id="L1995">            LOGGER.debug(&quot;[==RegisterPending==] Exception occurred while registering object, ignoring if already registered &quot;, e);</span>
<span class="nc" id="L1996">        }</span>
<span class="nc" id="L1997">        LOGGER.debug(&quot;[==RegisterPending==] Object registered&quot;);</span>
<span class="nc" id="L1998">    }</span>

    /**
     * Store pending object
     *
     * @param instance Instance to register
     * @param arrBytes Persistent object
     */
    private void storePendingObject(final DataClayExecutionObject instance, final byte[] arrBytes) {

<span class="nc" id="L2008">        LOGGER.debug(&quot;[==RegisterPending==] Registering pending object with ID &quot; + instance.getObjectID() + &quot; of class &quot;</span>
<span class="nc" id="L2009">                            + instance.getClass().getName() + &quot;. System.id = &quot; + System.identityHashCode(instance));</span>

<span class="nc" id="L2011">        this.storageLocation.store(this.executionEnvironmentID, instance.getObjectID(), arrBytes);</span>


<span class="nc" id="L2014">    }</span>

    /**
     * Register and store pending object
     *
     * @param instance Instance to register
     * @param arrBytes Persistent object
     * @param sync     Indicates if register is synchronous or asynchronous
     */
    private void registerAndStorePendingObject(final DataClayExecutionObject instance, final byte[] arrBytes,
                                               final boolean sync) {
<span class="nc" id="L2025">        storePendingObject(instance, arrBytes);</span>
<span class="nc" id="L2026">        registerObject(instance, sync);</span>

<span class="nc" id="L2028">	}</span>

    /**
     * Register all pending objects
     */
    @Override
    public void registerPendingObjects() {
<span class="nc" id="L2035">        throw new UnsupportedOperationException();</span>
    }

    // ============================== LAZY TASKS ==================== //

    /**
     * Add lazy task
     *
     * @param objectID ID of the object
     * @param lazyTask Lazy task
     */
    public void addLazyTask(final ObjectID objectID, final LazyTask lazyTask) {
<span class="nc" id="L2047">        this.lazyTasksRunner.addLazyTask(objectID, lazyTask);</span>
<span class="nc" id="L2048">    }</span>

    // ============================== GLOBAL DISK GC ==================== //

    /**
     * Execute lazy task
     *
     * @param implID        ID of the task to execute
     * @param paramObjectID ID of the parameter
     * @param sessionID     ID of the session
     * @param classID       ID of the class
     */
    public void executeLazyTask(final ImplementationID implID, final ObjectID paramObjectID, final SessionID sessionID,
                                final MetaClassID classID) {
        // TODO: check session?
        try {
            // create lots of objects here and stash them somewhere
<span class="nc bnc" id="L2065" title="All 2 branches missed.">            if (sessionID != null) {</span>
<span class="nc" id="L2066">                runtime.setCurrentThreadSessionID(sessionID);</span>
            }
<span class="nc bnc" id="L2068" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L2069">                DataClayMockObject.setCurrentThreadLib(this.runtime);</span>
            }

<span class="nc bnc" id="L2072" title="All 2 branches missed.">            if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2073">                LOGGER.debug(&quot;[==Execution==] ** New execution ** Executing task &quot; + implID);</span>

            }

            // ============================ DESERIALIZE PARAMETERS
            // ============================ //
<span class="nc" id="L2079">            final DataClayObject paramInstance = runtime.getOrNewInstanceFromDB(paramObjectID, true);</span>
<span class="nc" id="L2080">            final Object[] loadedparams = new Object[]{paramInstance};</span>

            // =================================== GET INSTANCE
            // ===================================//
            // We must instantiate an object of the execution class

            // SIMILAR TO NEW PERSISTENT INSTANCE

            // final DataClayObject instance = DataClayClassLoaderSrv.newInstance(classID,
            // new ObjectID(),
            // DataClayObjectState.VOLATILE_SERVER);
            // this.runImplementation(instance, implID, loadedparams);

<span class="nc" id="L2093">            final Class&lt;?&gt; clazz = DataClayClassLoaderSrv.getClass(classID);</span>
<span class="nc" id="L2094">            final StubInfo stubInfo = DataClayObject.getStubInfoFromClass(clazz.getName());</span>

<span class="nc" id="L2096">            final ImplementationStubInfo implStubInfo = stubInfo.getImplementationByID(implID.toString());</span>
<span class="nc" id="L2097">            final String signature = implStubInfo.getSignature();</span>

            /*
             * final UserType paramType = (UserType) implStubInfo.getParameters().get(0);
             * final Class&lt;?&gt; paramClass =
             * DataClayClassLoaderSrv.getClass(paramType.getClassID());
             */

            // ============================= EXECUTE =========================== //

<span class="nc" id="L2107">            final String methodName = signature.split(&quot;\\(&quot;)[0];</span>

<span class="nc" id="L2109">            Class&lt;?&gt; paramClass = paramInstance.getClass();</span>
<span class="nc" id="L2110">            boolean notExecuted = true;</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">            while (notExecuted) {</span>
                try {
<span class="nc" id="L2113">                    clazz.getMethod(methodName, paramClass).invoke(null, loadedparams);</span>
<span class="nc" id="L2114">                    notExecuted = false;</span>
<span class="nc" id="L2115">                } catch (final java.lang.NoSuchMethodException err) {</span>
<span class="nc" id="L2116">                    paramClass = paramClass.getSuperclass();</span>
<span class="nc" id="L2117">                }</span>
            }

            // clazz.getMethod(methodName, paramClass).invoke(null, loadedparams);

<span class="nc" id="L2122">        } catch (final StatusRuntimeException sterr) {</span>
<span class="nc" id="L2123">            LOGGER.debug(&quot;[==Execution==] Error at task of parameter object {} and implementation {}&quot;, paramObjectID,</span>
                    implID);
<span class="nc" id="L2125">            LOGGER.debug(&quot;executeLazyTask got a StatusRuntimeException&quot;, sterr);</span>
<span class="nc" id="L2126">            throw sterr;</span>
<span class="nc" id="L2127">        } catch (final DataClayException de) {</span>
<span class="nc" id="L2128">            LOGGER.debug(&quot;[==Execution==] Error at task of parameter object {} and implementation {}&quot;, paramObjectID,</span>
                    implID);
<span class="nc" id="L2130">            LOGGER.debug(&quot;executeLazyTask got a native DataClayException&quot;, de);</span>
<span class="nc" id="L2131">            throw de;</span>
<span class="nc" id="L2132">        } catch (final Exception ex) {</span>
<span class="nc" id="L2133">            LOGGER.debug(&quot;[==Execution==] Error at task of parameter object {} and implementation {}&quot;, paramObjectID,</span>
                    implID);
<span class="nc" id="L2135">            LOGGER.debug(&quot;executeLazyTask got an error&quot;, ex);</span>
<span class="nc" id="L2136">            throw new JavaExecutionException(ex);</span>
<span class="nc" id="L2137">        } catch (final Error err) {</span>
<span class="nc" id="L2138">            LOGGER.debug(&quot;executeLazyTask got a ``true'' error&quot;, err);</span>
<span class="nc" id="L2139">            throw new JavaExecutionException(err);</span>
        } finally {
<span class="nc bnc" id="L2141" title="All 2 branches missed.">            if (Configuration.mockTesting) {</span>
<span class="nc" id="L2142">                DataClayMockObject.removeCurrentThreadLib();</span>
            }
<span class="nc" id="L2144">            runtime.removeCurrentThreadSessionID();</span>
        }

<span class="nc" id="L2147">    }</span>

    @Override
    public boolean exists(final ObjectID objectID) {
<span class="nc bnc" id="L2151" title="All 2 branches missed.">        if (DEBUG_ENABLED) {</span>
<span class="nc" id="L2152">            LOGGER.debug(&quot;[==Exists==] Checking if object {} exists in current EE&quot;, objectID);</span>
        }
<span class="nc" id="L2154">        runtime.lock(objectID);  // RACE CONDITION: object is being unloaded but still not in SL</span>
        try {
<span class="nc" id="L2156">            final boolean inheap = this.runtime.existsInHeap(objectID);</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">            if (inheap) {</span>
<span class="nc" id="L2158">                    final DataClayExecutionObject obj = this.runtime.getFromHeap(objectID);</span>
                    // object might be in heap but as a &quot;proxy&quot;
                    // since this function is used from SL after checking if the object is in
                    // database,
                    // we return false if the object is not loaded so the combination of SL exists
                    // and EE exists
                    // can tell if the object actually exists
                    // summary: the object only exist in EE if it is loaded.
<span class="nc bnc" id="L2166" title="All 2 branches missed.">                    if (obj == null) {</span>
<span class="nc" id="L2167">                        return false;</span>
                    }
<span class="nc" id="L2169">                    return obj.isLoaded();</span>
            } else {
<span class="nc" id="L2171">                return false;</span>
            }
        } finally {
<span class="nc" id="L2174">            runtime.unlock(objectID);</span>
        }
    }

    @Override
    public void closeSessionInDS(final SessionID sessionID) {
<span class="nc" id="L2180">        this.runtime.closeSessionInEE(sessionID);</span>
<span class="nc" id="L2181">    }</span>


    @Override
    public void detachObjectFromSession(final ObjectID objectID, final SessionID sessionID) {
        try {
<span class="nc" id="L2187">            runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc" id="L2188">            this.runtime.detachObjectFromSession(objectID, null);</span>
        } finally {
<span class="nc" id="L2190">            runtime.removeCurrentThreadSessionID();</span>
        }
<span class="nc" id="L2192">    }</span>

    @Override
    public void deleteAlias(final SessionID sessionID, final ObjectID objectID) {
        try {
<span class="nc" id="L2197">            runtime.setCurrentThreadSessionID(sessionID);</span>
<span class="nc" id="L2198">            final DataClayObject instance = runtime.getOrNewInstanceFromDB(objectID, true);</span>
<span class="nc" id="L2199">            this.runtime.deleteAlias(instance);</span>
        } finally {
<span class="nc" id="L2201">            runtime.removeCurrentThreadSessionID();</span>
        }
<span class="nc" id="L2203">    }</span>

    @Override
    public boolean existsInDB(final ObjectID objectID) {
<span class="nc" id="L2207">        return this.storageLocation.exists(objectID);</span>
    }

    @Override
    public void store(final ExecutionEnvironmentID eeID, final ObjectID objectID, final byte[] bytes) {
<span class="nc" id="L2212">        this.storageLocation.store(eeID, objectID, bytes);</span>
<span class="nc" id="L2213">    }</span>

    /**
     * Get from this DB
     *
     * @param objectID ID of the object
     * @return Bytes of object
     */
    public byte[] getLocal(final ObjectID objectID) {
<span class="nc" id="L2222">        return this.storageLocation.get(this.executionEnvironmentID, objectID);</span>
    }

    @Override
    public byte[] get(final ExecutionEnvironmentID eeID, final ObjectID objectID) {
<span class="nc" id="L2227">        return this.storageLocation.get(eeID, objectID);</span>
    }

    @Override
    public void update(final ExecutionEnvironmentID eeID, final ObjectID objectID, final byte[] newbytes,
                       final boolean dirty) {
<span class="nc" id="L2233">        this.storageLocation.update(eeID, objectID, newbytes, dirty);</span>
<span class="nc" id="L2234">    }</span>

    @Override
    public void delete(final ExecutionEnvironmentID eeID, final ObjectID objectID) {
<span class="nc" id="L2238">        this.storageLocation.delete(eeID, objectID);</span>
<span class="nc" id="L2239">    }</span>

    @Override
    public void updateRefs(final Map&lt;ObjectID, Integer&gt; updateCounterRefs) {
<span class="nc" id="L2243">        this.storageLocation.updateRefs(updateCounterRefs);</span>
<span class="nc" id="L2244">    }</span>

    @Override
    public Set&lt;ObjectID&gt; getRetainedReferences() {
<span class="nc" id="L2248">        return runtime.getRetainedReferences();</span>
    }


    // ============= OTHER =========== //

    @Override
    public void cleanExecutionClassDirectory() {
<span class="nc" id="L2256">        cleanExecutionClasses();</span>
<span class="nc" id="L2257">    }</span>

    /**
     * Static function for cleaning paths. Static so can be called even if DS is not
     * running.
     */
    public static void cleanExecutionClasses() {
        try {

<span class="nc" id="L2266">            DataClayClassLoaderSrv.cleanCaches();</span>
<span class="nc" id="L2267">            File f = new File(Configuration.Flags.EXECUTION_CLASSES_PATH.getStringValue());</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">            if (f.exists()) {</span>
<span class="nc" id="L2269">                FileAndAspectsUtils.deleteFolderContent(f);</span>
            }
<span class="nc" id="L2271">        } catch (final Exception ex) {</span>
<span class="nc" id="L2272">            LOGGER.debug(&quot;cleanExecutionClasses error&quot;, ex);</span>
<span class="nc" id="L2273">            throw new CleanExecutionClassesDirException(ex.getLocalizedMessage());</span>
<span class="nc" id="L2274">        }</span>
<span class="nc" id="L2275">    }</span>

    @Override
    public void cleanCaches() {
<span class="nc" id="L2279">        runtime.cleanCaches();</span>
<span class="nc" id="L2280">    }</span>

    /**
     * Get DbHandler. Used for testing purposes.
     *
     * @return DbHandler.
     */
    public DBHandler getDbHandler() {
<span class="nc" id="L2288">        return this.storageLocation.getDbHandler(this.executionEnvironmentID);</span>
    }

    @Override
    public void closeDbHandler() {
<span class="nc" id="L2293">        this.storageLocation.closeDbHandler(this.executionEnvironmentID);</span>
<span class="nc" id="L2294">    }</span>

    @Override
    public void activateTracing(final int currentAvailableTaskID) {
<span class="nc" id="L2298">        DataClayExtrae.setCurrentAvailableTaskID(currentAvailableTaskID);</span>
<span class="nc" id="L2299">        DataClayExtrae.initializeExtrae(true);</span>

<span class="nc" id="L2301">    }</span>

    @Override
    public void deactivateTracing() {
<span class="nc" id="L2305">        DataClayExtrae.finishTracing(true);</span>
<span class="nc" id="L2306">    }</span>

    @Override
    public Map&lt;String, byte[]&gt; getTraces() {
<span class="nc" id="L2310">        return DataClayExtrae.getTraces();</span>
    }

    /**
     * Finish cache threads.
     *
     * @if some exception occurs
     */
    public void finishCacheThreads() {
<span class="nc" id="L2319">        this.runtime.finishCacheThreads();</span>
<span class="nc" id="L2320">    }</span>

    /**
     * Finish connections in DS.
     *
     * @throws Exception if some exception occurs
     */
    public void finishClientConnections() {
<span class="nc bnc" id="L2328" title="All 2 branches missed.">        if (this.runtime != null) {</span>
<span class="nc" id="L2329">            this.runtime.finishConnections();</span>
        }

<span class="nc" id="L2332">    }</span>

    /**
     * Unregister the data service from the logic module.
     */
    public void unregisterFromLogicModule() {
<span class="nc" id="L2338">        runtime.getLogicModuleAPI().unregisterExecutionEnvironment(executionEnvironmentID);</span>
<span class="nc" id="L2339">        runtime.getLogicModuleAPI().unregisterStorageLocation(storageLocationID);</span>
<span class="nc" id="L2340">    }</span>

    @Override
    public void shutDown() {
<span class="nc" id="L2344">        ownServer.stopService();</span>
<span class="nc" id="L2345">    }</span>

    @Override
    public void disconnectFromOthers() {
<span class="nc" id="L2349">        ownServer.disconnectFromOthers();</span>
<span class="nc" id="L2350">    }</span>

    /**
     * Return number of references pointing to object.
     *
     * @param objectID ID of object
     * @return Number of references pointing to object
     */
    public int getNumReferencesTo(final ObjectID objectID) {
<span class="nc" id="L2359">        return this.storageLocation.getNumReferencesTo(objectID);</span>
    }

    /**
     * Only for testing and SL representing a storage location, get storage location
     * service.
     *
     * @return storageLocation service
     */
    public StorageLocationService getStorageLocationService() {
<span class="nc" id="L2369">        return this.storageLocation;</span>
    }

    /**
     * Notify LM current execution environment left
     */
    public void notifyExecutionEnvironmentShutdown() {
<span class="nc" id="L2376">        final LogicModuleAPI lmAPI = this.runtime.getLogicModuleAPI();</span>
<span class="nc" id="L2377">        lmAPI.notifyExecutionEnvironmentShutdown(this.executionEnvironmentID);</span>
<span class="nc" id="L2378">    }</span>

    /**
     * Notify LM current storage location left
     */
    public void notifyStorageLocationShutdown() {
<span class="nc" id="L2384">        final LogicModuleAPI lmAPI = this.runtime.getLogicModuleAPI();</span>
<span class="nc" id="L2385">        lmAPI.notifyStorageLocationShutdown(this.storageLocationID);</span>
<span class="nc" id="L2386">    }</span>


    /**
     * Wait for all execution environments associated to current data service to finish and return
     */
    public void waitForExecutionEnvironmentsToFinish() {
<span class="nc" id="L2393">        final LogicModuleAPI lmAPI = this.runtime.getLogicModuleAPI();</span>
        while (true) {
<span class="nc bnc" id="L2395" title="All 2 branches missed.">            if (!lmAPI.existsActiveEnvironmentsForSL(this.storageLocationID)) {</span>
<span class="nc" id="L2396">                break;</span>
            }
            try {
<span class="nc" id="L2399">                LOGGER.info(&quot;Waiting for EEs associated to current SL to finish ...&quot;);</span>
<span class="nc" id="L2400">                Thread.sleep(Configuration.Flags.SLEEP_WAIT_SHUTDOWN.getLongValue());</span>
<span class="nc" id="L2401">            } catch (final InterruptedException ie) {</span>
<span class="nc" id="L2402">                LOGGER.warn(&quot;Connection to LM interrupted. Shutting down DS&quot;);</span>
<span class="nc" id="L2403">                break;</span>
<span class="nc" id="L2404">            }</span>
        }
<span class="nc" id="L2406">    }</span>


    @Override
    public int getNumObjectsInEE() {
<span class="nc" id="L2411">        return runtime.numLoadedObjs();</span>
    }

    @Override
    public int getNumObjects() {
<span class="nc" id="L2416">        return this.storageLocation.getNumObjects();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>